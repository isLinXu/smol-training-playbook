<!DOCTYPE html><html lang="en" data-theme="light" data-toc-auto-collapse="1"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>The Smol Training Playbook: The Secrets to Building World-Class LLMs</title><meta name="description" content="The Smol Training Playbook: The Secrets to Building World-Class LLMs"><link rel="canonical" href="http://localhost:4321/"><meta property="og:type" content="article"><meta property="og:title" content="The Smol Training Playbook: The Secrets to Building World-Class LLMs"><meta property="og:description" content="The Smol Training Playbook: The Secrets to Building World-Class LLMs"><meta property="og:url" content="http://localhost:4321/"><meta property="og:image" content="https://HuggingFaceTB-smol-training-playbook.hf.space/thumb.png"><meta property="article:published_time" content="Oct. 30, 2025"><meta property="article:author" content="Loubna Ben Allal"><meta property="article:author" content="Lewis Tunstall"><meta property="article:author" content="Nouamane Tazi"><meta property="article:author" content="Elie Bakouch"><meta property="article:author" content="Ed Beeching"><meta property="article:author" content="Carlos Miguel Patiño"><meta property="article:author" content="Clémentine Fourrier"><meta property="article:author" content="Thibaud Frere"><meta property="article:author" content="Anton Lozhkov"><meta property="article:author" content="Colin Raffel"><meta property="article:author" content="Leandro von Werra"><meta property="article:author" content="Thomas Wolf"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="The Smol Training Playbook: The Secrets to Building World-Class LLMs"><meta name="twitter:description" content="The Smol Training Playbook: The Secrets to Building World-Class LLMs"><meta name="twitter:image" content="https://HuggingFaceTB-smol-training-playbook.hf.space/thumb.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"The Smol Training Playbook: The Secrets to Building World-Class LLMs","description":"The Smol Training Playbook: The Secrets to Building World-Class LLMs","datePublished":"Oct. 30, 2025","author":[{"@type":"Person","name":"Loubna Ben Allal"},{"@type":"Person","name":"Lewis Tunstall"},{"@type":"Person","name":"Nouamane Tazi"},{"@type":"Person","name":"Elie Bakouch"},{"@type":"Person","name":"Ed Beeching"},{"@type":"Person","name":"Carlos Miguel Patiño"},{"@type":"Person","name":"Clémentine Fourrier"},{"@type":"Person","name":"Thibaud Frere"},{"@type":"Person","name":"Anton Lozhkov"},{"@type":"Person","name":"Colin Raffel"},{"@type":"Person","name":"Leandro von Werra"},{"@type":"Person","name":"Thomas Wolf"}],"keywords":"research, template","mainEntityOfPage":"http://localhost:4321/","image":["/thumb.auto.jpg"]}</script><script>
      (() => {
        try {
          const saved = localStorage.getItem("theme");
          const prefersDark =
            window.matchMedia &&
            window.matchMedia("(prefers-color-scheme: dark)").matches;
          const theme = saved || (prefersDark ? "dark" : "light");
          document.documentElement.setAttribute("data-theme", theme);
        } catch {}
      })();
    </script><script type="module" src="./scripts/color-palettes.js"></script><!-- TO MANAGE PROPERLY --><script src="https://cdn.plot.ly/plotly-3.0.0.min.js" charset="utf-8"></script><link rel="stylesheet" href="./_astro/index.DZ3G3zka.css"><script type="module" src="./_astro/hoisted.Cw1NicPi.js"></script>
<script type="module" src="./_astro/page.BOpD7CWq.js"></script></head> <body> <button id="theme-toggle" aria-label="Toggle color theme" data-astro-cid-x3pjskd3> <svg class="icon light" width="20" height="20" viewBox="0 0 24 24" aria-hidden="true" focusable="false" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-x3pjskd3> <circle cx="12" cy="12" r="5" data-astro-cid-x3pjskd3></circle> <line x1="12" y1="1" x2="12" y2="4" data-astro-cid-x3pjskd3></line> <line x1="12" y1="20" x2="12" y2="23" data-astro-cid-x3pjskd3></line> <line x1="1" y1="12" x2="4" y2="12" data-astro-cid-x3pjskd3></line> <line x1="20" y1="12" x2="23" y2="12" data-astro-cid-x3pjskd3></line> <line x1="4.22" y1="4.22" x2="6.34" y2="6.34" data-astro-cid-x3pjskd3></line> <line x1="17.66" y1="17.66" x2="19.78" y2="19.78" data-astro-cid-x3pjskd3></line> <line x1="4.22" y1="19.78" x2="6.34" y2="17.66" data-astro-cid-x3pjskd3></line> <line x1="17.66" y1="6.34" x2="19.78" y2="4.22" data-astro-cid-x3pjskd3></line> </svg> <svg class="icon dark" width="20" height="20" viewBox="0 0 24 24" aria-hidden="true" focusable="false" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-x3pjskd3> <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" data-astro-cid-x3pjskd3></path> </svg>  </button>  <section class="hero" data-astro-cid-bbe6dxrz> <h1 class="hero-title" data-astro-cid-bbe6dxrz>The Smol Training Playbook:<br/> The Secrets to Building World-Class LLMs</h1> <div class="hero-banner" data-astro-cid-bbe6dxrz> <figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-his88aaqm89"><div class="d3-loss-curves"></div>
<style>
  .d3-loss-curves {
    margin-top: 20px;
    width: 100%;
    height: 350px;
    padding: 0;
    position: relative;
    overflow: hidden;
  }

  /* Ghosting on hover */
  .d3-loss-curves.hovering .lines path.ghost {
    opacity: .25 !important;
  }

  .d3-loss-curves.hovering .legend-item.ghost {
    opacity: .25 !important;
  }

  /* Tooltip styling */
  .d3-loss-curves .d3-tooltip {
    z-index: var(--z-elevated);
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-loss-curves .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 4px;
    min-width: 180px;
  }

  .d3-loss-curves .d3-tooltip__header {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .d3-loss-curves .d3-tooltip__color-swatch {
    width: 12px;
    height: 12px;
    border-radius: 2px;
    flex-shrink: 0;
  }

  .d3-loss-curves .d3-tooltip__title {
    font-weight: 800;
    letter-spacing: 0.1px;
    font-size: 13px;
  }

  .d3-loss-curves .d3-tooltip__subtitle {
    font-size: 11px;
    color: var(--muted-color);
  }

  .d3-loss-curves .d3-tooltip__divider {
    width: 100%;
    height: 1px;
    background: var(--border-color);
    margin: 2px 0;
  }

  .d3-loss-curves .d3-tooltip__data {
    font-size: 11px;
    line-height: 1.5;
  }

  /* Container styling with gradient background */
  .d3-loss-curves {
    border: 1px solid var(--border-color);
    border-radius: 20px;
    background: radial-gradient(circle at 30% 50%, hsla(37, 99%, 67%, 0.035), transparent 40%),
      radial-gradient(circle at 60% 100%, hsla(316, 73%, 52%, 0.035), transparent 40%),
      radial-gradient(circle at 80% 40%, hsla(185, 100%, 57%, 0.035), transparent 40%),
      var(--surface-bg);
  }

  /* Hand-drawn annotation SVG */
  .d3-loss-curves .annotation {
    position: absolute;
    top: 55px;
    right: 70px;
    width: 240px;
    height: 56px;
    pointer-events: none;
  }

  .d3-loss-curves .annotation svg {
    width: 100%;
    height: 100%;
  }

  /* Text stroke styling for SVG paths */
  /* .d3-loss-curves .annotation path {
    fill: var(--text-color);
    stroke: var(--page-bg);
    stroke-width: 3px;
    stroke-linejoin: round;
    stroke-linecap: round;
    paint-order: stroke fill;
  } */

  /* Legend styling */
  .d3-loss-curves .legend {
    position: absolute;
    bottom: 16px;
    left: 20px;
    max-width: 50%;
    font-size: 11px;
    line-height: 1.2;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
  }

  .d3-loss-curves .legend-title {
    font-weight: 700;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--muted-color);
    margin-bottom: 4px;
  }

  .d3-loss-curves .legend-items {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .d3-loss-curves .legend-row {
    display: flex;
    align-items: center;
    gap: 16px;
    flex-wrap: wrap;
  }

  .d3-loss-curves .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    transition: opacity 0.2s ease;
    opacity: 1;
  }

  .d3-loss-curves .legend-swatch {
    width: 12px;
    height: 12px;
    border-radius: 2px;
    flex-shrink: 0;
  }

  .d3-loss-curves .legend-label {
    font-size: 11px;
    color: var(--text-color);
    white-space: nowrap;
  }

  /* Mobile: hide annotation and legend, reduce height */
  @media (max-width: 768px) {
    .d3-loss-curves {
      height: 250px;
    }

    .d3-loss-curves .annotation {
      display: none;
    }

    .d3-loss-curves .legend {
      display: none;
    }

  }
</style>
<script>
  (() => {
    // Pretty label mapping for run names
    const prettyRunLabel = (key) => {
      if (!key) return '';
      // Extract the meaningful part from run names like "attention_loss+22/09/2025_16:41:43_baseline"
      const parts = key.split('+');
      if (parts.length > 1) {
        const runType = parts[0].replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        return runType;
      }
      return key.replace(/[_-]+/g, ' ').trim();
    };

    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-loss-curves'))) {
        const cs = Array.from(document.querySelectorAll('.d3-loss-curves')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // No controls needed for this visualization

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '8px 10px', borderRadius: '8px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 4px 24px rgba(0,0,0,.18)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Legend
      let legend = container.querySelector('.legend');
      if (!legend) {
        legend = document.createElement('div');
        legend.className = 'legend';
        container.appendChild(legend);
      }

      // Hand-drawn annotation
      let annotation = container.querySelector('.annotation');
      if (!annotation) {
        annotation = document.createElement('div');
        annotation.className = 'annotation';
        annotation.innerHTML = `



<svg width="383px" height="66px" viewBox="0 0 383 66" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="hugging-science" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Group-25" transform="translate(1.000000, 0.544667)">
            <g id="Group-24" transform="translate(0.000000, 39.455333)" stroke="currentColor" stroke-linecap="round" stroke-width="2">
                <g id="Group">
                    <path d="M24,0 C21.6105156,1.87410542 15.8506615,4.97797779 12,10.0084559 C7.79314603,15.5042613 5.54420624,22.9525368 4.5,25" id="Path" stroke-linejoin="round"></path>
                    <path d="M4.5,25 L0,14.7058824 M4.5,25 L13.5,20.5882353" id="Shape"></path>
                </g>
            </g>
            <g id="just-one-more-yolo-r" transform="translate(37.647357, 0.000000)" fill="currentColor" fill-rule="nonzero">
                <path d="M6.41864286,38.3793333 C5.74397619,39.054 4.87764286,39.3836667 3.81964286,39.3683333 C2.76164286,39.353 1.86464286,38.962 1.12864286,38.1953333 C0.760642857,37.6126667 0.47697619,36.984 0.277642857,36.3093333 C0.0783095238,35.6346667 -0.0136904762,35.0443333 0.00164285714,34.5383333 C0.0169761905,34.0323333 0.17797619,33.7793333 0.484642857,33.7793333 C0.63797619,33.7793333 0.77597619,33.8253333 0.898642857,33.9173333 C1.02130952,34.0093333 1.12864286,34.1396667 1.22064286,34.3083333 C1.31264286,34.477 1.35864286,34.684 1.35864286,34.9293333 C1.35864286,35.3893333 1.46597619,35.8033333 1.68064286,36.1713333 C1.89530952,36.5393333 2.20197619,36.7233333 2.60064286,36.7233333 C2.93797619,36.846 3.39030952,36.754 3.95764286,36.4473333 C4.52497619,36.1406667 4.97730952,35.7113333 5.31464286,35.1593333 C5.62130952,34.7606667 5.99697619,34.132 6.44164286,33.2733333 C6.88630952,32.4146667 7.33097619,31.5176667 7.77564286,30.5823333 C8.22030952,29.647 8.54997619,28.888 8.76464286,28.3053333 C9.13264286,27.048 9.46230952,25.76 9.75364286,24.4413333 C10.0449762,23.1226667 10.3439762,21.712 10.6506429,20.2093333 C10.7733095,19.3813333 10.9189762,18.6683333 11.0876429,18.0703333 C11.2563095,17.4723333 11.3406429,17.112 11.3406429,16.9893333 C11.3406429,16.8666667 11.3559762,16.6136667 11.3866429,16.2303333 C11.4173095,15.847 11.5093095,15.502 11.6626429,15.1953333 C11.6626429,14.7353333 11.7009762,14.329 11.7776429,13.9763333 C11.8543095,13.6236667 11.8926429,13.386 11.8926429,13.2633333 C11.9846429,13.1713333 12.1149762,13.1406667 12.2836429,13.1713333 C12.4523095,13.202 12.6363095,13.2633333 12.8356429,13.3553333 C13.0349762,13.4473333 13.2113095,13.57 13.3646429,13.7233333 C13.6099762,13.9686667 13.7709762,14.214 13.8476429,14.4593333 C13.9243095,14.7046667 13.9396429,15.088 13.8936429,15.6093333 C13.8476429,16.1306667 13.7479762,16.9586667 13.5946429,18.0933333 C13.5946429,18.2773333 13.5486429,18.653 13.4566429,19.2203333 C13.3646429,19.7876667 13.2419762,20.424 13.0886429,21.1293333 C12.9353095,21.8346667 12.7819762,22.517 12.6286429,23.1763333 C12.4753095,23.8356667 12.3526429,24.38 12.2606429,24.8093333 C12.1379762,25.2693333 11.9999762,25.7753333 11.8466429,26.3273333 C11.6933095,26.8793333 11.6013095,27.2626667 11.5706429,27.4773333 C11.5399762,27.6613333 11.4326429,28.0216667 11.2486429,28.5583333 C11.0646429,29.095 10.8729762,29.624 10.6736429,30.1453333 C10.4743095,30.6666667 10.3593095,31.0346667 10.3286429,31.2493333 C10.2979762,31.372 10.2136429,31.6633333 10.0756429,32.1233333 C9.93764286,32.5833333 9.65397619,33.2886667 9.22464286,34.2393333 C9.07130952,34.6073333 8.81830952,35.0826667 8.46564286,35.6653333 C8.11297619,36.248 7.75264286,36.7923333 7.38464286,37.2983333 C7.01664286,37.8043333 6.69464286,38.1646667 6.41864286,38.3793333 Z M13.6866429,7.14533333 C13.3493095,6.74666667 13.2343095,6.22533333 13.3416429,5.58133333 C13.4489762,4.93733333 13.7479762,4.29333333 14.2386429,3.64933333 C14.6373095,3.18933333 15.0666429,2.92866667 15.5266429,2.86733333 C15.9866429,2.806 16.4159762,2.944 16.8146429,3.28133333 C17.1519762,3.80266667 17.3206429,4.22433333 17.3206429,4.54633333 C17.3206429,4.86833333 17.1519762,5.27466667 16.8146429,5.76533333 C16.0479762,6.624 15.4346429,7.153 14.9746429,7.35233333 C14.5146429,7.55166667 14.0853095,7.48266667 13.6866429,7.14533333 Z" id="j"></path>
                <path d="M28.1766429,29.3633333 C27.8699762,29.0566667 27.5633095,28.635 27.2566429,28.0983333 C26.9499762,27.5616667 26.7046429,26.9406667 26.5206429,26.2353333 C26.4593095,25.99 26.4363095,25.6526667 26.4516429,25.2233333 C26.4669762,24.794 26.4593095,24.4873333 26.4286429,24.3033333 C26.3366429,24.518 26.1909762,24.7403333 25.9916429,24.9703333 C25.7923095,25.2003333 25.6006429,25.392 25.4166429,25.5453333 C25.2939762,25.668 25.0179762,25.9056667 24.5886429,26.2583333 C24.1593095,26.611 23.7299762,26.8946667 23.3006429,27.1093333 C22.2886429,27.7533333 21.4529762,28.106 20.7936429,28.1673333 C20.1343095,28.2286667 19.5133095,27.8913333 18.9306429,27.1553333 C18.4399762,26.7566667 18.0949762,26.312 17.8956429,25.8213333 C17.6963095,25.3306667 17.6886429,24.656 17.8726429,23.7973333 C17.9339762,22.724 18.0873095,21.6736667 18.3326429,20.6463333 C18.5779762,19.619 19.0839762,18.2466667 19.8506429,16.5293333 C20.4946429,15.272 20.9853095,14.3443333 21.3226429,13.7463333 C21.6599762,13.1483333 21.8746429,12.788 21.9666429,12.6653333 C22.4266429,12.512 22.8099762,12.5196667 23.1166429,12.6883333 C23.4233095,12.857 23.6073095,13.156 23.6686429,13.5853333 C23.8526429,13.892 23.8296429,14.4133333 23.5996429,15.1493333 C23.3696429,15.8853333 22.9786429,16.79 22.4266429,17.8633333 C21.9973095,18.906 21.6063095,19.9486667 21.2536429,20.9913333 C20.9009762,22.034 20.6939762,22.9233333 20.6326429,23.6593333 C20.5713095,24.3953333 20.7553095,24.84 21.1846429,24.9933333 C21.4606429,25.1466667 21.9436429,25.1006667 22.6336429,24.8553333 C23.3236429,24.61 24.1056429,23.9966667 24.9796429,23.0153333 C25.8536429,22.034 26.7046429,20.5466667 27.5326429,18.5533333 C27.7779762,17.94 27.9619762,17.3956667 28.0846429,16.9203333 C28.2073095,16.445 28.2839762,15.916 28.3146429,15.3333333 C28.2533095,14.9653333 28.2763095,14.6356667 28.3836429,14.3443333 C28.4909762,14.053 28.7286429,13.8 29.0966429,13.5853333 C29.2193095,13.432 29.3879762,13.2863333 29.6026429,13.1483333 C29.8173095,13.0103333 29.9553095,13.018 30.0166429,13.1713333 L30.7526429,13.1253333 C30.8753095,13.0946667 30.9596429,13.1636667 31.0056429,13.3323333 C31.0516429,13.501 31.1513095,13.6466667 31.3046429,13.7693333 C31.6419762,14.0453333 31.7339762,14.6433333 31.5806429,15.5633333 C31.4273095,16.4833333 30.9979762,17.7713333 30.2926429,19.4273333 C29.7099762,20.6846667 29.3189762,21.6353333 29.1196429,22.2793333 C28.9203095,22.9233333 28.8053095,23.552 28.7746429,24.1653333 C28.7746429,24.7173333 28.8819762,25.2386667 29.0966429,25.7293333 C29.3113095,26.22 29.6486429,26.6646667 30.1086429,27.0633333 C30.4459762,27.278 30.6376429,27.5233333 30.6836429,27.7993333 C30.7296429,28.0753333 30.7373095,28.3973333 30.7066429,28.7653333 C30.6453095,29.0413333 30.4689762,29.2636667 30.1776429,29.4323333 C29.8863095,29.601 29.5566429,29.6853333 29.1886429,29.6853333 C28.8206429,29.6853333 28.4833095,29.578 28.1766429,29.3633333 Z" id="u"></path>
                <path d="M38.5726429,29.0413333 C37.8059762,29.1026667 37.0776429,29.0566667 36.3876429,28.9033333 C35.6976429,28.75 35.1149762,28.4816667 34.6396429,28.0983333 C34.1643095,27.715 33.8346429,27.2473333 33.6506429,26.6953333 C33.4359762,26.266 33.3286429,25.967 33.3286429,25.7983333 C33.3286429,25.6296667 33.4359762,25.484 33.6506429,25.3613333 C33.8959762,25.3613333 34.1183095,25.4303333 34.3176429,25.5683333 C34.5169762,25.7063333 34.7853095,25.852 35.1226429,26.0053333 C35.5826429,26.404 36.1423095,26.6186667 36.8016429,26.6493333 C37.4609762,26.68 38.0666429,26.5726667 38.6186429,26.3273333 C39.1706429,26.082 39.4773095,25.7753333 39.5386429,25.4073333 C39.5386429,25.2846667 39.4926429,25.07 39.4006429,24.7633333 C39.3086429,24.4566667 39.2013095,24.1346667 39.0786429,23.7973333 C38.2506429,22.632 37.6449762,21.4743333 37.2616429,20.3243333 C36.8783095,19.1743333 36.6866429,18.2313333 36.6866429,17.4953333 C36.6866429,16.9433333 36.8553095,16.353 37.1926429,15.7243333 C37.5299762,15.0956667 37.9899762,14.5666667 38.5726429,14.1373333 C39.1246429,13.5546667 39.7379762,13.0333333 40.4126429,12.5733333 C41.0873095,12.1133333 41.7696429,11.7146667 42.4596429,11.3773333 C43.1496429,11.04 43.7706429,10.7946667 44.3226429,10.6413333 C44.6599762,10.6413333 45.1046429,10.6873333 45.6566429,10.7793333 C46.2086429,10.8713333 46.5919762,10.9786667 46.8066429,11.1013333 C47.1439762,11.224 47.4659762,11.5536667 47.7726429,12.0903333 C48.0793095,12.627 48.2326429,13.156 48.2326429,13.6773333 C48.2326429,13.892 48.1713095,14.168 48.0486429,14.5053333 C47.9259762,14.8426667 47.7266429,15.2413333 47.4506429,15.7013333 C47.3279762,16.0386667 47.1899762,16.353 47.0366429,16.6443333 C46.8833095,16.9356667 46.8066429,17.1426667 46.8066429,17.2653333 C46.6533095,17.6026667 46.4463095,17.7636667 46.1856429,17.7483333 C45.9249762,17.733 45.6643095,17.595 45.4036429,17.3343333 C45.1429762,17.0736667 44.9359762,16.7593333 44.7826429,16.3913333 C44.6599762,15.9313333 44.6139762,15.5556667 44.6446429,15.2643333 C44.6753095,14.973 44.7979762,14.6586667 45.0126429,14.3213333 C45.3499762,13.984 45.5186429,13.754 45.5186429,13.6313333 C45.5186429,13.5086667 45.3499762,13.4473333 45.0126429,13.4473333 C44.7979762,13.4473333 44.4069762,13.5776667 43.8396429,13.8383333 C43.2723095,14.099 42.6743095,14.4363333 42.0456429,14.8503333 C41.4169762,15.2643333 40.8726429,15.7013333 40.4126429,16.1613333 C39.8299762,16.7133333 39.4849762,17.112 39.3776429,17.3573333 C39.2703095,17.6026667 39.2166429,17.986 39.2166429,18.5073333 C39.2166429,18.9366667 39.3163095,19.4733333 39.5156429,20.1173333 C39.7149762,20.7613333 39.9219762,21.1906667 40.1366429,21.4053333 C40.1366429,21.4053333 40.2439762,21.6123333 40.4586429,22.0263333 C40.6733095,22.4403333 40.9339762,22.8773333 41.2406429,23.3373333 C42.1299762,25.3 42.3599762,26.7106667 41.9306429,27.5693333 C41.5013095,28.428 40.3819762,28.9186667 38.5726429,29.0413333 Z" id="s"></path>
                <path d="M54.0286429,31.7553333 C53.0166429,31.602 52.3343095,31.2263333 51.9816429,30.6283333 C51.6289762,30.0303333 51.5446429,29.118 51.7286429,27.8913333 C51.9126429,27.3086667 52.0276429,26.7796667 52.0736429,26.3043333 C52.1196429,25.829 52.2499762,25.53 52.4646429,25.4073333 C52.4646429,25.4073333 52.4876429,25.3613333 52.5336429,25.2693333 C52.5796429,25.1773333 52.5566429,25.0853333 52.4646429,24.9933333 C52.4646429,24.5946667 52.6026429,24.0426667 52.8786429,23.3373333 C52.9399762,23.1533333 53.0243095,22.931 53.1316429,22.6703333 C53.2389762,22.4096667 53.2926429,22.2793333 53.2926429,22.2793333 C53.1393095,22.034 53.1393095,21.8346667 53.2926429,21.6813333 C53.4459762,21.528 53.6069762,21.3823333 53.7756429,21.2443333 C53.9443095,21.1063333 53.9519762,20.9453333 53.7986429,20.7613333 C53.7373095,20.6386667 53.8139762,20.355 54.0286429,19.9103333 C54.2433095,19.4656667 54.4886429,18.998 54.7646429,18.5073333 C55.0406429,18.0166667 55.2246429,17.6333333 55.3166429,17.3573333 C55.3166429,17.296 55.3933095,17.0813333 55.5466429,16.7133333 C55.6999762,16.3453333 55.8839762,15.916 56.0986429,15.4253333 C56.3133095,14.9346667 56.5203095,14.49 56.7196429,14.0913333 C56.9189762,13.6926667 57.0493095,13.432 57.1106429,13.3093333 C57.4173095,13.156 57.2946429,13.0486667 56.7426429,12.9873333 C56.1906429,12.926 55.6079762,12.9106667 54.9946429,12.9413333 C54.0439762,12.9106667 53.2849762,12.8646667 52.7176429,12.8033333 C52.1503095,12.742 51.6826429,12.604 51.3146429,12.3893333 C50.9466429,11.96 50.8163095,11.6456667 50.9236429,11.4463333 C51.0309762,11.247 51.3913095,11.132 52.0046429,11.1013333 C52.4033095,11.0706667 52.7176429,11.0553333 52.9476429,11.0553333 C53.1776429,11.0553333 53.4843095,11.0323333 53.8676429,10.9863333 C54.2509762,10.9403333 54.8566429,10.8713333 55.6846429,10.7793333 L58.0306429,10.5953333 L58.1686429,9.81333333 C58.4139762,9.41466667 58.6209762,9.05433333 58.7896429,8.73233333 C58.9583095,8.41033333 59.1039762,8.08066667 59.2266429,7.74333333 C59.3493095,7.406 59.4413095,7.05333333 59.5026429,6.68533333 C59.5026429,6.68533333 59.6406429,6.43233333 59.9166429,5.92633333 C60.1926429,5.42033333 60.3613095,4.89133333 60.4226429,4.33933333 C60.7906429,3.726 61.1126429,3.16633333 61.3886429,2.66033333 C61.6646429,2.15433333 61.8333095,1.84 61.8946429,1.71733333 C62.2319762,1.44133333 62.4696429,1.30333333 62.6076429,1.30333333 C62.7456429,1.30333333 63.0446429,1.45666667 63.5046429,1.76333333 C63.7806429,1.91666667 64.0259762,2.10066667 64.2406429,2.31533333 C64.4553095,2.53 64.5933095,2.75233333 64.6546429,2.98233333 C64.7159762,3.21233333 64.6239762,3.43466667 64.3786429,3.64933333 C64.3173095,3.772 64.2253095,3.99433333 64.1026429,4.31633333 C63.9799762,4.63833333 63.8879762,4.90666667 63.8266429,5.12133333 C63.6426429,5.336 63.4203095,5.681 63.1596429,6.15633333 C62.8989762,6.63166667 62.7226429,7.11466667 62.6306429,7.60533333 C62.3853095,8.12666667 62.1553095,8.59433333 61.9406429,9.00833333 C61.7259762,9.42233333 61.5573095,9.62933333 61.4346429,9.62933333 C61.4959762,9.936 61.6799762,10.0816667 61.9866429,10.0663333 C62.2933095,10.051 62.7993095,10.028 63.5046429,9.99733333 C64.0873095,9.936 64.4936429,9.867 64.7236429,9.79033333 C64.9536429,9.71366667 65.2219762,9.752 65.5286429,9.90533333 C65.6819762,10.12 65.8046429,10.3653333 65.8966429,10.6413333 C65.9886429,10.9173333 66.0116429,11.1703333 65.9656429,11.4003333 C65.9196429,11.6303333 65.7893095,11.7913333 65.5746429,11.8833333 C65.4213095,11.8833333 65.1069762,11.9676667 64.6316429,12.1363333 C64.1563095,12.305 63.5659762,12.4046667 62.8606429,12.4353333 L60.4226429,12.6653333 L59.6406429,14.2293333 C59.4259762,14.628 59.2419762,14.9883333 59.0886429,15.3103333 C58.9353095,15.6323333 58.8279762,15.824 58.7666429,15.8853333 C58.7666429,16.0693333 58.6669762,16.3453333 58.4676429,16.7133333 C58.2683095,17.0813333 58.0613095,17.48 57.8466429,17.9093333 C57.6626429,18.4306667 57.4556429,18.906 57.2256429,19.3353333 C56.9956429,19.7646667 56.8806429,19.9793333 56.8806429,19.9793333 C56.7579762,19.9793333 56.6966429,20.0713333 56.6966429,20.2553333 C56.8499762,20.6233333 56.8039762,20.8993333 56.5586429,21.0833333 C56.4053095,21.1753333 56.2749762,21.3056667 56.1676429,21.4743333 C56.0603095,21.643 56.0066429,21.7273333 56.0066429,21.7273333 C56.1293095,21.85 56.1523095,22.0033333 56.0756429,22.1873333 C55.9989762,22.3713333 55.8993095,22.5706667 55.7766429,22.7853333 C55.7766429,23.0306667 55.7076429,23.3833333 55.5696429,23.8433333 C55.4316429,24.3033333 55.2859762,24.7326667 55.1326429,25.1313333 C55.1633095,25.6833333 55.1939762,26.036 55.2246429,26.1893333 C55.2553095,26.3426667 55.3319762,26.404 55.4546429,26.3733333 C55.6079762,26.404 55.7459762,26.404 55.8686429,26.3733333 C55.9913095,26.3426667 56.1139762,26.3273333 56.2366429,26.3273333 C56.6659762,26.1433333 56.4359762,27.2166667 55.5466429,29.5473333 C55.0559762,30.314 54.7186429,30.8736667 54.5346429,31.2263333 C54.3506429,31.579 54.1819762,31.7553333 54.0286429,31.7553333 Z" id="t"></path>
                <path d="M81.0766429,27.7073333 C80.4326429,27.83 80.0263095,27.8683333 79.8576429,27.8223333 C79.6889762,27.7763333 79.4359762,27.6 79.0986429,27.2933333 C78.6079762,27.048 78.2016429,26.7413333 77.8796429,26.3733333 C77.5576429,26.0053333 77.3276429,25.6143333 77.1896429,25.2003333 C77.0516429,24.7863333 76.9979762,24.4413333 77.0286429,24.1653333 C77.1206429,23.092 77.3813095,21.942 77.8106429,20.7153333 C78.2399762,19.4886667 78.7613095,18.308 79.3746429,17.1733333 C79.9879762,16.0386667 80.6549762,15.065 81.3756429,14.2523333 C82.0963095,13.4396667 82.7939762,12.9106667 83.4686429,12.6653333 C84.0819762,12.42 84.6646429,12.328 85.2166429,12.3893333 C85.7686429,12.4506667 86.1673095,12.742 86.4126429,13.2633333 C86.8726429,14.1526667 86.7653095,14.72 86.0906429,14.9653333 C85.9986429,14.9653333 85.8913095,15.0036667 85.7686429,15.0803333 C85.6459762,15.157 85.5846429,15.2566667 85.5846429,15.3793333 C85.7073095,15.4406667 86.0446429,15.4483333 86.5966429,15.4023333 C87.1486429,15.3563333 87.7083095,15.2643333 88.2756429,15.1263333 C88.8429762,14.9883333 89.2186429,14.8426667 89.4026429,14.6893333 C89.5866429,14.5973333 89.7246429,14.5513333 89.8166429,14.5513333 C89.9086429,14.5513333 90.1386429,14.582 90.5066429,14.6433333 C91.0279762,14.7966667 91.2886429,14.9806667 91.2886429,15.1953333 C91.2886429,15.318 91.3346429,15.433 91.4266429,15.5403333 C91.5186429,15.6476667 91.6259762,15.7013333 91.7486429,15.7013333 C91.9633095,15.732 91.9403095,15.87 91.6796429,16.1153333 C91.4189762,16.3606667 90.9819762,16.698 90.3686429,17.1273333 C89.7859762,17.4953333 89.4256429,17.733 89.2876429,17.8403333 C89.1496429,17.9476667 89.1266429,18.17 89.2186429,18.5073333 C89.4639762,19.09 89.4793095,19.7646667 89.2646429,20.5313333 C89.0499762,21.298 88.6666429,22.08 88.1146429,22.8773333 C87.5626429,23.6746667 86.8956429,24.4183333 86.1136429,25.1083333 C85.3316429,25.7983333 84.5036429,26.381 83.6296429,26.8563333 C82.7556429,27.3316667 81.9046429,27.6153333 81.0766429,27.7073333 Z M80.2946429,25.6833333 C80.4173095,25.6833333 80.6319762,25.6143333 80.9386429,25.4763333 C81.2453095,25.3383333 81.4906429,25.2233333 81.6746429,25.1313333 C81.7973095,25.0086667 81.9583095,24.863 82.1576429,24.6943333 C82.3569762,24.5256667 82.5179762,24.426 82.6406429,24.3953333 C82.7633095,24.3953333 82.9166429,24.3416667 83.1006429,24.2343333 C83.2846429,24.127 83.5453095,23.897 83.8826429,23.5443333 C84.2199762,23.1916667 84.6646429,22.6626667 85.2166429,21.9573333 C85.8299762,21.2826667 86.3053095,20.6616667 86.6426429,20.0943333 C86.9799762,19.527 87.0719762,18.998 86.9186429,18.5073333 C86.8879762,18.3846667 86.8036429,18.308 86.6656429,18.2773333 C86.5276429,18.2466667 86.3513095,18.17 86.1366429,18.0473333 C85.8299762,18.0473333 85.5463095,17.963 85.2856429,17.7943333 C85.0249762,17.6256667 84.7259762,17.4033333 84.3886429,17.1273333 L83.6526429,16.2073333 L82.8706429,16.9893333 C82.3799762,17.48 81.8663095,18.2083333 81.3296429,19.1743333 C80.7929762,20.1403333 80.3406429,21.1216667 79.9726429,22.1183333 C79.6046429,23.115 79.3899762,23.9046667 79.3286429,24.4873333 C79.2979762,24.9473333 79.3746429,25.254 79.5586429,25.4073333 C79.7426429,25.5606667 79.9879762,25.6526667 80.2946429,25.6833333 Z" id="o"></path>
                <path d="M108.768643,27.3393333 C108.15531,27.3393333 107.64931,27.209 107.250643,26.9483333 C106.851976,26.6876667 106.514643,26.2506667 106.238643,25.6373333 C106.115976,25.208 106.01631,24.725 105.939643,24.1883333 C105.862976,23.6516667 105.824643,23.1456667 105.824643,22.6703333 C105.824643,22.195 105.870643,21.8806667 105.962643,21.7273333 C106.08531,21.6046667 106.138976,21.3823333 106.123643,21.0603333 C106.10831,20.7383333 106.100643,20.3933333 106.100643,20.0253333 C106.069976,19.412 105.92431,19.067 105.663643,18.9903333 C105.402976,18.9136667 105.02731,19.0133333 104.536643,19.2893333 C103.984643,19.6266667 103.263976,20.079 102.374643,20.6463333 C101.48531,21.2136667 100.557643,21.8346667 99.5916429,22.5093333 C98.6256429,23.184 97.7133095,23.8893333 96.8546429,24.6253333 C96.1799762,25.3613333 95.7736429,25.921 95.6356429,26.3043333 C95.4976429,26.6876667 95.3059762,26.8793333 95.0606429,26.8793333 C94.8153095,27.002 94.6083095,27.0096667 94.4396429,26.9023333 C94.2709762,26.795 94.0333095,26.6186667 93.7266429,26.3733333 C93.5119762,26.128 93.2973095,25.8903333 93.0826429,25.6603333 C92.8679762,25.4303333 92.7299762,25.254 92.6686429,25.1313333 C92.6686429,24.978 92.7146429,24.656 92.8066429,24.1653333 C92.8986429,23.6746667 93.0136429,23.184 93.1516429,22.6933333 C93.2896429,22.2026667 93.3893095,21.8806667 93.4506429,21.7273333 C93.6039762,21.7273333 93.7343095,21.574 93.8416429,21.2673333 C93.9489762,20.9606667 94.1253095,20.6233333 94.3706429,20.2553333 C94.4319762,19.8873333 94.5929762,19.389 94.8536429,18.7603333 C95.1143095,18.1316667 95.3519762,17.572 95.5666429,17.0813333 C95.9959762,16.3453333 96.2949762,15.732 96.4636429,15.2413333 C96.6323095,14.7506667 96.7473095,14.1373333 96.8086429,13.4013333 C96.7779762,13.2786667 96.8086429,13.1636667 96.9006429,13.0563333 C96.9926429,12.949 97.0999762,12.8953333 97.2226429,12.8953333 L97.2226429,12.8953333 L97.2226429,12.8953333 C97.4679762,12.65 97.7593095,12.581 98.0966429,12.6883333 C98.4339762,12.7956667 98.7406429,13.0333333 99.0166429,13.4013333 C99.5686429,14.1373333 99.7909762,14.8963333 99.6836429,15.6783333 C99.5763095,16.4603333 99.0779762,17.572 98.1886429,19.0133333 C97.9739762,19.504 97.8129762,19.8796667 97.7056429,20.1403333 C97.5983095,20.401 97.5446429,20.608 97.5446429,20.7613333 C97.5446429,20.7613333 97.7056429,20.654 98.0276429,20.4393333 C98.3496429,20.2246667 98.7176429,19.9716667 99.1316429,19.6803333 C99.5456429,19.389 99.8753095,19.1666667 100.120643,19.0133333 C100.273976,18.86 100.626643,18.584 101.178643,18.1853333 C101.730643,17.7866667 102.320976,17.3956667 102.949643,17.0123333 C103.57831,16.629 104.045976,16.4066667 104.352643,16.3453333 C104.597976,16.2226667 104.858643,16.1076667 105.134643,16.0003333 C105.410643,15.893 105.609976,15.8393333 105.732643,15.8393333 C105.977976,15.8393333 106.29231,15.9696667 106.675643,16.2303333 C107.058976,16.491 107.41931,16.7976667 107.756643,17.1503333 C108.093976,17.503 108.29331,17.802 108.354643,18.0473333 C108.354643,18.17 108.36231,18.2926667 108.377643,18.4153333 C108.392976,18.538 108.415976,18.6606667 108.446643,18.7833333 C108.56931,19.182 108.63831,19.7186667 108.653643,20.3933333 C108.668976,21.068 108.645976,21.6813333 108.584643,22.2333333 C108.52331,22.7853333 108.415976,23.1073333 108.262643,23.1993333 C108.262643,23.1993333 108.27031,23.2376667 108.285643,23.3143333 C108.300976,23.391 108.369976,23.4293333 108.492643,23.4293333 C108.492643,23.552 108.492643,23.621 108.492643,23.6363333 C108.492643,23.6516667 108.492643,23.6593333 108.492643,23.6593333 C108.33931,23.6593333 108.277976,23.7896667 108.308643,24.0503333 C108.33931,24.311 108.438976,24.5946667 108.607643,24.9013333 C108.77631,25.208 108.952643,25.4533333 109.136643,25.6373333 C109.504643,26.0053333 109.657976,26.3503333 109.596643,26.6723333 C109.53531,26.9943333 109.25931,27.2166667 108.768643,27.3393333 Z" id="n"></path>
                <path d="M116.404643,28.3513333 C115.208643,27.8606667 114.43431,27.1783333 114.081643,26.3043333 C113.728976,25.4303333 113.659976,24.0733333 113.874643,22.2333333 C113.935976,21.2826667 113.966643,20.654 113.966643,20.3473333 C113.966643,20.0406667 113.797976,19.734 113.460643,19.4273333 C113.368643,19.3046667 113.207643,19.136 112.977643,18.9213333 C112.747643,18.7066667 112.647976,18.5226667 112.678643,18.3693333 C112.647976,18.1546667 112.66331,17.917 112.724643,17.6563333 C112.785976,17.3956667 112.877976,17.2653333 113.000643,17.2653333 C113.12331,17.2653333 113.253643,17.2346667 113.391643,17.1733333 C113.529643,17.112 113.659976,17.112 113.782643,17.1733333 C113.90531,17.1733333 114.04331,17.1886667 114.196643,17.2193333 C114.349976,17.25 114.426643,17.3266667 114.426643,17.4493333 C114.54931,17.664 114.748643,17.687 115.024643,17.5183333 C115.300643,17.3496667 115.591976,16.9586667 115.898643,16.3453333 C116.20531,15.8546667 116.611643,15.364 117.117643,14.8733333 C117.623643,14.3826667 118.129643,13.9303333 118.635643,13.5163333 C119.141643,13.1023333 119.56331,12.8033333 119.900643,12.6193333 C120.053976,12.558 120.283976,12.4813333 120.590643,12.3893333 C120.89731,12.2973333 121.226976,12.2206667 121.579643,12.1593333 C121.93231,12.098 122.23131,12.0826667 122.476643,12.1133333 C123.028643,12.144 123.49631,12.2973333 123.879643,12.5733333 C124.262976,12.8493333 124.62331,13.1713333 124.960643,13.5393333 C125.35931,13.8153333 125.61231,14.1833333 125.719643,14.6433333 C125.826976,15.1033333 125.849976,15.594 125.788643,16.1153333 C125.72731,16.6366667 125.58931,17.112 125.374643,17.5413333 C125.282643,17.848 125.021976,18.216 124.592643,18.6453333 C124.16331,19.0746667 123.672643,19.4886667 123.120643,19.8873333 C122.568643,20.286 122.062643,20.5773333 121.602643,20.7613333 C121.203976,20.8533333 120.69031,20.93 120.061643,20.9913333 C119.432976,21.0526667 118.85031,21.0756667 118.313643,21.0603333 C117.776976,21.045 117.416643,20.9913333 117.232643,20.8993333 C117.017976,20.7766667 116.84931,20.9453333 116.726643,21.4053333 C116.603976,21.8653333 116.511976,22.5246667 116.450643,23.3833333 C116.38931,24.058 116.38931,24.5486667 116.450643,24.8553333 C116.511976,25.162 116.57331,25.3766667 116.634643,25.4993333 C116.84931,25.714 117.14831,25.9823333 117.531643,26.3043333 C117.914976,26.6263333 118.45931,26.68 119.164643,26.4653333 C119.74731,26.312 120.32231,25.9133333 120.889643,25.2693333 C121.456976,24.6253333 121.985976,24.104 122.476643,23.7053333 C122.59931,23.4906667 122.80631,23.3603333 123.097643,23.3143333 C123.388976,23.2683333 123.70331,23.2913333 124.040643,23.3833333 C124.377976,23.598 124.523643,23.851 124.477643,24.1423333 C124.431643,24.4336667 124.270643,24.8706667 123.994643,25.4533333 C123.902643,25.668 123.695643,25.9363333 123.373643,26.2583333 C123.051643,26.5803333 122.698976,26.9023333 122.315643,27.2243333 C121.93231,27.5463333 121.58731,27.7993333 121.280643,27.9833333 C120.360643,28.474 119.501976,28.727 118.704643,28.7423333 C117.90731,28.7576667 117.140643,28.6273333 116.404643,28.3513333 Z M119.118643,19.0133333 C119.79331,18.86 120.329976,18.7526667 120.728643,18.6913333 C121.12731,18.63 121.510643,18.4536667 121.878643,18.1623333 C122.246643,17.871 122.706643,17.3113333 123.258643,16.4833333 C123.38131,16.146 123.419643,15.8086667 123.373643,15.4713333 C123.327643,15.134 123.24331,14.904 123.120643,14.7813333 C122.844643,14.4746667 122.514976,14.375 122.131643,14.4823333 C121.74831,14.5896667 121.387976,14.766 121.050643,15.0113333 C120.835976,15.1033333 120.521643,15.3256667 120.107643,15.6783333 C119.693643,16.031 119.28731,16.4296667 118.888643,16.8743333 C118.489976,17.319 118.167976,17.7253333 117.922643,18.0933333 C117.67731,18.4613333 117.615976,18.676 117.738643,18.7373333 C117.67731,18.86 117.853643,18.9366667 118.267643,18.9673333 C118.681643,18.998 118.96531,19.0133333 119.118643,19.0133333 Z" id="e"></path>
                <path d="M140.554643,27.7533333 C140.462643,27.6306667 140.37831,27.4773333 140.301643,27.2933333 C140.224976,27.1093333 140.186643,26.956 140.186643,26.8333333 C140.186643,26.772 140.178976,26.6953333 140.163643,26.6033333 C140.14831,26.5113333 140.07931,26.4653333 139.956643,26.4653333 C139.864643,26.3733333 139.933643,26.013 140.163643,25.3843333 C140.393643,24.7556667 140.70031,24.0273333 141.083643,23.1993333 C141.466976,22.3713333 141.865643,21.5663333 142.279643,20.7843333 C142.693643,20.0023333 143.038643,19.3813333 143.314643,18.9213333 C143.467976,18.8293333 143.567643,18.699 143.613643,18.5303333 C143.659643,18.3616667 143.651976,18.2773333 143.590643,18.2773333 C143.590643,18.2773333 143.674976,18.1316667 143.843643,17.8403333 C144.01231,17.549 144.142643,17.3573333 144.234643,17.2653333 C144.479976,16.836 144.663976,16.399 144.786643,15.9543333 C144.90931,15.5096667 144.939976,15.134 144.878643,14.8273333 C144.755976,14.674 144.617976,14.628 144.464643,14.6893333 C144.31131,14.7506667 144.234643,14.7813333 144.234643,14.7813333 C144.111976,14.812 143.935643,14.8656667 143.705643,14.9423333 C143.475643,15.019 143.268643,15.1186667 143.084643,15.2413333 C142.37931,15.732 141.903976,15.9543333 141.658643,15.9083333 C141.41331,15.8623333 141.13731,15.4713333 140.830643,14.7353333 C140.707976,14.398 140.661976,14.1526667 140.692643,13.9993333 C140.72331,13.846 140.845976,13.6773333 141.060643,13.4933333 C141.305976,13.2786667 141.535976,13.133 141.750643,13.0563333 C141.96531,12.9796667 142.133976,12.8953333 142.256643,12.8033333 C142.593976,12.5886667 142.877643,12.4353333 143.107643,12.3433333 C143.337643,12.2513333 143.513976,12.19 143.636643,12.1593333 C144.433976,11.914 145.108643,11.868 145.660643,12.0213333 C146.212643,12.1746667 146.626643,12.5733333 146.902643,13.2173333 C147.331976,13.7386667 147.546643,14.329 147.546643,14.9883333 C147.546643,15.6476667 147.331976,16.4066667 146.902643,17.2653333 L146.442643,17.9553333 C146.28931,18.262 146.26631,18.4153333 146.373643,18.4153333 C146.480976,18.4153333 146.61131,18.308 146.764643,18.0933333 C146.856643,17.9706667 147.040643,17.7866667 147.316643,17.5413333 C147.592643,17.296 147.776643,17.1733333 147.868643,17.1733333 C147.868643,17.1733333 147.906976,17.158 147.983643,17.1273333 C148.06031,17.0966667 148.098643,16.974 148.098643,16.7593333 C148.190643,16.6673333 148.29031,16.5753333 148.397643,16.4833333 C148.504976,16.3913333 148.558643,16.3453333 148.558643,16.3453333 C148.68131,16.3453333 148.918976,16.1996667 149.271643,15.9083333 C149.62431,15.617 150.045976,15.272 150.536643,14.8733333 C150.873976,14.628 151.180643,14.5053333 151.456643,14.5053333 C152.161976,14.2906667 152.736976,14.5206667 153.181643,15.1953333 C153.62631,15.87 153.848643,16.744 153.848643,17.8173333 L152.882643,20.3013333 L154.538643,18.2773333 C154.722643,18.032 154.91431,17.8173333 155.113643,17.6333333 C155.312976,17.4493333 155.48931,17.296 155.642643,17.1733333 C155.703976,16.9586667 155.795976,16.836 155.918643,16.8053333 C156.04131,16.7746667 156.102643,16.7593333 156.102643,16.7593333 C156.102643,16.7593333 156.13331,16.7516667 156.194643,16.7363333 C156.255976,16.721 156.286643,16.6673333 156.286643,16.5753333 C156.439976,16.4526667 156.608643,16.3376667 156.792643,16.2303333 C156.976643,16.123 157.09931,16.008 157.160643,15.8853333 C157.681976,15.6706667 158.15731,15.6323333 158.586643,15.7703333 C159.015976,15.9083333 159.383976,16.2993333 159.690643,16.9433333 C159.90531,17.3113333 160.027976,17.6333333 160.058643,17.9093333 C160.08931,18.1853333 160.104643,18.5993333 160.104643,19.1513333 C160.04331,19.6113333 159.989643,19.9716667 159.943643,20.2323333 C159.897643,20.493 159.85931,20.7613333 159.828643,21.0373333 C159.797976,21.3133333 159.751976,21.6966667 159.690643,22.1873333 C159.567976,22.4326667 159.498976,22.6933333 159.483643,22.9693333 C159.46831,23.2453333 159.460643,23.506 159.460643,23.7513333 C159.460643,24.15 159.475976,24.4183333 159.506643,24.5563333 C159.53731,24.6943333 159.659976,24.7633333 159.874643,24.7633333 C160.303976,24.6713333 160.89431,24.449 161.645643,24.0963333 C162.396976,23.7436667 162.956643,23.3986667 163.324643,23.0613333 C163.784643,22.632 164.190976,22.4096667 164.543643,22.3943333 C164.89631,22.379 165.118643,22.5553333 165.210643,22.9233333 C165.271976,23.046 165.17231,23.322 164.911643,23.7513333 C164.650976,24.1806667 164.359643,24.5946667 164.037643,24.9933333 C163.715643,25.392 163.477976,25.5913333 163.324643,25.5913333 C163.232643,25.5913333 163.12531,25.6756667 163.002643,25.8443333 C162.879976,26.013 162.741976,26.1433333 162.588643,26.2353333 C162.373976,26.45 162.166976,26.6493333 161.967643,26.8333333 C161.76831,27.0173333 161.545976,27.1093333 161.300643,27.1093333 C161.177976,27.1093333 161.03231,27.1476667 160.863643,27.2243333 C160.694976,27.301 160.50331,27.3393333 160.288643,27.3393333 C159.981976,27.4313333 159.51431,27.3853333 158.885643,27.2013333 C158.256976,27.0173333 157.850643,26.588 157.666643,25.9133333 C157.543976,25.576 157.436643,25.0316667 157.344643,24.2803333 C157.252643,23.529 157.267976,22.77 157.390643,22.0033333 C157.51331,21.4513333 157.589976,20.9453333 157.620643,20.4853333 C157.65131,20.0253333 157.712643,19.7033333 157.804643,19.5193333 C157.804643,19.4273333 157.804643,19.205 157.804643,18.8523333 C157.804643,18.4996667 157.758643,18.3233333 157.666643,18.3233333 C157.543976,18.3233333 157.26031,18.5456667 156.815643,18.9903333 C156.370976,19.435 155.849643,19.9946667 155.251643,20.6693333 C154.653643,21.344 154.06331,22.0493333 153.480643,22.7853333 C152.897976,23.5213333 152.422643,24.1806667 152.054643,24.7633333 C151.778643,25.1006667 151.53331,25.5146667 151.318643,26.0053333 C151.103976,26.496 150.950643,26.772 150.858643,26.8333333 C150.643976,27.0786667 150.390976,27.1093333 150.099643,26.9253333 C149.80831,26.7413333 149.539976,26.45 149.294643,26.0513333 C149.202643,25.8673333 149.14131,25.7063333 149.110643,25.5683333 C149.079976,25.4303333 149.087643,25.231 149.133643,24.9703333 C149.179643,24.7096667 149.286976,24.3186667 149.455643,23.7973333 C149.62431,23.276 149.861976,22.54 150.168643,21.5893333 C150.505976,20.5466667 150.804976,19.6036667 151.065643,18.7603333 C151.32631,17.917 151.456643,17.4953333 151.456643,17.4953333 C151.456643,17.3726667 151.226643,17.4876667 150.766643,17.8403333 C150.306643,18.193 149.769976,18.63 149.156643,19.1513333 C148.880643,19.4886667 148.420643,19.9946667 147.776643,20.6693333 C147.132643,21.344 146.42731,22.1106667 145.660643,22.9693333 C144.893976,23.828 144.157976,24.7326667 143.452643,25.6833333 C142.56331,26.9406667 141.94231,27.7073333 141.589643,27.9833333 C141.236976,28.2593333 140.891976,28.1826667 140.554643,27.7533333 Z" id="m"></path>
                <path d="M170.592643,28.7653333 C170.193976,28.7653333 169.879643,28.6886667 169.649643,28.5353333 C169.419643,28.382 169.135976,28.1673333 168.798643,27.8913333 C168.215976,27.278 167.801976,26.6876667 167.556643,26.1203333 C167.31131,25.553 167.234643,25.0086667 167.326643,24.4873333 C167.418643,24.242 167.456976,24.0043333 167.441643,23.7743333 C167.42631,23.5443333 167.418643,23.4293333 167.418643,23.4293333 C167.26531,23.276 167.21931,23.1763333 167.280643,23.1303333 C167.341976,23.0843333 167.40331,23 167.464643,22.8773333 C167.648643,22.8773333 167.709976,22.7086667 167.648643,22.3713333 C167.58731,22.126 167.709976,21.5893333 168.016643,20.7613333 C168.32331,19.9333333 168.706643,19.1513333 169.166643,18.4153333 C169.350643,18.1086667 169.626643,17.7023333 169.994643,17.1963333 C170.362643,16.6903333 170.768976,16.1843333 171.213643,15.6783333 C171.65831,15.1723333 172.064643,14.766 172.432643,14.4593333 C173.19931,13.8153333 173.873976,13.34 174.456643,13.0333333 C175.03931,12.7266667 175.667976,12.4966667 176.342643,12.3433333 C177.01731,12.19 177.484976,12.1133333 177.745643,12.1133333 C178.00631,12.1133333 178.366643,12.3586667 178.826643,12.8493333 C179.531976,13.156 180.045643,13.524 180.367643,13.9533333 C180.689643,14.3826667 180.896643,15.0113333 180.988643,15.8393333 C181.080643,16.7593333 181.011643,17.8096667 180.781643,18.9903333 C180.551643,20.171 179.82331,21.6353333 178.596643,23.3833333 C177.829976,24.4873333 177.124643,25.3076667 176.480643,25.8443333 C175.836643,26.381 175.069976,26.91 174.180643,27.4313333 C173.536643,27.8606667 172.953976,28.175 172.432643,28.3743333 C171.91131,28.5736667 171.297976,28.704 170.592643,28.7653333 Z M175.008643,23.8893333 C175.744643,23.0613333 176.334976,22.2793333 176.779643,21.5433333 C177.22431,20.8073333 177.645976,19.872 178.044643,18.7373333 C178.16731,18.4 178.243976,17.9783333 178.274643,17.4723333 C178.30531,16.9663333 178.297643,16.491 178.251643,16.0463333 C178.205643,15.6016667 178.090643,15.3486667 177.906643,15.2873333 C177.538643,15.0726667 177.093976,15.0036667 176.572643,15.0803333 C176.05131,15.157 175.483976,15.456 174.870643,15.9773333 C173.919976,16.7746667 173.091976,17.7636667 172.386643,18.9443333 C171.68131,20.125 170.99131,21.4666667 170.316643,22.9693333 C169.856643,24.0733333 169.756976,24.955 170.017643,25.6143333 C170.27831,26.2736667 170.845643,26.5036667 171.719643,26.3043333 C172.593643,26.105 173.689976,25.3 175.008643,23.8893333 Z" id="o"></path>
                <path d="M185.956643,28.3973333 C185.80331,28.704 185.580976,28.796 185.289643,28.6733333 C184.99831,28.5506667 184.760643,28.428 184.576643,28.3053333 C184.361976,28.3053333 184.177976,28.244 184.024643,28.1213333 C183.87131,27.9986667 183.763976,27.8146667 183.702643,27.5693333 C183.64131,27.3853333 183.625976,27.163 183.656643,26.9023333 C183.68731,26.6416667 183.75631,26.335 183.863643,25.9823333 C183.970976,25.6296667 184.085976,25.2386667 184.208643,24.8093333 C184.453976,23.7973333 184.622643,23.0613333 184.714643,22.6013333 C184.806643,22.1413333 184.898643,21.7426667 184.990643,21.4053333 C185.082643,21.068 185.20531,20.5773333 185.358643,19.9333333 C185.603976,19.32 185.80331,18.722 185.956643,18.1393333 C186.109976,17.5566667 186.339976,16.974 186.646643,16.3913333 C186.86131,15.594 187.129643,14.835 187.451643,14.1143333 C187.773643,13.3936667 188.087976,12.788 188.394643,12.2973333 C188.455976,12.2053333 188.570976,12.0826667 188.739643,11.9293333 C188.90831,11.776 189.053976,11.6993333 189.176643,11.6993333 C189.421976,11.454 189.64431,11.3543333 189.843643,11.4003333 C190.042976,11.4463333 190.295976,11.592 190.602643,11.8373333 C190.970643,12.236 191.11631,12.696 191.039643,13.2173333 C190.962976,13.7386667 190.58731,14.5053333 189.912643,15.5173333 C189.544643,16.468 189.20731,17.2883333 188.900643,17.9783333 C188.593976,18.6683333 188.37931,19.32 188.256643,19.9333333 C188.593976,19.4426667 188.969643,18.9903333 189.383643,18.5763333 C189.797643,18.1623333 190.142643,17.8173333 190.418643,17.5413333 C191.09331,16.8666667 191.652976,16.376 192.097643,16.0693333 C192.54231,15.7626667 193.07131,15.41 193.684643,15.0113333 C194.052643,14.766 194.40531,14.5436667 194.742643,14.3443333 C195.079976,14.145 195.455643,13.9993333 195.869643,13.9073333 C196.283643,13.8153333 196.735976,13.8153333 197.226643,13.9073333 C197.53331,13.8766667 197.78631,13.9686667 197.985643,14.1833333 C198.184976,14.398 198.345976,14.6893333 198.468643,15.0573333 C198.59131,15.4253333 198.667976,15.8546667 198.698643,16.3453333 C197.99331,16.192 197.364643,16.215 196.812643,16.4143333 C196.260643,16.6136667 195.792976,16.8513333 195.409643,17.1273333 C195.02631,17.4033333 194.72731,17.618 194.512643,17.7713333 C194.052643,18.078 193.469976,18.4843333 192.764643,18.9903333 C192.05931,19.4963333 191.353976,20.102 190.648643,20.8073333 C190.096643,21.4206667 189.628976,21.942 189.245643,22.3713333 C188.86231,22.8006667 188.555643,23.184 188.325643,23.5213333 C188.095643,23.8586667 187.91931,24.2113333 187.796643,24.5793333 C187.489976,25.2846667 187.167976,26.0513333 186.830643,26.8793333 C186.49331,27.7073333 186.201976,28.2133333 185.956643,28.3973333 Z" id="r"></path>
                <path d="M204.632643,29.5933333 C203.28331,29.5933333 202.17931,29.0796667 201.320643,28.0523333 C200.461976,27.025 200.047976,25.7446667 200.078643,24.2113333 C200.139976,23.1073333 200.36231,21.919 200.745643,20.6463333 C201.128976,19.3736667 201.642643,18.147 202.286643,16.9663333 C202.930643,15.7856667 203.635976,14.7506667 204.402643,13.8613333 C205.16931,12.972 205.966643,12.3433333 206.794643,11.9753333 C207.10131,11.822 207.430976,11.6993333 207.783643,11.6073333 C208.13631,11.5153333 208.496643,11.4693333 208.864643,11.4693333 C209.201976,11.4693333 209.554643,11.523 209.922643,11.6303333 C210.290643,11.7376667 210.59731,11.8526667 210.842643,11.9753333 C211.363976,12.19 211.762643,12.4506667 212.038643,12.7573333 C212.314643,13.064 212.559976,13.5393333 212.774643,14.1833333 C212.866643,14.766 212.912643,15.18 212.912643,15.4253333 C212.912643,15.6706667 212.835976,16.0386667 212.682643,16.5293333 C212.314643,17.6333333 211.83931,18.584 211.256643,19.3813333 C210.673976,20.1786667 209.891976,20.8533333 208.910643,21.4053333 C208.66531,21.5586667 208.381643,21.6736667 208.059643,21.7503333 C207.737643,21.827 207.407976,21.8653333 207.070643,21.8653333 C206.45731,21.8653333 205.866976,21.7503333 205.299643,21.5203333 C204.73231,21.2903333 204.279976,20.9453333 203.942643,20.4853333 L203.620643,20.1173333 L203.482643,20.4853333 C203.175976,21.3133333 202.93831,22.08 202.769643,22.7853333 C202.600976,23.4906667 202.516643,24.1346667 202.516643,24.7173333 C202.516643,25.0853333 202.554976,25.438 202.631643,25.7753333 C202.70831,26.1126667 202.82331,26.404 202.976643,26.6493333 C203.09931,26.8333333 203.30631,26.9636667 203.597643,27.0403333 C203.888976,27.117 204.20331,27.1553333 204.540643,27.1553333 C204.75531,27.1553333 204.977643,27.1476667 205.207643,27.1323333 C205.437643,27.117 205.659976,27.0633333 205.874643,26.9713333 C206.395976,26.7873333 206.817643,26.588 207.139643,26.3733333 C207.461643,26.1586667 207.79131,25.9286667 208.128643,25.6833333 L208.312643,25.5913333 L208.266643,25.5913333 C208.634643,25.4073333 208.96431,25.2233333 209.255643,25.0393333 C209.546976,24.8553333 209.692643,24.7633333 209.692643,24.7633333 C209.81531,24.7633333 209.937976,24.6866667 210.060643,24.5333333 C210.305976,24.4106667 210.62031,24.4566667 211.003643,24.6713333 C211.386976,24.886 211.578643,25.162 211.578643,25.4993333 C211.547976,25.6526667 211.409976,25.8903333 211.164643,26.2123333 C210.91931,26.5343333 210.650976,26.8333333 210.359643,27.1093333 C210.06831,27.3853333 209.830643,27.5386667 209.646643,27.5693333 C209.615976,27.6 209.508643,27.6536667 209.324643,27.7303333 C209.140643,27.807 209.017976,27.876 208.956643,27.9373333 L209.002643,27.9373333 C208.726643,28.3053333 208.450643,28.4893333 208.174643,28.4893333 L207.806643,28.4893333 C207.683976,28.704 207.28531,28.9416667 206.610643,29.2023333 C205.935976,29.463 205.276643,29.5933333 204.632643,29.5933333 Z M206.702643,19.4733333 C207.254643,19.4733333 207.737643,19.3123333 208.151643,18.9903333 C208.565643,18.6683333 208.925976,18.308 209.232643,17.9093333 C209.845976,17.0813333 210.20631,16.2763333 210.313643,15.4943333 C210.420976,14.7123333 210.32131,14.168 210.014643,13.8613333 C209.830643,13.7693333 209.669643,13.7156667 209.531643,13.7003333 C209.393643,13.685 209.12531,13.7386667 208.726643,13.8613333 C208.450643,13.9226667 208.06731,14.1526667 207.576643,14.5513333 C207.085976,14.95 206.602976,15.3946667 206.127643,15.8853333 C205.65231,16.376 205.291976,16.79 205.046643,17.1273333 L204.448643,18.0933333 C204.693976,18.0013333 204.931643,17.9476667 205.161643,17.9323333 C205.391643,17.917 205.521976,17.94 205.552643,18.0013333 C205.552643,18.2773333 205.60631,18.5303333 205.713643,18.7603333 C205.820976,18.9903333 205.958976,19.1666667 206.127643,19.2893333 C206.29631,19.412 206.487976,19.4733333 206.702643,19.4733333 Z" id="e"></path>
                <path d="M225.332643,38.6093333 C224.596643,38.824 223.791643,38.8623333 222.917643,38.7243333 C222.043643,38.5863333 221.276976,38.318 220.617643,37.9193333 C219.95831,37.5206667 219.582643,37.076 219.490643,36.5853333 C219.459976,36.4013333 219.513643,36.202 219.651643,35.9873333 C219.789643,35.7726667 219.95831,35.627 220.157643,35.5503333 C220.356976,35.4736667 220.53331,35.5273333 220.686643,35.7113333 C220.931976,35.8646667 221.376643,36.0563333 222.020643,36.2863333 C222.664643,36.5163333 223.38531,36.5546667 224.182643,36.4013333 C224.887976,36.248 225.585643,35.834 226.275643,35.1593333 C226.965643,34.4846667 227.52531,33.856 227.954643,33.2733333 C228.199976,32.9053333 228.613976,32.246 229.196643,31.2953333 C229.77931,30.3446667 230.384976,29.2943333 231.013643,28.1443333 C231.64231,26.9943333 232.17131,25.9286667 232.600643,24.9473333 C232.692643,24.702 232.799976,24.4106667 232.922643,24.0733333 C233.04531,23.736 233.198643,23.46 233.382643,23.2453333 C233.566643,22.8773333 233.727643,22.5323333 233.865643,22.2103333 C234.003643,21.8883333 234.087976,21.666 234.118643,21.5433333 C234.14931,21.39 234.28731,21.0833333 234.532643,20.6233333 C234.777976,20.1633333 235.007976,19.7033333 235.222643,19.2433333 C235.375976,18.7833333 235.605976,18.1086667 235.912643,17.2193333 C236.21931,16.33 236.525976,15.6093333 236.832643,15.0573333 C237.200643,14.352 237.499643,13.777 237.729643,13.3323333 C237.959643,12.8876667 238.212643,12.6193333 238.488643,12.5273333 L238.488643,12.5273333 L238.488643,12.5273333 C238.764643,12.3126667 238.95631,12.2053333 239.063643,12.2053333 C239.170976,12.2053333 239.39331,12.2973333 239.730643,12.4813333 C240.098643,12.8493333 240.328643,13.2096667 240.420643,13.5623333 C240.512643,13.915 240.47431,14.3443333 240.305643,14.8503333 C240.136976,15.3563333 239.822643,16.0386667 239.362643,16.8973333 C239.11731,17.6333333 238.848976,18.3003333 238.557643,18.8983333 C238.26631,19.4963333 238.043976,19.8873333 237.890643,20.0713333 C237.73731,20.4393333 237.560976,20.8456667 237.361643,21.2903333 C237.16231,21.735 236.985976,22.1413333 236.832643,22.5093333 C236.280643,23.736 235.80531,24.7326667 235.406643,25.4993333 C235.007976,26.266 234.65531,26.9713333 234.348643,27.6153333 C234.041976,28.2593333 233.719976,29.0106667 233.382643,29.8693333 C232.67731,31.004 231.994976,32.085 231.335643,33.1123333 C230.67631,34.1396667 229.978643,35.098 229.242643,35.9873333 C228.935976,36.2633333 228.552643,36.5853333 228.092643,36.9533333 C227.632643,37.3213333 227.164976,37.6586667 226.689643,37.9653333 C226.21431,38.272 225.761976,38.4866667 225.332643,38.6093333 Z M231.542643,27.5693333 C231.082643,27.508 230.63031,27.232 230.185643,26.7413333 C229.740976,26.2506667 229.395976,25.7293333 229.150643,25.1773333 C228.90531,24.6253333 228.81331,24.2266667 228.874643,23.9813333 C228.874643,23.828 228.874643,23.7053333 228.874643,23.6133333 C228.874643,23.5213333 228.874643,23.4753333 228.874643,23.4753333 C228.690643,23.4753333 228.529643,23.2453333 228.391643,22.7853333 C228.253643,22.3253333 228.153976,21.7273333 228.092643,20.9913333 C228.03131,20.2553333 227.992976,19.4733333 227.977643,18.6453333 C227.96231,17.8173333 227.98531,17.0353333 228.046643,16.2993333 C228.16931,15.778 228.230643,15.203 228.230643,14.5743333 C228.230643,13.9456667 228.245976,13.4473333 228.276643,13.0793333 C228.245976,12.5886667 228.291976,12.259 228.414643,12.0903333 C228.53731,11.9216667 228.659976,11.7913333 228.782643,11.6993333 L228.782643,11.6993333 L228.782643,11.6993333 C229.64131,11.3313333 230.21631,11.5536667 230.507643,12.3663333 C230.798976,13.179 230.867976,14.6893333 230.714643,16.8973333 C230.65331,18.124 230.65331,19.3506667 230.714643,20.5773333 C230.775976,21.804 230.95231,22.8773333 231.243643,23.7973333 C231.534976,24.7173333 231.94131,25.346 232.462643,25.6833333 C232.67731,25.806 232.784643,25.9746667 232.784643,26.1893333 C232.784643,26.404 232.72331,26.6263333 232.600643,26.8563333 C232.477976,27.0863333 232.316976,27.2703333 232.117643,27.4083333 C231.91831,27.5463333 231.726643,27.6 231.542643,27.5693333 Z" id="y"></path>
                <path d="M246.630643,29.1793333 C246.231976,29.21 245.909976,29.1716667 245.664643,29.0643333 C245.41931,28.957 245.112643,28.796 244.744643,28.5813333 C244.069976,28.06 243.571643,27.531 243.249643,26.9943333 C242.927643,26.4576667 242.781976,25.9286667 242.812643,25.4073333 C242.873976,25.1313333 242.881643,24.886 242.835643,24.6713333 C242.789643,24.4566667 242.766643,24.3493333 242.766643,24.3493333 C242.582643,24.196 242.52131,24.0963333 242.582643,24.0503333 C242.643976,24.0043333 242.689976,23.92 242.720643,23.7973333 C242.965976,23.736 242.996643,23.5673333 242.812643,23.2913333 C242.720643,23.046 242.77431,22.4863333 242.973643,21.6123333 C243.172976,20.7383333 243.44131,19.918 243.778643,19.1513333 C243.931976,18.814 244.15431,18.3693333 244.445643,17.8173333 C244.736976,17.2653333 245.066643,16.7056667 245.434643,16.1383333 C245.802643,15.571 246.139976,15.1186667 246.446643,14.7813333 C247.12131,14.0146667 247.726976,13.4396667 248.263643,13.0563333 C248.80031,12.673 249.405976,12.3586667 250.080643,12.1133333 C250.693976,11.868 251.138643,11.73 251.414643,11.6993333 C251.690643,11.6686667 252.073976,11.8526667 252.564643,12.2513333 C253.300643,12.466 253.86031,12.765 254.243643,13.1483333 C254.626976,13.5316667 254.925976,14.122 255.140643,14.9193333 C255.385976,15.8086667 255.47031,16.859 255.393643,18.0703333 C255.316976,19.2816667 254.787976,20.838 253.806643,22.7393333 C253.223976,23.9353333 252.648976,24.84 252.081643,25.4533333 C251.51431,26.0666667 250.831976,26.7106667 250.034643,27.3853333 C249.451976,27.876 248.91531,28.2593333 248.424643,28.5353333 C247.933976,28.8113333 247.335976,29.026 246.630643,29.1793333 Z M250.310643,23.7053333 C250.923976,22.7853333 251.406976,21.9343333 251.759643,21.1523333 C252.11231,20.3703333 252.395976,19.3813333 252.610643,18.1853333 C252.671976,17.848 252.68731,17.4263333 252.656643,16.9203333 C252.625976,16.4143333 252.556976,15.9466667 252.449643,15.5173333 C252.34231,15.088 252.196643,14.858 252.012643,14.8273333 C251.613976,14.674 251.16931,14.6663333 250.678643,14.8043333 C250.187976,14.9423333 249.65131,15.318 249.068643,15.9313333 C248.54731,16.5446667 248.079643,17.2346667 247.665643,18.0013333 C247.251643,18.768 246.875976,19.6113333 246.538643,20.5313333 C246.20131,21.4513333 245.87931,22.4326667 245.572643,23.4753333 C245.265976,24.6406667 245.288976,25.53 245.641643,26.1433333 C245.99431,26.7566667 246.584643,26.9023333 247.412643,26.5803333 C248.240643,26.2583333 249.206643,25.3 250.310643,23.7053333 Z" id="o"></path>
                <path d="M258.958643,27.2933333 C258.651976,27.1093333 258.421976,26.9253333 258.268643,26.7413333 C258.11531,26.5573333 258.038643,26.2966667 258.038643,25.9593333 C258.038643,25.4993333 258.099976,25.0163333 258.222643,24.5103333 C258.34531,24.0043333 258.467976,23.506 258.590643,23.0153333 C258.651976,22.4633333 258.73631,21.9036667 258.843643,21.3363333 C258.950976,20.769 259.157976,20.24 259.464643,19.7493333 C259.801976,18.584 260.154643,17.4263333 260.522643,16.2763333 C260.890643,15.1263333 261.212643,13.938 261.488643,12.7113333 C261.88731,11.5766667 262.247643,10.5723333 262.569643,9.69833333 C262.891643,8.82433333 263.297976,7.71266667 263.788643,6.36333333 C264.064643,5.59666667 264.30231,4.77633333 264.501643,3.90233333 C264.700976,3.02833333 265.01531,2.23866667 265.444643,1.53333333 C265.628643,1.25733333 265.77431,1.01966667 265.881643,0.820333333 C265.988976,0.621 266.103976,0.429333333 266.226643,0.245333333 C266.25731,0.122666667 266.356976,0.046 266.525643,0.0153333333 C266.69431,-0.0153333333 266.885976,0 267.100643,0.0613333333 C267.31531,0.122666667 267.483976,0.23 267.606643,0.383333333 C267.698643,0.352666667 267.813643,0.437 267.951643,0.636333333 C268.089643,0.835666667 268.219976,1.058 268.342643,1.30333333 C268.46531,1.54866667 268.51131,1.76333333 268.480643,1.94733333 C268.480643,2.07 268.457643,2.23866667 268.411643,2.45333333 C268.365643,2.668 268.28131,2.86733333 268.158643,3.05133333 C268.035976,3.174 267.920976,3.35033333 267.813643,3.58033333 C267.70631,3.81033333 267.54531,4.12466667 267.330643,4.52333333 C267.207976,4.922 267.100643,5.32833333 267.008643,5.74233333 C266.916643,6.15633333 266.793976,6.532 266.640643,6.86933333 C266.517976,7.23733333 266.37231,7.59 266.203643,7.92733333 C266.034976,8.26466667 265.919976,8.54066667 265.858643,8.75533333 C265.643976,9.46066667 265.390976,10.1506667 265.099643,10.8253333 C264.80831,11.5 264.55531,12.2206667 264.340643,12.9873333 C264.125976,13.7233333 263.91131,14.4823333 263.696643,15.2643333 C263.481976,16.0463333 263.17531,16.79 262.776643,17.4953333 C262.561976,17.8326667 262.408643,18.262 262.316643,18.7833333 C262.224643,19.3046667 262.132643,19.826 262.040643,20.3473333 C261.856643,20.8993333 261.695643,21.413 261.557643,21.8883333 C261.419643,22.3636667 261.350643,22.6626667 261.350643,22.7853333 C261.166643,23.46 261.03631,24.127 260.959643,24.7863333 C260.882976,25.4456667 260.721976,26.0206667 260.476643,26.5113333 C260.445976,26.818 260.384643,27.0633333 260.292643,27.2473333 C260.200643,27.4313333 260.04731,27.531 259.832643,27.5463333 C259.617976,27.5616667 259.326643,27.4773333 258.958643,27.2933333 Z" id="l"></path>
                <path d="M269.170643,28.7653333 C268.771976,28.7653333 268.457643,28.6886667 268.227643,28.5353333 C267.997643,28.382 267.713976,28.1673333 267.376643,27.8913333 C266.793976,27.278 266.379976,26.6876667 266.134643,26.1203333 C265.88931,25.553 265.812643,25.0086667 265.904643,24.4873333 C265.996643,24.242 266.034976,24.0043333 266.019643,23.7743333 C266.00431,23.5443333 265.996643,23.4293333 265.996643,23.4293333 C265.84331,23.276 265.79731,23.1763333 265.858643,23.1303333 C265.919976,23.0843333 265.98131,23 266.042643,22.8773333 C266.226643,22.8773333 266.287976,22.7086667 266.226643,22.3713333 C266.16531,22.126 266.287976,21.5893333 266.594643,20.7613333 C266.90131,19.9333333 267.284643,19.1513333 267.744643,18.4153333 C267.928643,18.1086667 268.204643,17.7023333 268.572643,17.1963333 C268.940643,16.6903333 269.346976,16.1843333 269.791643,15.6783333 C270.23631,15.1723333 270.642643,14.766 271.010643,14.4593333 C271.77731,13.8153333 272.451976,13.34 273.034643,13.0333333 C273.61731,12.7266667 274.245976,12.4966667 274.920643,12.3433333 C275.59531,12.19 276.062976,12.1133333 276.323643,12.1133333 C276.58431,12.1133333 276.944643,12.3586667 277.404643,12.8493333 C278.109976,13.156 278.623643,13.524 278.945643,13.9533333 C279.267643,14.3826667 279.474643,15.0113333 279.566643,15.8393333 C279.658643,16.7593333 279.589643,17.8096667 279.359643,18.9903333 C279.129643,20.171 278.40131,21.6353333 277.174643,23.3833333 C276.407976,24.4873333 275.702643,25.3076667 275.058643,25.8443333 C274.414643,26.381 273.647976,26.91 272.758643,27.4313333 C272.114643,27.8606667 271.531976,28.175 271.010643,28.3743333 C270.48931,28.5736667 269.875976,28.704 269.170643,28.7653333 Z M273.586643,23.8893333 C274.322643,23.0613333 274.912976,22.2793333 275.357643,21.5433333 C275.80231,20.8073333 276.223976,19.872 276.622643,18.7373333 C276.74531,18.4 276.821976,17.9783333 276.852643,17.4723333 C276.88331,16.9663333 276.875643,16.491 276.829643,16.0463333 C276.783643,15.6016667 276.668643,15.3486667 276.484643,15.2873333 C276.116643,15.0726667 275.671976,15.0036667 275.150643,15.0803333 C274.62931,15.157 274.061976,15.456 273.448643,15.9773333 C272.497976,16.7746667 271.669976,17.7636667 270.964643,18.9443333 C270.25931,20.125 269.56931,21.4666667 268.894643,22.9693333 C268.434643,24.0733333 268.334976,24.955 268.595643,25.6143333 C268.85631,26.2736667 269.423643,26.5036667 270.297643,26.3043333 C271.171643,26.105 272.267976,25.3 273.586643,23.8893333 Z" id="o"></path>
                <path d="M295.666643,28.3973333 C295.51331,28.704 295.290976,28.796 294.999643,28.6733333 C294.70831,28.5506667 294.470643,28.428 294.286643,28.3053333 C294.071976,28.3053333 293.887976,28.244 293.734643,28.1213333 C293.58131,27.9986667 293.473976,27.8146667 293.412643,27.5693333 C293.35131,27.3853333 293.335976,27.163 293.366643,26.9023333 C293.39731,26.6416667 293.46631,26.335 293.573643,25.9823333 C293.680976,25.6296667 293.795976,25.2386667 293.918643,24.8093333 C294.163976,23.7973333 294.332643,23.0613333 294.424643,22.6013333 C294.516643,22.1413333 294.608643,21.7426667 294.700643,21.4053333 C294.792643,21.068 294.91531,20.5773333 295.068643,19.9333333 C295.313976,19.32 295.51331,18.722 295.666643,18.1393333 C295.819976,17.5566667 296.049976,16.974 296.356643,16.3913333 C296.57131,15.594 296.839643,14.835 297.161643,14.1143333 C297.483643,13.3936667 297.797976,12.788 298.104643,12.2973333 C298.165976,12.2053333 298.280976,12.0826667 298.449643,11.9293333 C298.61831,11.776 298.763976,11.6993333 298.886643,11.6993333 C299.131976,11.454 299.35431,11.3543333 299.553643,11.4003333 C299.752976,11.4463333 300.005976,11.592 300.312643,11.8373333 C300.680643,12.236 300.82631,12.696 300.749643,13.2173333 C300.672976,13.7386667 300.29731,14.5053333 299.622643,15.5173333 C299.254643,16.468 298.91731,17.2883333 298.610643,17.9783333 C298.303976,18.6683333 298.08931,19.32 297.966643,19.9333333 C298.303976,19.4426667 298.679643,18.9903333 299.093643,18.5763333 C299.507643,18.1623333 299.852643,17.8173333 300.128643,17.5413333 C300.80331,16.8666667 301.362976,16.376 301.807643,16.0693333 C302.25231,15.7626667 302.78131,15.41 303.394643,15.0113333 C303.762643,14.766 304.11531,14.5436667 304.452643,14.3443333 C304.789976,14.145 305.165643,13.9993333 305.579643,13.9073333 C305.993643,13.8153333 306.445976,13.8153333 306.936643,13.9073333 C307.24331,13.8766667 307.49631,13.9686667 307.695643,14.1833333 C307.894976,14.398 308.055976,14.6893333 308.178643,15.0573333 C308.30131,15.4253333 308.377976,15.8546667 308.408643,16.3453333 C307.70331,16.192 307.074643,16.215 306.522643,16.4143333 C305.970643,16.6136667 305.502976,16.8513333 305.119643,17.1273333 C304.73631,17.4033333 304.43731,17.618 304.222643,17.7713333 C303.762643,18.078 303.179976,18.4843333 302.474643,18.9903333 C301.76931,19.4963333 301.063976,20.102 300.358643,20.8073333 C299.806643,21.4206667 299.338976,21.942 298.955643,22.3713333 C298.57231,22.8006667 298.265643,23.184 298.035643,23.5213333 C297.805643,23.8586667 297.62931,24.2113333 297.506643,24.5793333 C297.199976,25.2846667 296.877976,26.0513333 296.540643,26.8793333 C296.20331,27.7073333 295.911976,28.2133333 295.666643,28.3973333 Z" id="r"></path>
                <path d="M320.736643,29.3633333 C320.521976,29.486 320.23831,29.44 319.885643,29.2253333 C319.532976,29.0106667 319.187976,28.6886667 318.850643,28.2593333 C318.635976,27.8913333 318.49031,27.4926667 318.413643,27.0633333 C318.336976,26.634 318.298643,26.036 318.298643,25.2693333 C318.32931,24.656 318.30631,24.2573333 318.229643,24.0733333 C318.152976,23.8893333 317.976643,23.9123333 317.700643,24.1423333 C317.424643,24.3723333 316.94931,24.8246667 316.274643,25.4993333 C315.507976,26.266 314.779643,26.864 314.089643,27.2933333 C313.399643,27.7226667 312.839976,27.922 312.410643,27.8913333 C312.195976,27.8913333 311.95831,27.7763333 311.697643,27.5463333 C311.436976,27.3163333 311.19931,27.025 310.984643,26.6723333 C310.769976,26.3196667 310.585976,25.9593333 310.432643,25.5913333 C310.248643,24.9166667 310.225643,24.0503333 310.363643,22.9923333 C310.501643,21.9343333 310.73931,20.8226667 311.076643,19.6573333 C311.413976,18.492 311.804976,17.388 312.249643,16.3453333 C312.69431,15.3026667 313.15431,14.4593333 313.629643,13.8153333 C314.104976,13.1713333 314.526643,12.8493333 314.894643,12.8493333 C315.139976,12.8493333 315.36231,12.972 315.561643,13.2173333 C315.760976,13.4626667 315.967976,13.846 316.182643,14.3673333 C316.30531,14.582 316.358976,14.766 316.343643,14.9193333 C316.32831,15.0726667 316.197976,15.2566667 315.952643,15.4713333 C315.676643,15.8393333 315.36231,16.3913333 315.009643,17.1273333 C314.656976,17.8633333 314.319643,18.6606667 313.997643,19.5193333 C313.675643,20.378 313.391976,21.206 313.146643,22.0033333 C312.90131,22.8006667 312.732643,23.4523333 312.640643,23.9583333 C312.548643,24.4643333 312.563976,24.7173333 312.686643,24.7173333 C313.115976,24.7173333 313.629643,24.541 314.227643,24.1883333 C314.825643,23.8356667 315.400643,23.3986667 315.952643,22.8773333 C316.596643,22.2333333 317.171643,21.528 317.677643,20.7613333 C318.183643,19.9946667 318.69731,19.182 319.218643,18.3233333 C319.61731,17.71 320.038976,17.0353333 320.483643,16.2993333 C320.92831,15.5633333 321.211976,15.042 321.334643,14.7353333 C321.763976,13.938 322.085976,13.3936667 322.300643,13.1023333 C322.51531,12.811 322.775976,12.6193333 323.082643,12.5273333 C323.235976,12.5273333 323.381643,12.5273333 323.519643,12.5273333 C323.657643,12.5273333 323.726643,12.5273333 323.726643,12.5273333 C323.910643,12.558 324.12531,12.696 324.370643,12.9413333 C324.615976,13.064 324.753976,13.179 324.784643,13.2863333 C324.81531,13.3936667 324.830643,13.524 324.830643,13.6773333 C324.707976,13.984 324.51631,14.4363333 324.255643,15.0343333 C323.994976,15.6323333 323.80331,16.0693333 323.680643,16.3453333 C323.097976,17.664 322.522976,18.9596667 321.955643,20.2323333 C321.38831,21.505 320.981976,22.8006667 320.736643,24.1193333 C320.67531,24.5486667 320.667643,25.047 320.713643,25.6143333 C320.759643,26.1816667 320.843976,26.588 320.966643,26.8333333 C321.058643,27.0173333 321.173643,27.2243333 321.311643,27.4543333 C321.449643,27.6843333 321.610643,27.876 321.794643,28.0293333 C322.070643,28.2133333 322.12431,28.4126667 321.955643,28.6273333 C321.786976,28.842 321.564643,29.0183333 321.288643,29.1563333 C321.012643,29.2943333 320.828643,29.3633333 320.736643,29.3633333 Z" id="u"></path>
                <path d="M343.230643,27.3393333 C342.61731,27.3393333 342.11131,27.209 341.712643,26.9483333 C341.313976,26.6876667 340.976643,26.2506667 340.700643,25.6373333 C340.577976,25.208 340.47831,24.725 340.401643,24.1883333 C340.324976,23.6516667 340.286643,23.1456667 340.286643,22.6703333 C340.286643,22.195 340.332643,21.8806667 340.424643,21.7273333 C340.54731,21.6046667 340.600976,21.3823333 340.585643,21.0603333 C340.57031,20.7383333 340.562643,20.3933333 340.562643,20.0253333 C340.531976,19.412 340.38631,19.067 340.125643,18.9903333 C339.864976,18.9136667 339.48931,19.0133333 338.998643,19.2893333 C338.446643,19.6266667 337.725976,20.079 336.836643,20.6463333 C335.94731,21.2136667 335.019643,21.8346667 334.053643,22.5093333 C333.087643,23.184 332.17531,23.8893333 331.316643,24.6253333 C330.641976,25.3613333 330.235643,25.921 330.097643,26.3043333 C329.959643,26.6876667 329.767976,26.8793333 329.522643,26.8793333 C329.27731,27.002 329.07031,27.0096667 328.901643,26.9023333 C328.732976,26.795 328.49531,26.6186667 328.188643,26.3733333 C327.973976,26.128 327.75931,25.8903333 327.544643,25.6603333 C327.329976,25.4303333 327.191976,25.254 327.130643,25.1313333 C327.130643,24.978 327.176643,24.656 327.268643,24.1653333 C327.360643,23.6746667 327.475643,23.184 327.613643,22.6933333 C327.751643,22.2026667 327.85131,21.8806667 327.912643,21.7273333 C328.065976,21.7273333 328.19631,21.574 328.303643,21.2673333 C328.410976,20.9606667 328.58731,20.6233333 328.832643,20.2553333 C328.893976,19.8873333 329.054976,19.389 329.315643,18.7603333 C329.57631,18.1316667 329.813976,17.572 330.028643,17.0813333 C330.457976,16.3453333 330.756976,15.732 330.925643,15.2413333 C331.09431,14.7506667 331.20931,14.1373333 331.270643,13.4013333 C331.239976,13.2786667 331.270643,13.1636667 331.362643,13.0563333 C331.454643,12.949 331.561976,12.8953333 331.684643,12.8953333 L331.684643,12.8953333 L331.684643,12.8953333 C331.929976,12.65 332.22131,12.581 332.558643,12.6883333 C332.895976,12.7956667 333.202643,13.0333333 333.478643,13.4013333 C334.030643,14.1373333 334.252976,14.8963333 334.145643,15.6783333 C334.03831,16.4603333 333.539976,17.572 332.650643,19.0133333 C332.435976,19.504 332.274976,19.8796667 332.167643,20.1403333 C332.06031,20.401 332.006643,20.608 332.006643,20.7613333 C332.006643,20.7613333 332.167643,20.654 332.489643,20.4393333 C332.811643,20.2246667 333.179643,19.9716667 333.593643,19.6803333 C334.007643,19.389 334.33731,19.1666667 334.582643,19.0133333 C334.735976,18.86 335.088643,18.584 335.640643,18.1853333 C336.192643,17.7866667 336.782976,17.3956667 337.411643,17.0123333 C338.04031,16.629 338.507976,16.4066667 338.814643,16.3453333 C339.059976,16.2226667 339.320643,16.1076667 339.596643,16.0003333 C339.872643,15.893 340.071976,15.8393333 340.194643,15.8393333 C340.439976,15.8393333 340.75431,15.9696667 341.137643,16.2303333 C341.520976,16.491 341.88131,16.7976667 342.218643,17.1503333 C342.555976,17.503 342.75531,17.802 342.816643,18.0473333 C342.816643,18.17 342.82431,18.2926667 342.839643,18.4153333 C342.854976,18.538 342.877976,18.6606667 342.908643,18.7833333 C343.03131,19.182 343.10031,19.7186667 343.115643,20.3933333 C343.130976,21.068 343.107976,21.6813333 343.046643,22.2333333 C342.98531,22.7853333 342.877976,23.1073333 342.724643,23.1993333 C342.724643,23.1993333 342.73231,23.2376667 342.747643,23.3143333 C342.762976,23.391 342.831976,23.4293333 342.954643,23.4293333 C342.954643,23.552 342.954643,23.621 342.954643,23.6363333 C342.954643,23.6516667 342.954643,23.6593333 342.954643,23.6593333 C342.80131,23.6593333 342.739976,23.7896667 342.770643,24.0503333 C342.80131,24.311 342.900976,24.5946667 343.069643,24.9013333 C343.23831,25.208 343.414643,25.4533333 343.598643,25.6373333 C343.966643,26.0053333 344.119976,26.3503333 344.058643,26.6723333 C343.99731,26.9943333 343.72131,27.2166667 343.230643,27.3393333 Z" id="n"></path>
            </g>
        </g>
    </g>
</svg>

        `;
        container.appendChild(annotation);
      }

      // ============ CONFIGURATION ============
      // Visualization mode: 'normalize' | 'align' | 'raw'
      //
      // 'normalize' (CURRENT) ✅
      //   → Each run starts at X=0 (relative to its own start)
      //   → Runs have different lengths (based on their training duration)
      //   → No data removed
      //   → Ideal for comparing curve shapes
      //
      // 'align'
      //   → All runs start at the same absolute point (latest start)
      //   → All runs end at the same absolute point (earliest end)
      //   → Same length for all runs (trimmed)
      //   → Data trimmed for alignment
      //   → Ideal for comparing over a common time window
      //
      // 'raw'
      //   → Displays raw data without transformation
      //   → Each run keeps its original start and end points
      //   → No normalization
      //   → Ideal for seeing real training timelines
      //
      const VISUALIZATION_MODE = 'align';

      // Log scale control: true = logarithmic, false = linear
      const USE_LOG_SCALE = true;

      // Gap between run groups: 0.2 = doubled gap, 0.1 = normal gap
      const CATEGORY_GAP = 0.05;
      // =======================================

      // State/data
      const svgPaddingTop = 20;
      const svgPaddingBottom = 20;
      // Get initial height from container instead of fixed value
      const getContainerHeight = () => {
        const containerHeight = container.clientHeight || 350;
        return Math.max(containerHeight - 20, 200); // Minimum 200px
      };
      let svgHeight = getContainerHeight();
      let contentHeight = svgHeight - svgPaddingTop - svgPaddingBottom;
      let width = 800, height = svgHeight; const margin = { top: 0, right: 0, bottom: 0, left: 0 };

      // SVG container
      const svg = d3.select(container).append('svg').attr('width', 800).attr('height', svgHeight).style('display', 'block');
      const gRoot = svg.append('g').attr('transform', `translate(0, ${svgPaddingTop})`);
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gAxes = gRoot.append('g').attr('class', 'axes');
      const gLines = gRoot.append('g').attr('class', 'lines');
      const gPoints = gRoot.append('g').attr('class', 'points');
      const overlay = gRoot.append('rect').attr('fill', 'transparent').style('cursor', 'crosshair');
      const hoverLine = gRoot.append('line').attr('stroke-width', 1).style('display', 'none');
      const xScale = USE_LOG_SCALE ? d3.scaleLinear() : d3.scaleLinear();
      const yScale = USE_LOG_SCALE ? d3.scaleLinear() : d3.scaleLinear();
      const lineGen = d3.line().x(d => xScale(d.logTokens)).y(d => yScale(d.logLoss));
      const dataByRun = new Map();
      let runOrder = [];

      // Colors - categorical for distinct run categories
      function getRunColors(count) {
        try {
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            return window.ColorPalettes.getColors('categorical', count);
          }
        } catch (_) { }
        // Fallback to categorical-like colors - evenly distributed hues
        const colors = [];
        for (let i = 0; i < count; i++) {
          const hue = (i * 360 / count) % 360;
          colors.push(`hsl(${hue}, 70%, 60%)`);
        }
        return colors;
      }

      // Format helper for thousands (5000 -> 5k, 1500 -> 1.5k)
      function formatK(v) {
        const abs = Math.abs(v);
        if (abs >= 1000) {
          const n = v / 1000;
          const s = d3.format('.1f')(n);
          return (s.endsWith('.0') ? s.slice(0, -2) : s) + 'k';
        }
        return d3.format('d')(v);
      }

      // Format numbers with K/M/B suffixes
      function formatNumber(num) {
        if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
        if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
        if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
        return num.toFixed(0);
      }

      // Parse run name to extract type and config
      function parseRunName(runName) {
        // Format: "category_loss+date_time_config"
        const parts = runName.split('+');
        const category = parts[0] || '';
        const configPart = parts[1] || '';

        // Extract readable category name
        const categoryName = category.replace(/_loss$/i, '').replace(/_/g, ' ')
          .replace(/\b\w/g, l => l.toUpperCase());

        // Remove date/time part (format: DD/MM/YYYY_HH:MM:SS_)
        // This will match patterns like "22/09/2025_16:41:43_"
        let config = configPart.replace(/^\d{2}\/\d{2}\/\d{4}_\d{2}:\d{2}:\d{2}_/, '');

        // Check if it was baseline before removing it
        const wasBaseline = /^baseline$/i.test(config) || /^baseline[-_]/i.test(config) || /[-_]baseline$/i.test(config);

        // Remove "baseline" (case insensitive)
        config = config.replace(/^baseline$/i, '').replace(/^baseline[-_]/i, '').replace(/[-_]baseline$/i, '');

        // Clean up and format if something remains
        if (config) {
          config = config.replace(/[_-]+/g, ' ').trim()
            .replace(/\b\w/g, l => l.toUpperCase());
        } else if (wasBaseline) {
          // If nothing remains but it was baseline, show "Baseline"
          config = 'Baseline';
        }

        return { categoryName, config };
      }

      // Helper function to check if a run is a true baseline (nothing after "baseline")
      function isBaselineRun(runName) {
        const parts = runName.split('+');
        if (parts.length < 2) return false;
        const configPart = parts[1] || '';
        // Remove date/time part first (format: DD/MM/YYYY_HH:MM:SS_)
        let config = configPart.replace(/^\d{2}\/\d{2}\/\d{4}_\d{2}:\d{2}:\d{2}_/, '');
        // Check if it's exactly "baseline" (case insensitive) with nothing after
        return /^baseline$/i.test(config);
      }

      // Helper function to map run labels to prettier names
      function mapRunLabel(label) {
        const labelMappings = {
          'Z': 'Z-loss',
          'Doc-Masking': 'IntraDoc Masking',
          'Doc Masking': 'IntraDoc Masking',
          'Doc_Masking': 'IntraDoc Masking',
          'Lr': 'Learning Rate',
          'No-Wd': 'No Weight Decay',
          'No Wd': 'No Weight Decay',
          'No_Wd': 'No Weight Decay',
          'Tied-Embeddings': 'Tied Embeddings',
          'Tied Embeddings': 'Tied Embeddings',
          'Tied_Embeddings': 'Tied Embeddings',
          'Batch Size Fix': 'Batch Size',
          'Batch_Size_Fix': 'Batch Size'
        };

        return labelMappings[label] || label;
      }

      // Helper function to saturate a color slightly
      function saturateColor(color) {
        // Handle different color formats
        if (color.startsWith('hsl(')) {
          // HSL color - boost saturation slightly and reduce lightness a bit
          const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
          if (match) {
            const h = parseInt(match[1]);
            const s = Math.min(100, parseInt(match[2]) + 25); // +10% saturation
            const l = Math.max(0, parseInt(match[3]));    // -5% lightness
            return `hsl(${h}, ${s}%, ${l}%)`;
          }
        } else if (color.startsWith('#')) {
          // Convert hex to RGB then to HSL
          const hex = color.replace('#', '');
          const r = parseInt(hex.substr(0, 2), 16) / 255;
          const g = parseInt(hex.substr(2, 2), 16) / 255;
          const b = parseInt(hex.substr(4, 2), 16) / 255;

          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;

          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
              case g: h = ((b - r) / d + 2) / 6; break;
              case b: h = ((r - g) / d + 4) / 6; break;
            }
          }

          h = Math.round(h * 360);
          s = Math.min(100, Math.round(s * 100) + 10);
          l = Math.max(0, Math.round(l * 100) - 5);

          return `hsl(${h}, ${s}%, ${l}%)`;
        }
        // Fallback: return original color
        return color;
      }

      // Single aggregated CSV file
      const AGGREGATED_CSV = 'aggregated-loss-data.csv';

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            // Add timestamp to bypass cache
            const url = p + (p.includes('?') ? '&' : '?') + '_=' + Date.now();
            const r = await fetch(url, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found');
      };

      // ============ DATA TRANSFORMATION MODES ============
      /**
       * Transform data according to the selected visualization mode
       * @param {Map} dataByRun - Map(run_name -> array of {tokens, loss, logTokens, logLoss})
       * @param {string} mode - 'normalize' | 'align' | 'raw'
       * @returns {Map} Transformed data
       */
      function transformDataByMode(dataByRun, mode) {
        const runs = Array.from(dataByRun.keys());
        const transformedData = new Map();

        if (mode === 'normalize') {
          // NORMALIZE MODE: Each run starts at X=0 (relative to its start)
          runs.forEach(r => {
            const data = dataByRun.get(r) || [];
            if (data.length > 0) {
              const firstLogTokens = Math.min(...data.map(d => d.logTokens));
              const normalizedData = data.map(d => ({
                ...d,
                logTokens: d.logTokens - firstLogTokens
              }));
              transformedData.set(r, normalizedData);
            }
          });

        } else if (mode === 'align') {
          // ALIGN MODE: Improved alignment strategy
          // 1. Collect all start and end points
          const runRanges = [];
          runs.forEach(r => {
            const data = dataByRun.get(r) || [];
            if (data.length > 0) {
              const minTokens = Math.min(...data.map(d => d.logTokens));
              const maxTokens = Math.max(...data.map(d => d.logTokens));
              runRanges.push({ run: r, min: minTokens, max: maxTokens, data });
            }
          });

          if (runRanges.length === 0) return transformedData;

          // 2. Use percentile-based alignment (70th percentile start, 30th percentile end)
          // This gives a better balance than strict min/max
          const starts = runRanges.map(r => r.min).sort((a, b) => a - b);
          const ends = runRanges.map(r => r.max).sort((a, b) => a - b);

          const startPercentile = Math.floor(starts.length * 0.3); // Use 30th percentile as start
          const endPercentile = Math.floor(ends.length * 0.8);    // Use 80th percentile as end

          const alignedStart = starts[Math.max(0, startPercentile)];
          const alignedEnd = ends[Math.min(ends.length - 1, endPercentile)];

          // 3. Filter and align data
          runs.forEach(r => {
            const data = dataByRun.get(r) || [];
            if (data.length > 0) {
              // Filter to alignment window but be more permissive
              const filtered = data.filter(d =>
                d.logTokens >= alignedStart && d.logTokens <= alignedEnd
              );

              // If we have very little data after filtering, be more lenient
              let finalData = filtered;
              if (filtered.length < 3) {
                // Fallback: use data that intersects with the alignment window
                finalData = data.filter(d => d.logTokens >= alignedStart);
                // Take at least 80% of the run's original length or minimum viable amount
                if (finalData.length < Math.max(3, data.length * 0.8)) {
                  finalData = data; // If still too restrictive, use all data
                }
                // But still normalize to the alignment start
              }

              if (finalData.length > 0) {
                const alignedData = finalData.map(d => ({
                  ...d,
                  logTokens: d.logTokens - alignedStart
                }));
                transformedData.set(r, alignedData);
              }
            }
          });

        } else {
          // RAW MODE: Raw data without transformation
          runs.forEach(r => {
            const data = dataByRun.get(r) || [];
            if (data.length > 0) {
              transformedData.set(r, [...data]); // Deep copy
            }
          });
        }

        return transformedData;
      }
      // ==================================================

      function updateLayout() {
        const axisColor = getComputedStyle(container).getPropertyValue('--axis-color').trim() || 'rgba(0,0,0,0.25)';
        width = container.clientWidth || 800;
        // Update height based on current container size
        svgHeight = getContainerHeight();
        contentHeight = svgHeight - svgPaddingTop - svgPaddingBottom;
        height = svgHeight;
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(0, ${svgPaddingTop})`);
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = contentHeight;
        overlay.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);
        hoverLine.attr('y1', 0).attr('y2', innerHeight).attr('stroke', axisColor);
        return { innerWidth, innerHeight };
      }

      function render() {
        const { innerWidth, innerHeight } = updateLayout();

        // Transform data according to selected mode
        const transformedData = transformDataByMode(dataByRun, VISUALIZATION_MODE);
        const allRuns = Array.from(transformedData.keys()).sort();
        // Filter out debug runs and the original "Batch Size" (keep only "Batch Size Fix")
        const runs = allRuns.filter(run => {
          const debugFilter = !run.toLowerCase().includes('debug') &&
            !run.toLowerCase().includes('tp debug') &&
            !run.toLowerCase().includes('tp-debug') &&
            !run.toLowerCase().includes('test');

          // Filter out "batch_size_loss" but keep "batch_size_fix_loss"
          const batchSizeFilter = !(run.toLowerCase().includes('batch_size_loss') &&
            !run.toLowerCase().includes('batch_size_fix'));

          return debugFilter && batchSizeFilter;
        });

        // Compute domains from transformed data
        let minLogTokens = Infinity, maxLogTokens = -Infinity;
        let minLogLoss = Infinity, maxLogLoss = -Infinity;

        runs.forEach(r => {
          const data = transformedData.get(r) || [];
          data.forEach(d => {
            minLogTokens = Math.min(minLogTokens, d.logTokens);
            maxLogTokens = Math.max(maxLogTokens, d.logTokens);
            minLogLoss = Math.min(minLogLoss, d.logLoss);
            maxLogLoss = Math.max(maxLogLoss, d.logLoss);
          });
        });

        // No grid or axes - clean visualization
        gGrid.selectAll('*').remove();
        gAxes.selectAll('*').remove();

        // Lines with vertical offset - optimized
        // Group runs by category (prefix before '+')
        const categoryMap = new Map();
        const categories = [];
        runs.forEach(r => {
          const parts = r.split('+');
          const category = parts.length > 1 ? parts[0] : r;
          if (!categoryMap.has(category)) {
            categories.push(category);
            categoryMap.set(category, []);
          }
          categoryMap.get(category).push(r);
        });

        // Generate one color per category
        const categoryColors = getRunColors(categories.length);
        const runColorMap = {};
        categories.forEach((cat, idx) => {
          const color = categoryColors[idx];
          categoryMap.get(cat).forEach(run => {
            runColorMap[run] = color;
          });
        });

        // Split categories into two rows (5 on top, 6 on bottom for 11 items)
        const midPoint = Math.floor(categories.length / 2);
        const firstRow = categories.slice(0, midPoint);
        const secondRow = categories.slice(midPoint);

        const createRow = (cats, startIdx) => cats.map((cat, i) => {
          const idx = startIdx + i;
          let prettyLabel = cat.replace(/_/g, ' ').replace(/loss/g, '').trim()
            .replace(/\b\w/g, l => l.toUpperCase());
          // Apply label mapping
          prettyLabel = mapRunLabel(prettyLabel);
          return `
            <div class="legend-item" data-category="${cat}">
              <div class="legend-swatch" style="background: ${categoryColors[idx]}"></div>
              <div class="legend-label">${prettyLabel}</div>
            </div>
          `;
        }).join('');

        // Update legend with two rows
        legend.innerHTML = `
          <div class="legend-title">Run Types</div>
          <div class="legend-items">
            <div class="legend-row">${createRow(firstRow, 0)}</div>
            <div class="legend-row">${createRow(secondRow, midPoint)}</div>
          </div>
        `;

        // Legend interaction - highlight category on hover
        legend.querySelectorAll('.legend-item').forEach(item => {
          const cat = item.getAttribute('data-category');
          item.addEventListener('mouseenter', () => {
            container.classList.add('hovering');
            // Ghost lines (both dashed and solid)
            gLines.selectAll('path.run').classed('ghost', function (d) {
              const parts = d.run.split('+');
              const runCat = parts.length > 1 ? parts[0] : d.run;
              return runCat !== cat;
            });
            gLines.selectAll('path.baseline-solid').classed('ghost', function (d) {
              const parts = d.run.split('+');
              const runCat = parts.length > 1 ? parts[0] : d.run;
              return runCat !== cat;
            });
            // Ghost legend items
            legend.querySelectorAll('.legend-item').forEach(otherItem => {
              if (otherItem.getAttribute('data-category') !== cat) {
                otherItem.classList.add('ghost');
              }
            });
          });
          item.addEventListener('mouseleave', () => {
            container.classList.remove('hovering');
            gLines.selectAll('path.run').classed('ghost', false);
            gLines.selectAll('path.baseline-solid').classed('ghost', false);
            legend.querySelectorAll('.legend-item').forEach(otherItem => {
              otherItem.classList.remove('ghost');
            });
          });
        });

        // Create vertical offset mapping with doubled gaps between categories
        const createVerticalOffsetMap = () => {
          const runToOffset = new Map();
          let runIndex = 0;

          categories.forEach((category, catIndex) => {
            const categoryRuns = categoryMap.get(category);
            categoryRuns.forEach(run => {
              // Gap between categories + normal run spacing (runIndex * 0.05)
              const verticalOffset = (catIndex * CATEGORY_GAP) + (runIndex * 0.05);
              runToOffset.set(run, verticalOffset);
              runIndex++;
            });
          });

          return runToOffset;
        };

        const verticalOffsetMap = createVerticalOffsetMap();

        // Calculate max vertical offset for padding
        let maxVerticalOffset = 0;
        for (const offset of verticalOffsetMap.values()) {
          maxVerticalOffset = Math.max(maxVerticalOffset, offset);
        }
        maxLogLoss += maxVerticalOffset;

        // Update scales with final domain
        xScale.domain([minLogTokens, maxLogTokens]).range([0, innerWidth]);
        yScale.domain([minLogLoss, maxLogLoss]).range([innerHeight, 0]);

        const series = runs.map((r) => {
          const data = transformedData.get(r) || [];
          // Sample data for performance - take every 5th point
          const sampledData = data.filter((_, idx) => idx % 5 === 0);
          return {
            run: r,
            color: runColorMap[r],
            values: sampledData.sort((a, b) => a.logTokens - b.logTokens).map(d => ({
              ...d,
              logLoss: d.logLoss + verticalOffsetMap.get(r) // Vertical offset with doubled category gaps
            }))
          };
        });

        // First, add solid lines under dashed baseline lines (background)
        const baselineSeries = series.filter(s => isBaselineRun(s.run));
        if (baselineSeries.length > 0) {
          const solidPaths = gLines.selectAll('path.baseline-solid').data(baselineSeries, d => `solid-${d.run}`);
          const solidPathsEnter = solidPaths.enter().append('path')
            .attr('class', 'baseline-solid')
            .attr('fill', 'none')
            .attr('stroke-width', 3)
            .attr('stroke', d => d.color)
            .attr('stroke-dasharray', null)
            .attr('d', d => lineGen(d.values));

          solidPathsEnter.merge(solidPaths)
            .attr('stroke', d => d.color)
            .attr('d', d => lineGen(d.values));
          solidPaths.exit().remove();
        }

        // Then, add all lines (saturated baselines will be on top)
        const paths = gLines.selectAll('path.run').data(series, d => d.run);
        const pathsEnter = paths.enter().append('path')
          .attr('class', 'run')
          .attr('fill', 'none')
          .attr('stroke-width', 2)
          .attr('stroke', d => isBaselineRun(d.run) ? saturateColor(d.color) : d.color)
          .attr('stroke-dasharray', null)
          .attr('d', d => lineGen(d.values));

        pathsEnter.merge(paths)
          .attr('stroke', d => isBaselineRun(d.run) ? saturateColor(d.color) : d.color)
          .attr('stroke-dasharray', null)
          .attr('d', d => lineGen(d.values)); // No transition for performance
        paths.exit().remove();

        // Hover capture paths (wider invisible stroke for easy hovering) - optimized
        const captures = gLines.selectAll('path.run-hover').data(series, d => `cap-${d.run}`);
        captures.enter().append('path').attr('class', 'run-hover').attr('fill', 'none').attr('stroke', 'transparent').attr('stroke-width', 12).style('pointer-events', 'stroke')
          .attr('d', d => lineGen(d.values))
          .merge(captures)
          .attr('d', d => lineGen(d.values))
          .on('mouseenter', function (ev, d) {
            container.classList.add('hovering');
            // Ghost non-hovered lines (both dashed and solid)
            gLines.selectAll('path.run').classed('ghost', s => s.run !== d.run);
            gLines.selectAll('path.baseline-solid').classed('ghost', s => s.run !== d.run);
          })
          .on('mouseleave', function () {
            container.classList.remove('hovering');
            gLines.selectAll('path.run').classed('ghost', false);
            gLines.selectAll('path.baseline-solid').classed('ghost', false);
          });
        captures.exit().remove();

        // No point markers - just lines

        // No legend needed

        // Hover interaction - optimized
        function onMove(ev) {
          const [mx, my] = d3.pointer(ev, overlay.node());

          // Find nearest point on any line - optimized search
          let nearestPoint = null;
          let minDist = Infinity;
          const threshold = 20;

          for (const s of series) {
            for (const pt of s.values) {
              const dist = Math.abs(xScale(pt.logTokens) - mx); // Only check X distance first
              if (dist < threshold && dist < minDist) {
                const yDist = Math.abs(yScale(pt.logLoss) - my);
                const totalDist = Math.sqrt(dist * dist + yDist * yDist);
                if (totalDist < minDist) {
                  minDist = totalDist;
                  nearestPoint = { ...pt, run: s.run, color: s.color };
                }
              }
            }
          }

          if (nearestPoint && minDist < threshold) {
            // Parse run info
            const { categoryName, config } = parseRunName(nearestPoint.run);

            // Apply label mapping to category name
            const mappedCategoryName = mapRunLabel(categoryName);

            // Format metrics
            const tokensFormatted = formatNumber(nearestPoint.tokens);
            const lossFormatted = nearestPoint.loss.toFixed(2);

            // Build rich tooltip with color swatch
            let html = `
              <div class="d3-tooltip__header">
                <div class="d3-tooltip__color-swatch" style="background: ${nearestPoint.color}"></div>
                <div class="d3-tooltip__title">${mappedCategoryName}</div>
              </div>
            `;

            // Only show config if it exists
            if (config) {
              html += `<div class="d3-tooltip__subtitle">Config: ${config}</div>`;
            }

            html += `
              <div class="d3-tooltip__divider"></div>
              <div class="d3-tooltip__data">
                Tokens: ${tokensFormatted}<br/>
                Loss: ${lossFormatted}
              </div>
            `;

            tipInner.innerHTML = html;
            tip.style.opacity = '1';

            // Ghost other lines (both dashed and solid)
            container.classList.add('hovering');
            gLines.selectAll('path.run').classed('ghost', s => s.run !== nearestPoint.run);
            gLines.selectAll('path.baseline-solid').classed('ghost', s => s.run !== nearestPoint.run);

            // Smart positioning - keep tooltip within container bounds
            const tooltipRect = tip.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            const offset = 12;
            let x = mx + margin.left + offset;
            let y = my + margin.top + offset;

            // Check right edge
            if (x + tooltipRect.width > containerRect.width) {
              x = mx + margin.left - tooltipRect.width - offset;
            }

            // Check bottom edge
            if (y + tooltipRect.height > containerRect.height) {
              y = my + margin.top - tooltipRect.height - offset;
            }

            // Check left edge (if flipped to left)
            if (x < 0) {
              x = offset;
            }

            // Check top edge (if flipped to top)
            if (y < 0) {
              y = offset;
            }

            tip.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
          } else {
            tip.style.opacity = '0';
            container.classList.remove('hovering');
            gLines.selectAll('path.run').classed('ghost', false);
            gLines.selectAll('path.baseline-solid').classed('ghost', false);
          }
        }
        function onLeave() {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          container.classList.remove('hovering');
          gLines.selectAll('path.run').classed('ghost', false);
          gLines.selectAll('path.baseline-solid').classed('ghost', false);
        }
        overlay.on('mousemove', onMove).on('mouseleave', onLeave);
      }

      // Load aggregated CSV file and initialize
      (async () => {
        try {
          // Load single aggregated CSV file
          const paths = [
            `/data/${AGGREGATED_CSV}`,
            `./assets/data/${AGGREGATED_CSV}`,
            `../assets/data/${AGGREGATED_CSV}`,
            `../../assets/data/${AGGREGATED_CSV}`
          ];

          const text = await fetchFirstAvailable(paths);

          // Parse CSV - format is run_name,tokens,loss with prefixes already included
          const rows = d3.csvParse(text, d => ({
            run: (d.run_name || '').trim(),
            tokens: +d.tokens,
            loss: +d.loss
          }));

          // Filter out invalid data and compute log values
          const allData = rows
            .filter(r => r.run && r.tokens > 0 && r.loss > 0) // Valid data only
            .map(row => ({
              run: row.run,
              tokens: row.tokens,
              loss: row.loss,
              logTokens: USE_LOG_SCALE ? Math.log(row.tokens) : row.tokens,
              logLoss: USE_LOG_SCALE ? Math.log(row.loss) : row.loss
            }));

          // Group data by run
          runOrder = Array.from(new Set(allData.map(r => r.run))).sort();
          runOrder.forEach(r => {
            dataByRun.set(r, allData.filter(d => d.run === r));
          });

          render();
          const rerender = () => render();
          if (window.ResizeObserver) { const ro = new ResizeObserver(() => rerender()); ro.observe(container); } else { window.addEventListener('resize', rerender); }
        } catch (e) {
          const pre = document.createElement('pre'); pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)'; pre.style.fontSize = '12px'; pre.style.whiteSpace = 'pre-wrap'; container.appendChild(pre);
        }
      })();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure> <p class="hero-desc" data-astro-cid-bbe6dxrz>A practical journey through the challenges, decisions, and messy reality behind training state-of-the-art language models</p> </div> </section> <header class="meta" aria-label="Article meta information" data-astro-cid-bbe6dxrz> <div class="meta-container" data-astro-cid-bbe6dxrz> <div class="meta-container-cell" data-astro-cid-bbe6dxrz> <h3 data-astro-cid-bbe6dxrz>Authors</h3> <ul class="authors" data-astro-cid-bbe6dxrz> <li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/loubnabnl" data-astro-cid-bbe6dxrz>Loubna Ben Allal</a><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/lewtun" data-astro-cid-bbe6dxrz>Lewis Tunstall</a><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/nouamanetazi" data-astro-cid-bbe6dxrz>Nouamane Tazi</a><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/eliebak" data-astro-cid-bbe6dxrz>Elie Bakouch</a><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/edbeeching" data-astro-cid-bbe6dxrz>Ed Beeching</a><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/cmpatino" data-astro-cid-bbe6dxrz>Carlos Miguel Patiño</a><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/clefourrier" data-astro-cid-bbe6dxrz>Clémentine Fourrier</a><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/tfrere" data-astro-cid-bbe6dxrz>Thibaud Frere</a><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/anton-l" data-astro-cid-bbe6dxrz>Anton Lozhkov</a><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/craffel" data-astro-cid-bbe6dxrz>Colin Raffel</a><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/lvwerra" data-astro-cid-bbe6dxrz>Leandro von Werra</a><span data-astro-cid-bbe6dxrz>, </span> </li><li data-astro-cid-bbe6dxrz> <a href="https://huggingface.co/thomwolf" data-astro-cid-bbe6dxrz>Thomas Wolf</a> </li> </ul> </div> <div class="meta-container-cell meta-container-cell--affiliations" data-astro-cid-bbe6dxrz> <h3 data-astro-cid-bbe6dxrz>Affiliation</h3> <p data-astro-cid-bbe6dxrz> <a href="https://huggingface.co" target="_blank" rel="noopener noreferrer" data-astro-cid-bbe6dxrz> Hugging Face </a> </p> </div>  <div class="meta-container-cell meta-container-cell--published" data-astro-cid-bbe6dxrz> <h3 data-astro-cid-bbe6dxrz>Published</h3> <p data-astro-cid-bbe6dxrz>Oct. 30, 2025</p> </div> <!-- {doi && (
      <div class="meta-container-cell">
        <h3>DOI</h3>
        <p><a href={`https://doi.org/${doi}`} target="_blank" rel="noopener noreferrer">{doi}</a></p>
      </div>
    )} --> <div class="meta-container-cell meta-container-cell--pdf" data-astro-cid-bbe6dxrz> <div class="pdf-header-wrapper" data-astro-cid-bbe6dxrz> <h3 data-astro-cid-bbe6dxrz>PDF</h3> <span class="pro-badge-wrapper" style="display: none;" data-astro-cid-bbe6dxrz> <span class="pro-badge-prefix" data-astro-cid-bbe6dxrz>- you are</span> <span class="pro-badge" data-astro-cid-bbe6dxrz>PRO</span> </span> <span class="pro-only-label" style="display: none;" data-astro-cid-bbe6dxrz> <span class="pro-only-dash" data-astro-cid-bbe6dxrz>-</span> <span class="pro-only-text" data-astro-cid-bbe6dxrz>pro only</span> <svg class="pro-only-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-bbe6dxrz> <rect x="3" y="11" width="18" height="11" rx="2" ry="2" data-astro-cid-bbe6dxrz></rect> <path d="M7 11V7a5 5 0 0 1 10 0v4" data-astro-cid-bbe6dxrz></path> </svg> </span> </div> <div id="pdf-download-container" data-pdf-pro-only="true" data-astro-cid-bbe6dxrz> <p class="pdf-loading" data-astro-cid-bbe6dxrz>Checking access...</p> <p class="pdf-pro-only" style="display: none;" data-astro-cid-bbe6dxrz> <a class="button" href="./the-smol-training-playbook-the-secrets-to-building-world-class-llms.pdf" download="the-smol-training-playbook-the-secrets-to-building-world-class-llms.pdf" aria-label="Download PDF the-smol-training-playbook-the-secrets-to-building-world-class-llms.pdf" data-astro-cid-bbe6dxrz>
Download PDF
</a> </p> <div class="pdf-locked" style="display: none;" data-astro-cid-bbe6dxrz> <a class="button button-locked" href="https://huggingface.co/subscribe/pro" target="_blank" rel="noopener noreferrer" data-astro-cid-bbe6dxrz> <svg class="lock-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" role="img" width="1em" height="1em" viewBox="0 0 12 12" fill="none" data-astro-cid-bbe6dxrz> <path d="M6.48 1.26c0 1.55.67 2.58 1.5 3.24.86.68 1.9 1 2.58 1.07v.86A5.3 5.3 0 0 0 7.99 7.5a3.95 3.95 0 0 0-1.51 3.24h-.96c0-1.55-.67-2.58-1.5-3.24a5.3 5.3 0 0 0-2.58-1.07v-.86A5.3 5.3 0 0 0 4.01 4.5a3.95 3.95 0 0 0 1.51-3.24h.96Z" fill="currentColor" data-astro-cid-bbe6dxrz></path> </svg> <span class="locked-title" data-astro-cid-bbe6dxrz>Subscribe to Pro</span> </a> </div> </div> </div> </div> </header>   <section class="content-grid"> <nav class="table-of-contents" aria-label="Table of Contents" data-auto-collapse="1"> <div class="title">Table of Contents</div> <div id="article-toc-placeholder"></div> </nav> <details class="table-of-contents-mobile"> <summary>Table of Contents</summary> <div id="article-toc-mobile-placeholder"></div> </details> <script>
  // Build TOC from article headings (h2/h3/h4) and render into the sticky aside
  const buildTOC = () => {
    const holder = document.getElementById("article-toc-placeholder");
    const holderMobile = document.getElementById(
      "article-toc-mobile-placeholder",
    );
    // Always rebuild TOC to avoid stale entries
    if (holder) holder.innerHTML = "";
    if (holderMobile) holderMobile.innerHTML = "";
    const articleRoot = document.querySelector("section.content-grid main");
    if (!articleRoot) return;
    const headings = articleRoot.querySelectorAll("h2, h3, h4");
    if (!headings.length) return;

    // Inclure tous les titres H2/H3/H4 sans filtrer "Table of contents"
    const headingsArr = Array.from(headings);
    if (!headingsArr.length) return;

    // Ensure unique ids for headings (deduplicate duplicates)
    const usedIds = new Set();
    const slugify = (s) =>
      String(s || "")
        .toLowerCase()
        .trim()
        .replace(/\s+/g, "_")
        .replace(/[^a-z0-9_\-]/g, "");
    headingsArr.forEach((h) => {
      let id = (h.id || "").trim();
      if (!id) {
        const base = slugify(h.textContent || "");
        id = base || "section";
      }
      let candidate = id;
      let n = 2;
      while (usedIds.has(candidate)) {
        candidate = `${id}-${n++}`;
      }
      if (h.id !== candidate) h.id = candidate;
      usedIds.add(candidate);
    });

    const nav = document.createElement("nav");
    let ulStack = [document.createElement("ul")];
    nav.appendChild(ulStack[0]);

    const levelOf = (tag) => (tag === "H2" ? 2 : tag === "H3" ? 3 : 4);
    let prev = 2;
    let headingCount = 0;
    headingsArr.forEach((h) => {
      const lvl = levelOf(h.tagName);
      // adjust depth
      while (lvl > prev) {
        const ul = document.createElement("ul");
        ulStack[ulStack.length - 1].lastElementChild?.appendChild(ul);
        ulStack.push(ul);
        prev++;
      }
      while (lvl < prev) {
        ulStack.pop();
        prev--;
      }
      const li = document.createElement("li");
      const a = document.createElement("a");
      a.href = "#" + h.id;
      a.textContent = h.textContent;
      a.target = "_self";
      li.appendChild(a);
      // Ajouter un index unique à chaque heading pour le tracking
      li.setAttribute("data-heading-idx", String(headingCount));
      headingCount++;
      ulStack[ulStack.length - 1].appendChild(li);
    });

    if (holder) holder.appendChild(nav);
    const navClone = nav.cloneNode(true);
    if (holderMobile) holderMobile.appendChild(navClone);

    // active link on scroll
    const links = [
      ...(holder ? holder.querySelectorAll("a") : []),
      ...(holderMobile ? holderMobile.querySelectorAll("a") : []),
    ];
    // Read breakpoint from CSS var and set autoCollapse only on desktop (disabled on mobile)
    const getCollapsePx = () => {
      const root = document.documentElement;
      const raw = getComputedStyle(root)
        .getPropertyValue("--bp-content-collapse")
        .trim();
      return raw || "1100px";
    };
    const mq = window.matchMedia(`(max-width: ${getCollapsePx()})`);
    const attrEnabled =
      document
        .querySelector(".table-of-contents")
        ?.getAttribute("data-auto-collapse") === "1";
    let autoCollapse = attrEnabled && !mq.matches;

    // Inject styles for collapsible & animation (tous les niveaux)
    const ensureStyles = () => {
      if (document.getElementById("toc-collapse-style")) return;
      const style = document.createElement("style");
      style.id = "toc-collapse-style";
      style.textContent = `
        .table-of-contents nav.table-of-contents-collapsible li > ul,
        details.table-of-contents-mobile nav.table-of-contents-collapsible li > ul { overflow: hidden; transition: height 200ms ease; }
        .table-of-contents nav.table-of-contents-collapsible li.collapsed > ul,
        details.table-of-contents-mobile nav.table-of-contents-collapsible li.collapsed > ul { display: block; }
      `;
      document.head.appendChild(style);
    };
    ensureStyles();

    const getAllItemsWithChildren = () => {
      const sideNav = holder ? holder.querySelector("nav") : null;
      const mobileNav = holderMobile ? holderMobile.querySelector("nav") : null;
      const q = (navEl) =>
        navEl
          ? Array.from(navEl.querySelectorAll("li[data-heading-idx]")).filter(
              (li) => li.querySelector(":scope > ul"),
            )
          : [];
      return {
        sideNav,
        mobileNav,
        sideItems: q(sideNav),
        mobileItems: q(mobileNav),
      };
    };

    const setNavCollapsible = () => {
      const sideNav = holder ? holder.querySelector("nav") : null;
      const mobileNav = holderMobile ? holderMobile.querySelector("nav") : null;
      if (sideNav) sideNav.classList.add("table-of-contents-collapsible");
      if (mobileNav) mobileNav.classList.add("table-of-contents-collapsible");
    };

    const measure = (el) => {
      if (!el) return 0;
      // Temporarily set height to auto to measure scrollHeight reliably
      const prev = el.style.height;
      el.style.height = "auto";

      // Force un reflow pour que le navigateur calcule les wraps de texte
      void el.offsetHeight;

      // Maintenant scrollHeight inclut la vraie hauteur avec tous les line wraps
      const h = el.scrollHeight;
      el.style.height = prev || "";
      return h;
    };

    // Tracker les animations en cours pour pouvoir les annuler
    const activeAnimations = new Map();

    const cancelAnimation = (el) => {
      if (!el) return;
      const animData = activeAnimations.get(el);
      if (animData) {
        // Nettoyer le listener de l'animation précédente
        el.removeEventListener("transitionend", animData.onEnd);
        activeAnimations.delete(el);
      }
    };

    const animateTo = (el, target) => {
      if (!el) return;

      // Annuler toute animation en cours sur cet élément
      cancelAnimation(el);

      // Obtenir la hauteur ACTUELLE (même si une animation est en cours)
      const current = parseFloat(getComputedStyle(el).height) || 0;

      // Si on est déjà proche de la cible, pas besoin d'animer
      if (Math.abs(current - target) < 1) {
        el.style.height = target ? "auto" : "0px";
        return;
      }

      // Démarrer depuis la hauteur actuelle
      el.style.height = current + "px";
      // Force reflow
      void el.offsetHeight;

      // Aller vers la cible
      el.style.height = target + "px";

      // Créer le listener de fin
      const onEnd = (e) => {
        if (e.propertyName !== "height") return;
        el.removeEventListener("transitionend", onEnd);
        activeAnimations.delete(el);
        if (target > 0) el.style.height = "auto";
      };

      // Sauvegarder le listener pour pouvoir l'annuler plus tard
      activeAnimations.set(el, { onEnd });
      el.addEventListener("transitionend", onEnd);
    };

    let prevActiveIdx = -1;
    let prevActiveElements = new Set();
    let prevActiveHeadingId = null;

    const setCollapsedState = (activeIdx) => {
      if (!autoCollapse) return;
      if (activeIdx == null || activeIdx < 0) activeIdx = 0;
      const { sideItems, mobileItems } = getAllItemsWithChildren();

      // Trouver l'élément <li> correspondant au heading actif et tous ses ancêtres
      const getActiveAndAncestors = (items, targetIdx) => {
        const toExpand = new Set();

        // Trouver le <li> qui correspond au targetIdx
        const findActiveLi = (li) => {
          const idx = Number(li.getAttribute("data-heading-idx") || "-1");
          if (idx === targetIdx) {
            return li;
          }

          const childUl = li.querySelector(":scope > ul");
          if (!childUl) return null;

          const childLis = childUl.querySelectorAll(
            ":scope > li[data-heading-idx]",
          );
          for (const child of childLis) {
            const found = findActiveLi(child);
            if (found) return found;
          }
          return null;
        };

        let activeLi = null;
        for (const li of items) {
          activeLi = findActiveLi(li);
          if (activeLi) break;
        }

        if (!activeLi) return toExpand;

        // Collecter l'élément actif lui-même
        const activeIdx = Number(
          activeLi.getAttribute("data-heading-idx") || "-1",
        );
        toExpand.add(activeIdx);

        // Remonter et collecter TOUS les ancêtres, sans condition
        // La structure de la TOC détermine automatiquement qui doit être ouvert
        let current = activeLi;
        while (current) {
          const parent = current.parentElement?.closest("li[data-heading-idx]");
          if (parent) {
            const parentIdx = Number(
              parent.getAttribute("data-heading-idx") || "-1",
            );
            toExpand.add(parentIdx);
            current = parent;
          } else {
            break;
          }
        }

        return toExpand;
      };

      const update = (items) => {
        const newActiveAncestors = getActiveAndAncestors(items, activeIdx);

        // Étape 0 : Annuler TOUTES les animations en cours avant de commencer
        // Cela évite les conflits si l'utilisateur scroll rapidement
        items.forEach((li) => {
          const sub = li.querySelector(":scope > ul");
          if (sub) cancelAnimation(sub);
        });

        // Étape 1 : Identifier TOUS les éléments qui vont changer d'état
        const allChanges = [];
        items.forEach((li) => {
          const sub = li.querySelector(":scope > ul");
          if (!sub) return;

          const idx = Number(li.getAttribute("data-heading-idx") || "-1");

          // Un élément doit être expanded SI il contient (directement ou indirectement) le heading actif
          // Donc soit il est dans newActiveAncestors, soit un de ses descendants l'est
          let shouldBeExpanded = false;

          // Vérifier si cet élément ou un de ses descendants est dans le chemin actif
          const allDescendants = li.querySelectorAll("li[data-heading-idx]");
          const allRelatedIndices = [
            idx,
            ...Array.from(allDescendants).map((d) =>
              Number(d.getAttribute("data-heading-idx") || "-1"),
            ),
          ];

          // Si au moins un de ces indices est dans newActiveAncestors, garder ouvert
          shouldBeExpanded = allRelatedIndices.some((i) =>
            newActiveAncestors.has(i),
          );

          const isCurrentlyCollapsed = li.classList.contains("collapsed");

          const isChanging =
            (shouldBeExpanded && isCurrentlyCollapsed) ||
            (!shouldBeExpanded && !isCurrentlyCollapsed);

          if (isChanging) {
            allChanges.push({ li, sub, shouldBeExpanded, idx });
          }
        });

        // Étape 2 : Parmi tous les changements, trouver ceux qui sont des "top-level"
        // (= n'ont PAS d'ancêtre qui change aussi)
        const topLevelChanges = [];
        const descendantChanges = [];

        allChanges.forEach((change) => {
          let hasAncestorChanging = false;

          // Remonter l'arbre pour voir si un ancêtre change aussi
          let currentLi = change.li;
          while (currentLi) {
            const parentLi = currentLi.parentElement?.closest(
              "li[data-heading-idx]",
            );
            if (!parentLi) break;

            const parentIdx = Number(
              parentLi.getAttribute("data-heading-idx") || "-1",
            );

            // Vérifier si ce parent est dans la liste des changements
            const parentIsChanging = allChanges.some(
              (c) => c.idx === parentIdx,
            );
            if (parentIsChanging) {
              hasAncestorChanging = true;
              break;
            }

            currentLi = parentLi;
          }

          if (hasAncestorChanging) {
            descendantChanges.push(change);
          } else {
            topLevelChanges.push(change);
          }
        });

        // Étape 3 : Appliquer TOUS les descendants instantanément (sans animation)
        // Ceci doit être fait AVANT toute animation pour que les hauteurs soient correctes
        if (descendantChanges.length > 0) {
          descendantChanges.forEach(({ li, sub, shouldBeExpanded }) => {
            const oldTransition = sub.style.transition;
            sub.style.transition = "none";

            if (shouldBeExpanded) {
              li.classList.remove("collapsed");
              sub.style.height = "auto";
            } else {
              li.classList.add("collapsed");
              sub.style.height = "0px";
            }

            // Forcer un reflow immédiat pour cet élément
            void sub.offsetHeight;
            sub.style.transition = oldTransition || "";
          });

          // Forcer un reflow global pour que TOUS les changements soient appliqués
          void document.body.offsetHeight;

          // IMPORTANT : Attendre un frame pour que le navigateur ait fini tous les calculs
          // avant de mesurer les hauteurs des parents
        }

        // Étape 4 : Animer SEULEMENT les top-level avec requestAnimationFrame
        // Les descendants sont déjà dans leur état final, donc la hauteur du parent sera correcte
        if (topLevelChanges.length > 0) {
          // Double requestAnimationFrame pour être sûr que le DOM est stabilisé
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              topLevelChanges.forEach(({ li, sub, shouldBeExpanded }) => {
                if (shouldBeExpanded) {
                  li.classList.remove("collapsed");

                  // CRITIQUE : Avant de mesurer, mettre ABSOLUMENT TOUS les sous-éléments
                  // dans leur état final (expanded OU collapsed) de manière synchrone
                  const allInnerItems = sub.querySelectorAll(
                    "li[data-heading-idx]",
                  );

                  // D'abord, désactiver toutes les transitions
                  allInnerItems.forEach((innerLi) => {
                    const innerSub = innerLi.querySelector(":scope > ul");
                    if (innerSub) {
                      innerSub.style.transition = "none";
                    }
                  });

                  // Ensuite, mettre chaque élément dans son état final
                  allInnerItems.forEach((innerLi) => {
                    const innerIdx = Number(
                      innerLi.getAttribute("data-heading-idx") || "-1",
                    );
                    const innerSub = innerLi.querySelector(":scope > ul");
                    if (innerSub) {
                      if (newActiveAncestors.has(innerIdx)) {
                        // Cet élément devrait être expanded
                        innerLi.classList.remove("collapsed");
                        innerSub.style.height = "auto";
                      } else {
                        // Cet élément devrait être collapsed
                        innerLi.classList.add("collapsed");
                        innerSub.style.height = "0px";
                      }
                    }
                  });

                  // Forcer un reflow global pour que TOUT soit calculé
                  void sub.offsetHeight;

                  // Réactiver les transitions
                  allInnerItems.forEach((innerLi) => {
                    const innerSub = innerLi.querySelector(":scope > ul");
                    if (innerSub) {
                      innerSub.style.transition = "";
                    }
                  });

                  // Maintenant on peut mesurer avec confiance : tous les éléments
                  // sont dans leur état final définitif
                  const target = measure(sub);
                  animateTo(sub, target);
                } else {
                  li.classList.add("collapsed");
                  animateTo(sub, 0);
                }
              });
            });
          });
        }

        prevActiveElements = newActiveAncestors;
      };

      update(sideItems);
      update(mobileItems);
      setNavCollapsible();
      prevActiveIdx = activeIdx;
    };

    // When switching between desktop/mobile, refresh autoCollapse and expand all on mobile
    const expandAll = () => {
      const { sideItems, mobileItems } = getAllItemsWithChildren();
      const expand = (items) =>
        items.forEach((li) => {
          li.classList.remove("collapsed");
          const sub = li.querySelector(":scope > ul");
          if (sub) sub.style.height = "auto";
        });
      expand(sideItems);
      expand(mobileItems);
    };

    const onMqChange = () => {
      autoCollapse = attrEnabled && !mq.matches;
      if (!autoCollapse) {
        expandAll();
      } else {
        setCollapsedState(prevActiveIdx);
      }
    };
    if (mq.addEventListener) mq.addEventListener("change", onMqChange);
    else if (mq.addListener) mq.addListener(onMqChange);

    // Debounce pour traiter la dernière mise à jour après que le scroll se stabilise
    let scrollDebounceTimer = null;
    let lastRequestedIdx = -1;
    let isProcessing = false;
    let hasUserScrolled = false; // Flag pour savoir si l'utilisateur a vraiment scrollé

    // Fonction pour mettre à jour l'URL avec l'ancre actuelle
    const updateURL = (headingId, force = false) => {
      if (!headingId) return;

      // Ne pas mettre à jour l'URL si l'utilisateur n'a pas scrollé et que ce n'est pas forcé
      if (!force && !hasUserScrolled) return;

      const newUrl = `${window.location.pathname}${window.location.search}#${headingId}`;

      // Mettre à jour l'URL sans recharger la page
      if (window.location.href !== newUrl) {
        history.pushState(null, null, newUrl);

        // Communiquer avec la fenêtre parente (format officiel Hugging Face)
        if (window.parent !== window) {
          try {
            window.parent.postMessage(
              {
                queryString: "",
                hash: headingId,
              },
              "https://huggingface.co",
            );
          } catch (e) {
            // Ignorer les erreurs silencieusement
          }
        }
      }
    };

    const onScroll = () => {
      // Marquer que l'utilisateur a scrollé
      hasUserScrolled = true;

      // active link highlight
      let activeIdx = -1;
      let activeHeadingId = null;

      for (let i = headingsArr.length - 1; i >= 0; i--) {
        const top = headingsArr[i].getBoundingClientRect().top;
        if (top - 60 <= 0) {
          links.forEach((l) => l.classList.remove("active"));
          const id = "#" + headingsArr[i].id;
          const actives = Array.from(links).filter(
            (l) => l.getAttribute("href") === id,
          );
          actives.forEach((a) => a.classList.add("active"));
          // Utiliser l'index du heading actif (n'importe quel niveau)
          activeIdx = i;
          activeHeadingId = headingsArr[i].id;
          break;
        }
      }

      // Mettre à jour l'URL si la section active a changé
      if (activeHeadingId && activeHeadingId !== prevActiveHeadingId) {
        updateURL(activeHeadingId);
        prevActiveHeadingId = activeHeadingId;
      }

      if (activeIdx === prevActiveIdx) return;

      // Sauvegarder la dernière demande
      lastRequestedIdx = activeIdx;

      // Si on est en train de traiter, ne rien faire (on traitera la dernière demande après)
      if (isProcessing) return;

      // Debounce : attendre un peu que le scroll se stabilise
      clearTimeout(scrollDebounceTimer);
      scrollDebounceTimer = setTimeout(() => {
        // Traiter la dernière demande
        if (lastRequestedIdx !== prevActiveIdx) {
          isProcessing = true;
          setCollapsedState(lastRequestedIdx);
          // Le processing flag sera réinitialisé après les animations
          setTimeout(() => {
            isProcessing = false;
            // Si une nouvelle demande est arrivée pendant qu'on traitait, la traiter maintenant
            if (lastRequestedIdx !== prevActiveIdx) {
              onScroll();
            }
          }, 250); // Attendre que les animations soient lancées
        }
      }, 100); // Debounce de 100ms
    };

    // If auto-collapse, collapse immediately (expand first section) before any scroll
    if (autoCollapse) setCollapsedState(0);

    window.addEventListener("scroll", onScroll);

    // Gérer la navigation par ancres au chargement de la page
    const handleInitialNavigation = () => {
      const hash = window.location.hash;
      if (hash) {
        const targetElement = document.querySelector(hash);
        if (targetElement) {
          // Attendre que le DOM soit prêt puis faire défiler vers l'élément
          setTimeout(() => {
            targetElement.scrollIntoView({ block: "start" });
            // Mettre à jour l'URL après le scroll (forcé car c'est une navigation initiale avec ancre)
            setTimeout(() => {
              updateURL(hash.substring(1), true); // Enlever le # du hash, forcer la mise à jour
            }, 100);
          }, 100);
        }
      }
      // Ne plus mettre à jour l'URL automatiquement si pas d'ancre
    };

    // Initialize state (sans mettre à jour l'URL)
    // Ne pas marquer hasUserScrolled ici pour éviter les mises à jour d'URL au chargement
    let activeIdx = -1;
    for (let i = headingsArr.length - 1; i >= 0; i--) {
      const top = headingsArr[i].getBoundingClientRect().top;
      if (top - 60 <= 0) {
        links.forEach((l) => l.classList.remove("active"));
        const id = "#" + headingsArr[i].id;
        const actives = Array.from(links).filter(
          (l) => l.getAttribute("href") === id,
        );
        actives.forEach((a) => a.classList.add("active"));
        activeIdx = i;
        prevActiveHeadingId = headingsArr[i].id;
        break;
      }
    }
    prevActiveIdx = activeIdx;

    // Gérer la navigation initiale
    handleInitialNavigation();

    // Gérer les événements de navigation du navigateur (boutons précédent/suivant)
    window.addEventListener("popstate", (event) => {
      const hash = window.location.hash;
      if (hash) {
        const targetElement = document.querySelector(hash);
        if (targetElement) {
          targetElement.scrollIntoView({ block: "start" });
        }
      } else {
        // Si pas d'ancre, aller au début de la page
        window.scrollTo({ top: 0 });
      }
    });

    // Marquer qu'un scroll a eu lieu quand l'utilisateur clique sur un lien du TOC
    links.forEach((link) => {
      link.addEventListener("click", () => {
        hasUserScrolled = true;
      });
    });

    // Close mobile accordion when a link inside it is clicked
    if (holderMobile) {
      const details = holderMobile.closest("details");
      holderMobile.addEventListener("click", (ev) => {
        const target = ev.target;
        const anchor =
          target && "closest" in target ? target.closest("a") : null;
        if (anchor instanceof HTMLAnchorElement && details && details.open) {
          details.open = false;
        }
      });
    }
  };

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", buildTOC, { once: true });
  } else {
    buildTOC();
  }
</script>  <main> <h2 id="introduction"><a href="#introduction">Introduction</a></h2>
<p>What does it actually take to train a high-performance LLM today?</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Reading time: 2-4 days.</p> </aside> </div>  
<p>Published research makes it look straightforward: strategic architecture choices, carefully curated datasets, and sufficient compute. The results are polished, the ablations are structured and clean. Every decision seems obvious in hindsight. But these technical reports only show what worked and apply a bit of rosy retrospection – they don’t capture the 2am dataloader debugging sessions, the loss spikes, or the subtle tensor parallelism bug (see later!) that quietly sabotages your training. The reality is messier, more iterative, and full of decisions that don’t make it into the final technical report.</p>
<p>Join us as we look behind the scenes of training <a href="https://huggingface.co/HuggingFaceTB/SmolLM3-3B">SmolLM3</a>, a 3B multilingual reasoning model trained on 11T tokens. This is not an ordinary blog post, but rather the untangling of a spiderweb of decisions, discoveries, and dead ends that led to deep insights into what it takes to build world-class language models.</p>
<p>It is also the final opus in our model-training long-form series: we’ve worked through building datasets at scale (<a href="https://huggingface.co/spaces/HuggingFaceFW/blogpost-fineweb-v1">FineWeb</a>), orchestrating thousands of GPUs to sing in unison (<a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook">Ultra Scale Playbook</a>), and selecting the best evaluations at each step of the process (<a href="https://github.com/huggingface/evaluation-guidebook">Evaluation Guidebook</a>). Now we shape it all together to build a strong AI model. We’ll walk you through the complete journey – not just the final recipe that worked, but showcase how experiments fail, infrastructure breaks, and how debugging processes shaped our decisions.</p>
<p>The story reads like a drama: you’ll see how promising small-scale ablations sometimes don’t translate at scale, why we restarted a training after 1T tokens, how we balanced the competing objectives of multilinguality, math, and code while maintaining strong English performance, and finally how we post-trained a hybrid reasoning model.</p>
<p>We also tried to avoid a cold list of all we did in favour of an organized story through our adventure. Think of this as a guide for anyone trying to go from “we have a great dataset and GPUs” to “we built a really strong model”. We hope being this open will helps close the gap between research and production, and make your next training run a little less chaotic.</p>
<h3 id="how-to-read-this-blog-post"><a href="#how-to-read-this-blog-post">How to read this blog post</a></h3>
<p>You don’t need to read this blog post from top to bottom, and at this point it’s too long to realistically read end-to-end in one sitting anyway. The blog post is structured in several distinct pieces that can be skipped or read individually:</p>
<ul>
<li><strong>Training compass:</strong>  A high-level discussion about whether or not you should pretrain your own model. We walk you through fundamental questions to ask yourself before burning through all your VC money, and how to think systematically through the decision process. This is a high-level section, if you want to skip straight to the technical content, scroll quickly past this part.</li>
<li><strong>Pretraining:</strong> The sections following the training compass cover everything you need to know to build a solid recipe for your own pretraining run: how to run ablations, select evaluations, mix data sources, make architecture choices, tune hyperparameters, and finally endure the training marathon. This section also applies if you’re not planning to pretrain from scratch but are interested in continued pretraining (aka mid-training).</li>
<li><strong>Post-training:</strong> In this part of the blog you’ll learn all the tricks needed to get most out of your pretrained models. Learn the whole post-training alphabet starting with SFT, DPO and GRPO as well as the dark arts and alchemy of model merging. Most of the knowledge about making these algorithms work well is learned through painful lessons, and we’ll share our experience here to hopefully spare you some of them.</li>
<li><strong>Infrastructure:</strong> If pretraining is the cake and post-training is the icing and cherry on top, then infrastructure is the industrial-grade oven. Without it, nothing happens, and if it’s broken, your happy Sunday baking session turns into a fire hazard. Knowledge about how to understand, analyse, and debug GPU clusters is scattered across the internet in various libraries, docs, and forums. This section walks through GPU layout, communication patterns between CPU/GPU/nodes/storage, and how to identify and overcome bottlenecks.</li>
</ul>
<p>So where do we even start? Pick the section that you find most exciting and let’s go!</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>If you have questions or remarks, open a discussion on the <a href="https://huggingface.co/spaces/HuggingFaceTB/smol-training-playbook/discussions">Community tab</a>!</p> </aside> </div>  
<h2 id="training-compass-why--what--how"><a href="#training-compass-why--what--how">Training compass: why → what → how</a></h2>
<figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-v1eyih9uodb"><div class="training-compass"></div>

<style>
  .training-compass {
    font-family: var(--default-font-family);
    background: transparent;
    border: none;
    border-radius: 0;
    padding: 0;
    max-width: 800px;
    width: 100%;
    margin: 0 auto;
  }


  .training-compass .compass-flow {
    display: flex;
    align-items: flex-start;
    justify-content: center;
    gap: var(--spacing-1);
  }

  .training-compass .compass-stage {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 220px;
  }

  .training-compass .stage-header {
    background: oklch(from var(--primary-color) calc(l + 0.35) calc(c * 0.6) h / 0.50);
    color: oklch(from var(--primary-color) calc(l - 0.15) calc(c * 1.2) h);
    padding: var(--spacing-3) var(--spacing-4);
    border-radius: 6px;
    border: 1.5px solid oklch(from var(--primary-color) calc(l + 0.05) calc(c * 1) h / 0.9);
    font-size: 16px;
    font-weight: 600;
    text-align: center;
    width: 100%;
    margin-bottom: var(--spacing-4);
    min-height: 48px;
    line-height: 1.2;
  }

  /* Dark mode adjustments for better readability */
  [data-theme="dark"] .training-compass .stage-header {
    background: oklch(from var(--primary-color) calc(l + 0.25) calc(c * 0.8) h / 0.3);
    color: oklch(from var(--primary-color) calc(l + 0.1) calc(c * 1.4) h);
    border-color: oklch(from var(--primary-color) calc(l + 0.1) calc(c * 1.2) h / 0.7);
  }

  .training-compass .arrow-right {
    font-size: 32px;
    color: oklch(from var(--primary-color) l c h / 0.5);
    flex-shrink: 0;
    margin: 0 var(--spacing-2);
    font-weight: 300;
  }

  /* Dark mode adjustments for better readability */
  [data-theme="dark"] .training-compass .arrow-right {
    color: oklch(from var(--primary-color) calc(l + 0.1) c h / 0.7);
  }

  .training-compass .stage-items {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-2);
    width: 100%;
  }

  .training-compass .stage-item {
    background: var(--page-bg);
    border: 1px solid oklch(from var(--text-color) l c h / 0.2);
    padding: var(--spacing-2) var(--spacing-3);
    border-radius: 4px;
    font-size: 14px;
    color: var(--muted-color);
    font-weight: 500;
  }

  /* Dark mode adjustments for better readability */
  [data-theme="dark"] .training-compass .stage-item {
    background: var(--surface-bg);
    border-color: var(--border-color);
    color: var(--text-color);
  }

  .training-compass .stage-dots {
    color: var(--text-color);
    font-size: 16px;
    font-weight: 600;
    padding: var(--spacing-2) var(--spacing-3);
    text-align: left;
    opacity: 0.5;
  }

  @media (max-width: 768px) {
    .training-compass {
      padding: var(--spacing-1) var(--spacing-2);
    }

    .training-compass .compass-flow {
      flex-direction: column;
      gap: var(--spacing-1);
    }

    .training-compass .arrow-right {
      transform: rotate(90deg);
      margin: var(--spacing-3) auto;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .training-compass .compass-stage {
      max-width: 100%;
      width: 100%;
    }

    .training-compass .stage-header {
      font-size: 16px;
    }
  }
</style>

<script>
  (() => {
    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('training-compass'))) {
        const candidates = Array.from(document.querySelectorAll('.training-compass'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Create the compass structure
      container.innerHTML = `
        
        <div class="compass-flow">
          <!-- Why Stage -->
          <div class="compass-stage">
            <div class="stage-header">Why train?</div>
            <div class="stage-items">
              <div class="stage-item">Research</div>
              <div class="stage-item">Production</div>
              <div class="stage-item">Strategic</div>
            </div>
          </div>
          
          <div class="arrow-right">→</div>
          
          <!-- What Stage -->
          <div class="compass-stage">
            <div class="stage-header">What to train?</div>
            <div class="stage-items">
              <div class="stage-item">Architecture</div>
              <div class="stage-item">Model size</div>
              <div class="stage-item">Data mix</div>
              <div class="stage-item">Assistant type</div>
              <div class="stage-item">Running ablations</div>
              <div class="stage-dots">...</div>
            </div>
          </div>
          
          <div class="arrow-right">→</div>
          
          <!-- How Stage -->
          <div class="compass-stage">
            <div class="stage-header">How to train?</div>
            <div class="stage-items">
              <div class="stage-item">Setup infra</div>
              <div class="stage-item">Training framework</div>
              <div class="stage-item">Handling loss spikes</div>
              <div class="stage-item">Midtraining</div>
              <div class="stage-item">SFT vs RL</div>
              <div class="stage-dots">...</div>
            </div>
          </div>
        </div>
      `;
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
    } else {
      bootstrap();
    }
  })();
</script></div></div></figure>
<p>The field of machine learning has an obsessive relationship with optimisation. We fixate on loss curves, model architectures, and throughput; after all, machine learning is fundamentally about optimising the loss function of a model. Yet before diving into these technical details, there’s a more fundamental question that often goes unasked:  <em>should we even be training this model?</em></p>
<p>In 2025, the open-source AI ecosystem releases world-class models on a nearly daily basis: Qwen, Gemma, DeepSeek, Kimi, Llama 🪦, Olmo, and the list grows longer every month. These aren’t just research prototypes or toy examples: they’re production-grade models covering an astonishing breadth of use cases from multilingual understanding to code generation and reasoning. Most of them come with permissive licenses and active communities ready to help you use them.</p>
<iframe class="card card--p0" frameborder="0" width="100%" height="600px" src="https://cfahlgren1-model-release-heatmap.hf.space/"></iframe>
<p>Which raises an uncomfortable truth: maybe you <em>don’t need to train your own model</em>  <em>.</em></p>
<p>This might seem like an odd way to start an “LLM training guide”. But many failed training projects didn’t fail because of bad hyperparameters or buggy code, they failed because someone decided to train a model they didn’t need. So before you commit to training, and dive into  <em>how</em>  to execute it, you need to answer two questions:  <em>why</em>  are you training this model? And  <em>what</em>  model should you train? Without clear answers, you’ll waste months of compute and engineering time building something the world already has, or worse, something nobody needs.</p>
<p>Let’s start with the why, because without understanding your purpose, you can’t make coherent decisions about anything that follows.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>About this section</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>This section is different from the rest of the blog: it’s less about experiments and technical details,
more about strategic planning. We’ll guide you through deciding <b>whether you need to train from scratch and what model to build.</b>
If you’ve already thought deeply about your why and what,
feel free to jump to the <a href="#every-big-model-starts-with-a-small-ablation">Every big model starts with a small ablation</a> chapter for the technical deep-dive.
But if you’re uncertain, investing time here will save you a lot of effort later.</p> </div> </div> </div> 
<h3 id="why-the-question-nobody-wants-to-answer"><a href="#why-the-question-nobody-wants-to-answer"><strong>Why: the question nobody wants to answer</strong></a></h3>
<p>Let’s be blunt about what happens in practice. Someone (if they’re lucky) gets access to a GPU cluster, maybe through a research grant, maybe through a company’s spare capacity, and the thought process goes roughly like this: “We have 100 H100s for three months. Let’s train a model!” The model size gets picked arbitrarily, the dataset gets assembled from whatever’s available. Training starts. And six months later, after burning through compute budget and team morale, the resulting model sits unused because nobody ever asked  <em>why.</em></p>
<p>Here are some reasons why you shouldn’t train a model:</p>
<figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-veb9icxp3zg"><div class="wrong-reasons"></div>

<style>
  .wrong-reasons {
    font-family: var(--default-font-family);
    background: transparent;
    border: none;
    border-radius: 0;
    padding: 0;
    width: 100%;
    margin: 0 auto;
  }

  .wrong-reasons .bad-reasons {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: var(--spacing-4);
    margin-bottom: 0;
  }

  .wrong-reasons .reason-card {
    background: oklch(from var(--danger-color) calc(l + 0.4) c h / 0.26);
    border: 1px solid oklch(from var(--danger-color) calc(l + 0.15) c h / 0.5);
    border-radius: 16px;
    padding: var(--spacing-6) var(--spacing-8);
    text-align: left;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    min-height: 140px;
  }

  /* Dark mode adjustments for better readability */
  [data-theme="dark"] .wrong-reasons .reason-card {
    background: oklch(from var(--danger-color) calc(l + 0.3) c h / 0.2);
    border-color: oklch(from var(--danger-color) calc(l + 0.1) c h / 0.6);
  }

  .wrong-reasons .reason-quote {
    font-size: 18px;
    font-weight: 600;
    color: var(--danger-color);
    margin-bottom: var(--spacing-2);
    line-height: 1.2;
    letter-spacing: -0.01em;
    position: relative;
    z-index: 1;
  }

  /* Dark mode adjustments for better readability */
  [data-theme="dark"] .wrong-reasons .reason-quote {
    color: oklch(from var(--danger-color) calc(l + 0.1) calc(c * 1.2) h);
  }

  .wrong-reasons .reason-explanation {
    font-size: 13px;
    color: oklch(from var(--danger-color) calc(l + 0.05) calc(c * 0.8) h);
    line-height: 1.4;
    font-weight: 500;
    opacity: 0.9;
    position: relative;
    z-index: 1;
    font-style: italic;
    letter-spacing: -0.005em;
    padding-left: 1.6em;
  }

  .wrong-reasons .reason-explanation::before {
    content: "";
    position: absolute;
    left: 0;
    top: 0.5em;
    width: 1.4em;
    height: 1.4em;
    background-color: var(--danger-color);
    mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 16'%3E%3Cpath d='M2 2 L2 8 L18 8 M18 8 L14 4 M18 8 L14 12' stroke='white' stroke-width='2' fill='none' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    mask-size: contain;
    mask-repeat: no-repeat;
    mask-position: center;
    -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 16'%3E%3Cpath d='M2 2 L2 8 L18 8 M18 8 L14 4 M18 8 L14 12' stroke='white' stroke-width='2' fill='none' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    -webkit-mask-size: contain;
    -webkit-mask-repeat: no-repeat;
    -webkit-mask-position: center;
    opacity: 0.85;
    transform: translateY(-50%);
  }

  /* Dark mode adjustments for better readability */
  [data-theme="dark"] .wrong-reasons .reason-explanation {
    color: oklch(from var(--danger-color) calc(l + 0.2) calc(c * 0.95) h);
    opacity: 0.95;
  }

  @media (max-width: 768px) {
    .wrong-reasons {
      padding: var(--spacing-5) var(--spacing-4);
    }

    .wrong-reasons .title {
      font-size: 24px;
    }

    .wrong-reasons .bad-reasons {
      grid-template-columns: 1fr;
    }
  }
</style>

<script>
  (() => {
    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('wrong-reasons'))) {
        const candidates = Array.from(document.querySelectorAll('.wrong-reasons'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Create the wrong reasons structure
      container.innerHTML = `
        <div class="bad-reasons">
          <div class="reason-card">
            <div class="reason-quote">We have compute available</div>
            <div class="reason-explanation">That's a resource, not a goal</div>
          </div>
          
          <div class="reason-card">
            <div class="reason-quote">Everyone else is doing it</div>
            <div class="reason-explanation">That's peer pressure, not strategy</div>
          </div>
          
          <div class="reason-card">
            <div class="reason-quote">AI is the future</div>
            <div class="reason-explanation">That's a platitude, not a plan</div>
          </div>
          
          <div class="reason-card">
            <div class="reason-quote">We want the best model possible</div>
            <div class="reason-explanation">That's not specific enough to guide decisions</div>
          </div>
        </div>
      `;
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
    } else {
      bootstrap();
    }
  })();
</script></div></div></figure>
<p>The allure of “we trained our own model” is powerful, but before investing a lot of time and resources, it makes sense to ask:  <strong>why do you need to train this model?</strong></p>
<p>The flowchart below guides the thought process one should go through before starting a big pretraining project. From a technical perspective, you should essentially first find out if there isn’t an existing model that you can either prompt of fine-tune to do the job.</p>
<pre class="mermaid">flowchart TD
    A[&quot;Should you train your own model?&quot;] --&gt; B[&quot;Can existing models handle your use case?&quot;]
    
    B --&gt; C[&quot;YES
    Existing models work well just with prompting&quot;]
    B --&gt; D[&quot;NO
    Prompting isn&#39;t enough&quot;]
    
    C --&gt; E[&quot;❌
    Don&#39;t train. Use existing models&quot;]
    
    D --&gt; F[&quot;Can finetuning solve your problem?&quot;]
    
    F --&gt; G[&quot;YES
    Finetuning works (post-training/continual pretraining)&quot;]
    F --&gt; H[&quot;NO
    Finetuning cannot solve your problem&quot;]
    
    G --&gt; I[&quot;❌
    Don&#39;t train from scratch&quot;]
    
    H --&gt; J[&quot;Train a model under one of these categories&quot;]
    
    J --&gt; K[&quot;🔬
     Research&quot;]
    J --&gt; L[&quot;🏭 
    Production&quot;]
    J --&gt; N[&quot;🌐 
    Strategic Open-Source&quot;]
    
    classDef question fill:#ffd0c5
    classDef decision fill:#f9f9f9
    classDef success fill:#d1f2eb
    classDef danger fill:#f8d7da
    classDef category fill:#ffb9b7
    
    class A,B,F question
    class C,D,G,H decision
    class E,I success
    class J,K,L,N category</pre>
<p>There are essentially three common areas where custom pretraining can make sense: you want to do novel research, you have very specific needs for production use-case, or you want to fill a gap in the open model ecosystem. Let’s have a quick look at each:</p>
<h4 id="research-what-do-you-want-to-understand"><a href="#research-what-do-you-want-to-understand"><strong>Research: what do you want to understand?</strong></a></h4>
<p>There is plenty of research one can do in the LLM space. What LLM research projects have in common is that you normally start with a clearly defined question:</p>
<ul>
<li>Can we scale training on this new optimiser to a 10B+ model?  From <a href="https://huggingface.co/papers/2502.16982">Muon is Scalable for LLM Training </a></li>
<li>Can reinforcement learning alone, without SFT, produce reasoning capabilities? From <a href="https://huggingface.co/papers/2501.12948">DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a></li>
<li>Can we train good small models on purely synthetic textbooks data? From <a href="./href="./b349da53329a408f83c48c1f7ab8d6f0">Textbooks Are All You Need </a></li>
<li>Can we achieve competitive performance by training on only openly licensed data? From<a href="https://huggingface.co/papers/2506.05209"> The Common Pile v0.1: An 8TB Dataset of Public Domain and Openly Licensed Text </a></li>
</ul>
<p>Making the hypothesis as concrete as possible and thinking about the necessary experiment scale increases the chance of success.</p>
<h4 id="production-why-cant-you-use-an-existing-model"><a href="#production-why-cant-you-use-an-existing-model"><strong>Production: why can’t you use an existing model?</strong></a></h4>
<p>There are mainly three reasons why companies can’t use off the shelf models for their use-case. Two of them are technical and the other is due to governance.</p>
<p>The first reason to train your own model is  <strong>domain specificity:</strong>  when your data or tasks involve highly specialized vocabulary or structure that existing models can’t handle well. For example:</p>
<ul>
<li>
<p>A DNA model with a unique vocabulary and long-range dependencies.</p>
</li>
<li>
<p>A legal or financial model requiring deep familiarity with domain-specific jargon and logic.</p>
</li>
</ul>
<p>A second, related reason is deployment constraints: when you need a model tailored to your hardware, latency, or privacy requirements. For instance, an LLM running on a drone or on-prem system with custom hardware like FPGAs.</p>
<p>Here’s a simple test: spend a few days building on top of Qwen3, Gemma3, or another current SOTA model. Can you reach your performance goals through prompting, tool-use, or post-training? If not, it’s probably time to train your own.</p>
<p>Even if the post-training budget needed to meet your requirements is immense, it might still be cheaper than starting from scratch. Post-training your model for 1T tokens is still more economic than starting from scratch to train for 10T+ tokens.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>At this point LLM trainers start to miraculously call it mid-training
instead of post-training</p> </aside> </div>  
<p>The third reason to build you own in-house language model is  <strong>safety and governance:</strong>  You need complete control over training data, model behaviour, and update cycles because you’re in a regulated industry or high-stakes application. You need to know  <em>exactly</em>  what went into the model and be able to prove it to regulators. In some cases you might have no other option than building your own model.</p>
<p>These are the main reasons companies train in-house models, but what about companies or organisations that release open models?</p>
<h4 id="strategic-open-source-do-you-see-a-gap-you-can-fill"><a href="#strategic-open-source-do-you-see-a-gap-you-can-fill"><strong>Strategic open-source: do you see a gap you can fill?</strong></a></h4>
<p>One of the most common reasons experienced AI labs release new open models is that they’ve identified a specific gap or new AI use-case in the open-source ecosystem.</p>
<p>The pattern typically looks like this; you notice an under explored area, maybe there are no strong on-device models with very long context, or multilingual models exist but they’re weak on low resource languages, or the field is moving towards interactive world-models like <a href="https://deepmind.google/discover/blog/genie-3-a-new-frontier-for-world-models/">Genie3</a> and no good open-weight model exists.</p>
<p>You have reasons to believe you can do better; perhaps you’ve curated better training data, developed better training recipes, or have the compute to overtrain where others couldn’t. Your goal is concrete: not “the best model ever,” but “the best 3B model for on-device use” or “the first small model with 1M context”.</p>
<p>This is a real goal and success creates value: developers adopt your model, it becomes infrastructure for others, or it establishes technical credibility. But success requires experience. You need to know what’s actually feasible and how to execute reliably in a competitive space. To make this concrete, let’s look at how we think about this question at Hugging Face.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>We also don’t cover distillation or pruning in this blog. These are valid paths to efficient models but represent different workflows than training from scratch. We recommend NVIDIA’s <a href="https://arxiv.org/abs/2408.11796" target="_blank">Minitron paper</a> for an overview of these topics.</p> </aside> </div>  
<h4 id="hugging-faces-journey"><a href="#hugging-faces-journey"><strong>Hugging Face’s journey</strong></a></h4>
<p>So why does Hugging Face train open models? The answer is simple: we build things that are useful to the open-source ecosystem and fill gaps that few others are filling.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Although there are millions of open-weight models, there are very few organisations that train fully open models. In addition to Hugging Face, there’s <a href="https://allenai.org/">Ai2</a> and <a href="https://marin.community/">Stanford’s Marin community</a>.</p> </aside> </div>  
<p>This includes datasets, tooling and training models. Every LLM training project we’ve started began with noticing a gap and believing we could contribute something meaningful.</p>
<p>We started our first LLM project after GPT-3 <span class="" id="citation--gpt3--1">(<a href="https://arxiv.org/abs/2005.14165" id="refctx-bib-gpt3-1" data-ref-id="bib-gpt3" target="_blank" rel="noopener noreferrer">Brown et al., 2020</a>)</span> was released. At the time, it felt like no one else was building an open alternative, and we were worried that the knowledge would end up locked away in just a few industry labs. So we launched the <a href="https://bigscience.huggingface.co/">BigScience workshop</a> to train an open version of GPT-3. The resulting model was <a href="https://huggingface.co/bigscience/bloom">Bloom</a>, and came from dozens of contributors working for a year to build the training stack, tokenizer, and pretraining corpus to pre-train a 175B parameter model.</p>
<p>The successor of Bloom was StarCoder in 2022 <span class="" id="citation--starcoder--2">(<a href="https://arxiv.org/abs/2305.06161" id="refctx-bib-starcoder-1" data-ref-id="bib-starcoder" target="_blank" rel="noopener noreferrer">Li et al., 2023</a>)</span>. OpenAI had developed Codex for GitHub Copilot <span class="" id="citation--codex--3">(<a href="https://arxiv.org/abs/2107.03374" id="refctx-bib-codex-1" data-ref-id="bib-codex" target="_blank" rel="noopener noreferrer">Chen et al., 2021</a>)</span>, but it was closed-source. Building an open-source alternative clearly would provide value to the ecosystem. So in collaboration with ServiceNow, under the <a href="https://huggingface.co/bigcode">BigCode</a> umbrella, we built <a href="https://huggingface.co/datasets/bigcode/the-stack">The Stack</a> dataset, and we trained <a href="https://huggingface.co/bigcode/starcoder">StarCoder 15B</a> to reproduce Codex. <a href="https://huggingface.co/collections/bigcode/starcoder2-65de6da6e87db3383572be1a">StarCoder2</a> <span class="" id="citation--starcoder2--4">(<a href="https://arxiv.org/abs/2402.19173" id="refctx-bib-starcoder2-1" data-ref-id="bib-starcoder2" target="_blank" rel="noopener noreferrer">Lozhkov et al., 2024</a>)</span> came from learning we could have trained longer, and recognising that smaller models trained longer might be more valuable than one large model. We trained a family (3B/7B/15B) on multiple trillions of tokens, far beyond what anyone had done for open code models at the time.</p>
<p>The <a href="https://huggingface.co/HuggingFaceTB">SmolLM family</a> followed a similar pattern. We noticed there were very few strong small models and we had just built <a href="https://huggingface.co/datasets/HuggingFaceFW/fineweb-edu">FineWeb-Edu</a> <span class="" id="citation--fineweb--5">(<a href="https://arxiv.org/abs/2406.17557" id="refctx-bib-fineweb-1" data-ref-id="bib-fineweb" target="_blank" rel="noopener noreferrer">Penedo et al., 2024</a>)</span>, which was a strong pre-training dataset. <a href="https://huggingface.co/collections/HuggingFaceTB/smollm-6695016cad7167254ce15966">SmolLM</a> (135M/360M/1.7B) was our first version. <a href="https://huggingface.co/collections/HuggingFaceTB/smollm2-6723884218bcda64b34d7db9">SmolLM2</a> <span class="" id="citation--smollm2--6">(<a href="https://arxiv.org/abs/2502.02737" id="refctx-bib-smollm2-1" data-ref-id="bib-smollm2" target="_blank" rel="noopener noreferrer">Allal et al., 2025</a>)</span> focused on better data and training longer, reaching SOTA performance on multiple fronts. <a href="https://huggingface.co/HuggingFaceTB/SmolLM3-3B">SmolLM3</a> scaled to 3B while adding hybrid reasoning, multilinguality and long context, features that the community values in 2025.</p>
<p>This pattern extends beyond pretraining: we trained <a href="https://huggingface.co/HuggingFaceH4/zephyr-7b-alpha">Zephyr</a> <span class="" id="citation--zephyr--7">(<a href="https://arxiv.org/abs/2310.16944" id="refctx-bib-zephyr-1" data-ref-id="bib-zephyr" target="_blank" rel="noopener noreferrer">Tunstall et al., 2023</a>)</span> to show DPO works at scale, started <a href="https://github.com/huggingface/open-r1">Open-R1</a> to reproduce DeepSeek R1’s distillation pipeline and released <a href="https://huggingface.co/open-r1/OlympicCoder-7B">OlympicCoder</a> for competitive programming, with SOTA performance in the International Olympiad in Informatics. We’ve also explored other modalities with <a href="https://huggingface.co/collections/HuggingFaceTB/smolvlm-6740bd584b2dcbf51ecb1f39">SmolVLM</a> <span class="" id="citation--smolvlm--8">(<a href="https://arxiv.org/abs/2504.05299" id="refctx-bib-smolvlm-1" data-ref-id="bib-smolvlm" target="_blank" rel="noopener noreferrer">Marafioti et al., 2025</a>)</span> for vision and <a href="https://huggingface.co/lerobot/smolvla_base">SmolVLA</a> <span class="" id="citation--smolvla--9">(<a href="https://arxiv.org/abs/2506.01844" id="refctx-bib-smolvla-1" data-ref-id="bib-smolvla" target="_blank" rel="noopener noreferrer">Shukor et al., 2025</a>)</span> for robotics.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>If you’re curious about the HF science projects,
you can find an overview here <a href="https://huggingface.co/science" target="_blank"><a href="https://huggingface.co/science">https://huggingface.co/science</a></a></p> </aside> </div>  
<p>Hopefully, this section has convinced you that there is value in thinking deeply about why you want to train a model.</p>
<p><strong>For the rest of this blog post, we’ll assume you’ve done this soul-searching and have a legitimate reason to train.</strong></p>
<h3 id="what-translating-goals-into-decisions"><a href="#what-translating-goals-into-decisions">What: translating goals into decisions</a></h3>
<p>Now that you know  <em>why</em>  you’re training, what should you train? By “what”, we mean: model type (dense, MoE, hybrid, something new), model size, architecture details and data mixture. Once you’ve settled on the why, you can derive the what, for example:</p>
<ul>
<li>fast model for on device → small efficient model</li>
<li>multilingual model → large tokenizer vocab</li>
<li>super long context → hybrid architecture</li>
</ul>
<p>Besides decisions driven by the use-case, there are also some choices that optimise the training itself, either by being more stable, more sample efficient, or faster. These decisions are not always so clear cut, but you can divide the decision process roughly into two phases:</p>
<p><strong>Planning:</strong>  Before running experiments, map your use case to the components you need to decide on. Your deployment environment determines model size constraints. Your timeline determines which architectural risks you can take. Your target capabilities determine dataset requirements. This phase is about connecting each constraint from your “why” to concrete specifications in your “what.”</p>
<p><strong>Validation:</strong>  Once you have a starting point and a list of potential modifications, test systematically. Since testing is expensive, focus on changes that could meaningfully improve performance for your use case or optimise your training. This is where ablations come in, covered in the <a href="#every-big-model-starts-with-a-small-ablation">ablations section</a>.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>Learn to identify what&#39;s worth testing, not just how to run tests.</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Perfect ablations on irrelevant choices waste as much compute as sloppy ablations on important ones.</p> </div> </div> </div> 
<p>In the following chapters you will learn about all the options you have to define your model and how to narrow down the choices with systematic experiments. Before going there we want to share a few learnings on how to setup teams and projects from training our own models as well as observing amazing other teams building great LLMs.</p>
<h3 id="super-power-speed-and-data"><a href="#super-power-speed-and-data">Super power: speed and data</a></h3>
<p>Of course there are many ways to get to Rome, but we’ve found that what consistently sets successful LLM training teams apart is  <strong>iteration speed.</strong>  Training LLMs is really a learning by training discipline, the more often you train, the better your team will become.
So between the teams that train a model a year and the ones that train one per quarter, the latter will improve so much faster. You can look at the teams from Qwen and DeepSeek for example. Now household names, they have a long track record of consistently releasing new models on a fast cadence.</p>
<p>Besides iteration speed, by far the most influential aspect of LLM training is  <strong>data curation</strong> . There’s a natural tendency to dive into architecture choices to improve the model, but the teams that excel in LLM training are the ones that are obsessed with high quality data more than anything else.</p>
<p>Another aspect that is tied to iteration speed is the team size: for the main pretraining tasks you only need a handful of people equipped with enough compute to execute. To pre-train a model like Llama 3 today you probably only need 2-3 people. Only once you start to venture into more diverse trainings and downstream tasks (multimodal, multilingual, post-training etc) will you slowly need to add a few more people to excel at each domain.</p>
<p>So start with a small, well equipped team, and build a new model every 2-3 months and within short amount of time you’ll climb to the top. Now the rest of the blog will focus on the technical day-to-day of this team!</p>
<h2 id="every-big-model-starts-with-a-small-ablation"><a href="#every-big-model-starts-with-a-small-ablation">Every big model starts with a small ablation</a></h2>
<p>Before we can start training an LLM, we need to make many decisions that will shape the model’s performance and training efficiency. Which architecture will best serve our use case? What optimiser and learning rate schedule to use and which data sources to mix in?</p>
<p>How these decisions are made is a frequently asked question. People sometimes expect that they are made by thinking deeply about them. And while strategic thinking is essential—as we covered in the <a href="#training-compass:-why-%E2%86%92-what-%E2%86%92-how">previous section</a> where we discussed choosing baselines and identifying which modifications are worth testing—reasoning alone isn’t enough. Things are not always intuitive with LLMs, and hypotheses about what should work sometimes don’t pan out in practice.</p>
<p>For example, using what seems like “the highest quality data” doesn’t always yield stronger models. Take the <a href="https://arxiv.org/">arXiv</a> for example, which is a vast collection of humanity’s scientific knowledge. Intuitively, training on such rich STEM data should produce superior models, right? In practice, it doesn’t and especially for smaller models, where it can even hurt performance <span class="" id="citation--grpo--10">(<a href="https://arxiv.org/abs/2402.03300" id="refctx-bib-grpo-1" data-ref-id="bib-grpo" target="_blank" rel="noopener noreferrer">Shao et al., 2024</a>)</span>. Why? The reason is that while arXiv papers are full of knowledge, they’re highly specialized and written in a narrow academic style that’s quite different from the diverse, general text that models learn best from.</p>
<p>So, how can we know what works if staring at the problem long and hard doesn’t help? We run a lot of experiments, like good empiricists! Machine learning is not pure math, but actually very much an experimental science.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>In many ways, machine learning resembles thermodynamics before the discovery of statistical mechanics: we have reliable empirical laws and design principles that work remarkably well, even if deeper theoretical explanations are still emerging.</p> </aside> </div>  
<p>Since those experiments will guide many of our crucial decisions, it is really important to set them up well. There are essentially two main attributes we want from them:</p>
<ol>
<li><strong>Speed:</strong> they should run as fast as possible so we can iterate often. The more ablations we can run, the more  hypotheses we can test.</li>
<li><strong>Reliability:</strong> they should provide strong discriminative power. If the metrics we look at can’t meaningfully distinguish between different setups early on, our ablations may reveal little (and if they’re noisy, we risk chasing noise!) For more details, check out the <a href="https://huggingface.co/spaces/HuggingFaceFW/blogpost-fineweb-v1">FineWeb blog post</a>.</li>
</ol>
<p>But before we can set up our ablations, we need to make some foundational choices about architecture type and model size. These decisions—guided by our compass—impact which training framework to use, how to allocate our compute budget, and which baseline to start from.</p>
<p>For SmolLM3, we went with a dense Llama-style architecture at 3B parameters because we were targeting small on-device models. But as you’ll see in the <a href="#defining-your-llm">Defining your LLM chapter</a>, a MoE or hybrid model might be better suited for your use case, and different model sizes come with different tradeoffs. We’ll explore these choices in depth later, and show you how to make these decisions. For now, let’s start with the most practical first step: choosing your baseline.</p>
<h3 id="choosing-your-baseline"><a href="#choosing-your-baseline"><strong>Choosing your baseline</strong></a></h3>
<p>Every successful model builds on a proven foundation and modifies it for their needs. When Qwen trained their first model family <span class="" id="citation--qwen1--11">(<a href="https://arxiv.org/abs/2309.16609" id="refctx-bib-qwen1-1" data-ref-id="bib-qwen1" target="_blank" rel="noopener noreferrer">Bai et al., 2023</a>)</span>, they started from Llama’s architecture. When Meta trained Llama 3, they started from Llama 2. Kimi K2, started from DeepSeek-V3’s MoE architecture. This applies to architectures, but also training hyperparameters and optimisers.</p>
<p>Why? Good architectures and training setups design takes years of iteration across many organisations. The standard transformer and optimisers like AdamW have been refined through thousands of experiments. People have found their failure modes, debugged instabilities, optimised implementations. Starting from a proven foundation means inheriting all that accumulated knowledge. Starting fresh means rediscovering every problem yourself.</p>
<p>Here’s what makes a good starting point for an architecture:</p>
<ul>
<li>Matches your constraints: aligns with your deployment target and use case.</li>
<li>Proven at scale: multi-trillion token runs at similar or larger sizes.</li>
<li>Well-documented: known hyperparameters which have been proven to work in open models.</li>
<li>Framework support: It should ideally be supported in the training frameworks you are considering and the inference frameworks you are planning to use.</li>
</ul>
<p>Below is a non-exhaustive list of strong 2025 baseline options for various architectures:</p>
















































































<div class="table-scroll"><table><thead><tr><th>Architecture Type</th><th>Model Family</th><th>Sizes</th></tr></thead><tbody><tr><td><strong>Dense</strong></td><td><a href="https://huggingface.co/collections/meta-llama/llama-31-669fc079a0c406a149a5738f">Llama 3.1</a></td><td>8B, 70B</td></tr><tr><td><strong>Dense</strong></td><td><a href="https://huggingface.co/collections/meta-llama/llama-32-66f448ffc8c32f949b04c8cf">Llama 3.2</a></td><td>1B, 3B</td></tr><tr><td><strong>Dense</strong></td><td><a href="https://huggingface.co/collections/Qwen/qwen3-67dd247413f0e2e4f653967f">Qwen3</a></td><td>0.6B, 1.7B, 4B, 14B, 32B</td></tr><tr><td><strong>Dense</strong></td><td><a href="https://huggingface.co/collections/google/gemma-3-release-67c6c6f89c4f76621268bb6d">Gemma3</a></td><td>12B, 27B</td></tr><tr><td><strong>Dense</strong></td><td><a href="https://huggingface.co/collections/HuggingFaceTB/smollm2-6723884218bcda64b34d7db9">SmolLM2</a>, <a href="https://huggingface.co/HuggingFaceTB/SmolLM3-3B">SmolLM3</a></td><td>135M, 360M, 1.7B, 3B</td></tr><tr><td><strong>MoE</strong></td><td><a href="https://huggingface.co/collections/Qwen/qwen3-67dd247413f0e2e4f653967f">Qwen3 MoE</a></td><td>30B-A3B, 235B-A122B</td></tr><tr><td><strong>MoE</strong></td><td><a href="https://huggingface.co/collections/openai/gpt-oss-68911959590a1634ba11c7a4">GPT-OSS</a></td><td>21B-A3B, 117B-A5B</td></tr><tr><td><strong>MoE</strong></td><td><a href="https://huggingface.co/moonshotai/Moonlight-16B-A3B-Instruct">Kimi Moonlight</a></td><td>16B-A3B</td></tr><tr><td><strong>MoE</strong></td><td><a href="https://huggingface.co/collections/moonshotai/kimi-k2-6871243b990f2af5ba60617d">Kimi-k2</a></td><td>1T-A32B</td></tr><tr><td><strong>MoE</strong></td><td><a href="https://huggingface.co/deepseek-ai/DeepSeek-V2">DeepSeek v2</a></td><td>671B-A37B</td></tr><tr><td><strong>Hybrid</strong></td><td><a href="https://huggingface.co/Zyphra/models?search=zamba2">Zamba2</a></td><td>1.2B, 2.7B, 7B</td></tr><tr><td><strong>Hybrid</strong></td><td><a href="https://huggingface.co/collections/tiiuae/falcon-h1-6819f2795bc406da60fab8df">Falcon-H1</a></td><td>0.5B, 1.5B, 3B, 7B, 34B</td></tr><tr><td><strong>MoE + Hybrid</strong></td><td><a href="https://huggingface.co/Qwen/Qwen3-Next-80B-A3B-Instruct">Qwen3-Next</a></td><td>80B-A3B</td></tr><tr><td><strong>MoE + Hybrid</strong></td><td><a href="https://huggingface.co/MiniMaxAI/MiniMax-Text-01">MiniMax-01</a></td><td>456B-A46B</td></tr></tbody></table></div>
<p>So go to your architecture type and pick a baseline close to the number of parameters you’d like your model to have. Don’t overthink it too much as the architecture you start from is not set in stone. In the next section, we will see how to go from a baseline to a  final architecture that is optimal for you.</p>
<h4 id="modifying-your-baseline-the-discipline-of-de-risking"><a href="#modifying-your-baseline-the-discipline-of-de-risking"><strong>Modifying your baseline: the discipline of de-risking</strong></a></h4>
<p>Now you have a baseline that works and fits your use case. You could stop here, train it on your data mixture (assuming it’s good) and likely get a decent model. Many successful projects do exactly that. But baselines aren’t optimised for your specific constraints, they’re designed for the use cases and deployment targets of whoever built them. So there are likely modifications worth making to better align with your goals. However, every architectural change carries risk: it might boost performance, tank it, or do nothing while wasting a week of your compute budget.</p>
<p>The discipline that keeps you on track is  <strong>de-risking</strong> : never change anything unless you know it helps.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>What counts as de-risked?</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>A change is de-risked when testing shows it either improves performance
on your target capabilities, or provides a meaningful benefit
(e.g. faster inference, lower memory, better stability) without hurting
performance beyond your acceptable tradeoffs.</p> </div> </div> </div> 
<p>The tricky part is that your baseline and training setup have many components you could modify: attention mechanisms, positional encodings, activation functions, optimisers, training hyperparameters, normalisation schemes, model layout, and more. Each represents a potential experiment, and these components often interact in non-linear ways. You have neither the time nor compute to test everything or explore every interaction.</p>
<p>Start by testing the promising changes individually to understand their isolated impact, then combine the ones that work and run a leave-one-out analysis if your compute budget allows for it.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Check out the ScaleRL paper <span class="" id="citation--scalerl--12">(<a href="https://arxiv.org/abs/2510.13786" id="refctx-bib-scalerl-1" data-ref-id="bib-scalerl" target="_blank" rel="noopener noreferrer">Khatri et al., 2025</a>)</span> for an excellent example of this methodology in practice.</p> </aside> </div>  
<p>Don’t fall into the trap of exhaustive grid searches over every hyperparameter or testing every architectural variant that comes out.</p>
<div class="note note--success" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>🎯</span> <div class="note__title" data-astro-cid-qg6lmfty>Strategic experimentation</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Knowing how to run experiments isn’t enough if you don’t know which experiments are worth running.
Ask yourself two questions before testing any modification:</p><ul>
<li>Will this help my specific use case?</li>
<li>Will this optimise my training?</li>
</ul><p>If a modification doesn’t clearly address either question, skip it.</p> </div> </div> </div> 
<p>Now that you know how to identify what’s promising through strategic planning, it’s time to move to the  <strong>empirical validation</strong> . In the next sections, we’ll show you  <em>how</em>  to actually test these changes in practice. We’ll cover how to set up reliable experiments, interpret results, and avoid common pitfalls. Then in the following chapters, we’ll walk through concrete examples of testing popular architectural, data, infra and training decisions.</p>
<p>So let’s build a simple ablation setup we can use for our experiments. First, we need to decide which training framework to pick.</p>
<h3 id="picking-a-training-framework"><a href="#picking-a-training-framework">Picking a training framework</a></h3>
<p>The first decision we need to make is which framework to use for training our model, and by extension, for running all our ablations. This choice involves balancing three key considerations that, frustratingly, will work against each other:</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Don’t be a hero and switch the training framework between ablations and your final run. That is the road to suffering.</p> </aside> </div>  
<ol>
<li>The framework must support our target architecture or let us easily extend it.</li>
<li>It needs to be stable and production-ready, and not prone to mysteriously breaking midway through training.</li>
<li>It should deliver strong throughput so we can iterate quickly and make the most of our compute budget.</li>
</ol>
<p>In practice, these requirements might pull against each other, creating trade-offs. Let’s look at the available options.</p>
<div class="wide"> 












































<div class="table-scroll"><table><thead><tr><th>Framework</th><th>Features</th><th>Battle-tested</th><th>Optimised</th><th>Lines of Code (core / total)</th><th>Extensibility &amp; Debugging</th></tr></thead><tbody><tr><td><strong>Megatron-LM</strong></td><td>✅ Extensive</td><td>✅ Kimi-K2, Nemotron</td><td>✅ Pioneers of 3D parallelism</td><td>93k / 269k</td><td>⚠️ Hard for beginners</td></tr><tr><td><strong>DeepSpeed</strong></td><td>✅ Extensive</td><td>✅ BLOOM, GLM</td><td>✅ Pioneers of ZeRO &amp; 3D parallelism</td><td>94k / 194k</td><td>⚠️ Hard for beginners</td></tr><tr><td><strong>TorchTitan</strong></td><td>⚡ Growing feature set</td><td>⚠️ Newer but tested by PyTorch team</td><td>⚡Optimised for dense models, MoE improvements underway.</td><td>7k / 9k</td><td>⚡ Moderate: requires parallelism know-how</td></tr><tr><td><strong>Nanotron</strong></td><td>🎯 Minimal, tailored for HF pretraining</td><td>✅ Yes (StarCoder, SmolLM)</td><td>✅ Optimised (UltraScale Playbook)</td><td>15k / 66k</td><td>⚡ Moderate: requires parallelism know-how</td></tr></tbody></table></div> </div>
<p>The table above summarises the key trade-offs between popular frameworks. Lines of code for the first three frameworks are from the TorchTitan technical report <span class="" id="citation--torchtitan--13">(<a href="https://arxiv.org/abs/2410.06511" id="refctx-bib-torchtitan-1" data-ref-id="bib-torchtitan" target="_blank" rel="noopener noreferrer">Liang et al., 2025</a>)</span> Let’s discuss each in more detail:</p>
<p><a href="https://github.com/NVIDIA/Megatron-LM">Megatron-LM</a> from Nvidia has been around for years and is battle-tested. It’s what powers models like Kimi’s K2 <span class="" id="citation--kimik2--14">(<a href="https://arxiv.org/abs/2507.20534" id="refctx-bib-kimik2-1" data-ref-id="bib-kimik2" target="_blank" rel="noopener noreferrer">Team et al., 2025</a>)</span>, it delivers solid throughput and has most of the production features we’d want. But that maturity comes with complexity: the codebase can be hard to navigate and modify when we need to implement something new.</p>
<p><a href="https://github.com/deepspeedai/DeepSpeed">DeepSpeed</a> falls into a similar category. It’s the pioneer of ZeRO optimisation and powered models like BLOOM and GLM. Like Megatron-LM, it’s extensively battle-tested and optimised, but shares the same complexity challenges. The large codebase (194k total lines) can be intimidating when you need to implement custom features or debug unexpected behavior.</p>
<p>On the other side, PyTorch’s recent <a href="https://github.com/pytorch/torchtitan">TorchTitan</a> library is much lighter and simpler to navigate, thanks to its compact and modular codebase. It has the core features needed for pretraining and is great for rapid experimentation. However, being newer, it isn’t as battle-tested and can still be a bit unstable as it’s actively developed.</p>
<p>We took a different path and built our own framework, nanotron, from scratch. This gave us full flexibility and a deep understanding of large-scale pretraining; insights that later evolved into the <a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook">Ultra Scale Playbook</a>. Since we open-sourced the library, we also got valuable feedback from the community, though for most cases we had to battle-test features ourselves first. The framework now supports all the production features we need for training, but we’re still building out areas like MoE support.</p>
<p>Building from scratch made sense then, but it demands major investment in team expertise and time to debug issues and add missing features. A strong alternative is forking an existing framework and enhancing it for your needs. For example, Thinking Machines Lab built their internal pretraining library as a fork of TorchTitan (<a href="https://x.com/cHHillee/status/1949470943291805832">source</a>).</p>
<p>Ultimately, your choice depends on your team’s expertise, target features, and how much time you’re willing to invest in development versus using the most production-ready option.</p>
<p>If multiple frameworks support your needs, compare their throughput on your specific hardware. For quick experiments and speed runs, simpler codebases often win.</p>
<h3 id="ablation-setup"><a href="#ablation-setup">Ablation setup</a></h3>
<h4 id="setting-up-our-ablation-framework"><a href="#setting-up-our-ablation-framework">Setting up our ablation framework</a></h4>
<p>Now that we’ve chosen a framework, we need to decide on our ablation setup. Remember, the goal is to run experiments at a small scale and get results we can confidently extrapolate to our final production run.</p>
<p>There are two main approaches. First, we can take our target model size and train it on fewer tokens. For the SmolLM3 ablations, we trained the full 3B model on 100B tokens instead of the final 11T. Second, if our target model is too large, we can train a smaller proxy model for ablations. For example, when Kimi was developing their 1T parameter Kimi K2 model with 32B active parameters, using the full size for all ablations would have been prohibitively expensive, so they ran some ablations on a 3B MoE with 0.5B active parameters <span class="" id="citation--kimik2--15">(<a href="https://arxiv.org/abs/2507.20534" id="refctx-bib-kimik2-2" data-ref-id="bib-kimik2" target="_blank" rel="noopener noreferrer">Team et al., 2025</a>)</span>.</p>
<p>One key question is whether these small-scale findings actually transfer. In our experience, if something hurts performance at small scale, you can confidently rule it out for large scale. Now something works at small scale, you should still make sure you’ve trained on a reasonable number of tokens to conclude with high probability that these findings will extrapolate to larger scales. The longer you train and the closer the ablation models are to the final model, the better.</p>
<p>In this blog post, we’ll use a baseline vanilla transformer for all ablations. Our main setup is a 1B transformer following <a href="https://huggingface.co/meta-llama/Llama-3.2-1B">Llama3.2 1B</a> architecture trained on 45B tokens. This takes about 1.5 days to train on a node of 8xH100s using this nanotron <a href="https://huggingface.co/datasets/HuggingFaceTB/ablations-training-configs/blob/main/baseline_config_1B.yaml">config</a> (42k tokens per second per GPU). For experiments needing stronger signal, we’ll also show results from our larger setup: the 3B model trained on 100B tokens that we used for SmolLM3. You can find the 3B baseline config <a href="https://huggingface.co/datasets/HuggingFaceTB/ablations-training-configs/blob/main/baseline_config_3B.yaml">here</a>.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>We train for 45B tokens to ensure we get stable signal, though ~35B is <a href="https://arxiv.org/abs/2203.15556" target="_blank">Chinchilla-optimal</a> for this model size.</p> </aside> </div>  
<p>Our baseline 1B config captures all the essential training details in a structured YAML format. Here are the key sections:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="yaml"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Datasets and mixing weights</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">data_stages</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">- </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    dataset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">      dataset_folder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">fineweb-edu</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">stack-edu-python</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">finemath-3plus</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">      dataset_weights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      - </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0.7</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      - </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0.2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">      - </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0.1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Model architecture, Llama3.2 1B configuration</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  model_config</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    hidden_size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2048</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    num_hidden_layers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">16</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    num_attention_heads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">32</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    num_key_value_heads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  </span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    intermediate_size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">8192</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    max_position_embeddings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">4096</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    rope_theta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">50000.0</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    tie_word_embeddings</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Training hyperparameters, AdamW with cosine schedule</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">optimizer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  clip_grad</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1.0</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  learning_rate_scheduler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    learning_rate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0.0005</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    lr_decay_starting_step</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2000</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    lr_decay_steps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">18000</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    lr_decay_style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">cosine</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    lr_warmup_steps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2000</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    lr_warmup_style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">linear</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    min_decay_lr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">5.0e-05</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  optimizer_factory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    adam_beta1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0.9</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    adam_beta2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0.95</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    adam_eps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1.0e-08</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">    name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">adamW</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Parallelism, 1 node</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">parallelism</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  dp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">8</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  # Data parallel across 8 GPUs</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  tp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  # No tensor or pipeline parallelism needed at 1B scale</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  pp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Tokenizer</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">tokenizer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  tokenizer_max_length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">4096</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  tokenizer_name_or_path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">HuggingFaceTB/SmolLM3-3B</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Batch size, sequence length and total training for 30B tokens</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">tokens</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  batch_accumulation_per_replica</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">16</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  micro_batch_size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">3</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D"> # GBS (global batch size)=dp * batch_acc* MBS * sequence=1.5M tokens</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  sequence_length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">4096</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D">  train_steps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">20000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D"> # GBS * 20000 = 30B</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> ...(truncated)</span></span>
<span class="line"></span></code></pre></div>
<p>For our ablations, we’ll modify the first 3 sections while keeping everything else constant.</p>
<div class="note note--danger" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>☝️</span> <div class="note__title" data-astro-cid-qg6lmfty>Modify one thing at a time</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Change only one variable per ablation while keeping everything else constant.
If you change multiple things and performance improves, you won’t know what
caused it. Test modifications individually, then combine successful ones and reassess.</p> </div> </div> </div> 
<p>When running ablations, some architectural changes can significantly alter parameter count. For instance, switching from tied to untied embeddings doubles our embedding parameters, while going from MHA to GQA or MQA decreases our attention parameters substantially. To ensure fair comparisons, we need to track parameter counts and occasionally adjust other hyperparameters (like hidden size or layer count) to keep model sizes roughly the same. Here is a simple function that we use to estimate parameter counts for different configurations:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> transformers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> LlamaConfig, LlamaForCausalLM</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> count_parameters</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    tie_embeddings</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    num_key_value_heads</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    num_attention_heads</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    hidden_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2048</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    num_hidden_layers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    intermediate_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">8192</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    vocab_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">128256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    sequence_length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">4096</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    config </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> LlamaConfig(</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">        hidden_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">hidden_size,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">        num_hidden_layers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">num_hidden_layers,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">        num_attention_heads</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">num_attention_heads,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">        num_key_value_heads</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">num_key_value_heads,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">        intermediate_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">intermediate_size,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">        vocab_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">vocab_size,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">        max_position_embeddings</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">sequence_length,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">        tie_word_embeddings</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">tie_embeddings,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> LlamaForCausalLM(config)  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">{sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(p.numel() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> model.parameters())</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1e9</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">:.2f</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">B&quot;</span></span>
<span class="line"></span></code></pre></div>
<p>We also provide an interactive tool to visualise LLM parameter distributions, in the case of a dense transformer. This can come in handy when making architecture decisions or setting up configs for ablations.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-kte2boe459"><div class="d3-parameter-calculator"></div>

<style>
  .d3-parameter-calculator {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.5;
    color: var(--text-color);
  }

  .d3-parameter-calculator .controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 16px;
    margin-bottom: 20px;
  }

  .d3-parameter-calculator .control-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .d3-parameter-calculator .control-group label {
    font-size: 0.8em;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-parameter-calculator .control-group input {
    padding: 6px 10px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 0.85em;
    background: var(--surface-bg);
    color: var(--text-color);
  }

  .d3-parameter-calculator .control-group input:focus {
    outline: none;
    border-color: var(--primary-color);
    background: var(--surface-bg);
  }

  .d3-parameter-calculator .slider-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .d3-parameter-calculator .slider-group label {
    font-size: 0.8em;
    font-weight: 700;
    color: var(--text-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .d3-parameter-calculator .slider-value {
    font-size: 0.75em;
    color: var(--muted-color);
    font-weight: 600;
  }

  /* Slider styling */
  .d3-parameter-calculator input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    height: 6px;
    border-radius: 3px;
    position: relative;
  }

  /* Slider container for progress bar */
  .d3-parameter-calculator .slider-group {
    position: relative;
  }

  .d3-parameter-calculator .slider-group::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 6px;
    background: var(--border-color);
    border-radius: 3px;
    pointer-events: none;
  }

  .d3-parameter-calculator .slider-group::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: var(--progress-width, 0%);
    height: 6px;
    background: var(--primary-color);
    border-radius: 3px;
    transition: width 0.1s ease;
    pointer-events: none;
  }

  /* WebKit slider track */
  .d3-parameter-calculator input[type="range"]::-webkit-slider-track {
    background: var(--border-color);
    height: 6px;
    border-radius: 3px;
  }

  /* WebKit slider thumb */
  .d3-parameter-calculator input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    background: var(--primary-color);
    height: 18px;
    width: 18px;
    border-radius: 50%;
    cursor: pointer;
    border: 1px solid rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease;
    margin-top: 2px;
  }

  .d3-parameter-calculator input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }

  /* Firefox slider track */
  .d3-parameter-calculator input[type="range"]::-moz-range-track {
    background: var(--border-color);
    height: 6px;
    border-radius: 3px;
    border: none;
  }

  /* Firefox slider thumb */
  .d3-parameter-calculator input[type="range"]::-moz-range-thumb {
    background: var(--primary-color);
    height: 18px;
    width: 18px;
    border-radius: 50%;
    cursor: pointer;
    border: 1px solid rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease;
    margin-top: 2px;
  }

  .d3-parameter-calculator input[type="range"]::-moz-range-thumb:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
  }

  /* Firefox slider progress */
  .d3-parameter-calculator input[type="range"]::-moz-range-progress {
    background: var(--primary-color);
    height: 6px;
    border-radius: 3px;
  }


  .d3-parameter-calculator .total-params-container {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    margin: 16px 0 20px 0;
    text-align: center;
    width: 100%;
  }

  .d3-parameter-calculator .total-params {
    font-size: 1.8em;
    font-weight: bold;
    color: var(--primary-color);
    margin: 0 0 4px 0;
  }

  .d3-parameter-calculator .total-params-label {
    font-size: 0.8em;
    font-weight: 500;
    color: var(--muted-color);
    margin: 0;
  }

  .d3-parameter-calculator .breakdown {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 24px;
  }

  .d3-parameter-calculator .component {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 16px;
    position: relative;
  }

  .d3-parameter-calculator .component-title {
    font-weight: 700;
    color: var(--text-color);
    margin-bottom: 8px;
    font-size: 1em;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    text-align: center;
  }

  .d3-parameter-calculator .component-description {
    font-size: 0.8em;
    color: var(--muted-color);
    margin-bottom: 12px;
    line-height: 1.3;
    text-align: center;
  }

  .d3-parameter-calculator .component-params {
    font-weight: 700;
    color: var(--primary-color);
    font-size: 1.2em;
    text-align: center;
    margin: 12px 0 8px 0;
    padding: 8px;
  }

  .d3-parameter-calculator .calculation-section {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 10px;
    margin: 8px 0;
  }

  .d3-parameter-calculator .component-calculation {
    font-family: 'Courier New', monospace;
    font-size: 0.8em;
    color: var(--text-color);
    font-weight: 600;
    text-align: center;
    margin-bottom: 6px;
  }

  .d3-parameter-calculator .component-formula {
    font-size: 0.75em;
    color: var(--text-color);
    opacity: 0.7;
    font-style: italic;
    text-align: center;
    border-top: 1px solid var(--border-color);
    padding-top: 6px;
  }

  .d3-parameter-calculator .comparison {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 12px;
    margin: 16px 0 0 0;
  }

  .d3-parameter-calculator .config-card {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 12px;
    text-align: center;
    flex: 1;
    min-width: 0;
  }

  .d3-parameter-calculator .config-title {
    font-size: 0.75em;
    color: var(--text-color);
    margin-bottom: 4px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .d3-parameter-calculator .config-value {
    font-weight: 600;
    color: var(--primary-color);
    font-size: 0.9em;
  }

  .d3-parameter-calculator .formula-box {
    background: transparent;
    border: none;
    padding: 12px 0;
    margin: 12px 0 0 0;
    font-family: 'Courier New', monospace;
    font-size: 0.75em;
    color: var(--text-color);
    text-align: center;
  }

  /* Responsive design */
  @media (max-width: 768px) {
    .d3-parameter-calculator .controls-grid {
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .d3-parameter-calculator .breakdown {
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .d3-parameter-calculator .comparison {
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .d3-parameter-calculator .total-params {
      font-size: 1.5em;
    }

    .d3-parameter-calculator .component-params {
      font-size: 1.1em;
    }
  }

  @media (max-width: 480px) {
    .d3-parameter-calculator {
      padding: 16px;
    }

    .d3-parameter-calculator .total-params-container {
      padding: 16px;
    }

    .d3-parameter-calculator .component {
      padding: 12px;
    }

    .d3-parameter-calculator .config-card {
      padding: 10px;
    }

    .d3-parameter-calculator .total-params {
      font-size: 1.3em;
    }
  }
</style>

<script>
  (() => {
    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-parameter-calculator'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-parameter-calculator'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Create the calculator interface
      container.innerHTML = `
        <div class="controls-grid">
          <div class="slider-group">
            <label for="vocabSize">Vocabulary Size <span class="slider-value" id="vocabValue">128k</span></label>
            <input type="range" id="vocabSize" min="32000" max="256000" step="1000" value="128256">
          </div>
          
          <div class="slider-group">
            <label for="hiddenSize">Hidden Size <span class="slider-value" id="hiddenValue">2048</span></label>
            <input type="range" id="hiddenSize" min="512" max="8192" step="64" value="2048">
          </div>
          
          <div class="slider-group">
            <label for="numLayers">Layers <span class="slider-value" id="layersValue">16</span></label>
            <input type="range" id="numLayers" min="4" max="64" step="1" value="16">
          </div>
          
          <div class="slider-group">
            <label for="numHeads">Attention Heads <span class="slider-value" id="headsValue">32</span></label>
            <input type="range" id="numHeads" min="8" max="128" step="1" value="32">
          </div>
          
          <div class="slider-group">
            <label for="numKVHeads">KV Heads <span class="slider-value" id="kvHeadsValue">32</span></label>
            <input type="range" id="numKVHeads" min="1" max="64" step="1" value="32">
          </div>
          
          <div class="slider-group">
            <label for="intermediateSize">Intermediate Size <span class="slider-value" id="intermediateValue">8192</span></label>
            <input type="range" id="intermediateSize" min="2048" max="32768" step="256" value="8192">
          </div>
          
          <div class="control-group" style="grid-column: 1 / -1;">
            <label for="tieEmbeddings">Tie Embeddings</label>
            <select id="tieEmbeddings">
              <option value="true">Yes</option>
              <option value="false">No</option>
            </select>
          </div>
        </div>
        
        <div class="total-params-container">
          <div class="total-params" id="totalParams">1.46B</div>
          <div class="total-params-label">Parameters</div>
        </div>
        
        <div class="breakdown">
          <div class="component">
            <div class="component-title">Embeddings</div>
            <div class="component-description">Input + Output Projection</div>
            <div class="component-params" id="embeddingParams">524M</div>
            <div class="calculation-section">
              <div class="component-calculation" id="embeddingCalculation">128k × 2048 × 2</div>
              <div class="component-formula" id="embeddingFormula">vocab_size × hidden_size × 2</div>
            </div>
          </div>
          
          <div class="component">
            <div class="component-title">Attention Layers</div>
            <div class="component-description">Q, K, V, O projections</div>
            <div class="component-params" id="attentionParams">268M</div>
            <div class="calculation-section">
              <div class="component-calculation" id="attentionCalculation">16 × 2048² × 4</div>
              <div class="component-formula" id="attentionFormula">layers × hidden_size² × 4</div>
            </div>
          </div>
          
          <div class="component">
            <div class="component-title">Feed Forward</div>
            <div class="component-description">Up, Gate, Down projections</div>
            <div class="component-params" id="ffnParams">805M</div>
            <div class="calculation-section">
              <div class="component-calculation" id="ffnCalculation">16 × 2048 × 8192 × 3</div>
              <div class="component-formula" id="ffnFormula">layers × hidden_size × intermediate_size × 3</div>
            </div>
          </div>
          
          <div class="component">
            <div class="component-title">Layer Norms</div>
            <div class="component-description">Input + Attention norms</div>
            <div class="component-params" id="lnParams">131K</div>
            <div class="calculation-section">
              <div class="component-calculation" id="lnCalculation">16 × 2048 × 2</div>
              <div class="component-formula" id="lnFormula">layers × hidden_size × 2</div>
            </div>
          </div>
        </div>
        
        <div class="comparison">
          <div class="config-card">
            <div class="config-title">Attention Type</div>
            <div class="config-value" id="attentionType">MHA</div>
          </div>
          <div class="config-card">
            <div class="config-title">Embedding Strategy</div>
            <div class="config-value" id="embeddingStrategy">Tied</div>
          </div>
          <div class="config-card">
            <div class="config-title">Params per Layer</div>
            <div class="config-value" id="paramsPerLayer">67M</div>
          </div>
        </div>
      `;

      function updateSliderValues() {
        const vocabSize = parseInt(container.querySelector('#vocabSize').value) || 0;
        const hiddenSize = parseInt(container.querySelector('#hiddenSize').value) || 0;
        const numLayers = parseInt(container.querySelector('#numLayers').value) || 0;
        const numHeads = parseInt(container.querySelector('#numHeads').value) || 0;
        const numKVHeads = parseInt(container.querySelector('#numKVHeads').value) || 0;
        const intermediateSize = parseInt(container.querySelector('#intermediateSize').value) || 0;

        container.querySelector('#vocabValue').innerHTML = vocabSize >= 1000 ? `${(vocabSize / 1000).toFixed(0)} <span style="opacity: 0.6;">k</span>` : vocabSize.toString();
        container.querySelector('#hiddenValue').textContent = hiddenSize.toString();
        container.querySelector('#layersValue').textContent = numLayers.toString();
        container.querySelector('#headsValue').textContent = numHeads.toString();
        container.querySelector('#kvHeadsValue').textContent = numKVHeads.toString();
        container.querySelector('#intermediateValue').textContent = intermediateSize.toString();

        // Update progress bars
        updateProgressBars();
      }

      function updateProgressBars() {
        const sliders = container.querySelectorAll('input[type="range"]');
        sliders.forEach(slider => {
          const sliderGroup = slider.closest('.slider-group');
          if (sliderGroup) {
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const value = parseFloat(slider.value);
            const percentage = ((value - min) / (max - min)) * 100;
            sliderGroup.style.setProperty('--progress-width', `${percentage}%`);
          }
        });
      }

      function calculateParameters() {
        const vocabSize = parseInt(container.querySelector('#vocabSize').value) || 0;
        const hiddenSize = parseInt(container.querySelector('#hiddenSize').value) || 0;
        const numLayers = parseInt(container.querySelector('#numLayers').value) || 0;
        const numHeads = parseInt(container.querySelector('#numHeads').value) || 0;
        const numKVHeads = parseInt(container.querySelector('#numKVHeads').value) || 0;
        const intermediateSize = parseInt(container.querySelector('#intermediateSize').value) || 0;
        const tieEmbeddings = container.querySelector('#tieEmbeddings').value === 'true';

        updateSliderValues();

        // Calculate each component
        const embeddingParams = vocabSize * hiddenSize * (tieEmbeddings ? 1 : 2);

        // Attention parameters - corrected formula
        let attentionParams;
        if (numKVHeads === numHeads) {
          // MHA: 4 full projections (Q, K, V, O)
          attentionParams = numLayers * 4 * hiddenSize * hiddenSize;
        } else {
          // GQA/MQA: Q + O are full size, K + V are reduced
          attentionParams = numLayers * hiddenSize * hiddenSize * (2 + 2 * numKVHeads / numHeads);
        }

        // FFN parameters (up, gate, down)
        const ffnParams = numLayers * hiddenSize * intermediateSize * 3;

        // Layer norm parameters
        const lnParams = numLayers * hiddenSize * 2 + hiddenSize; // +1 for final layer norm

        // Total
        const totalParams = embeddingParams + attentionParams + ffnParams + lnParams;

        // Format numbers with reduced opacity suffixes
        const formatNumber = (num) => {
          if (num >= 1000000000) return `${(num / 1000000000).toFixed(2)} <span style="opacity: 0.6;">B</span>`;
          if (num >= 1000000) return `${(num / 1000000).toFixed(0)} <span style="opacity: 0.6;">M</span>`;
          if (num >= 1000) return `${(num / 1000).toFixed(0)} <span style="opacity: 0.6;">K</span>`;
          return num.toString();
        };

        // Update displays
        container.querySelector('#totalParams').innerHTML = formatNumber(totalParams);
        container.querySelector('#embeddingParams').innerHTML = formatNumber(embeddingParams);
        container.querySelector('#attentionParams').innerHTML = formatNumber(attentionParams);
        container.querySelector('#ffnParams').innerHTML = formatNumber(ffnParams);
        container.querySelector('#lnParams').innerHTML = formatNumber(lnParams);

        // Update calculations and formulas
        const vocabDisplay = vocabSize >= 1000 ? `${(vocabSize / 1000).toFixed(0)} <span style="opacity: 0.6;">k</span>` : vocabSize.toString();

        container.querySelector('#embeddingCalculation').innerHTML =
          tieEmbeddings ? `${vocabDisplay} × ${hiddenSize}` : `${vocabDisplay} × ${hiddenSize} × 2`;
        container.querySelector('#embeddingFormula').textContent =
          tieEmbeddings ? 'vocab_size × hidden_size' : 'vocab_size × hidden_size × 2';

        if (numKVHeads === numHeads) {
          container.querySelector('#attentionCalculation').textContent =
            `${numLayers} × ${hiddenSize}² × 4`;
          container.querySelector('#attentionFormula').textContent =
            'layers × hidden_size² × 4';
        } else {
          container.querySelector('#attentionCalculation').textContent =
            `${numLayers} × ${hiddenSize}² × ${(2 + 2 * numKVHeads / numHeads).toFixed(2)}`;
          container.querySelector('#attentionFormula').textContent =
            'layers × hidden_size² × (2 + 2 × kv_heads/num_heads)';
        }

        container.querySelector('#ffnCalculation').textContent =
          `${numLayers} × ${hiddenSize} × ${intermediateSize} × 3`;
        container.querySelector('#ffnFormula').textContent =
          'layers × hidden_size × intermediate_size × 3';

        container.querySelector('#lnCalculation').textContent =
          `${numLayers} × ${hiddenSize} × 2`;
        container.querySelector('#lnFormula').textContent =
          'layers × hidden_size × 2';

        // Update config display
        let attentionType = 'MHA';
        if (numKVHeads === 1) attentionType = 'MQA';
        else if (numKVHeads < numHeads) attentionType = 'GQA';

        container.querySelector('#attentionType').textContent = attentionType;
        container.querySelector('#embeddingStrategy').textContent = tieEmbeddings ? 'Tied' : 'Separate';
        container.querySelector('#paramsPerLayer').innerHTML =
          formatNumber((attentionParams + ffnParams + lnParams) / numLayers);

        // Update progress bars
        updateProgressBars();
      }

      // Add event listeners
      container.querySelector('#vocabSize').addEventListener('input', calculateParameters);
      container.querySelector('#hiddenSize').addEventListener('input', calculateParameters);
      container.querySelector('#numLayers').addEventListener('input', calculateParameters);
      container.querySelector('#numHeads').addEventListener('input', calculateParameters);
      container.querySelector('#numKVHeads').addEventListener('input', calculateParameters);
      container.querySelector('#intermediateSize').addEventListener('input', calculateParameters);
      container.querySelector('#tieEmbeddings').addEventListener('change', calculateParameters);

      // Initialize
      updateSliderValues();
      calculateParameters();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
    } else {
      bootstrap();
    }
  })();
</script></div></div></figure>
<div class="sidenote-container"> <aside class="sidenote"> <p>This calculator assumes standard architectural choices: gated feedforward networks, standard head dimensions for attention (hidden_size / num_heads), and 2 layer norms per transformer layer. It doesn’t include bias terms (if used).</p> </aside> </div>  
<h4 id="understanding-what-works-evaluation"><a href="#understanding-what-works-evaluation"><strong>Understanding what works: evaluation</strong></a></h4>
<p>Once we launch our ablations, how do we know what works or not?</p>
<p>The first instinct of anyone who trains models might be to look at the loss, and yes, that’s indeed important. You want to see it decreasing smoothly without wild spikes or instability. For many architectural choices, the loss correlates well with downstream performance and can be sufficient <span class="" id="citation--chen2025--16">(<a href="https://arxiv.org/abs/2410.08527" id="refctx-bib-chen2025-1" data-ref-id="bib-chen2025" target="_blank" rel="noopener noreferrer">Y. Chen et al., 2025</a>)</span>. However, looking at the loss only is not always reliable. Taking the example of data ablations, you would find that training on Wikipedia gives a lower loss than training on web pages (the next token is easier to predict), but that doesn’t mean you’d get a more capable model. Similarly, if we change the tokenizer between runs, the losses aren’t directly comparable since text gets split differently. Some changes might also specifically affect certain capabilities like reasoning and math and get washed away in the average loss. Last but not least, models can continue improving on downstream tasks even after pretraining loss has converged <span class="" id="citation--liu2022--17">(<a href="https://arxiv.org/abs/2210.14199" id="refctx-bib-liu2022-1" data-ref-id="bib-liu2022" target="_blank" rel="noopener noreferrer">Liu et al., 2022</a>)</span>.</p>
<p>We need more fine-grained evaluation to see the full picture and understand these nuanced effects and a natural approach is to use downstream evaluations that test knowledge, understanding, reasoning, and whatever other domains matter for us.</p>
<p>For these ablations, it’s good to focus on tasks that give good early signal and avoid noisy benchmarks. In <a href="https://huggingface.co/spaces/HuggingFaceFW/blogpost-fine-tasks">FineTasks</a> and <a href="https://arxiv.org/pdf/2506.20920">FineWeb2</a>, reliable evaluation tasks are defined by four key principles:</p>
<ul>
<li><strong>Monotonicity:</strong>  The benchmark scores should consistently improve as models train longer.</li>
<li><strong>Low noise:</strong>  When we train models with the same setup but different random seeds, the benchmark scores shouldn’t vary wildly.</li>
<li><strong>Above-random performance:</strong>  Many capabilities only emerge later in training, so tasks that show random-level performance for extended periods aren’t useful for ablations. This is the case, for example, for MMLU in multiple choice format as we will explain later.</li>
<li><strong>Ranking consistency:</strong>  If one approach outperforms another at early stages, this ordering should remain stable as training continues.</li>
</ul>
<p>The quality of a task also depends on the task formulation (how we ask the model questions) and metric choice (how we compute the answer score).</p>
<p>Three common task formulations are multiple choice format (MCF), cloze formulation (CF) and freeform generation (FG). Multiple choice format requires models to select an option from a number of choices explicitly presented in the prompt and prefixed with A/B/C/D (as is done in MMLU, for example). In cloze formulation, we compare the likelihood of the difference choices to see which one is more likely without having provided them in the prompt. In FG, we look at the accuracy of the greedy generation for a given prompt. FG requires a lot of latent knowledge in the model and is usually too difficult a task for the models to be really useful in short pre-training ablations before a full of training. We thus focus on multiple choice formulations when running small sized ablations (MCF or CF).</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>Heads‑up</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>For post-trained models, FG becomes the primary formulation since
we’re evaluating whether the model can actually generate useful responses.
We’ll cover evaluation for these models in the post-training chapter.</p> </div> </div> </div> 
<p>Research has also shown that models struggle with MCF early in training, only learning this skill after extensive training, making CF better for early signal <span class="" id="citation--datacomp--18">(<a href="https://arxiv.org/abs/2406.11794" id="refctx-bib-datacomp-1" data-ref-id="bib-datacomp" target="_blank" rel="noopener noreferrer">@olmes, @du2025, J. Li et al., 2025</a>)</span>. We thus use CF for small ablations, and integrate MCF in the main run as it gives better mid-training signal once a model has passed a threshold to get sufficiently high signal-over-noise ratio for MCF. A quick note also that, to score a model’s answer in sequence likelihood evaluations like CF, we compute accuracy as the percentage of questions where the the correct answer has the highest log probability normalised by character count. This normalisation prevents a bias toward shorter answers.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>The point at which MMLU MCF becomes non-random depends on the model size and training data. For a 7B transformer, <a href="https://arxiv.org/pdf/2406.08446">t</a>he OLMES paper <span class="" id="citation--olmes--19">(<a href="https://arxiv.org/abs/2406.08446" id="refctx-bib-olmes-1" data-ref-id="bib-olmes" target="_blank" rel="noopener noreferrer">Gu et al., 2025</a>)</span> found the model starts showing non-random performance after 500B tokens. For 1.7B model, we found this happens after 6T tokens in SmolLM2. <span class="" id="citation--du2025--20"><a href="https://arxiv.org/abs/2403.15796" id="refctx-bib-du2025-1" data-ref-id="bib-du2025" target="_blank" rel="noopener noreferrer">Du et al. (2025)</a></span> argue this is fundamentally about the pre-training loss reaching a certain threshold.</p> </aside> </div>  
<p>Our ablations evaluation suite includes the benchmarks from <a href="https://huggingface.co/spaces/HuggingFaceFW/blogpost-fineweb-v1">FineWeb</a> ablations, except for SIQA which we found to be too noisy. We add math and code benchmarks like GSM8K and HumanEval and a long context benchmark RULER for long context ablations. This aggregation of tasks test world knowledge, reasoning, and common sense across a variety of formats, as shown in the table below. To speed up evaluations at the expense of some additional noise, we only evaluate on 1,000 questions from each benchmark. We also use the cloze fomulation (CF) way of evaluating for all multiple-choice benchmarks, as explained above.  Note that for multilingual ablations and actual training, we add more benchmarks to test multilinguality, which we detail later. These evaluations are run using LightEval and the individual benchmarks are covered in more detail in the <a href="#appendix">Appendix</a>. The table above summarises the key characteristics of each benchmark:</p>











































































<div class="table-scroll"><table><thead><tr><th>Benchmark</th><th>Domain</th><th>Task Type</th><th>Questions</th><th>What it Tests</th></tr></thead><tbody><tr><td>MMLU</td><td>Knowledge</td><td>Multiple choice</td><td>14k</td><td>Broad academic knowledge across 57 subjects</td></tr><tr><td>ARC</td><td>Science &amp; reasoning</td><td>Multiple choice</td><td>7k</td><td>Grade-school level science reasoning</td></tr><tr><td>HellaSwag</td><td>Commonsense reasoning</td><td>Multiple choice</td><td>10k</td><td>Commonsense reasoning about everyday situations (narrative completion)</td></tr><tr><td>WinoGrande</td><td>Commonsense reasoning</td><td>Binary choice</td><td>1.7k</td><td>Pronoun resolution requiring world knowledge</td></tr><tr><td>CommonSenseQA</td><td>Commonsense reasoning</td><td>Multiple choice</td><td>1.1k</td><td>Commonsense reasoning about everyday concepts</td></tr><tr><td>OpenBookQA</td><td>Science</td><td>Multiple choice</td><td>500</td><td>Elementary science facts with reasoning</td></tr><tr><td>PIQA</td><td>Physical commonsense</td><td>Binary choice</td><td>1.8k</td><td>Physical commonsense about everyday objects</td></tr><tr><td>GSM8K</td><td>Math</td><td>Free-form generation</td><td>1.3k</td><td>Grade-school math word problems</td></tr><tr><td>HumanEval</td><td>Code</td><td>Free-form generation</td><td>164</td><td>Python function synthesis from docstrings</td></tr></tbody></table></div>
<p>Let’s look at a few example questions from each to get a concrete sense of what these evaluations actually test:</p>
<iframe src="https://huggingface.co/datasets/HuggingFaceTB/llm-benchmarks-viewer/embed/viewer/default/mmlu" class="card card--p0" frameborder="0" width="100%" height="450px"></iframe>
<p>Browse through the examples above to see the types of questions in each benchmark. Notice how MMLU and ARC test factual knowledge with multiple choices, GSM8K requires computing numerical answers to math problems, and HumanEval requires generating complete Python code. This diversity ensures we’re testing different aspects of model capability throughout our ablations.</p>
<p><strong>Which data mixture for the ablations?</strong></p>
<p>For  <em>architecture ablations</em> , we train on a fixed mix of high-quality datasets that provide early signal across a wide range of tasks. We use English (<a href="https://huggingface.co/datasets/HuggingFaceFW/fineweb-edu">FineWeb-Edu</a>), math (<a href="https://huggingface.co/datasets/HuggingFaceTB/finemath">FineMath</a>), and code (<a href="https://huggingface.co/datasets/HuggingFaceTB/stack-edu">Stack-Edu-Python</a>). Architectural findings should extrapolate well to other datasets and domains, including multilingual data so we can keep our data mixture simple.</p>
<p>For  <em>data ablations</em> , we take the opposite approach: we fix the architecture and systematically vary the data mixtures to understand how different data sources affect model performance.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Sometimes the differences in the evaluations can be small. If you have enough compute, it might be worth re-running the same ablations with different seeds to see how much the results vary.</p> </aside> </div>  
<p>The real value of a solid ablation setup goes beyond just building a good model. When things inevitably go wrong during our main training run (and they will, no matter how much we prepare), we want to be confident in every decision we made and quickly identify which components weren’t properly tested and could be causing the issues. This preparation saves debugging time and bullet proof our future mental sanity.</p>
<h4 id="estimating-ablations-cost"><a href="#estimating-ablations-cost">Estimating ablations cost</a></h4>
<p>Ablations are amazing but they require GPU time and it’s worth understanding the cost of these experiments. The table below shows our complete compute breakdown for SmolLM3 pretraining: the main run (accounting for occasional downtimes), ablations before and during training, plus compute spent on an unexpected scaling issue that forced a restart and some debugging (which we’ll detail later).</p>









































<div class="table-scroll"><table><thead><tr><th>Phase</th><th>GPUs</th><th>Days</th><th>GPU-hours</th></tr></thead><tbody><tr><td>Main pretraining run</td><td>384</td><td>30</td><td>276,480</td></tr><tr><td>Ablations (pretraining)</td><td>192</td><td>15</td><td>69,120</td></tr><tr><td>Ablations (mid-training)</td><td>192</td><td>10</td><td>46,080</td></tr><tr><td>Training reset &amp; debugging</td><td>384/192</td><td>3/4</td><td>46,080</td></tr><tr><td><strong>Total cost</strong></td><td>-</td><td>-</td><td><strong>437,760</strong></td></tr></tbody></table></div>
<div class="sidenote-container"> <aside class="sidenote"> <p>We estimate evaluation costs to be slightly under 10,000 GPU hours. Our full evaluation suite (english, multilingual, math &amp; code) takes around 1.5 hours per GPU, and we evaluate every 10B tokens throughout the 11T tokens, in addition to numerous ablations. The long context evaluations were particularly expensive, taking around 1 hour on 8 GPUs per run.</p> </aside> </div>  
<p>The numbers reveal an important fact: ablations and debugging consumed a total of 161,280 GPU hours,  <strong>more than half the cost of our main training run</strong>  (276,480 GPU hours) <strong>.</strong>  We run over 100 ablations total across SmolLM3’s development: we spent 20 days on pre-training ablations, 10 days on mid-training ablations, and 7 days recovering from an unexpected training issue that forced a restart and some debugging (which we’ll detail later).</p>
<p>This highlights why ablation costs must be factored into your compute budget: plan for training cost plus ablations plus buffer for surprises. If you’re targeting SOTA performance, implementing new architecture changes, or don’t already have a proven recipe, ablations become a substantial cost center rather than minor experiments.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>When <a href="https://huggingface.co/deepseek-ai/DeepSeek-V3">DeepSeek-V3</a> came out, <a href="https://www.forbes.com/sites/markminevich/2025/02/06/the-6-million-ai-bombshell-how-deepseek-shook-wall-street-and-ai-leadership/">the world fixated</a> on its reported $5.6M training cost. Many interpreted that number as the full R&amp;D cost. In reality, it only reflects the final training run. The much larger — and usually invisible — expense is in the research itself: the ablations, failed runs, and debugging that lead to a final recipe. Given the scale and novelty of the model, their research costs were certainly higher.</p> </aside> </div>  
<p>Before we move to the next section, let’s establish some ground rules that every person running experiments should follow.</p>
<h3 id="rules-of-engagement"><a href="#rules-of-engagement">Rules of engagement</a></h3>
<blockquote class="quote" data-astro-cid-arj5dyob> <div class="quote__text" data-astro-cid-arj5dyob> <p>TL;DR: Be paranoid.</p> </div>  </blockquote> 
<p><strong>Validate your evaluation suite.</strong> Before training any models, make sure your evaluation suite can reproduce the published results of models you will compare against. If any benchmarks are generative in nature (e.g. GSM8k), be extra paranoid and manually inspect a few samples to ensure the prompt is formatted correctly and that any post-processing is extracting the correct information. Since evals will guide every single decision, getting this step right is crucial for the success of the project!</p>
<p><strong>Test every change, no matter how small.</strong>  Don’t underestimate the impact of that seemingly innocent library upgrade or the commit that “only changed two lines”. These small changes can introduce subtle bugs or performance shifts that will contaminate your results. You need a library with a strong test suite on the cases which matter to you to avoid regression.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>In some cases, a bug can be solved by upgrading the library to the latest version. For a beautiful example of this with some detective debugging, see the <a href="https://elanapearl.github.io/blog/2025/the-bug-that-taught-me-pytorch/?t=1">blog post</a> by Elana Simon.</p> </aside> </div>  
<p><strong>Change one thing at a time.</strong>  Keep everything else identical between experiments. Some changes can interact with each other in unexpected ways, so we first want to assess the individual contribution of each change, then try combining them to see their overall impact.</p>
<p><strong>Train on enough tokens and use sufficient evaluations.</strong>  As we mentioned earlier, we need to make sure we have good coverage in our evaluation suite and train long enough to get reliable signal. Cutting corners here will lead to noisy results and bad decisions.</p>
<p>Following these rules might feel overly cautious, but the alternative is spending days debugging mysterious performance drops that turn out to be caused by an unrelated dependency update from days earlier. The golden principle: once you have a good setup,  <em>no change should go untested!</em></p>
<h2 id="designing-the-model-architecture"><a href="#designing-the-model-architecture">Designing the model architecture</a></h2>
<p>Now that we have our experimental framework in place, it’s time to make the big decisions that will define our model. Every choice we make, from model size to attention mechanisms to tokenizer choice, creates constraints and opportunities that will affect model training and usage.</p>
<p>Remember the <a href="#training-compass-why--what--how">training compass</a>: before making any technical choices, we need clarity on the  <em>why</em>  and  <em>what</em> . Why are we training this model, and what should it look like?</p>
<p>It sounds obvious, but as we explained in the Training Compass, being deliberate here shapes our decisions and keeps us from getting lost in the endless space of possible experiments. Are we aiming for a SOTA model in English? Is long context a priority? Or a we trying to validate a new architecture?  The training loop may look similar in all these cases, but the experiments we run and the trade-offs we accept will be different. Answering this question early helps us decide how to balance our time between data and architecture work, and how much to innovate in each before starting the run.</p>
<p>So, let’s lead by example and walk through the goals that guided SmolLM3’s design. We wanted a strong model for on-device applications with competitive multilingual performance, solid math and coding capabilities, and robust long context handling. As we mentioned earlier, this led us to a dense model with 3B parameters: large enough for strong capabilities but small enough to fit comfortably on phones. We went with a dense transformer rather than MoE or Hybrid given the memory constraints of edge devices and our project timeline (roughly 3 months).</p>
<p>We had a working recipe from SmolLM2 for English at a smaller scale (1.7B parameters), but scaling up meant re-validating everything and tackling new challenges like multilinguality and extended context length. One clear example of how having defined goals shaped our approach. For example, in SmolLM2, we struggled to extend the context length at the end of pretraining, so for SmolLM3 we made architectural choices from the start — like using NoPE and intra-document masking (see later) — to maximise our chances of getting it right, and it worked.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>SmolLM2 was our previous generation of small language models, with three variants at 135M, 360M, and 1.7B parameters designed for on-device deployment. They were English only with 8k context length.</p> </aside> </div>  
<p>Once our goals are clear, we can start making the technical decisions that will bring them to life. In this chapter, we’ll go through our systematic approach to these core decisions:  architecture, data, and hyperparameters. Think of this as our strategic planning phase, getting these fundamentals right will save us from costly mistakes during the actual training marathon.</p>
<h3 id="architecture-choices"><a href="#architecture-choices">Architecture choices</a></h3>
<p>If you look at recent models like Qwen3, Gemma3, or DeepSeek v3, you’ll see that despite their differences, they all share the same foundation — the transformer architecture introduced in 2017 <span class="" id="citation--transformer--21">(<a href="https://arxiv.org/abs/1706.03762" id="refctx-bib-transformer-1" data-ref-id="bib-transformer" target="_blank" rel="noopener noreferrer">Vaswani et al., 2023</a>)</span>. What’s changed over the years isn’t the fundamental structure, but the refinements to its core components. Whether you’re building a dense model, a Mixture of Experts, or a hybrid architecture, you’re working with these same building blocks.</p>
<p>These refinements emerged from teams pushing for better performance and tackling specific challenges: memory constraints during inference, training instability at scale, or the need to handle longer contexts. Some modifications, like shifting from Multi-Head Attention (MHA) to more compute efficient attention variants like Grouped Query Attention (GQA) <span class="" id="citation--gqa--22">(<a href="https://arxiv.org/abs/2305.13245" id="refctx-bib-gqa-1" data-ref-id="bib-gqa" target="_blank" rel="noopener noreferrer">Ainslie et al., 2023</a>)</span>, are now widely adopted. Others, like different positional encoding schemes, are still being debated. Eventually, today’s experiments will crystalize into tomorrow’s baselines.</p>
<p>So what do modern LLMs actually use today? Let’s look at what leading models have converged on. Unfortunately, not all models disclose their training details, but we have enough transparency from families like DeepSeek, OLMo, Kimi, and SmolLM to see the current landscape:</p>
<div class="wide"> <div class="reference-wrapper" id="llms-landscape-pretrain" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> 




















































































































































<div class="table-scroll"><table><thead><tr><th>Model</th><th>Architecture</th><th>Parameters</th><th>Training Tokens</th><th>Attention</th><th>Context Length (final)</th><th>Position Encoding</th><th>Precision</th><th>Init (std)</th><th>Optimizer</th><th>Max LR</th><th>LR Schedule</th><th>Warmup Steps</th><th>Batch Size</th></tr></thead><tbody><tr><td>DeepSeek LLM 7B</td><td>Dense</td><td>7B</td><td>2T</td><td>GQA</td><td>4K</td><td>RoPE</td><td>BF16</td><td>0.006</td><td>AdamW</td><td>4.2×10⁻⁴</td><td>Multi-Step</td><td>2K</td><td>9.4M</td></tr><tr><td>DeepSeek LLM 67B</td><td>Dense</td><td>67B</td><td>2T</td><td>GQA</td><td>4K</td><td>RoPE</td><td>BF16</td><td>0.006</td><td>AdamW</td><td>3.2×10⁻⁴</td><td>Multi-Step</td><td>2K</td><td>18.9M</td></tr><tr><td>DeepSeek V2</td><td>MoE</td><td>236B (21B active)</td><td>8.1T</td><td>MLA</td><td>128K</td><td>Partial RoPE</td><td>-</td><td>0.006</td><td>AdamW</td><td>2.4×10⁻⁴</td><td>Multi-Step</td><td>2K</td><td>9.4M→37.7M (warmup 225B)</td></tr><tr><td>DeepSeek V3</td><td>MoE</td><td>671B (37B active)</td><td>14.8T</td><td>MLA</td><td>129K</td><td>Partial RoPE</td><td>FP8</td><td>0.006</td><td>AdamW</td><td>2.2×10⁻⁴</td><td>Multi-Step + Cosine</td><td>2K</td><td>12.6M→62.9M (warmup 469B)</td></tr><tr><td>MiniMax-01</td><td>MoE + Hybrid</td><td>456B (45.9 active)</td><td>11.4T</td><td>Linear attention + GQA</td><td>4M</td><td>Partial RoPE</td><td>-</td><td>Xavier init with deepnorm scaling</td><td>AdamW</td><td>2×10⁻⁴</td><td>Multi-Step</td><td>500</td><td>16M→32M→64M→128M</td></tr><tr><td>Kimi K2</td><td>MoE</td><td>1T (32B active)</td><td>15.5T</td><td>MLA</td><td>128K</td><td>Partial RoPE</td><td>BF16</td><td>likely 0.006</td><td>MuonClip</td><td>2×10⁻⁴</td><td>WSD</td><td>500</td><td>67M</td></tr><tr><td>OLMo 2 7B</td><td>Dense</td><td>7B</td><td>5T</td><td>MHA</td><td>4K</td><td>RoPE</td><td>BF16</td><td>0.02</td><td>AdamW</td><td>3×10⁻⁴</td><td>Cosine</td><td>2K</td><td>4.2M</td></tr><tr><td>SmolLM3</td><td>Dense</td><td>3B</td><td>11T</td><td>GQA</td><td>128K</td><td>NoPE</td><td>BF16</td><td>0.02</td><td>AdamW</td><td>2×10⁻⁴</td><td>WSD</td><td>2K</td><td>2.3M</td></tr></tbody></table></div> </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce></figcaption> </figure> </div>  </div>
<p>If you don’t understand some of these terms yet, such as MLA or NoPE or WSD, don’t worry. We’ll explain each one in this section. For now, just notice the variety: different attention mechanisms (MHA, GQA, MLA), position encodings (RoPE, NoPE, partial RoPE), and learning rate schedules (Cosine, Multi-Step, WSD).</p>
<p>Looking at this long list of architecture choices it’s a bit overwhelming to figure out where to even start. As in most such situations, we’ll take it step by step and gradually build up all the necessary know-how. We’ll focus on the simplest base architecture first (a dense model) and investigate each architectural aspect in detail. Later, we’ll dive deep into MoE and Hybrid models and discuss when using them is a good choice. Finally we explore the tokenizer, an often overlooked and underrated component. Should we use an existing one or train our own? How do we even evaluate if our tokenizer is good?</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>Ablation setup</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Throughout the rest of this chapter, we validate most of the architectural choices through ablations using the setup described in the chapter above: our 1B baseline model (following the Llama3.2 1B architecture) trained on 45B tokens from a mix of FineWeb-Edu, FineMath, and Python-Edu. For each experiment, we show both training loss curves and downstream evaluation scores to assess the impact of each modification. You can find the configs for all the runs in <a href="https://huggingface.co/datasets/HuggingFaceTB/training-guide-nanotron-configs/tree/main">HuggingFaceTB/training-guide-nanotron-configs</a>.</p> </div> </div> </div> 
<div class="sidenote-container"> <aside class="sidenote"> <p>This <a href="https://sebastianraschka.com/blog/2025/the-big-llm-architecture-comparison.html">blog post</a> by Sebastian Raschka gives a good overview of modern LLM architectures in 2025.</p> </aside> </div>  
<p>But now let’s start with the core of every LLM: the attention mechanism.</p>
<h4 id="attention"><a href="#attention"><strong>Attention</strong></a></h4>
<p>One of the most active areas of research around transformer architectures is the attention mechanism. While feedforward layers dominate compute during pretraining, attention becomes the main bottleneck at inference (especially with long contexts), where it drives up compute cost and the KV cache quickly consumes GPU memory, reducing throughput. Let’s take a quick tour around the main attention mechanisms and how they trade-off capacity and speed.</p>
<p><strong>How many heads for my attention?</strong></p>
<p><em>Multi-head attention (MHA)</em> is the standard attention introduced with the original transformer <span class="" id="citation--transformer--23">(<a href="https://arxiv.org/abs/1706.03762" id="refctx-bib-transformer-2" data-ref-id="bib-transformer" target="_blank" rel="noopener noreferrer">Vaswani et al., 2023</a>)</span>. The main idea is that you have N attention heads each independently doing the same retrieval task: transform the hidden state into queries, keys, and values, then use the current query to retrieve the most relevant token by match on the keys and finally forward the value associated with the matched tokens. At inference time we don’t need to recompute the KV values for past tokens and can reuse them. The memory for past KV values is called the  <em>KV-Cache</em> .  As context windows grow, this cache can quickly become an inference bottleneck and consume a large share of GPU memory. Here’s a simple calculation to estimate the KV-Cache memory <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>K</mi><mi>V</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{KV}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em">K</span><span class="mord mathnormal mtight" style="margin-right:0.22222em">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> for the Llama 3 architecture with MHA and a sequence length of 8192:</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Checkout <a href="https://jalammar.github.io/illustrated-transformer/">Jay Alamar’s famous blog</a> post for a quick refresher!</p> </aside> </div>  
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>s</mi><mrow><mi>K</mi><mi>V</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><mo>×</mo><msub><mi>n</mi><mrow><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></mrow></msub><mo>×</mo><mi>s</mi><mi>e</mi><mi>q</mi><mo>×</mo><msub><mi>n</mi><mrow><mi>l</mi><mi>a</mi><mi>y</mi><mi>e</mi><mi>r</mi><mi>s</mi></mrow></msub><mo>×</mo><msub><mi>n</mi><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>s</mi></mrow></msub><mo>×</mo><mi>d</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>s</mi></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>8192</mn><mo>×</mo><mn>32</mn><mo>×</mo><mn>32</mn><mo>×</mo><mn>128</mn><mo>=</mo><mn>4</mn><mtext> GB</mtext><mrow><mtext> </mtext><mtext mathvariant="italic">(Llama</mtext><mtext> </mtext><mtext mathvariant="italic">3</mtext><mtext> </mtext><mtext mathvariant="italic">8B)</mtext></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>8192</mn><mo>×</mo><mn>80</mn><mo>×</mo><mn>64</mn><mo>×</mo><mn>128</mn><mo>=</mo><mn>20</mn><mtext> GB</mtext><mrow><mtext> </mtext><mtext mathvariant="italic">(Llama</mtext><mtext> </mtext><mtext mathvariant="italic">3</mtext><mtext> </mtext><mtext mathvariant="italic">70B)</mtext></mrow></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd><mtd class="mtr-glue"></mtd><mtd class="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation} 
\begin{aligned} 
s_{KV} &amp;= 2 \times n_{bytes} \times seq \times n_{layers} \times n_{heads} \times dim_{heads} \\
&amp;= 2 \times 2 \times8192 \times 32 \times 32 \times 128  =4 \text{ GB} \textit{ (Llama 3 8B)} \\
&amp;= 2 \times 2 \times8192 \times 80 \times 64 \times 128  =20 \text{ GB} \textit{ (Llama 3 70B)}
\end{aligned} 
\end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.5em;vertical-align:-2em"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em"><span style="top:-4.5em"><span class="pstrut" style="height:4.5em"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em"><span style="top:-4.66em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em">K</span><span class="mord mathnormal mtight" style="margin-right:0.22222em">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span><span style="top:-3.16em"><span class="pstrut" style="height:3em"></span><span class="mord"></span></span><span style="top:-1.66em"><span class="pstrut" style="height:3em"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em"><span style="top:-4.66em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">es</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">yers</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span><span style="top:-3.16em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">8192</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">32</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">32</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord">4</span><span class="mord text"><span class="mord"> GB</span></span><span class="mord text"><span class="mord textit"> (Llama 3 8B)</span></span></span></span><span style="top:-1.66em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">8192</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">80</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">64</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">128</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord">20</span><span class="mord text"><span class="mord"> GB</span></span><span class="mord text"><span class="mord textit"> (Llama 3 70B)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em"><span style="top:-4.5em"><span class="pstrut" style="height:4.5em"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em"><span></span></span></span></span></span></span></span></span>
<p>Note that the leading factor of 2 comes from storing both key and value caches. As you can see, the cache increases linearly with sequence length, but context windows have grown exponentially, now reaching millions of tokens. So improving the efficiency of the cache would make scaling context at inference time much easier.</p>
<p>The natural question to ask is: do we really need new KV values for each head? Probably not and both Multi-Query Attention (MQA) <span class="" id="citation--mqa--24">(<a href="https://arxiv.org/abs/1911.02150" id="refctx-bib-mqa-1" data-ref-id="bib-mqa" target="_blank" rel="noopener noreferrer">Shazeer, 2019</a>)</span> and Grouped Query Attention (GQA) <span class="" id="citation--gqa--25">(<a href="https://arxiv.org/abs/2305.13245" id="refctx-bib-gqa-2" data-ref-id="bib-gqa" target="_blank" rel="noopener noreferrer">Ainslie et al., 2023</a>)</span> address this. The simplest case is to share the KV values across all heads, thus dividing the size of the KV cache by  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">n_{heads}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> , which is e.g. a 64 decrease for Llama 3 70B! This is the idea of MQA and was used in some models like StarCoder as an alternative to MHA. However, we might give away a bit more attention capacity than we are willing to, so we could consider the middle ground and share the KV values across groups of heads e.g. 4 heads sharing the same KV values. This is the GQA approach and strikes a middle ground between MQA and MHA.</p>
<p>More recently, DeepSeek-v2 (and also used in v3) introduced  <em>Multi-Latent Attention (MLA) [@deepseekv2]</em> , which uses a different strategy to compress the cache: rather than reducing the number KV-values it reduces their size and simply stores a latent variable which can be decompressed into KV values at runtime. With this approach they managed to reduce the cache to an equivalent of GQA with 2.25 groups while giving stronger performance than MHA! In order to make this work with RoPE, a small tweak with an extra small latent vector is needed. In DeepSeek-v2 they chose  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><mi>d</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">4*dim_{head}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  for the main latent variable and  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>∗</mo><mi>d</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">1/2*dim_{head}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1/2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  for the RoPE part so a total fo  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4.5</mn><mo>∗</mo><mi>d</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">4.5*dim_{head}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">4.5</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  which is used for both K and V simultaneously thus dropping the leading factor of 2.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>RoPE (Rotary Position Embeddings) is a method for encoding positional information by rotating query and key vectors based on their positions in the sequence. It’s commonly used in today’s LLMs.</p> </aside> </div>  
<p>You can see a visual explanation of each attention mechanism in the following graphic:</p>
<div class="wide"> <div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <figure class="html-embed"><div class="html-embed__card"><div id="frag-5g0ht3hwztb"><div class="kv-cache-diagrams"></div>

<style>
    .kv-cache-diagrams {
        font-family: 'Arial', sans-serif;
        padding: 0;
    }

    .kv-cache-diagrams .diagrams-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
    }

    .kv-cache-diagrams .diagram-container {
        padding: 15px;
        background: var(--page-bg, #fff);
        border-radius: 12px;
        border: 1px solid var(--border-color, #e0e0e0);
        display: flex;
        flex-direction: column;
    }

    .kv-cache-diagrams .diagram-title {
        font-size: 12px;
        font-weight: 700;
        text-align: center;
        margin-bottom: 10px;
        color: var(--text-color, #333);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .kv-cache-diagrams .diagram-svg-container {
        width: 100%;
        height: auto;
        min-height: 250px;
    }

    .kv-cache-diagrams .diagram-svg-container svg {
        width: 100%;
        height: 100%;
    }

    .kv-cache-diagrams .placeholder-content {
        min-height: 250px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #999;
        font-size: 14px;
    }

    /* Mobile breakpoint - single column */
    @media (max-width: 900px) {
        .kv-cache-diagrams .diagrams-grid {
            grid-template-columns: 1fr;
        }
    }

    /* Legend styles */
    .kv-cache-diagrams .legend {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        margin-bottom: 20px;
    }

    .kv-cache-diagrams .legend-title {
        font-size: 12px;
        font-weight: 700;
        color: var(--text-color);
    }

    .kv-cache-diagrams .legend .items {
        display: flex;
        flex-wrap: wrap;
        gap: 8px 14px;
        justify-content: center;
    }

    .kv-cache-diagrams .legend .item {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
        font-size: 12px;
        color: var(--text-color);
    }

    .kv-cache-diagrams .legend .swatch {
        width: 18px;
        height: 18px;
        border-radius: 4px;
        border-width: 1px;
        border-style: solid;
        position: relative;
    }

    .kv-cache-diagrams .legend .swatch.hatched {
        position: relative;
    }

    .kv-cache-diagrams .legend .swatch.hatched::after {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 4px;
        background-image: repeating-linear-gradient(135deg,
                transparent,
                transparent 3px,
                currentColor 3px,
                currentColor 4px);
        opacity: 0.5;
    }
</style>

<!-- Import SVG.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.5/svg.min.js"></script>

<script>
    (() => {
        const bootstrap = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;
            if (!(container && container.classList && container.classList.contains('kv-cache-diagrams'))) {
                const candidates = Array.from(document.querySelectorAll('.kv-cache-diagrams'))
                    .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
                container = candidates[candidates.length - 1] || null;
            }
            if (!container) return;
            if (container.dataset) {
                if (container.dataset.mounted === 'true') return;
                container.dataset.mounted = 'true';
            }

            // Apply categorical color palette
            const applyColorPalette = () => {
                try {
                    if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
                        const colors = window.ColorPalettes.getColors('categorical', 3);
                        return {
                            query: colors[0],
                            key: colors[1],
                            value: colors[2]
                        };
                    } else {
                        // Fallback colors
                        return {
                            query: '#E889AB',
                            key: '#4EA5B7',
                            value: '#E38A42'
                        };
                    }
                } catch (e) {
                    console.warn('ColorPalettes not available, using fallback colors');
                    return {
                        query: '#E889AB',
                        key: '#4EA5B7',
                        value: '#E38A42'
                    };
                }
            };

            const paletteColors = applyColorPalette();
            if (window.ColorPalettes && typeof window.ColorPalettes.refresh === 'function') {
                window.ColorPalettes.refresh();
            }

            // Configuration
            const CONFIG = {
                colors: {
                    query: paletteColors.query,
                    key: paletteColors.key,
                    value: paletteColors.value,
                    arrow: 'var(--text-color, #666)',
                    clkv: '#adb5bd',  // Gray color for Compressed Latent KV (same as groups)
                    clkvFill: '#e9ecef'
                },
                node: {
                    width: 18,  // Narrow vertical rectangle
                    height: 42,  // Shorter vertical rectangle
                    rx: 2,
                    fontSize: 13,
                    strokeWidth: 1
                },
                arrow: {
                    length: 15,
                    width: 1,
                    headSize: 4,
                    gap: 3  // Gap between node edge and arrow
                }
            };

            // Helper: Create a rounded rect node with text
            function createNode(svg, x, y, text, type, noCachedPattern = false) {
                const config = CONFIG.node;
                const colors = CONFIG.colors;

                let fill, stroke, useCachedPattern;

                switch (type) {
                    case 'query':
                        fill = { color: colors.query, opacity: 0.6 };
                        stroke = colors.query;
                        useCachedPattern = false;
                        break;
                    case 'key':
                        fill = { color: colors.key, opacity: 0.4 };  // Lighter base for pattern visibility
                        stroke = colors.key;
                        useCachedPattern = !noCachedPattern;
                        break;
                    case 'value':
                        fill = { color: colors.value, opacity: 0.4 };  // Lighter base for pattern visibility
                        stroke = colors.value;
                        useCachedPattern = !noCachedPattern;
                        break;
                }

                const group = svg.group();

                // Create rectangle
                const rect = group.rect(config.width, config.height)
                    .move(x - config.width / 2, y - config.height / 2)
                    .radius(config.rx)
                    .fill(fill)
                    .stroke({ color: stroke, width: config.strokeWidth });

                // Add hatch pattern overlay for cached nodes (K and V)
                if (useCachedPattern) {
                    const patternId = `hatch-${type}-${Math.random().toString(36).substr(2, 9)}`;
                    createHatchPattern(svg, stroke, patternId);

                    group.rect(config.width, config.height)
                        .move(x - config.width / 2, y - config.height / 2)
                        .radius(config.rx)
                        .fill(`url(#${patternId})`)
                        .stroke('none');
                }

                // Add small letter indicator with border color
                let letter = '';
                if (type === 'query') letter = 'Q';
                else if (type === 'key') letter = 'K';
                else if (type === 'value') letter = 'V';

                if (letter) {
                    const textEl = group.text(letter)
                        .font({
                            family: 'Arial, sans-serif',
                            size: 10,
                            anchor: 'middle',
                            weight: '600',
                            fill: stroke
                        })
                        .cx(x)
                        .cy(y)
                        .opacity(0.6);  // Not too contrasted
                }

                return { group, rect, x, y };
            }

            // Helper: Create diagonal hatch pattern for cached nodes
            function createHatchPattern(svg, color, id) {
                const pattern = svg.pattern(10, 10, function (add) {
                    // Create diagonal lines from bottom-left to top-right
                    add.line(0, 10, 10, 0).stroke({ color: color, width: 2, opacity: 0.5 });
                });
                pattern.attr('id', id);
                pattern.attr('patternUnits', 'userSpaceOnUse');
                return pattern;
            }


            // Helper: Create arrow without arrowhead (just a line)
            function createArrow(svg, x1, y1, x2, y2) {
                const config = CONFIG.arrow;
                const arrowGroup = svg.group();

                // Create line without marker (no arrowhead)
                arrowGroup.line(x1, y1, x2, y2)
                    .stroke({ color: CONFIG.colors.arrow, width: config.width })
                    .opacity(0.5);

                return arrowGroup;
            }

            // ========================================================================
            // DIAGRAM 1: Individual Q-K-V Pairs (8 columns)
            // ========================================================================
            function drawDiagram1(containerEl) {
                const svg = SVG().addTo(containerEl).size('100%', '100%');

                const nodeConfig = CONFIG.node;
                const columns = 8;
                const columnSpacing = 40;
                const rowSpacing = 68;
                const padding = 5;
                const startX = 30 + padding;
                const startY = 20 + padding;

                const viewboxWidth = startX * 2 + columnSpacing * (columns - 1) + padding;
                const viewboxHeight = startY * 2 + rowSpacing * 2 + padding;

                svg.viewbox(0, 0, viewboxWidth, viewboxHeight);

                for (let i = 0; i < columns; i++) {
                    const x = startX + i * columnSpacing;
                    const yValue = startY;
                    const yKey = startY + rowSpacing;
                    const yQuery = startY + rowSpacing * 2;

                    // Create nodes (no text labels)
                    const v = createNode(svg, x, yValue, '', 'value');
                    const k = createNode(svg, x, yKey, '', 'key');
                    const q = createNode(svg, x, yQuery, '', 'query');

                    // Create arrows (V -> K -> Q, top to bottom)
                    // Arrow from V to K
                    const arrowGap = CONFIG.arrow.gap;
                    createArrow(svg,
                        x,
                        yValue + nodeConfig.height / 2 + arrowGap,
                        x,
                        yKey - nodeConfig.height / 2 - arrowGap
                    );
                    // Arrow from K to Q
                    createArrow(svg,
                        x,
                        yKey + nodeConfig.height / 2 + arrowGap,
                        x,
                        yQuery - nodeConfig.height / 2 - arrowGap
                    );
                }
            }

            // ========================================================================
            // DIAGRAM 2: Multi-Query Attention (8 Q -> 1 K -> 1 V)
            // ========================================================================
            function drawDiagram2(containerEl) {
                const svg = SVG().addTo(containerEl).size('100%', '100%');

                const nodeConfig = CONFIG.node;
                const queries = 8;
                const querySpacing = 40;
                const padding = 5;
                const centerX = 170 + padding;
                const viewboxWidth = 340 + padding * 2;
                const rowSpacing = 68;
                const startY = 20 + padding;
                const viewboxHeight = startY * 2 + rowSpacing * 2 + padding;

                svg.viewbox(0, 0, viewboxWidth, viewboxHeight);

                // Calculate starting X for queries to center them
                const queriesWidth = (queries - 1) * querySpacing;
                const startX = centerX - queriesWidth / 2;
                const yValue = startY;
                const yKey = startY + rowSpacing;
                const yQuery = startY + rowSpacing * 2;

                // Create K and V nodes (centered)
                const k = createNode(svg, centerX, yKey, '', 'key');
                const v = createNode(svg, centerX, yValue, '', 'value');

                // Arrow from K to V
                const arrowGap = CONFIG.arrow.gap;
                createArrow(svg,
                    centerX,
                    yKey - nodeConfig.height / 2 - arrowGap,
                    centerX,
                    yValue + nodeConfig.height / 2 + arrowGap
                );

                // Create query nodes and arrows converging to K
                const arrowSpacing = 2;  // Gap between arrow arrival points
                const totalArrowWidth = (queries - 1) * arrowSpacing;
                const arrowStartX = centerX - totalArrowWidth / 2;

                for (let i = 0; i < queries; i++) {
                    const x = startX + i * querySpacing;
                    const q = createNode(svg, x, yQuery, '', 'query');

                    // Calculate arrow start and end points with gap
                    const startY = yQuery - nodeConfig.height / 2 - arrowGap;
                    const endY = yKey + nodeConfig.height / 2 + arrowGap;
                    const endX = arrowStartX + i * arrowSpacing;  // Spread arrival points

                    // Arrow from Q to K (converging) - no arrowhead
                    svg.line(x, startY, endX, endY)
                        .stroke({ color: CONFIG.colors.arrow, width: CONFIG.arrow.width })
                        .opacity(0.4);
                }
            }

            // ========================================================================
            // DIAGRAM 3: Grouped-Query Attention (8 Q -> 4 K -> 4 V)
            // ========================================================================
            function drawDiagram3(containerEl) {
                const svg = SVG().addTo(containerEl).size('100%', '100%');

                const nodeConfig = CONFIG.node;
                const queries = 8;
                const groups = 4;  // 4 groups of K-V pairs
                const querySpacing = 40;
                const groupSpacing = 80;
                const padding = 5;
                const centerX = 170 + padding;
                const viewboxWidth = 340 + padding * 2;
                const rowSpacing = 68;
                const startY = 20 + padding;
                const viewboxHeight = startY * 2 + rowSpacing * 2 + padding;

                svg.viewbox(0, 0, viewboxWidth, viewboxHeight);

                // Calculate starting X for queries to center them
                const queriesWidth = (queries - 1) * querySpacing;
                const startXQuery = centerX - queriesWidth / 2;
                const yValue = startY;
                const yKey = startY + rowSpacing;
                const yQuery = startY + rowSpacing * 2;

                // Calculate starting X for K-V groups
                const groupsWidth = (groups - 1) * groupSpacing;
                const startXGroup = centerX - groupsWidth / 2;

                const arrowGap = CONFIG.arrow.gap;

                // Create K and V nodes for each group
                const kvPairs = [];
                for (let g = 0; g < groups; g++) {
                    const xGroup = startXGroup + g * groupSpacing;
                    const k = createNode(svg, xGroup, yKey, '', 'key');
                    const v = createNode(svg, xGroup, yValue, '', 'value');
                    kvPairs.push({ k, v, x: xGroup });

                    // Arrow from K to V
                    createArrow(svg,
                        xGroup,
                        yKey - nodeConfig.height / 2 - arrowGap,
                        xGroup,
                        yValue + nodeConfig.height / 2 + arrowGap
                    );
                }

                // Create query nodes and arrows (2 queries per K)
                const queriesPerK = 2;
                const arrowSpacing = 3;  // Gap between arrow arrival points

                for (let i = 0; i < queries; i++) {
                    const x = startXQuery + i * querySpacing;
                    const q = createNode(svg, x, yQuery, '', 'query');

                    // Determine which K group this Q belongs to (2 queries per K)
                    const groupIndex = Math.floor(i / 2);
                    const indexInGroup = i % queriesPerK;
                    const targetXBase = kvPairs[groupIndex].x;

                    // Spread arrival points horizontally, centered
                    const totalArrowWidth = (queriesPerK - 1) * arrowSpacing;
                    const targetX = targetXBase - totalArrowWidth / 2 + indexInGroup * arrowSpacing;

                    // Calculate arrow start and end points with gap
                    const startY = yQuery - nodeConfig.height / 2 - arrowGap;
                    const endY = yKey + nodeConfig.height / 2 + arrowGap;

                    // Arrow from Q to K (converging, 2 per K) - no arrowhead
                    svg.line(x, startY, targetX, endY)
                        .stroke({ color: CONFIG.colors.arrow, width: CONFIG.arrow.width })
                        .opacity(0.4);
                }
            }

            // ========================================================================
            // DIAGRAM 4: Latent Compressed KV with Projection
            // ========================================================================
            function drawDiagram4(containerEl) {
                const svg = SVG().addTo(containerEl).size('100%', '100%');

                const nodeConfig = CONFIG.node;
                const columns = 8;
                const columnSpacing = 28;  // Slightly increased spacing
                const rowSpacing = 68;  // Same as diagrams 1, 2, 3
                const padding = 5;
                const startX = 30 + padding;  // Starting X for first column
                const startY = 20 + padding;  // Same as diagrams 1, 2, 3

                // Match viewbox dimensions with other diagrams for consistent sizing
                const viewboxWidth = 340 + padding * 2;  // Same as diagrams 1, 2, 3
                const viewboxHeight = startY * 2 + rowSpacing * 2 + padding;

                svg.viewbox(0, 0, viewboxWidth, viewboxHeight);

                const arrowGap = CONFIG.arrow.gap;

                // Calculate positions for K and V rows (inverted: V top, K middle, Q bottom)
                const yValue = startY;
                const yKey = startY + rowSpacing;
                const yQuery = startY + rowSpacing * 2;

                // Draw background rectangles for K and V groups
                const groupPadding = 6;
                const groupX = startX - nodeConfig.width / 2 - groupPadding;
                const groupWidth = columnSpacing * (columns - 1) + nodeConfig.width + groupPadding * 2;
                const groupHeight = nodeConfig.height + groupPadding * 2;

                // V group background (now at top)
                svg.rect(groupWidth, groupHeight)
                    .move(groupX, yValue - nodeConfig.height / 2 - groupPadding)
                    .radius(4)
                    .fill('none')
                    .stroke({ color: '#adb5bd', width: 1 })
                    .opacity(0.8);

                // K group background (in middle)
                svg.rect(groupWidth, groupHeight)
                    .move(groupX, yKey - nodeConfig.height / 2 - groupPadding)
                    .radius(4)
                    .fill('none')
                    .stroke({ color: '#adb5bd', width: 1 })
                    .opacity(0.8);

                // Draw Q, K, V nodes
                for (let i = 0; i < columns; i++) {
                    const x = startX + i * columnSpacing;

                    // Create nodes (inverted order: V top, K middle, Q bottom)
                    // No hatch patterns for V and K in diagram 4
                    const v = createNode(svg, x, yValue, '', 'value', true);
                    const k = createNode(svg, x, yKey, '', 'key', true);
                    const q = createNode(svg, x, yQuery, '', 'query');

                    // Create arrows (V -> K -> Q, top to bottom)
                    createArrow(svg,
                        x,
                        yValue + nodeConfig.height / 2 + arrowGap,
                        x,
                        yKey - nodeConfig.height / 2 - arrowGap
                    );
                    createArrow(svg,
                        x,
                        yKey + nodeConfig.height / 2 + arrowGap,
                        x,
                        yQuery - nodeConfig.height / 2 - arrowGap
                    );
                }

                // Create Compressed Latent KV node on the right side
                const lastColumnX = startX + (columns - 1) * columnSpacing;
                const clkvX = lastColumnX + nodeConfig.width / 2 + 75;  // Right side with gap
                const clkvY = (yKey + yValue) / 2;  // Between K and V groups
                const clkvWidth = nodeConfig.width;  // Same width as other nodes
                const clkvHeight = nodeConfig.height;  // Same height as other nodes

                // Draw CLKV node with cached styling (hatch pattern like K/V nodes)
                const clkvGroup = svg.group();
                clkvGroup.rect(clkvWidth, clkvHeight)
                    .move(clkvX - clkvWidth / 2, clkvY - clkvHeight / 2)
                    .radius(nodeConfig.rx)
                    .fill({ color: CONFIG.colors.clkvFill, opacity: 0.15 })
                    .stroke({ color: CONFIG.colors.clkv, width: CONFIG.node.strokeWidth });

                // Add hatch pattern overlay for CLKV (like cached K/V nodes)
                const clkvPatternId = `hatch-clkv-${Math.random().toString(36).substr(2, 9)}`;
                createHatchPattern(svg, CONFIG.colors.clkv, clkvPatternId);

                clkvGroup.rect(clkvWidth, clkvHeight)
                    .move(clkvX - clkvWidth / 2, clkvY - clkvHeight / 2)
                    .radius(nodeConfig.rx)
                    .fill(`url(#${clkvPatternId})`)
                    .stroke('none');

                // CLKV text below the node (multi-line)
                svg.text('Compressed\nLatent KV')
                    .font({
                        family: 'Arial, sans-serif',
                        size: 9,
                        anchor: 'middle',
                        weight: '700',
                        fill: 'var(--text-color, #666)',
                        leading: '1.2em'
                    })
                    .cx(clkvX)
                    .cy(clkvY + clkvHeight / 2 + 28);

                // Draw projection arrows from CLKV to K group and V group (solid lines, no arrowheads)
                // Projection to V group (from top-right of V group to top-left corner of CLKV)
                const vGroupTopY = yValue - nodeConfig.height / 2 - groupPadding;
                const vGroupRightX = groupX + groupWidth;
                const clkvTopLeftX = clkvX - clkvWidth / 2;
                const clkvTopLeftY = clkvY - clkvHeight / 2;
                svg.line(vGroupRightX, vGroupTopY, clkvTopLeftX, clkvTopLeftY)
                    .stroke({ color: CONFIG.colors.clkv, width: 1 })
                    .opacity(0.7);

                // Projection to K group (from bottom-right of K group to bottom-left corner of CLKV)
                const kGroupBottomY = yKey + nodeConfig.height / 2 + groupPadding;
                const kGroupRightX = groupX + groupWidth;
                const clkvBottomLeftX = clkvX - clkvWidth / 2;
                const clkvBottomLeftY = clkvY + clkvHeight / 2;
                svg.line(kGroupRightX, kGroupBottomY, clkvBottomLeftX, clkvBottomLeftY)
                    .stroke({ color: CONFIG.colors.clkv, width: 1 })
                    .opacity(0.7);

                // Add single "projection" label centered between both lines
                const centerTextX = (clkvX + vGroupRightX) / 2 - 5;  // Shifted slightly to the right
                const centerTextY = (vGroupTopY + kGroupBottomY) / 2;
                svg.text('projection')
                    .font({
                        family: 'Arial, sans-serif',
                        size: 9,
                        anchor: 'middle',
                        fill: CONFIG.colors.clkv,
                        weight: '600'
                    })
                    .cx(centerTextX)
                    .cy(centerTextY - 4);

                // Add small arrow pointing left below the text
                const arrowY = centerTextY + 6;
                const arrowStartX = centerTextX + 15;
                const arrowEndX = centerTextX - 15;
                const arrowSize = 3;

                // Arrow line
                svg.line(arrowStartX, arrowY, arrowEndX, arrowY)
                    .stroke({ color: CONFIG.colors.clkv, width: 1 });

                // Arrow head (triangle pointing left)
                svg.polygon(`${arrowEndX},${arrowY} ${arrowEndX + arrowSize},${arrowY - arrowSize} ${arrowEndX + arrowSize},${arrowY + arrowSize}`)
                    .fill(CONFIG.colors.clkv);
            }

            // Build HTML structure
            container.innerHTML = `
                <!-- Legend -->
                <div class="legend">
                    <div class="legend-title">Legend</div>
                    <div class="items">
                        <span class="item">
                            <span class="swatch" style="background-color: color-mix(in srgb, ${paletteColors.value} 40%, transparent); border-color: ${paletteColors.value};"></span>
                            <span>Values</span>
                        </span>
                        <span class="item">
                            <span class="swatch" style="background-color: color-mix(in srgb, ${paletteColors.key} 40%, transparent); border-color: ${paletteColors.key};"></span>
                            <span>Keys</span>
                        </span>
                        <span class="item">
                            <span class="swatch" style="background-color: color-mix(in srgb, ${paletteColors.query} 60%, transparent); border-color: ${paletteColors.query};"></span>
                            <span>Queries</span>
                        </span>
                        <span class="item">
                            <span class="swatch hatched" style="background-color: transparent; border-color: #adb5bd; color: #adb5bd;"></span>
                            <span>Cached during inference</span>
                        </span>
                    </div>
                </div>
                
                <div class="diagrams-grid">
                    <!-- DIAGRAM 1: Multi Head Attention -->
                    <div class="diagram-container">
                        <div class="diagram-title">Multi head attention</div>
                        <div class="diagram-svg-container" id="diagram-1"></div>
                    </div>
                    
                    <!-- DIAGRAM 2: Multi Query Attention -->
                    <div class="diagram-container">
                        <div class="diagram-title">Multi query attention</div>
                        <div class="diagram-svg-container" id="diagram-2"></div>
                    </div>
                    
                    <!-- DIAGRAM 3: Grouped Query Attention -->
                    <div class="diagram-container">
                        <div class="diagram-title">Grouped query attention</div>
                        <div class="diagram-svg-container" id="diagram-3"></div>
                    </div>
                    
                    <!-- DIAGRAM 4: Multi Head Latent Attention -->
                    <div class="diagram-container">
                        <div class="diagram-title">Multi head latent attention</div>
                        <div class="diagram-svg-container" id="diagram-4"></div>
                    </div>
                </div>
            `;

            // Wait for SVG.js to be ready, then draw diagrams
            setTimeout(() => {
                const diagram1Container = document.getElementById('diagram-1');
                const diagram2Container = document.getElementById('diagram-2');
                const diagram3Container = document.getElementById('diagram-3');
                const diagram4Container = document.getElementById('diagram-4');

                if (diagram1Container && diagram2Container && diagram3Container && diagram4Container && typeof SVG !== 'undefined') {
                    drawDiagram1(diagram1Container);
                    drawDiagram2(diagram2Container);
                    drawDiagram3(diagram3Container);
                    drawDiagram4(diagram4Container);
                }
            }, 50);
        };

        // Wait for both DOM and SVG.js to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
            bootstrap();
        }
    })();
</script></div></div></figure> </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Simplified illustration of Multi-Head Attention (MHA), Grouped-Query Attention (GQA), Multi-Query Attention (MQA), and Multi-head Latent Attention (MLA). Through jointly compressing the keys and values into a latent vector, MLA significantly reduces the KV cache during inference.</figcaption> </figure> </div>  </div>
<p>The following table compares the attention mechanisms we just discussed in this section. For simplicity we compare the parameters used per token, if you want to compute total memory simply multiply by bytes per parameter (typically 2) and sequence length:</p>

























<div class="table-scroll"><table><thead><tr><th>Attention Mechanism</th><th>KV-Cache parameters per token</th></tr></thead><tbody><tr><td>MHA</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>2</mn><mo>×</mo><msub><mi>n</mi><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>s</mi></mrow></msub><mo>×</mo><msub><mi>n</mi><mrow><mi>l</mi><mi>a</mi><mi>y</mi><mi>e</mi><mi>r</mi><mi>s</mi></mrow></msub><mo>×</mo><mi>d</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">= 2 \times n_{heads} \times n_{layers} \times dim_{head}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">yers</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>MQA</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>2</mn><mo>×</mo><mn>1</mn><mo>×</mo><msub><mi>n</mi><mrow><mi>l</mi><mi>a</mi><mi>y</mi><mi>e</mi><mi>r</mi><mi>s</mi></mrow></msub><mo>×</mo><mi>d</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">= 2 \times 1 \times n_{layers} \times dim_{head}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">yers</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>GQA</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>2</mn><mo>×</mo><mi>g</mi><mo>×</mo><msub><mi>n</mi><mrow><mi>l</mi><mi>a</mi><mi>y</mi><mi>e</mi><mi>r</mi><mi>s</mi></mrow></msub><mo>×</mo><mi>d</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub><mtext> (typically g=2,4,8 )</mtext></mrow><annotation encoding="application/x-tex">= 2 \times g \times n_{layers} \times dim_{head} \text { (typically g=2,4,8 )}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">yers</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> (typically g=2,4,8 )</span></span></span></span></span></td></tr><tr><td>MLA</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>4.5</mn><mo>×</mo><msub><mi>n</mi><mrow><mi>l</mi><mi>a</mi><mi>y</mi><mi>e</mi><mi>r</mi><mi>s</mi></mrow></msub><mo>×</mo><mi>d</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">= 4.5 \times n_{layers} \times dim_{head}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">4.5</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">yers</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></td></tr></tbody></table></div>
<p>Now let’s see how these attention mechanisms fare in real experiments!</p>
<p><strong>Ablation - GQA beats MHA</strong></p>
<p>Here we compare different attention mechanisms. Our <a href="https://huggingface.co/datasets/HuggingFaceTB/ablations-training-configs/blob/main/baseline_config_1B.yaml">baseline</a> model uses 32 heads and 8 KV heads which corresponds to GQA with ratio 32/8=4. How would performance change if we used MHA, or if we went for even less KV heads and a higher GQA ratio?</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Some libraries call the GQA ratio: Query groups = Query heads / KV heads</p> </aside> </div>  
<p>Changing the number of KV heads affects parameter count especially for the MHA case. For consistency, we adjust the number of layers for the MHA run since it would otherwise have a 100M+ parameter discrepancy; for the rest we keep the default 16 layers.</p>













































































<div class="table-scroll"><table><thead><tr><th>Attention Type</th><th>Query Heads</th><th>KV Heads</th><th>Layers</th><th>Parameter Count</th><th>Notes</th></tr></thead><tbody><tr><td>MQA</td><td>32</td><td>1</td><td>16</td><td>1.21B</td><td></td></tr><tr><td>GQA (ratio 16)</td><td>32</td><td>2</td><td>16</td><td>1.21B</td><td></td></tr><tr><td>GQA (ratio 8)</td><td>32</td><td>4</td><td>16</td><td>1.22B</td><td><strong>Our baseline</strong></td></tr><tr><td>GQA (ratio 4)</td><td>32</td><td>8</td><td>16</td><td>1.24B</td><td></td></tr><tr><td>GQA (ratio 2)</td><td>32</td><td>16</td><td>15</td><td>1.22B</td><td>Reduced layers</td></tr><tr><td>MHA</td><td>32</td><td>32</td><td>14</td><td>1.20B</td><td>Reduced layers</td></tr><tr><td>GQA (ratio 2)</td><td>32</td><td>16</td><td>16</td><td>1.27B</td><td>Too large - not ablated</td></tr><tr><td>MHA</td><td>32</td><td>32</td><td>16</td><td>1.34B</td><td>Too large - not ablated</td></tr></tbody></table></div>
<p>So we compare MHA, MQA and 4 setups for GQA (ratios 2, 4, 8, 16). You can find the nanotron configs <a href="https://huggingface.co/datasets/HuggingFaceTB/training-guide-nanotron-configs/tree/main/attention">here</a>.</p>
<p>Looking at the ablation results, we find that MQA and GQA with 16 groups (leaving only 1 and 2 KV heads respectively) underperform MHA significantly. On the other hand, GQA configurations with 2, 4, and 8 groups roughly match MHA performance.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-iz0py7rdzl" data-config="{&#34;dataUrl&#34;:&#34;./data/attention_loss.csv&#34;,&#34;xDomain&#34;:[0,45000000000],&#34;yDomain&#34;:[2.1,2.7],&#34;smoothing&#34;:true,&#34;title&#34;:&#34;Attention Loss&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-7fv6hfpzk2m" data-config="{&#34;dataUrl&#34;:&#34;./data/attention_evals.csv&#34;,&#34;charts&#34;:[{&#34;title&#34;:&#34;HellaSwag&#34;,&#34;metric&#34;:&#34;hellaswag&#34;},{&#34;title&#34;:&#34;MMLU&#34;,&#34;metric&#34;:&#34;mmlu&#34;},{&#34;title&#34;:&#34;ARC&#34;,&#34;metric&#34;:&#34;arc&#34;},{&#34;title&#34;:&#34;PIQA&#34;,&#34;metric&#34;:&#34;piqa&#34;},{&#34;title&#34;:&#34;OpenBookQA&#34;,&#34;metric&#34;:&#34;openbookqa&#34;},{&#34;title&#34;:&#34;WinoGrande&#34;,&#34;metric&#34;:&#34;winogrande&#34;}],&#34;smoothing&#34;:true,&#34;smoothingWindow&#34;:15}"><!-- 
  Multi-Line Charts Grid
  
  A configurable grid of line charts with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute:
  {
    "dataUrl": "./assets/data/your_data.csv",
    "charts": [
      { "title": "Chart 1", "metric": "metric1" },
      { "title": "Chart 2", "metric": "metric2" },
      ...
    ],
    "smoothingWindow": 15,
    "smoothingCurve": "monotoneX",
    "gridColumns": 3  // Optional: number of columns (default: 3)
  }
  
  CSV format: run_name, step, metric1, metric2, ...
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/d3-six-line-charts.html" 
    config={{ 
      dataUrl: "./assets/data/attention_evals.csv",
      charts: [
        { title: "HellaSwag", metric: "hellaswag" },
        { title: "MMLU", metric: "mmlu" },
        { title: "ARC", metric: "arc" },
        { title: "PIQA", metric: "piqa" },
        { title: "OpenBookQA", metric: "openbookqa" },
        { title: "WinoGrande", metric: "winogrande" }
      ],
      smoothingWindow: 15
    }} 
  />
-->
<div class="d3-multi-charts"></div>
<style>
  .d3-multi-charts {
    position: relative;
    container-type: inline-size;
  }

  /* Legend header */
  .d3-multi-charts__header {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
  }

  .d3-multi-charts__header .legend-bottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
    max-width: 80%;
  }

  .d3-multi-charts__header .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-multi-charts__header .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
    justify-content: center;
  }

  .d3-multi-charts__header .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-multi-charts__header .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  /* Grid */
  .d3-multi-charts__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }

  /* Container queries - basées sur la largeur du container parent, pas de la viewport */
  @container (max-width: 900px) {
    .d3-multi-charts__grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @container (max-width: 600px) {
    .d3-multi-charts__grid {
      grid-template-columns: 1fr;
    }
  }

  .chart-cell {
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
    box-shadow: inset 0 0 0 1px var(--border-color);
    border-radius: 8px;
  }

  .chart-cell__title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
    margin-bottom: 8px;
    padding-bottom: 8px;
  }

  .chart-cell__body {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .chart-cell__body svg {
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* Reset button */
  .chart-cell .reset-button {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
    display: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-size: 11px;
    padding: 3px 6px;
    border-radius: 4px;
    background: var(--surface-bg);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    cursor: pointer;
  }

  /* Axes */
  .d3-multi-charts .axes path {
    display: none;
  }

  .d3-multi-charts .axes line {
    stroke: var(--axis-color);
  }

  .d3-multi-charts .axes text {
    fill: var(--tick-color);
    font-size: 10px;
  }

  .d3-multi-charts .axis-label {
    fill: var(--text-color);
    font-size: 10px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    stroke-width: 3px;
    paint-order: stroke fill;
  }

  .d3-multi-charts .grid line {
    stroke: var(--grid-color);
  }

  /* Lines */
  .d3-multi-charts path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-multi-charts path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-multi-charts.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-multi-charts.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  .d3-multi-charts.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  /* Tooltip */
  .d3-multi-charts .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-multi-charts .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 200px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-multi-charts .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-multi-charts'))) {
        const cs = Array.from(document.querySelectorAll('.d3-multi-charts')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration
      const CONFIG = {
        dataUrl: embedConfig.dataUrl || './assets/data/attention_evals.csv',
        charts: embedConfig.charts || [],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        gridColumns: embedConfig.gridColumns || 3,
        chartHeight: 240,
        margin: { top: 20, right: 20, bottom: 40, left: 50 },
        zoomExtent: [1.0, 8],
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Value',
        xColumn: embedConfig.xColumn || 'tokens',
        runColumn: embedConfig.runColumn || 'run_name'
      };

      if (!CONFIG.charts.length) {
        container.innerHTML = '<p style="color: var(--danger); font-size: 12px;">Error: No charts configured</p>';
        return;
      }

      // Create legend header
      const header = document.createElement('div');
      header.className = 'd3-multi-charts__header';
      header.innerHTML = `
      <div class="legend-bottom">
        <div class="legend-title">Legend</div>
        <div class="items"></div>
      </div>
    `;
      container.appendChild(header);

      // Create grid
      const grid = document.createElement('div');
      grid.className = 'd3-multi-charts__grid';
      container.appendChild(grid);

      // Trackio footer removed

      // Create chart cells
      CONFIG.charts.forEach((chartConfig, idx) => {
        const cell = document.createElement('div');
        cell.className = 'chart-cell';
        cell.style.zIndex = CONFIG.charts.length - idx; // Stacking order
        cell.innerHTML = `
        <div class="chart-cell__title">${chartConfig.title}</div>
        <button class="reset-button">Reset</button>
        <div class="chart-cell__body"></div>
      `;
        grid.appendChild(cell);
      });

      // Data
      let allData = [];
      let runList = [];
      let runColorMap = {};

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].value)) { sum += values[j].value; count++; } }
          const avg = count ? (sum / count) : values[i].value;
          out[i] = { step: values[i].step, value: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Init each chart
      function initChart(cellElement, chartConfig) {
        const bodyEl = cellElement.querySelector('.chart-cell__body');
        const resetBtn = cellElement.querySelector('.reset-button');

        const metric = chartConfig.metric;
        let smoothEnabled = CONFIG.smoothing;
        let hasMoved = false;

        // Tooltip
        let tip = cellElement.querySelector('.d3-tooltip');
        let tipInner;
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'd3-tooltip';
          Object.assign(tip.style, {
            position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
            padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
            background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease', zIndex: '20'
          });
          tipInner = document.createElement('div');
          tipInner.className = 'd3-tooltip__inner';
          tip.appendChild(tipInner);
          cellElement.appendChild(tip);
        } else {
          tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
        }

        // Create SVG
        const svg = d3.select(bodyEl).append('svg').attr('width', '100%').style('display', 'block');

        // Clip path
        const clipId = 'clip-' + Math.random().toString(36).slice(2);
        const clipPath = svg.append('defs').append('clipPath').attr('id', clipId);
        const clipRect = clipPath.append('rect');

        // Groups
        const g = svg.append('g');
        const gGrid = g.append('g').attr('class', 'grid');
        const gAxes = g.append('g').attr('class', 'axes');
        const gPlot = g.append('g').attr('class', 'plot').attr('clip-path', `url(#${clipId})`);
        const gHover = g.append('g').attr('class', 'hover-layer');
        const overlay = g.append('rect').attr('class', 'overlay').attr('fill', 'none').attr('pointer-events', 'all').style('cursor', 'grab')
          .on('mousedown', function () {
            d3.select(this).style('cursor', 'grabbing');
            tip.style.opacity = '0';
            if (hoverLine) hoverLine.style('display', 'none');
          })
          .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

        // Scales
        const xScale = d3.scaleLinear();
        const yScale = d3.scaleLinear();

        // Hover state
        let hoverLine = null;
        let steps = [];
        let hideTipTimer = null;

        // Formatters (will be set in render())
        let formatStep = (v) => v;
        let formatValue = (v) => v;

        // Zoom
        const zoom = d3.zoom().scaleExtent(CONFIG.zoomExtent).on('zoom', zoomed);
        overlay.call(zoom);

        function zoomed(event) {
          const transform = event.transform;
          hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
          updateResetButton();

          const newXScale = transform.rescaleX(xScale);
          const newYScale = transform.rescaleY(yScale);

          const innerWidth = xScale.range()[1];

          // Update grid
          const gridTicks = newYScale.ticks(5);
          gGrid.selectAll('line').data(gridTicks).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => newYScale(d)).attr('y2', d => newYScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Update lines
          const line = d3.line()
            .x(d => newXScale(d.step))
            .y(d => newYScale(d.value))
            .curve(getCurve(smoothEnabled));

          gPlot.selectAll('path.ghost-line')
            .attr('d', d => {
              const rawLine = d3.line().x(d => newXScale(d.step)).y(d => newYScale(d.value)).curve(d3.curveLinear);
              return rawLine(d.values);
            });

          gPlot.selectAll('path.main-line')
            .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

          // Update axes
          gAxes.select('.x-axis').call(d3.axisBottom(newXScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.select('.y-axis').call(d3.axisLeft(newYScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
        }

        function updateResetButton() {
          if (hasMoved) {
            resetBtn.style.display = 'block';
            requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
          } else {
            resetBtn.style.opacity = '0';
            setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
          }
        }

        function render() {
          const rect = bodyEl.getBoundingClientRect();
          const width = Math.max(1, Math.round(rect.width || 400));
          const height = CONFIG.chartHeight;
          svg.attr('width', width).attr('height', height);

          const margin = CONFIG.margin;
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;

          g.attr('transform', `translate(${margin.left},${margin.top})`);

          // Filter data for this metric
          const metricData = allData.filter(d => d[metric] != null && !isNaN(d[metric]));

          if (!metricData.length) {
            return;
          }

          // Auto-compute domains from data
          const stepExtent = d3.extent(metricData, d => d.step);
          const valueExtent = d3.extent(metricData, d => d[metric]);

          xScale.domain(stepExtent).range([0, innerWidth]);
          yScale.domain(valueExtent).range([innerHeight, 0]);

          // Create smart formatters based on actual data
          const stepValues = metricData.map(d => d.step);
          const metricValues = metricData.map(d => d[metric]);
          formatStep = createSmartFormatter(stepValues);
          formatValue = createSmartFormatter(metricValues);

          // Update clip
          clipRect.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update overlay
          overlay.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update zoom extent
          zoom.extent([[0, 0], [innerWidth, innerHeight]])
            .translateExtent([[0, 0], [innerWidth, innerHeight]]);

          // Grid
          gGrid.selectAll('line').data(yScale.ticks(5)).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Axes
          gAxes.selectAll('*').remove();
          gAxes.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.append('g').attr('class', 'y-axis')
            .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
          gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');
          gAxes.selectAll('text').attr('fill', 'var(--tick-color)');

          // Axis labels
          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight + 32)
            .attr('text-anchor', 'middle')
            .text(CONFIG.xAxisLabel);

          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -38)
            .attr('text-anchor', 'middle')
            .text(CONFIG.yAxisLabel);

          // Group data by run
          const dataByRun = {};
          runList.forEach(run => { dataByRun[run] = []; });
          metricData.forEach(d => {
            if (dataByRun[d.run]) dataByRun[d.run].push({ step: d.step, value: d[metric] });
          });
          runList.forEach(run => { dataByRun[run].sort((a, b) => a.step - b.step); });

          const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] })).filter(s => s.values.length > 0);

          // Ghost lines
          const ghostLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(d3.curveLinear);
          gPlot.selectAll('path.ghost-line').data(series, d => d.run).join('path')
            .attr('class', 'ghost-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 1.5)
            .attr('opacity', smoothEnabled ? 0.15 : 0)
            .attr('pointer-events', 'none')
            .attr('d', d => ghostLine(d.values));

          // Main lines
          const mainLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(getCurve(smoothEnabled));
          gPlot.selectAll('path.main-line').data(series, d => d.run).join('path')
            .attr('class', 'main-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('opacity', 0.85)
            .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

          // Hover
          setupHover(series, innerWidth, innerHeight);
        }

        function setupHover(series, innerWidth, innerHeight) {
          gHover.selectAll('*').remove();

          hoverLine = gHover.append('line')
            .style('stroke', 'var(--text-color)')
            .attr('stroke-opacity', 0.25)
            .attr('stroke-width', 1)
            .attr('y1', 0)
            .attr('y2', innerHeight)
            .style('display', 'none')
            .attr('pointer-events', 'none');

          const stepSet = new Set();
          series.forEach(s => s.values.forEach(v => stepSet.add(v.step)));
          steps = Array.from(stepSet).sort((a, b) => a - b);

          overlay.on('mousemove', function (ev) {
            if (ev.buttons === 0) onHoverMove(ev, series);
          }).on('mouseleave', onHoverLeave);
        }

        function onHoverMove(ev, series) {
          if (hideTipTimer) { clearTimeout(hideTipTimer); hideTipTimer = null; }

          const [mx, my] = d3.pointer(ev, overlay.node());
          const targetStep = xScale.invert(mx);
          const nearest = steps.reduce((best, t) => Math.abs(t - targetStep) < Math.abs(best - targetStep) ? t : best, steps[0]);

          const xpx = xScale(nearest);
          hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

          let html = `<div><strong>${chartConfig.title}</strong></div>`;
          html += `<div>${formatStep(nearest)}</div>`;

          const entries = series.map(s => {
            const values = s.values;
            let before = null, after = null;
            for (let i = 0; i < values.length; i++) {
              if (values[i].step <= nearest) before = values[i];
              if (values[i].step >= nearest && !after) { after = values[i]; break; }
            }

            let interpolatedValue = null;
            if (before && after && before.step !== after.step) {
              const t = (nearest - before.step) / (after.step - before.step);
              interpolatedValue = before.value + t * (after.value - before.value);
            } else if (before && before.step === nearest) {
              interpolatedValue = before.value;
            } else if (after && after.step === nearest) {
              interpolatedValue = after.value;
            } else if (before) {
              interpolatedValue = before.value;
            } else if (after) {
              interpolatedValue = after.value;
            }

            return { run: s.run, color: s.color, value: interpolatedValue };
          }).filter(e => e.value != null);

          entries.sort((a, b) => b.value - a.value);

          entries.forEach(e => {
            html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.value.toFixed(4)}</span></div>`;
          });

          tipInner.innerHTML = html;
          const offsetX = 12, offsetY = 12;
          tip.style.opacity = '1';
          tip.style.transform = `translate(${Math.round(mx + offsetX + CONFIG.margin.left)}px, ${Math.round(my + offsetY + CONFIG.margin.top)}px)`;
        }

        function onHoverLeave() {
          hideTipTimer = setTimeout(() => {
            tip.style.opacity = '0';
            tip.style.transform = 'translate(-9999px, -9999px)';
            if (hoverLine) hoverLine.style('display', 'none');
          }, 100);
        }

        // Reset button
        resetBtn.addEventListener('click', () => {
          overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        });

        return { render };
      }

      // Load data
      async function load() {
        try {
          const response = await fetch(CONFIG.dataUrl, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);

          const csvText = await response.text();

          // Parse CSV (long format: run_name, metric, tokens, value)
          const rawRows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            metric: (d.metric || '').trim(),
            tokens: +d[CONFIG.xColumn],
            value: +d.value
          }));

          // Pivot data: group by run + tokens, create columns for each metric
          const pivotMap = new Map();
          rawRows.forEach(row => {
            if (isNaN(row.tokens) || isNaN(row.value)) return;

            const key = `${row.run}|${row.tokens}`;
            if (!pivotMap.has(key)) {
              pivotMap.set(key, { run: row.run, step: row.tokens });
            }
            const pivotRow = pivotMap.get(key);
            pivotRow[row.metric] = row.value;
          });

          allData = Array.from(pivotMap.values());

          runList = Array.from(new Set(allData.map(d => d.run))).sort();

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => { runColorMap[run] = colors[i % colors.length]; });

          // Build legend
          const legendItemsHost = header.querySelector('.legend-bottom .items');
          if (legendItemsHost) {
            legendItemsHost.innerHTML = runList.map(run => {
              const color = runColorMap[run];
              return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
            }).join('');

            // Add hover interactions
            legendItemsHost.querySelectorAll('.item').forEach(el => {
              el.addEventListener('mouseenter', () => {
                const run = el.getAttribute('data-run');
                container.classList.add('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                grid.querySelectorAll('path.ghost-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                legendItemsHost.querySelectorAll('.item').forEach(it => {
                  it.classList.toggle('ghost', it.getAttribute('data-run') !== run);
                });
              });

              el.addEventListener('mouseleave', () => {
                container.classList.remove('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => path.classList.remove('ghost'));
                grid.querySelectorAll('path.ghost-line').forEach(path => path.classList.remove('ghost'));
                legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
              });
            });
          }

          // Init all charts
          const cells = Array.from(grid.querySelectorAll('.chart-cell'));
          const chartInstances = cells.map((cell, idx) => initChart(cell, CONFIG.charts[idx]));

          // Render all
          chartInstances.forEach(chart => chart.render());

          // Responsive - observe container for resize
          let resizeTimer;
          const handleResize = () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              chartInstances.forEach(chart => chart.render());
            }, 100);
          };

          const ro = window.ResizeObserver ? new ResizeObserver(handleResize) : null;
          if (ro) {
            ro.observe(container);
          }

          // Also observe window resize as fallback
          window.addEventListener('resize', handleResize);

          // Force a re-render after a short delay to ensure proper sizing
          setTimeout(() => {
            chartInstances.forEach(chart => chart.render());
          }, 100);

        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure> </div>
<p>The results are consistent across both loss curves and downstream evaluations. We observe this clearly in benchmarks like HellaSwag, MMLU, and ARC, while benchmarks like OpenBookQA and WinoGrande show a bit of noise.</p>
<p>Based on these ablations, GQA is a solid alternative to MHA. It preserves performance while being more efficient at inference. Some recent models have adopted MLA for even greater KV cache compression, though it hasn’t been as widely adopted yet. We didn’t ablate MLA since it wasn’t implemented in nanotron at the time of the ablations. For SmolLM3, we used GQA with 4 groups.</p>
<p>Beyond the attention architecture itself, the attention pattern we use during training also matters. Let’s have a look at attention masking.</p>
<p><strong>Document masking</strong></p>
<p>How we apply attention across our training sequences impacts both computational efficiency and model performance. This brings us to  <em>document masking</em>  and the broader question of how we structure our training samples in the dataloader.</p>
<p>During pretraining, we train with fixed sequence lengths but our documents have variable lengths. A research paper might be 10k tokens while a short code snippet might only have few hundred tokens. How do we fit variable-length documents into fixed-length training sequences? Padding shorter documents to reach our target length wastes compute on meaningless padding tokens. Instead, we use  <strong>packing</strong> : shuffle and concatenate documents with end-of-sequence (EOS) tokens, then split the result into fixed-length chunks matching the sequence size.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>We could also add BOS tokens at the beginning of documents. In this case you’ll notice a different <code>bos_token_id</code> present in the model/tokenizer configs.</p> </aside> </div>  
<p>Here’s what this looks like in practice:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="markdown"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">File 1: &quot;Recipe for granola bars...&quot; (400 tokens) &lt;EOS&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">File 2: &quot;def hello_world()...&quot; (300 tokens) &lt;EOS&gt;  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">File 3: &quot;Climate change impacts...&quot; (1000 tokens) &lt;EOS&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">File 4: &quot;import numpy as np...&quot; (3000 tokens) &lt;EOS&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">After concatenation and chunking into 4k sequences:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">Sequence 1: [File 1] + [File 2] + [File 3] + [partial File 4]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">Sequence 2: [rest of File 4] + [File 5] + [File 6] + ...</span></span>
<span class="line"></span></code></pre></div>
<p>A training sequence might contain one complete file if it’s long enough to fill our 4k context, but in most cases files are short, so sequences contain concatenations of multiple random files.</p>
<p>With standard causal masking, tokens can attend to all previous tokens in the packed sequence. In the examples above, a token in that Python function of file 4 can attend to the granola bars recipe, the climate change article, and any other content that happened to be packed together. Let’s quickly take a look at what a typical 4k pre-training context would contain. A quick<a href="https://www.harmdevries.com/post/context-length/"> analysis</a> reveals that a substantial portion (about 80-90%) of files in CommonCrawl and GitHub are shorter than 2k tokens.</p>
<p>The chart below examines token distribution for more recent datasets, used throughout this blog:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-joel0jyf6"><div class="d3-token-distribution"></div>

<style>
    .d3-token-distribution {
        position: relative;
    }

    .d3-token-distribution .legend {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        margin: 8px 0 0 0;
    }

    .d3-token-distribution .legend .legend-title {
        font-size: 12px;
        font-weight: 700;
        color: var(--text-color);
    }

    .d3-token-distribution .legend .items {
        display: flex;
        flex-wrap: wrap;
        gap: 8px 14px;
    }

    .d3-token-distribution .legend .item {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: var(--muted-color);
        cursor: pointer;
    }

    .d3-token-distribution .legend .swatch {
        width: 14px;
        height: 14px;
        border-radius: 3px;
        border: 1px solid var(--border-color);
    }

    .d3-token-distribution .ghost {
        opacity: .25;
    }

    .d3-token-distribution .d3-tooltip {
        position: absolute;
        top: 0px;
        left: 0px;
        transform: translate(-9999px, -9999px);
        pointer-events: none;
        padding: 8px 10px;
        border-radius: 8px;
        font-size: 12px;
        line-height: 1.35;
        border: 1px solid var(--border-color);
        background: var(--surface-bg);
        color: var(--text-color);
        box-shadow: 0 4px 24px rgba(0, 0, 0, .18);
        opacity: 0;
        transition: opacity .12s ease;
        text-align: left;
    }

    .d3-token-distribution .chart-card {
        background: transparent;
        border: none;
        border-radius: 0;
        padding: 0;
    }
</style>

<script>
    (() => {
        const ensureD3 = (cb) => {
            if (window.d3 && typeof window.d3.select === 'function') return cb();
            let s = document.getElementById('d3-cdn-script');
            if (!s) {
                s = document.createElement('script');
                s.id = 'd3-cdn-script';
                s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
                document.head.appendChild(s);
            }
            const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
            s.addEventListener('load', onReady, { once: true });
            if (window.d3) onReady();
        };

        const bootstrap = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;
            if (!(container && container.classList && container.classList.contains('d3-token-distribution'))) {
                const cs = Array.from(document.querySelectorAll('.d3-token-distribution')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
                container = cs[cs.length - 1] || null;
            }
            if (!container) return;
            if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

            container.style.position = container.style.position || 'relative';
            let tip = container.querySelector('.d3-tooltip'); let tipInner;
            if (!tip) {
                tip = document.createElement('div'); tip.className = 'd3-tooltip';
                tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tip.appendChild(tipInner);
                container.appendChild(tip);
            } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

            // header below chart
            const header = document.createElement('div'); header.className = 'chart-header';

            const makeLegend = (series, colorBySeries) => {
                let legend = header.querySelector('.legend');
                if (!legend) { legend = document.createElement('div'); legend.className = 'legend'; header.appendChild(legend); }
                // Ensure title
                let title = legend.querySelector('.legend-title');
                if (!title) { title = document.createElement('div'); title.className = 'legend-title'; title.textContent = 'Datasets'; legend.appendChild(title); }
                // Ensure items container
                let items = legend.querySelector('.items');
                if (!items) { items = document.createElement('div'); items.className = 'items'; legend.appendChild(items); }
                items.innerHTML = '';
                series.forEach(name => {
                    const item = document.createElement('div'); item.className = 'item';
                    const sw = document.createElement('span'); sw.className = 'swatch'; sw.style.background = colorBySeries(name);
                    const txt = document.createElement('span'); txt.textContent = name;
                    item.appendChild(sw); item.appendChild(txt); items.appendChild(item);
                    item.addEventListener('mouseenter', () => { state.highlightDataset = name; updateHighlight(); });
                    item.addEventListener('mouseleave', () => { state.highlightDataset = null; updateHighlight(); });
                });
            };

            // SVG scaffolding inside a card wrapper, then header appended after
            const card = document.createElement('div'); card.className = 'chart-card'; container.appendChild(card);
            container.appendChild(header);
            const svg = d3.select(card).append('svg').attr('width', '100%').style('display', 'block');
            const gRoot = svg.append('g');

            // Data from the CSV
            const rawData = [
                { bucket: "0-1k", "FineWeb-Edu": 69.11, "DCLM": 67.656, "FineMath": 60.076, "Python-Edu": 91.636 },
                { bucket: "1-2k", "FineWeb-Edu": 21.602, "DCLM": 19.158, "FineMath": 22.5635, "Python-Edu": 5.906 },
                { bucket: "2-3k", "FineWeb-Edu": 4.876, "DCLM": 5.857, "FineMath": 7.509, "Python-Edu": 1.38 },
                { bucket: "3-4k", "FineWeb-Edu": 1.829, "DCLM": 2.471, "FineMath": 3.444, "Python-Edu": 0.473 },
                { bucket: "4-5k", "FineWeb-Edu": 0.829, "DCLM": 1.249, "FineMath": 1.9575, "Python-Edu": 0.246 },
                { bucket: "5-6k", "FineWeb-Edu": 0.472, "DCLM": 0.824, "FineMath": 1.1365, "Python-Edu": 0.139 },
                { bucket: "6-7k", "FineWeb-Edu": 0.281, "DCLM": 0.608, "FineMath": 0.7575, "Python-Edu": 0.065 },
                { bucket: "7-8k", "FineWeb-Edu": 0.233, "DCLM": 0.408, "FineMath": 0.58, "Python-Edu": 0.046 },
                { bucket: "8-9k", "FineWeb-Edu": 0.16, "DCLM": 0.327, "FineMath": 0.3895, "Python-Edu": 0.032 },
                { bucket: "9-10k", "FineWeb-Edu": 0.127, "DCLM": 0.24, "FineMath": 0.2695, "Python-Edu": 0.018 },
                { bucket: "10-11k", "FineWeb-Edu": 0.08, "DCLM": 0.217, "FineMath": 0.194, "Python-Edu": 0.006 },
                { bucket: "11-12k", "FineWeb-Edu": 0.069, "DCLM": 0.158, "FineMath": 0.1635, "Python-Edu": 0.008 },
                { bucket: "12-13k", "FineWeb-Edu": 0.053, "DCLM": 0.145, "FineMath": 0.1495, "Python-Edu": 0.009 },
                { bucket: "13-14k", "FineWeb-Edu": 0.045, "DCLM": 0.142, "FineMath": 0.1195, "Python-Edu": 0.004 },
                { bucket: "14-15k", "FineWeb-Edu": 0.035, "DCLM": 0.072, "FineMath": 0.091, "Python-Edu": 0.002 },
                { bucket: "15-16k", "FineWeb-Edu": 0.028, "DCLM": 0.061, "FineMath": 0.0715, "Python-Edu": 0.001 },
                { bucket: "16k+", "FineWeb-Edu": 0.171, "DCLM": 0.407, "FineMath": 0.528, "Python-Edu": 0.029 }
            ];

            // Define logarithmic buckets and mapping function
            const logBuckets = ["0-1k", "1-2k", "2-4k", "4-8k", "8-16k", "16k+"];

            function mapToLogBucket(linearBucket) {
                if (linearBucket === "0-1k") return "0-1k";
                if (linearBucket === "1-2k") return "1-2k";
                if (["2-3k", "3-4k"].includes(linearBucket)) return "2-4k";
                if (["4-5k", "5-6k", "6-7k", "7-8k"].includes(linearBucket)) return "4-8k";
                if (["8-9k", "9-10k", "10-11k", "11-12k", "12-13k", "13-14k", "14-15k", "15-16k"].includes(linearBucket)) return "8-16k";
                return "16k+";
            }

            // Aggregate data into logarithmic buckets
            const aggregatedData = {};
            logBuckets.forEach(bucket => {
                aggregatedData[bucket] = {
                    "FineWeb-Edu": 0,
                    "DCLM": 0,
                    "FineMath": 0,
                    "Python-Edu": 0
                };
            });

            rawData.forEach(row => {
                const logBucket = mapToLogBucket(row.bucket);
                Object.keys(aggregatedData[logBucket]).forEach(dataset => {
                    aggregatedData[logBucket][dataset] += row[dataset];
                });
            });

            // Convert to array format for D3
            const data = logBuckets.map(bucket => ({
                bucket: bucket,
                ...aggregatedData[bucket]
            }));

            const state = {
                data: data,
                colorsByDataset: null,
                highlightDataset: null,
            };

            const margin = { top: 12, right: 28, bottom: 24, left: 56 };
            let width = 800, height = 360;
            const x0 = d3.scaleBand().paddingInner(0.2).paddingOuter(0.05); // group: bucket
            const x1 = d3.scaleBand().padding(0.12); // series: dataset per bucket
            const y = d3.scaleLinear();
            const xAxis = d3.axisBottom(x0).tickSizeOuter(0);
            const yAxis = d3.axisLeft(y).ticks(6).tickSizeOuter(0);
            const yTopPadding = 2; // avoid bars touching top at max

            function getPrimaryColor() {
                try { if (window.ColorPalettes && typeof window.ColorPalettes.getPrimary === 'function') return window.ColorPalettes.getPrimary(); } catch (e) { }
                return getComputedStyle(document.documentElement).getPropertyValue('--primary-color') || '#6D4AFF';
            }

            function getCategoricalColors(n) {
                try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (e) { }
                // Fallback: generate hues around the primary color (simple fallback)
                const base = getPrimaryColor();
                const colors = [];
                for (let i = 0; i < n; i++) {
                    const hue = Math.round((360 / n) * i);
                    colors.push(`hsl(${hue}, 60%, 55%)`);
                }
                return colors;
            }

            function computeSeriesColors(datasets) {
                const palette = getCategoricalColors(datasets.length);
                const map = new Map(datasets.map((d, i) => [d, palette[i % palette.length]]));
                return (dataset) => map.get(dataset) || getPrimaryColor();
            }

            function getDatasets(data) {
                return ["FineWeb-Edu", "DCLM", "FineMath", "Python-Edu"];
            }

            function getBuckets(data) {
                return Array.from(new Set(data.map(d => d.bucket)));
            }

            function updateSize() {
                width = container.clientWidth || 800;
                height = Math.max(240, Math.round(width / 3.4));
                svg.attr('width', width).attr('height', height);
                gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
                return { innerWidth: width - margin.left - margin.right, innerHeight: height - margin.top - margin.bottom };
            }

            function showTip(html, x, y) {
                tip.style.transform = `translate(${x + 12}px, ${y + 12}px)`;
                tip.style.opacity = '1';
                const inner = tip.querySelector('.d3-tooltip__inner') || tip;
                inner.innerHTML = html;
            }

            function hideTip() {
                tip.style.opacity = '0';
                tip.style.transform = 'translate(-9999px, -9999px)';
            }

            function updateHighlight() {
                const dataset = state.highlightDataset;
                const bars = gRoot.selectAll('rect.bar');
                const labels = gRoot.selectAll('text.value');
                if (dataset) {
                    bars.classed('ghost', d => d.dataset !== dataset);
                    labels.classed('ghost', d => d.dataset !== dataset);
                    const items = container.querySelectorAll('.legend .item');
                    items.forEach((el) => {
                        const name = el.textContent.trim();
                        if (name !== dataset) el.classList.add('ghost'); else el.classList.remove('ghost');
                    });
                } else {
                    bars.classed('ghost', false);
                    labels.classed('ghost', false);
                    container.querySelectorAll('.legend .item').forEach(el => el.classList.remove('ghost'));
                }
            }

            function render() {
                const { innerWidth, innerHeight } = updateSize();
                const datasets = getDatasets(state.data);
                if (!state.colorsByDataset) state.colorsByDataset = computeSeriesColors(datasets);
                makeLegend(datasets, state.colorsByDataset);

                x0.domain(getBuckets(state.data)).range([0, innerWidth]);
                x1.domain(datasets).range([0, x0.bandwidth()]);

                const yMaxRaw = d3.max(state.data, d => Math.max(d["FineWeb-Edu"], d["DCLM"], d["FineMath"], d["Python-Edu"]));
                const yMax = yMaxRaw + yTopPadding;
                y.domain([0, yMax]).range([innerHeight, 0]).nice();

                // Axes (standardized colors)
                gRoot
                    .selectAll('.axis-x')
                    .data([0])
                    .join('g')
                    .attr('class', 'axis-x')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(xAxis)
                    .call(g => {
                        g.selectAll('path, line').attr('stroke', 'var(--axis-color)');
                        g.selectAll('text').attr('fill', 'var(--tick-color)').style('font-size', '12px');
                    });

                gRoot
                    .selectAll('.axis-y')
                    .data([0])
                    .join('g')
                    .attr('class', 'axis-y')
                    .call(yAxis)
                    .call(g => {
                        g.selectAll('path, line').attr('stroke', 'var(--axis-color)');
                        g.selectAll('text').attr('fill', 'var(--tick-color)').style('font-size', '12px');
                    });

                // Gridlines (y) standardized color
                gRoot
                    .selectAll('.grid-y')
                    .data([0])
                    .join('g')
                    .attr('class', 'grid-y')
                    .call(d3.axisLeft(y).ticks(6).tickSize(-innerWidth).tickFormat(''))
                    .call(g => g.select('.domain').remove())
                    .call(g => g.selectAll('.tick line').attr('stroke', 'var(--grid-color)').attr('stroke-opacity', 1))
                    .call(g => g.selectAll('.tick').filter((d, i, nodes) => i === nodes.length - 1).select('line').attr('stroke-opacity', 0));

                // Groups per bucket
                const groups = gRoot.selectAll('.group').data(getBuckets(state.data), d => d);
                const groupsEnter = groups.enter().append('g').attr('class', 'group');
                groupsEnter.merge(groups).attr('transform', d => `translate(${x0(d)},0)`);
                groups.exit().remove();

                // Bars per dataset
                const nested = d3.group(state.data, d => d.bucket);
                groupsEnter.each(function (bucket) { d3.select(this).selectAll('rect.bar').data([]).join('rect'); });
                const allGroups = gRoot.selectAll('.group');
                allGroups.each(function (bucket) {
                    const dataForBucket = nested.get(bucket) || [];
                    const bars = d3.select(this).selectAll('rect.bar').data(datasets.map(d => ({ bucket, dataset: d, value: (dataForBucket.find(dd => dd.bucket === bucket) || {})[d] || 0 })), d => d.dataset);
                    bars.join(
                        enter => enter.append('rect')
                            .attr('class', 'bar')
                            .attr('x', d => x1(d.dataset))
                            .attr('y', innerHeight)
                            .attr('width', x1.bandwidth())
                            .attr('height', 0)
                            .attr('fill', d => state.colorsByDataset(d.dataset))
                            .attr('rx', 2)
                            .attr('ry', 2)
                            .on('mouseenter', (event, d) => { state.highlightDataset = d.dataset; updateHighlight(); })
                            .on('mousemove', (event, d) => {
                                const [mx, my] = d3.pointer(event, container);
                                showTip(`<strong>${d.dataset}</strong><br/>${d.bucket}: <strong>${d.value.toFixed(2)}%</strong>`, mx, my);
                            })
                            .on('mouseleave', () => { hideTip(); state.highlightDataset = null; updateHighlight(); })
                            .transition().duration(160)
                            .attr('y', d => y(d.value))
                            .attr('height', d => Math.max(0, innerHeight - y(d.value))),
                        update => update
                            .on('mouseenter', (event, d) => { state.highlightDataset = d.dataset; updateHighlight(); })
                            .on('mousemove', (event, d) => {
                                const [mx, my] = d3.pointer(event, container);
                                showTip(`<strong>${d.dataset}</strong><br/>${d.bucket}: <strong>${d.value.toFixed(2)}%</strong>`, mx, my);
                            })
                            .on('mouseleave', () => { hideTip(); state.highlightDataset = null; updateHighlight(); })
                            .transition().duration(160)
                            .attr('x', d => x1(d.dataset))
                            .attr('y', d => y(d.value))
                            .attr('width', x1.bandwidth())
                            .attr('height', d => Math.max(0, innerHeight - y(d.value)))
                            .attr('fill', d => state.colorsByDataset(d.dataset)),
                        exit => exit.transition().duration(120).attr('y', innerHeight).attr('height', 0).remove()
                    );
                });

                // Axis labels
                gRoot.selectAll('.y-label').data([0]).join('text').attr('class', 'y-label')
                    .attr('transform', `rotate(-90)`)
                    .attr('x', -innerHeight / 2)
                    .attr('y', -margin.left + 24)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'var(--text-color)')
                    .attr('font-size', 12)
                    .attr('font-weight', 700)
                    .text('Documents (%)');
            }

            // Initial render + resize handling
            render();
            const rerender = () => render();
            if (window.ResizeObserver) { const ro = new ResizeObserver(() => rerender()); ro.observe(container); }
            else { window.addEventListener('resize', rerender); }

            // Load color palettes script if not already loaded
            if (!window.ColorPalettes) {
                const script = document.createElement('script');
                script.src = '/scripts/color-palettes.js';
                script.onload = () => {
                    // Re-render with proper colors after palette script loads
                    state.colorsByDataset = null;
                    render();
                };
                document.head.appendChild(script);
            }
        };

        if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); }
        else { ensureD3(bootstrap); }
    })();
</script></div></div></figure>
<p>More than 80% of documents in FineWeb-Edu, DCLM, FineMath and Python-Edu contain fewer than 2k tokens. This means with a 2k or 4k training sequence and standard causal masking, the vast majority of tokens would spend compute attending to unrelated documents packed together.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty>  <div class="note__title" data-astro-cid-qg6lmfty>Longer documents in PDFs</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>While most web-based datasets consist of short documents, PDF-based datasets contain substantially longer content. <a href="https://huggingface.co/datasets/HuggingFaceFW/fineweb-2">FinePDFs</a> documents are on average 2× longer than web text, and they improve performance when mixed with FineWeb-Edu and DCLM.</p> </div> </div> </div> 
<p>Besides computational inefficiency, <span class="" id="citation--zhao2024--26"><a href="https://doi.org/10.18653/v1/2024.acl-long.427" id="refctx-bib-zhao2024-1" data-ref-id="bib-zhao2024" target="_blank" rel="noopener noreferrer">Zhao et al. (2024)</a></span> find that this approach introduces noise from unrelated content that can degrade performance. They suggest using  <em>intra-document masking</em> , where we modify the attention mask so tokens can only attend to previous tokens within the same document. The visualization below illustrates this difference:</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-gk0tlt4skbq"><div class="doc-masking"></div>

<style>
  .doc-masking {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.5;
    color: var(--text-color);
    padding: 20px 0;
  }
  
  .doc-masking .concatenated {
    padding: 15px;
    margin: 0 auto 30px auto;
    text-align: center;
    max-width: 70%;
  }
  
  .doc-masking .section-title {
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 10px;
    color: var(--text-color);
  }
  
  .doc-masking .token-sequence {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-bottom: 10px;
    justify-content: center;
  }
  
  .doc-masking .token {
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 0.8rem;
    font-weight: 500;
    white-space: nowrap;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .doc-masking .token:hover {
    transform: scale(1.05);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  }
  
  .doc-masking .token-recipe { 
    background: var(--token-recipe-bg); 
    color: var(--token-recipe-color); 
    filter: saturate(1.3);
  }
  .doc-masking .token-code { 
    background: var(--token-code-bg); 
    color: var(--token-code-color); 
    filter: saturate(1.3);
  }
  .doc-masking .token-climate { 
    background: var(--token-climate-bg); 
    color: var(--token-climate-color); 
    filter: saturate(1.3);
  }
  .doc-masking .token-separator { 
    background: var(--border-color); 
    color: var(--muted-color); 
    font-weight: 600; 
  }
  
  .doc-masking .attention-comparison {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
  }
  
  .doc-masking .attention-section {
    text-align: center;
  }
  
  .doc-masking .mask-type {
    font-weight: 600;
    font-size: 1.1rem;
    margin-top: 15px;
    margin-bottom: 30px;
  }
  
  .doc-masking .causal-mask { 
    color: #92400E; 
  }
  .doc-masking .intradoc-mask { 
    color: #077c3a; 
  }
  
  .doc-masking .matrix-container {
    display: grid;
    grid-template-columns: 60px 1fr;
    grid-template-rows: 1fr 30px;
    gap: 8px;
    justify-self: center;
    align-items: center;
    background: var(--page-bg)!important;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  }
  
  .doc-masking .doc-labels {
    display: grid;
    gap: 2px;
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--muted-color);
  }
  
  .doc-masking .doc-label {
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 3px 0 0 3px;
  }
  
  .doc-masking .doc-recipe-label { 
    background: var(--token-recipe-bg); 
    color: var(--token-recipe-color); 
    font-weight: 700;
  }
  .doc-masking .doc-code-label { 
    background: var(--token-code-bg); 
    color: var(--token-code-color); 
    font-weight: 700;
  }
  .doc-masking .doc-climate-label { 
    background: var(--token-climate-bg); 
    color: var(--token-climate-color); 
    font-weight: 700;
  }
  
  .doc-masking .doc-labels-bottom {
    display: grid;
    gap: 2px;
    font-size: 0.7rem;
    font-weight: 600;
    color: var(--muted-color);
    grid-column: 2;
  }
  
  .doc-masking .doc-label-bottom {
    width: 18px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 0 0 3px 3px;
    writing-mode: vertical-rl;
    text-orientation: mixed;
    font-size: 0.65rem;
  }
  
  .doc-masking .attention-matrix {
    display: grid;
    gap: 2px;
    justify-items: stretch;
    align-items: stretch;
    grid-column: 2;
    grid-row: 1;
    position: relative;
  }
  
  .doc-masking .attention-cell {
    width: 18px;
    height: 18px;
    border-radius: 3px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 9px;
    font-weight: 600;
    transition: all 0.2s ease;
    cursor: pointer;
  }
  
  .doc-masking .highlight-overlay {
    position: absolute;
    background: color-mix(in srgb, var(--border-color) 35%, transparent);
    pointer-events: none;
    z-index: 1;
    transition: opacity 0.2s ease;
  }
  
  .doc-masking .highlight-overlay.row {
    left: 0;
    right: 0;
    height: 18px;
  }
  
  .doc-masking .highlight-overlay.col {
    top: 0;
    bottom: 0;
    width: 18px;
  }
  
  .doc-masking .can-attend {
    background: #10B981;
    color: white;
  }
  
  .doc-masking .cannot-attend {
    background: var(--border-color);
    color: var(--muted-color);
  }
  
  .doc-masking .attention-cell:hover {
    transform: scale(1.2);
    z-index: 10;
    position: relative;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }
  
  .doc-masking .tooltip {
    position: absolute;
    background: var(--surface-bg);
    color: var(--text-color);
    padding: 8px 10px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 500;
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    pointer-events: none;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.2s ease;
    max-width: 240px;
    text-align: left;
    line-height: 1.3;
  }
  
  .doc-masking .tooltip.show {
    opacity: 1;
  }
  
  .doc-masking .legend {
    display: flex;
    gap: 20px;
    justify-content: center;
    margin-top: 45px;
    padding: 10px;
  }
  
  .doc-masking .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
  }
  
  .doc-masking .legend-box {
    width: 18px;
    height: 18px;
    border-radius: 3px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 600;
    color: white;
  }
  
  .doc-masking .legend-box.can-attend {
    background: #10B981;
  }
  
  .doc-masking .legend-box.cannot-attend {
    background: var(--border-color);
    color: var(--text-color);
  }
  
  /* Responsive design */
  @media (max-width: 1000px) {
    .doc-masking .attention-comparison {
      grid-template-columns: 1fr;
      gap: 20px;
    }
    
    .doc-masking .token-sequence {
      font-size: 0.7rem;
    }
    
    .doc-masking .matrix-container {
      grid-template-columns: 50px 1fr;
    }
    
    .doc-masking .doc-labels {
      font-size: 0.7rem;
    }
  }
  
  @media (max-width: 480px) {
    .doc-masking {
      padding: 16px 0;
    }
    
    .doc-masking .concatenated {
      padding: 16px;
    }
    
    .doc-masking .legend {
      flex-direction: column;
      gap: 12px;
    }
  }
</style>

<script>
  (() => {
    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('doc-masking'))) {
        const candidates = Array.from(document.querySelectorAll('.doc-masking'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Generate categorical colors for 3 categories
      const setupColors = () => {
        try {
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            const colors = window.ColorPalettes.getColors('categorical', 3);
            if (colors && colors.length >= 3) {
              const root = document.documentElement;
              
              // Recipe (index 0)
              root.style.setProperty('--token-recipe-bg', `color-mix(in srgb, ${colors[0]} 20%, var(--surface-bg))`);
              root.style.setProperty('--token-recipe-color', `color-mix(in srgb, ${colors[0]} 60%, var(--text-color))`);
              
              // Code (index 1) 
              root.style.setProperty('--token-code-bg', `color-mix(in srgb, ${colors[1]} 20%, var(--surface-bg))`);
              root.style.setProperty('--token-code-color', `color-mix(in srgb, ${colors[1]} 60%, var(--text-color))`);
              
              // Climate (index 2)
              root.style.setProperty('--token-climate-bg', `color-mix(in srgb, ${colors[2]} 20%, var(--surface-bg))`);
              root.style.setProperty('--token-climate-color', `color-mix(in srgb, ${colors[2]} 60%, var(--text-color))`);
              
              return;
            }
          }
        } catch (e) {
          console.warn('Failed to load color palettes:', e);
        }
        
        // Fallback colors if palette system fails
        const root = document.documentElement;
        root.style.setProperty('--token-recipe-bg', 'color-mix(in srgb, #FED7AA 12%, var(--surface-bg))');
        root.style.setProperty('--token-recipe-color', '#9A3412');
        root.style.setProperty('--token-code-bg', 'color-mix(in srgb, #BFDBFE 12%, var(--surface-bg))');
        root.style.setProperty('--token-code-color', '#1E40AF');
        root.style.setProperty('--token-climate-bg', 'color-mix(in srgb, #FDE68A 12%, var(--surface-bg))');
        root.style.setProperty('--token-climate-color', '#92400E');
      };

      setupColors();

      // Listen for palette updates
      document.addEventListener('palettes:updated', setupColors);

      // Define the token sequence with document boundaries
      const tokens = [
        { text: 'Mix', type: 'recipe', doc: 0 },
        { text: 'oats', type: 'recipe', doc: 0 },
        { text: 'with', type: 'recipe', doc: 0 },
        { text: 'honey', type: 'recipe', doc: 0 },
        { text: '<|end_of_text|>', type: 'separator', doc: 0 },
        { text: 'def', type: 'code', doc: 1 },
        { text: 'hello():', type: 'code', doc: 1 },
        { text: 'print', type: 'code', doc: 1 },
        { text: '<|end_of_text|>', type: 'separator', doc: 1 },
        { text: 'Climate', type: 'climate', doc: 2 },
        { text: 'change', type: 'climate', doc: 2 },
        { text: 'affects', type: 'climate', doc: 2 },
        { text: 'the', type: 'climate', doc: 2 },
        { text: 'planet', type: 'climate', doc: 2 },
        { text: '<|end_of_text|>', type: 'separator', doc: 2 }
      ];

      // Create the HTML structure
      container.innerHTML = `
        <div class="concatenated">
          <div class="section-title">Training sequence = concatenated files</div>
          <div class="token-sequence" id="tokenSequence">
            <!-- Tokens will be generated by JavaScript -->
          </div>
        </div>

        <div class="attention-comparison">
          <div class="attention-section">
            <div class="mask-type causal-mask">Causal Masking</div>
            <div class="matrix-container">
              <div class="doc-labels" id="causalLabels">
                <!-- Labels will be generated by JavaScript -->
              </div>
              <div class="attention-matrix" id="causalMatrix">
                <!-- Matrix will be generated by JavaScript -->
              </div>
              <div class="doc-labels-bottom" id="causalLabelsBottom">
                <!-- Bottom labels will be generated by JavaScript -->
              </div>
            </div>
          </div>

          <div class="attention-section">
            <div class="mask-type intradoc-mask">Intra-Document Masking</div>
            <div class="matrix-container">
              <div class="doc-labels" id="intradocLabels">
                <!-- Labels will be generated by JavaScript -->
              </div>
              <div class="attention-matrix" id="intradocMatrix">
                <!-- Matrix will be generated by JavaScript -->
              </div>
              <div class="doc-labels-bottom" id="intradocLabelsBottom">
                <!-- Bottom labels will be generated by JavaScript -->
              </div>
            </div>
          </div>
        </div>

        <div class="legend">
          <div class="legend-item">
            <div class="legend-box can-attend">✓</div>
            <span>Can Attend</span>
          </div>
          <div class="legend-item">
            <div class="legend-box cannot-attend">✗</div>
            <span>Cannot Attend</span>
          </div>
        </div>
        
        <div class="tooltip" id="tooltip"></div>
      `;

      // Render tokens
      function renderTokens() {
        const container = document.getElementById('tokenSequence');
        tokens.forEach((token, index) => {
          const tokenEl = document.createElement('span');
          tokenEl.className = `token token-${token.type}`;
          tokenEl.textContent = token.text;
          tokenEl.dataset.tokenIndex = index;
          container.appendChild(tokenEl);
        });
      }

      // Create attention matrix with labels
      function createAttentionMatrix(containerId, labelsId, bottomLabelsId, maskType) {
        const container = document.getElementById(containerId);
        const labelsContainer = document.getElementById(labelsId);
        const bottomLabelsContainer = document.getElementById(bottomLabelsId);
        const size = tokens.length;
        
        // Create side labels (Y-axis)
        labelsContainer.style.gridTemplateRows = `repeat(${size}, 18px)`;
        tokens.forEach((token, index) => {
          const label = document.createElement('div');
          
          if (token.doc === 0) {
            label.className = 'doc-label doc-recipe-label';
            if (index === 0) label.textContent = 'Recipe';
          } else if (token.doc === 1) {
            label.className = 'doc-label doc-code-label';
            if (index === 5) label.textContent = 'Code';
          } else if (token.doc === 2) {
            label.className = 'doc-label doc-climate-label';
            if (index === 9) label.textContent = 'Climate';
          } else {
            label.className = 'doc-label';
          }
          
          labelsContainer.appendChild(label);
        });

        // Create bottom labels (X-axis)
        bottomLabelsContainer.style.gridTemplateColumns = `repeat(${size}, 18px)`;
        tokens.forEach((token, index) => {
          const label = document.createElement('div');
          
          if (token.doc === 0) {
            label.className = 'doc-label-bottom doc-recipe-label';
            if (index === 0) label.textContent = 'Recipe';
          } else if (token.doc === 1) {
            label.className = 'doc-label-bottom doc-code-label';
            if (index === 5) label.textContent = 'Code';
          } else if (token.doc === 2) {
            label.className = 'doc-label-bottom doc-climate-label';
            if (index === 9) label.textContent = 'Climate';
          } else {
            label.className = 'doc-label-bottom';
          }
          
          bottomLabelsContainer.appendChild(label);
        });
        
        // Create attention matrix
        container.style.gridTemplateColumns = `repeat(${size}, 18px)`;
        container.style.gridTemplateRows = `repeat(${size}, 18px)`;

        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            const cell = document.createElement('div');
            cell.className = 'attention-cell';
            cell.dataset.row = i;
            cell.dataset.col = j;
            
            let canAttend = false;
            
            if (maskType === 'causal') {
              canAttend = j <= i;
            } else if (maskType === 'intradoc') {
              canAttend = j <= i && tokens[i].doc === tokens[j].doc;
            }
            
            if (canAttend) {
              cell.classList.add('can-attend');
              cell.textContent = '✓';
            } else {
              cell.classList.add('cannot-attend');
              cell.textContent = '✗';
            }
            
            // Add hover events for tooltip
            cell.addEventListener('mouseenter', (e) => {
              const tooltip = document.getElementById('tooltip');
              const fromToken = tokens[i];
              const toToken = tokens[j];
              const fromDoc = fromToken.doc === 0 ? 'Recipe' : fromToken.doc === 1 ? 'Code' : 'Climate';
              const toDoc = toToken.doc === 0 ? 'Recipe' : toToken.doc === 1 ? 'Code' : 'Climate';
              
              tooltip.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 2px;">${canAttend ? '✓ Can attend' : '✗ Cannot attend'}</div>
                <div style="font-size: 11px; color: var(--muted-color);">
                  From: "${fromToken.text}" (${fromDoc}, pos ${i})<br>
                  To: "${toToken.text}" (${toDoc}, pos ${j})
                </div>
              `;
              tooltip.classList.add('show');
              
              const rect = cell.getBoundingClientRect();
              const containerRect = document.querySelector('.doc-masking').getBoundingClientRect();
              tooltip.style.left = (rect.left - containerRect.left + rect.width / 2) + 'px';
              tooltip.style.top = (rect.top - containerRect.top - 35) + 'px';
            });
            
            cell.addEventListener('mouseleave', () => {
              const tooltip = document.getElementById('tooltip');
              tooltip.classList.remove('show');
            });
            
            container.appendChild(cell);
          }
        }
      }

      // Add hover effects for tokens
      function addTokenHoverEffects() {
        const tokenElements = document.querySelectorAll('.token');
        
        tokenElements.forEach((tokenEl, index) => {
          tokenEl.addEventListener('mouseenter', () => {
            // Highlight corresponding row and column in both matrices
            const matrices = document.querySelectorAll('.attention-matrix');
            matrices.forEach(matrix => {
              const cellSize = 18; // Size of each cell
              const gap = 2; // Gap between cells
              const rowPos = index * (cellSize + gap);
              const colPos = index * (cellSize + gap);
              
              // Create row highlight overlay
              const rowOverlay = document.createElement('div');
              rowOverlay.className = 'highlight-overlay row';
              rowOverlay.style.top = `${rowPos}px`;
              
              // Create column highlight overlay
              const colOverlay = document.createElement('div');
              colOverlay.className = 'highlight-overlay col';
              colOverlay.style.left = `${colPos}px`;
              
              // Add overlays to matrix
              matrix.appendChild(rowOverlay);
              matrix.appendChild(colOverlay);
              
              // Store references for cleanup
              matrix._rowOverlay = rowOverlay;
              matrix._colOverlay = colOverlay;
            });
          });
          
          tokenEl.addEventListener('mouseleave', () => {
            // Remove highlight overlays from all matrices
            const matrices = document.querySelectorAll('.attention-matrix');
            matrices.forEach(matrix => {
              if (matrix._rowOverlay) {
                matrix._rowOverlay.remove();
                matrix._rowOverlay = null;
              }
              if (matrix._colOverlay) {
                matrix._colOverlay.remove();
                matrix._colOverlay = null;
              }
            });
          });
        });
      }

      // Initialize the visualization
      renderTokens();
      createAttentionMatrix('causalMatrix', 'causalLabels', 'causalLabelsBottom', 'causal');
      createAttentionMatrix('intradocMatrix', 'intradocLabels', 'intradocLabelsBottom', 'intradoc');
      addTokenHoverEffects();
    };

    // Load color palettes script if not already loaded
    if (!window.ColorPalettes) {
      const script = document.createElement('script');
      script.src = '/scripts/color-palettes.js';
      script.onload = () => {
        if (window.ColorPalettes) {
          window.ColorPalettes.refresh();
        }
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
          bootstrap();
        }
      };
      document.head.appendChild(script);
    } else {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
      } else {
        bootstrap();
      }
    }
  })();
</script>
</div></div></figure> </div>
<p><span class="" id="citation--skyladder--27"><a href="https://arxiv.org/abs/2503.15450" id="refctx-bib-skyladder-1" data-ref-id="bib-skyladder" target="_blank" rel="noopener noreferrer">Zhu et al. (2025)</a></span> in SkyLadder found similar benefits from intra-document masking, but offer a different explanation. They found that shorter context lengths work better for training, and intra-document masking effectively reduces the average context length.</p>
<div class="wide"> <div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <div class="ri-root" data-ri-root="ri_54m2hh9wq28" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/image_27c1384e-bcac-807c-807b-fac08be1d884.C286JbWA_AmD26.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/image_27c1384e-bcac-807c-807b-fac08be1d884.C286JbWA.png" data-astro-cid-6kov3kig width="1800" height="513" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script>  </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>These plots from SkyLadder demonstrate multiple findings: (a) shorter contexts often perform better during pretraining (lower validation perplexity), (b) intra-document masking (IntraDoc) achieves lower perplexity than both random packing (Random) and semantic grouping (BM25), (c) the shorter context advantage holds even without positional encoding, and (d) IntraDoc creates a distribution skewed toward shorter effective context lengths.</figcaption> </figure> </div>  </div>
<p>Llama3 <span class="" id="citation--llama3--28">(<a href="https://arxiv.org/abs/2407.21783" id="refctx-bib-llama3-1" data-ref-id="bib-llama3" target="_blank" rel="noopener noreferrer">Grattafiori et al., 2024</a>)</span> also trained with intra-document masking, they found limited impact during short context pretraining but significant benefits for long-context extension, where the attention overhead becomes more significant. In addition, the ProLong paper <span class="" id="citation--prolong--29">(<a href="https://arxiv.org/abs/2410.02660" id="refctx-bib-prolong-1" data-ref-id="bib-prolong" target="_blank" rel="noopener noreferrer">Gao et al., 2025</a>)</span> showed that using document masking to extend Llama3 8B’s context in continual pretraining, benefits both long context and short context benchmarks.</p>
<p>We decided to run an ablation on our 1B baseline model and test whether document masking impacts short-context performance. You can find the config <a href="https://huggingface.co/datasets/HuggingFaceTB/training-guide-nanotron-configs/blob/main/doc_masking/doc_masking.yaml">here</a>. The results showed identical loss curves and downstream evaluation scores compared to standard causal masking, as shown in the charts below.</p>
<p>To enable document masking in nanotron, simply set this flag to  <code>true</code>  in the model config:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="diff"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">model_config:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  _attn_implementation: flash_attention_2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  _fused_rms_norm: true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  _fused_rotary_emb: true</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7"><span style="user-select:none">-</span> _use_doc_masking: false</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D"><span style="user-select:none">+</span> _use_doc_masking: true</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-9uxuontmfk9" data-config="{&#34;dataUrl&#34;:&#34;./data/doc-masking_loss.csv&#34;,&#34;xDomain&#34;:[0,45000000000],&#34;yDomain&#34;:[2.1,2.7],&#34;smoothing&#34;:true,&#34;title&#34;:&#34;Doc Masking Loss&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-csl8vnnkorj" data-config="{&#34;dataUrl&#34;:&#34;./data/doc-masking_evals.csv&#34;,&#34;charts&#34;:[{&#34;title&#34;:&#34;HellaSwag&#34;,&#34;metric&#34;:&#34;hellaswag&#34;},{&#34;title&#34;:&#34;MMLU&#34;,&#34;metric&#34;:&#34;mmlu&#34;},{&#34;title&#34;:&#34;ARC&#34;,&#34;metric&#34;:&#34;arc&#34;},{&#34;title&#34;:&#34;PIQA&#34;,&#34;metric&#34;:&#34;piqa&#34;},{&#34;title&#34;:&#34;OpenBookQA&#34;,&#34;metric&#34;:&#34;openbookqa&#34;},{&#34;title&#34;:&#34;WinoGrande&#34;,&#34;metric&#34;:&#34;winogrande&#34;}],&#34;smoothing&#34;:true,&#34;smoothingWindow&#34;:15}"><!-- 
  Multi-Line Charts Grid
  
  A configurable grid of line charts with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute:
  {
    "dataUrl": "./assets/data/your_data.csv",
    "charts": [
      { "title": "Chart 1", "metric": "metric1" },
      { "title": "Chart 2", "metric": "metric2" },
      ...
    ],
    "smoothingWindow": 15,
    "smoothingCurve": "monotoneX",
    "gridColumns": 3  // Optional: number of columns (default: 3)
  }
  
  CSV format: run_name, step, metric1, metric2, ...
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/d3-six-line-charts.html" 
    config={{ 
      dataUrl: "./assets/data/attention_evals.csv",
      charts: [
        { title: "HellaSwag", metric: "hellaswag" },
        { title: "MMLU", metric: "mmlu" },
        { title: "ARC", metric: "arc" },
        { title: "PIQA", metric: "piqa" },
        { title: "OpenBookQA", metric: "openbookqa" },
        { title: "WinoGrande", metric: "winogrande" }
      ],
      smoothingWindow: 15
    }} 
  />
-->
<div class="d3-multi-charts"></div>
<style>
  .d3-multi-charts {
    position: relative;
    container-type: inline-size;
  }

  /* Legend header */
  .d3-multi-charts__header {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
  }

  .d3-multi-charts__header .legend-bottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
    max-width: 80%;
  }

  .d3-multi-charts__header .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-multi-charts__header .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
    justify-content: center;
  }

  .d3-multi-charts__header .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-multi-charts__header .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  /* Grid */
  .d3-multi-charts__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }

  /* Container queries - basées sur la largeur du container parent, pas de la viewport */
  @container (max-width: 900px) {
    .d3-multi-charts__grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @container (max-width: 600px) {
    .d3-multi-charts__grid {
      grid-template-columns: 1fr;
    }
  }

  .chart-cell {
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
    box-shadow: inset 0 0 0 1px var(--border-color);
    border-radius: 8px;
  }

  .chart-cell__title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
    margin-bottom: 8px;
    padding-bottom: 8px;
  }

  .chart-cell__body {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .chart-cell__body svg {
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* Reset button */
  .chart-cell .reset-button {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
    display: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-size: 11px;
    padding: 3px 6px;
    border-radius: 4px;
    background: var(--surface-bg);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    cursor: pointer;
  }

  /* Axes */
  .d3-multi-charts .axes path {
    display: none;
  }

  .d3-multi-charts .axes line {
    stroke: var(--axis-color);
  }

  .d3-multi-charts .axes text {
    fill: var(--tick-color);
    font-size: 10px;
  }

  .d3-multi-charts .axis-label {
    fill: var(--text-color);
    font-size: 10px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    stroke-width: 3px;
    paint-order: stroke fill;
  }

  .d3-multi-charts .grid line {
    stroke: var(--grid-color);
  }

  /* Lines */
  .d3-multi-charts path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-multi-charts path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-multi-charts.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-multi-charts.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  .d3-multi-charts.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  /* Tooltip */
  .d3-multi-charts .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-multi-charts .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 200px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-multi-charts .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-multi-charts'))) {
        const cs = Array.from(document.querySelectorAll('.d3-multi-charts')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration
      const CONFIG = {
        dataUrl: embedConfig.dataUrl || './assets/data/attention_evals.csv',
        charts: embedConfig.charts || [],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        gridColumns: embedConfig.gridColumns || 3,
        chartHeight: 240,
        margin: { top: 20, right: 20, bottom: 40, left: 50 },
        zoomExtent: [1.0, 8],
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Value',
        xColumn: embedConfig.xColumn || 'tokens',
        runColumn: embedConfig.runColumn || 'run_name'
      };

      if (!CONFIG.charts.length) {
        container.innerHTML = '<p style="color: var(--danger); font-size: 12px;">Error: No charts configured</p>';
        return;
      }

      // Create legend header
      const header = document.createElement('div');
      header.className = 'd3-multi-charts__header';
      header.innerHTML = `
      <div class="legend-bottom">
        <div class="legend-title">Legend</div>
        <div class="items"></div>
      </div>
    `;
      container.appendChild(header);

      // Create grid
      const grid = document.createElement('div');
      grid.className = 'd3-multi-charts__grid';
      container.appendChild(grid);

      // Trackio footer removed

      // Create chart cells
      CONFIG.charts.forEach((chartConfig, idx) => {
        const cell = document.createElement('div');
        cell.className = 'chart-cell';
        cell.style.zIndex = CONFIG.charts.length - idx; // Stacking order
        cell.innerHTML = `
        <div class="chart-cell__title">${chartConfig.title}</div>
        <button class="reset-button">Reset</button>
        <div class="chart-cell__body"></div>
      `;
        grid.appendChild(cell);
      });

      // Data
      let allData = [];
      let runList = [];
      let runColorMap = {};

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].value)) { sum += values[j].value; count++; } }
          const avg = count ? (sum / count) : values[i].value;
          out[i] = { step: values[i].step, value: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Init each chart
      function initChart(cellElement, chartConfig) {
        const bodyEl = cellElement.querySelector('.chart-cell__body');
        const resetBtn = cellElement.querySelector('.reset-button');

        const metric = chartConfig.metric;
        let smoothEnabled = CONFIG.smoothing;
        let hasMoved = false;

        // Tooltip
        let tip = cellElement.querySelector('.d3-tooltip');
        let tipInner;
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'd3-tooltip';
          Object.assign(tip.style, {
            position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
            padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
            background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease', zIndex: '20'
          });
          tipInner = document.createElement('div');
          tipInner.className = 'd3-tooltip__inner';
          tip.appendChild(tipInner);
          cellElement.appendChild(tip);
        } else {
          tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
        }

        // Create SVG
        const svg = d3.select(bodyEl).append('svg').attr('width', '100%').style('display', 'block');

        // Clip path
        const clipId = 'clip-' + Math.random().toString(36).slice(2);
        const clipPath = svg.append('defs').append('clipPath').attr('id', clipId);
        const clipRect = clipPath.append('rect');

        // Groups
        const g = svg.append('g');
        const gGrid = g.append('g').attr('class', 'grid');
        const gAxes = g.append('g').attr('class', 'axes');
        const gPlot = g.append('g').attr('class', 'plot').attr('clip-path', `url(#${clipId})`);
        const gHover = g.append('g').attr('class', 'hover-layer');
        const overlay = g.append('rect').attr('class', 'overlay').attr('fill', 'none').attr('pointer-events', 'all').style('cursor', 'grab')
          .on('mousedown', function () {
            d3.select(this).style('cursor', 'grabbing');
            tip.style.opacity = '0';
            if (hoverLine) hoverLine.style('display', 'none');
          })
          .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

        // Scales
        const xScale = d3.scaleLinear();
        const yScale = d3.scaleLinear();

        // Hover state
        let hoverLine = null;
        let steps = [];
        let hideTipTimer = null;

        // Formatters (will be set in render())
        let formatStep = (v) => v;
        let formatValue = (v) => v;

        // Zoom
        const zoom = d3.zoom().scaleExtent(CONFIG.zoomExtent).on('zoom', zoomed);
        overlay.call(zoom);

        function zoomed(event) {
          const transform = event.transform;
          hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
          updateResetButton();

          const newXScale = transform.rescaleX(xScale);
          const newYScale = transform.rescaleY(yScale);

          const innerWidth = xScale.range()[1];

          // Update grid
          const gridTicks = newYScale.ticks(5);
          gGrid.selectAll('line').data(gridTicks).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => newYScale(d)).attr('y2', d => newYScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Update lines
          const line = d3.line()
            .x(d => newXScale(d.step))
            .y(d => newYScale(d.value))
            .curve(getCurve(smoothEnabled));

          gPlot.selectAll('path.ghost-line')
            .attr('d', d => {
              const rawLine = d3.line().x(d => newXScale(d.step)).y(d => newYScale(d.value)).curve(d3.curveLinear);
              return rawLine(d.values);
            });

          gPlot.selectAll('path.main-line')
            .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

          // Update axes
          gAxes.select('.x-axis').call(d3.axisBottom(newXScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.select('.y-axis').call(d3.axisLeft(newYScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
        }

        function updateResetButton() {
          if (hasMoved) {
            resetBtn.style.display = 'block';
            requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
          } else {
            resetBtn.style.opacity = '0';
            setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
          }
        }

        function render() {
          const rect = bodyEl.getBoundingClientRect();
          const width = Math.max(1, Math.round(rect.width || 400));
          const height = CONFIG.chartHeight;
          svg.attr('width', width).attr('height', height);

          const margin = CONFIG.margin;
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;

          g.attr('transform', `translate(${margin.left},${margin.top})`);

          // Filter data for this metric
          const metricData = allData.filter(d => d[metric] != null && !isNaN(d[metric]));

          if (!metricData.length) {
            return;
          }

          // Auto-compute domains from data
          const stepExtent = d3.extent(metricData, d => d.step);
          const valueExtent = d3.extent(metricData, d => d[metric]);

          xScale.domain(stepExtent).range([0, innerWidth]);
          yScale.domain(valueExtent).range([innerHeight, 0]);

          // Create smart formatters based on actual data
          const stepValues = metricData.map(d => d.step);
          const metricValues = metricData.map(d => d[metric]);
          formatStep = createSmartFormatter(stepValues);
          formatValue = createSmartFormatter(metricValues);

          // Update clip
          clipRect.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update overlay
          overlay.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update zoom extent
          zoom.extent([[0, 0], [innerWidth, innerHeight]])
            .translateExtent([[0, 0], [innerWidth, innerHeight]]);

          // Grid
          gGrid.selectAll('line').data(yScale.ticks(5)).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Axes
          gAxes.selectAll('*').remove();
          gAxes.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.append('g').attr('class', 'y-axis')
            .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
          gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');
          gAxes.selectAll('text').attr('fill', 'var(--tick-color)');

          // Axis labels
          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight + 32)
            .attr('text-anchor', 'middle')
            .text(CONFIG.xAxisLabel);

          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -38)
            .attr('text-anchor', 'middle')
            .text(CONFIG.yAxisLabel);

          // Group data by run
          const dataByRun = {};
          runList.forEach(run => { dataByRun[run] = []; });
          metricData.forEach(d => {
            if (dataByRun[d.run]) dataByRun[d.run].push({ step: d.step, value: d[metric] });
          });
          runList.forEach(run => { dataByRun[run].sort((a, b) => a.step - b.step); });

          const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] })).filter(s => s.values.length > 0);

          // Ghost lines
          const ghostLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(d3.curveLinear);
          gPlot.selectAll('path.ghost-line').data(series, d => d.run).join('path')
            .attr('class', 'ghost-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 1.5)
            .attr('opacity', smoothEnabled ? 0.15 : 0)
            .attr('pointer-events', 'none')
            .attr('d', d => ghostLine(d.values));

          // Main lines
          const mainLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(getCurve(smoothEnabled));
          gPlot.selectAll('path.main-line').data(series, d => d.run).join('path')
            .attr('class', 'main-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('opacity', 0.85)
            .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

          // Hover
          setupHover(series, innerWidth, innerHeight);
        }

        function setupHover(series, innerWidth, innerHeight) {
          gHover.selectAll('*').remove();

          hoverLine = gHover.append('line')
            .style('stroke', 'var(--text-color)')
            .attr('stroke-opacity', 0.25)
            .attr('stroke-width', 1)
            .attr('y1', 0)
            .attr('y2', innerHeight)
            .style('display', 'none')
            .attr('pointer-events', 'none');

          const stepSet = new Set();
          series.forEach(s => s.values.forEach(v => stepSet.add(v.step)));
          steps = Array.from(stepSet).sort((a, b) => a - b);

          overlay.on('mousemove', function (ev) {
            if (ev.buttons === 0) onHoverMove(ev, series);
          }).on('mouseleave', onHoverLeave);
        }

        function onHoverMove(ev, series) {
          if (hideTipTimer) { clearTimeout(hideTipTimer); hideTipTimer = null; }

          const [mx, my] = d3.pointer(ev, overlay.node());
          const targetStep = xScale.invert(mx);
          const nearest = steps.reduce((best, t) => Math.abs(t - targetStep) < Math.abs(best - targetStep) ? t : best, steps[0]);

          const xpx = xScale(nearest);
          hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

          let html = `<div><strong>${chartConfig.title}</strong></div>`;
          html += `<div>${formatStep(nearest)}</div>`;

          const entries = series.map(s => {
            const values = s.values;
            let before = null, after = null;
            for (let i = 0; i < values.length; i++) {
              if (values[i].step <= nearest) before = values[i];
              if (values[i].step >= nearest && !after) { after = values[i]; break; }
            }

            let interpolatedValue = null;
            if (before && after && before.step !== after.step) {
              const t = (nearest - before.step) / (after.step - before.step);
              interpolatedValue = before.value + t * (after.value - before.value);
            } else if (before && before.step === nearest) {
              interpolatedValue = before.value;
            } else if (after && after.step === nearest) {
              interpolatedValue = after.value;
            } else if (before) {
              interpolatedValue = before.value;
            } else if (after) {
              interpolatedValue = after.value;
            }

            return { run: s.run, color: s.color, value: interpolatedValue };
          }).filter(e => e.value != null);

          entries.sort((a, b) => b.value - a.value);

          entries.forEach(e => {
            html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.value.toFixed(4)}</span></div>`;
          });

          tipInner.innerHTML = html;
          const offsetX = 12, offsetY = 12;
          tip.style.opacity = '1';
          tip.style.transform = `translate(${Math.round(mx + offsetX + CONFIG.margin.left)}px, ${Math.round(my + offsetY + CONFIG.margin.top)}px)`;
        }

        function onHoverLeave() {
          hideTipTimer = setTimeout(() => {
            tip.style.opacity = '0';
            tip.style.transform = 'translate(-9999px, -9999px)';
            if (hoverLine) hoverLine.style('display', 'none');
          }, 100);
        }

        // Reset button
        resetBtn.addEventListener('click', () => {
          overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        });

        return { render };
      }

      // Load data
      async function load() {
        try {
          const response = await fetch(CONFIG.dataUrl, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);

          const csvText = await response.text();

          // Parse CSV (long format: run_name, metric, tokens, value)
          const rawRows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            metric: (d.metric || '').trim(),
            tokens: +d[CONFIG.xColumn],
            value: +d.value
          }));

          // Pivot data: group by run + tokens, create columns for each metric
          const pivotMap = new Map();
          rawRows.forEach(row => {
            if (isNaN(row.tokens) || isNaN(row.value)) return;

            const key = `${row.run}|${row.tokens}`;
            if (!pivotMap.has(key)) {
              pivotMap.set(key, { run: row.run, step: row.tokens });
            }
            const pivotRow = pivotMap.get(key);
            pivotRow[row.metric] = row.value;
          });

          allData = Array.from(pivotMap.values());

          runList = Array.from(new Set(allData.map(d => d.run))).sort();

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => { runColorMap[run] = colors[i % colors.length]; });

          // Build legend
          const legendItemsHost = header.querySelector('.legend-bottom .items');
          if (legendItemsHost) {
            legendItemsHost.innerHTML = runList.map(run => {
              const color = runColorMap[run];
              return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
            }).join('');

            // Add hover interactions
            legendItemsHost.querySelectorAll('.item').forEach(el => {
              el.addEventListener('mouseenter', () => {
                const run = el.getAttribute('data-run');
                container.classList.add('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                grid.querySelectorAll('path.ghost-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                legendItemsHost.querySelectorAll('.item').forEach(it => {
                  it.classList.toggle('ghost', it.getAttribute('data-run') !== run);
                });
              });

              el.addEventListener('mouseleave', () => {
                container.classList.remove('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => path.classList.remove('ghost'));
                grid.querySelectorAll('path.ghost-line').forEach(path => path.classList.remove('ghost'));
                legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
              });
            });
          }

          // Init all charts
          const cells = Array.from(grid.querySelectorAll('.chart-cell'));
          const chartInstances = cells.map((cell, idx) => initChart(cell, CONFIG.charts[idx]));

          // Render all
          chartInstances.forEach(chart => chart.render());

          // Responsive - observe container for resize
          let resizeTimer;
          const handleResize = () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              chartInstances.forEach(chart => chart.render());
            }, 100);
          };

          const ro = window.ResizeObserver ? new ResizeObserver(handleResize) : null;
          if (ro) {
            ro.observe(container);
          }

          // Also observe window resize as fallback
          window.addEventListener('resize', handleResize);

          // Force a re-render after a short delay to ensure proper sizing
          setTimeout(() => {
            chartInstances.forEach(chart => chart.render());
          }, 100);

        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure> </div>
<p>We don’t observe any impact on short context tasks, similar to Llama3. However, document masking becomes crucial when scaling to long sequences to speed up the training. This is particularly important for our long context extension, where we scale from 4k to 64k tokens (detailed in the <a href="#training-marathon">Training marathon</a> chapter). We therefore adopted it for SmolLM3 throughout the full training run.</p>
<p>We’ve covered in this section how attention processes sequences. Now let’s look at another major parameter block in transformers: the embeddings.</p>
<h4 id="embedding-sharing"><a href="#embedding-sharing"><strong>Embedding sharing</strong></a></h4>
<p>If you look at the <a href="https://huggingface.co/datasets/HuggingFaceTB/training-guide-nanotron-configs/blob/main/baseline_config_1B.yaml">config</a> of our baseline ablation model, one thing that is different from a standard transformer is embedding sharing enabled by the flag  <code>tie_word_embeddings</code> .</p>
<p>LLMs have two embedding components: input embeddings that serve as a token-to-vector lookup table (of size vocab_size × hidden_dim) and the output embeddings, which is the final linear layer mapping hidden states to vocabulary logits (hidden_dim × vocab_size). In the classic case where these are separate matrices, total embedding parameters are 2 × vocab_size × hidden_dim. Therefore, in small language models, embeddings can constitute a large portion of the total parameter count, especially with a large vocabulary size. This makes embedding sharing (reusing input embeddings in the output) a natural optimization for small models.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-pbbase2xbbl"><div class="d3-embedding-calculator"></div>

<style>
  .d3-embedding-calculator {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.5;
    color: var(--text-color);
  }

  .d3-embedding-calculator .controls-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
  }

  .d3-embedding-calculator .slider-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
    position: relative;
  }

  .d3-embedding-calculator .slider-group label {
    font-size: 0.8em;
    font-weight: 700;
    color: var(--text-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .d3-embedding-calculator .slider-value {
    font-size: 0.75em;
    color: var(--muted-color);
    font-weight: 600;
  }

  /* Slider styling */
  .d3-embedding-calculator input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    height: 6px;
    border-radius: 3px;
    position: relative;
  }

  /* Slider container for progress bar */
  .d3-embedding-calculator .slider-group::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 6px;
    background: var(--border-color);
    border-radius: 3px;
    pointer-events: none;
  }

  .d3-embedding-calculator .slider-group::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: var(--progress-width, 0%);
    height: 6px;
    background: var(--primary-color);
    border-radius: 3px;
    pointer-events: none;
    transition: width 0.1s ease;
  }

  /* Webkit slider thumb */
  .d3-embedding-calculator input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    background: var(--primary-color);
    height: 18px;
    width: 18px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid var(--page-bg);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  /* Firefox slider thumb */
  .d3-embedding-calculator input[type="range"]::-moz-range-thumb {
    background: var(--primary-color);
    height: 18px;
    width: 18px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid var(--page-bg);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .d3-embedding-calculator .results-summary {
    margin: 20px 0 24px 0;
    text-align: center;
  }

  .d3-embedding-calculator .summary-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 16px;
    margin-bottom: 16px;
  }

  .d3-embedding-calculator .summary-card {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    text-align: center;
  }

  .d3-embedding-calculator .summary-label {
    font-size: 0.7em;
    color: var(--text-color);
    margin-bottom: 8px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .d3-embedding-calculator .summary-value {
    font-weight: 700;
    color: var(--primary-color);
    font-size: 1.1em;
    line-height: 1.2;
  }

  .d3-embedding-calculator .savings-highlight {
    background: color-mix(in srgb, var(--primary-color) 10%, transparent);
    border: 1px solid color-mix(in srgb, var(--primary-color) 30%, var(--border-color));
    border-radius: 8px;
    padding: 12px 16px;
    color: var(--primary-color);
    font-weight: 600;
    font-size: 0.9em;
    display: inline-block;
  }

  .d3-embedding-calculator .comparison {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 20px 0 0 0;
  }

  .d3-embedding-calculator .network-side {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    text-align: center;
    position: relative;
  }

  .d3-embedding-calculator .no-tying {}

  .d3-embedding-calculator .with-tying {
    position: relative;
  }

  .d3-embedding-calculator .sharing-arrow {
    position: absolute;
    right: 20px;
    top: 240px;
    bottom: 100px;
    width: 2px;
    background: var(--primary-color);
    z-index: 10;
  }

  .d3-embedding-calculator .sharing-arrow::before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 25px;
    height: 2px;
    background: var(--primary-color);
  }

  .d3-embedding-calculator .sharing-arrow::after {
    content: '';
    position: absolute;
    bottom: 0;
    right: 0;
    width: 25px;
    height: 2px;
    background: var(--primary-color);
  }

  .d3-embedding-calculator .arrow-head-top {
    position: absolute;
    top: -3px;
    left: -25px;
    width: 0;
    height: 0;
    border-right: 6px solid var(--primary-color);
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
  }

  .d3-embedding-calculator .arrow-head-bottom {
    position: absolute;
    bottom: -3px;
    left: -25px;
    width: 0;
    height: 0;
    border-right: 6px solid var(--primary-color);
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
  }

  .d3-embedding-calculator .network-icon {
    font-size: 0.8em;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
  }

  .d3-embedding-calculator .network-icon.check {
    color: #22c55e;
  }

  .d3-embedding-calculator .network-icon.cross {
    color: #ef4444;
  }

  .d3-embedding-calculator .network-icon-text {
    font-weight: 600;
    font-size: 0.9em;
  }

  .d3-embedding-calculator .network-title {
    font-weight: 700;
    font-size: 1em;
    margin-bottom: 15px;
    color: var(--text-color);
  }

  .d3-embedding-calculator .model-size {
    font-size: 1.1em;
    font-weight: 600;
    margin-bottom: 20px;
  }

  .d3-embedding-calculator .model-size.untied {
    color: color-mix(in srgb, #cc6600 80%, var(--text-color));
  }

  .d3-embedding-calculator .model-size.tied {
    color: var(--primary-color);
  }

  .d3-embedding-calculator .network-layer {
    margin: 15px 0;
  }

  .d3-embedding-calculator .layer-title {
    font-size: 0.8em;
    color: var(--muted-color);
    margin-bottom: 8px;
    font-weight: 500;
  }

  .d3-embedding-calculator .matrix-visual {
    display: inline-block;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 10px;
    background: var(--surface-bg);
    margin: 5px 0;
  }

  .d3-embedding-calculator .matrix-grid {
    display: grid;
    gap: 2px;
    margin: 8px 0;
  }

  .d3-embedding-calculator .matrix-cell {
    width: 12px;
    height: 12px;
    background: var(--primary-color);
    border-radius: 2px;
  }


  .d3-embedding-calculator .matrix-label {
    font-size: 0.7em;
    color: var(--muted-color);
    margin: 5px 0;
    font-family: 'Courier New', monospace;
  }

  .d3-embedding-calculator .neurons-layer {
    display: flex;
    justify-content: center;
    gap: 4px;
    margin: 12px 0;
    flex-wrap: wrap;
  }

  .d3-embedding-calculator .neuron {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--muted-color);
  }

  .d3-embedding-calculator .dots {
    font-size: 1.2em;
    color: var(--muted-color);
    margin: 10px 0;
  }

  .d3-embedding-calculator .connection-line {
    width: 2px;
    height: 15px;
    background: var(--border-color);
    margin: 0 auto;
  }


  .d3-embedding-calculator .results-detail {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    margin: 20px 0;
  }

  .d3-embedding-calculator .result-item {
    margin: 12px 0;
    font-size: 0.9em;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .d3-embedding-calculator .result-value {
    font-weight: 600;
    color: var(--primary-color);
  }

  .d3-embedding-calculator .savings {
    color: var(--primary-color);
    font-weight: 600;
  }

  /* Responsive design */
  @media (max-width: 768px) {
    .d3-embedding-calculator .controls-grid {
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .d3-embedding-calculator .comparison {
      grid-template-columns: 1fr;
      gap: 16px;
    }

    .d3-embedding-calculator .summary-grid {
      grid-template-columns: 1fr;
      gap: 12px;
    }

  }

  @media (max-width: 480px) {
    .d3-embedding-calculator {
      padding: 16px;
    }

    .d3-embedding-calculator .results-summary,
    .d3-embedding-calculator .results-detail {
      padding: 16px;
    }

    .d3-embedding-calculator .network-side {
      padding: 16px;
    }
  }
</style>

<script>
  (() => {
    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-embedding-calculator'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-embedding-calculator'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Create the calculator interface
      container.innerHTML = `
        <div class="controls-grid">
          <div class="slider-group">
            <label for="vocabSize">Vocabulary Size <span class="slider-value" id="vocabValue">128k</span></label>
            <input type="range" id="vocabSize" min="32000" max="256000" step="1000" value="128000">
          </div>
          <div class="slider-group">
            <label for="hiddenSize">Hidden Size <span class="slider-value" id="hiddenValue">2048</span></label>
            <input type="range" id="hiddenSize" min="512" max="8192" step="64" value="2048">
          </div>
          <div class="slider-group">
            <label for="modelSize">Total Model Size (M) <span class="slider-value" id="modelValue">1460M</span></label>
            <input type="range" id="modelSize" min="100" max="10000" step="100" value="1460">
          </div>
        </div>
        
        <div class="results-summary">
          <div class="summary-grid">
            <div class="summary-card">
              <div class="summary-label">Total Embedding Parameters</div>
              <div class="summary-value" id="totalEmbeddingTop">524M</div>
            </div>
            <div class="summary-card">
              <div class="summary-label">Percentage of Model</div>
              <div class="summary-value" id="percentageTop">44%</div>
            </div>
            <div class="summary-card">
              <div class="summary-label">Weight Tying Savings</div>
              <div class="summary-value" id="savingsTop">262M (22%)</div>
            </div>
          </div>
        </div>
        
        <div class="comparison">
          <div class="network-side no-tying">
            <div class="network-icon cross"></div>
            <div class="network-title">Separate Embeddings</div>
            <div class="model-size untied" id="modelSizeUntied">1.46B</div>
            
            <div class="network-layer">
              <div class="layer-title">Input Embedding</div>
              <div class="matrix-visual">
                <div class="matrix-grid" id="inputMatrix1"></div>
                <div class="matrix-label" id="inputDim1">128k × 2048</div>
              </div>
            </div>
            
            <div class="connection-line"></div>
            
            <div class="network-layer">
              <div class="layer-title">Layer 1</div>
              <div class="neurons-layer" id="neurons1"></div>
            </div>
            
            <div class="dots">⋮</div>
            
            <div class="network-layer">
              <div class="layer-title">Layer N</div>
              <div class="neurons-layer" id="neurons2"></div>
            </div>
            
            <div class="connection-line"></div>
            
            <div class="network-layer">
              <div class="layer-title">Output Projection</div>
              <div class="matrix-visual">
                <div class="matrix-grid" id="outputMatrix1"></div>
                <div class="matrix-label" id="outputDim1">2048 × 128k</div>
              </div>
            </div>
          </div>
          
          <div class="network-side with-tying">
            <div class="network-icon check"></div>
            <div class="network-title">Tied Embeddings</div>
            <div class="model-size tied" id="modelSizeTied">1.20B</div>
            <div class="sharing-arrow">
              <div class="arrow-head-top"></div>
              <div class="arrow-head-bottom"></div>
            </div>
            
            <div class="network-layer">
              <div class="layer-title">Input Embedding</div>
              <div class="matrix-visual">
                <div class="matrix-grid" id="inputMatrix2"></div>
                <div class="matrix-label" id="inputDim2">128k × 2048</div>
              </div>
            </div>
            
            <div class="connection-line"></div>
            
            <div class="network-layer">
              <div class="layer-title">Layer 1</div>
              <div class="neurons-layer" id="neurons3"></div>
            </div>
            
            <div class="dots">⋮</div>
            
            <div class="network-layer">
              <div class="layer-title">Layer N</div>
              <div class="neurons-layer" id="neurons4"></div>
            </div>
            
            <div class="connection-line"></div>
            
            <div class="network-layer">
              <div class="layer-title">Output Projection (Shared)</div>
              <div class="matrix-visual">
                <div class="matrix-grid" id="outputMatrix2"></div>
                <div class="matrix-label" id="outputDim2">2048 × 128k</div>
              </div>
            </div>
            
          </div>
        </div>
        
      `;

      function createMatrix(containerId, rows, cols, isOutput = false, isSeparate = true, color = null) {
        const container = document.getElementById(containerId);

        if (isOutput) {
          // Output matrices (2048 × 128k) - MORE COLUMNS than rows (transposed)
          container.style.gridTemplateColumns = `repeat(${Math.min(cols, 12)}, 1fr)`;
          const totalCells = Math.min(rows * cols, 64);
          container.innerHTML = '';

          for (let i = 0; i < totalCells; i++) {
            const cell = document.createElement('div');
            cell.className = 'matrix-cell';
            if (isSeparate) {
              cell.classList.add('output-separate');
            }
            if (color) {
              cell.style.backgroundColor = color;
            }
            container.appendChild(cell);
          }
        } else {
          // Input matrices (128k × 2048) - more rows than columns
          container.style.gridTemplateColumns = `repeat(${Math.min(cols, 8)}, 1fr)`;
          const totalCells = Math.min(rows * cols, 64);
          container.innerHTML = '';

          for (let i = 0; i < totalCells; i++) {
            const cell = document.createElement('div');
            cell.className = 'matrix-cell';
            if (color) {
              cell.style.backgroundColor = color;
            }
            container.appendChild(cell);
          }
        }
      }

      function createNeurons(containerId, count) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';

        const displayCount = Math.min(count, 12);
        for (let i = 0; i < displayCount; i++) {
          const neuron = document.createElement('div');
          neuron.className = 'neuron';
          container.appendChild(neuron);
        }
      }

      function updateSliderValues() {
        const vocabSize = parseInt(container.querySelector('#vocabSize').value) || 0;
        const hiddenSize = parseInt(container.querySelector('#hiddenSize').value) || 0;
        const modelSize = parseInt(container.querySelector('#modelSize').value) || 0;

        container.querySelector('#vocabValue').innerHTML = vocabSize >= 1000 ? `${(vocabSize / 1000).toFixed(0)} <span style="opacity: 0.6;">k</span>` : vocabSize.toString();
        container.querySelector('#hiddenValue').textContent = hiddenSize.toString();
        container.querySelector('#modelValue').innerHTML = `${modelSize} <span style="opacity: 0.6;">M</span>`;

        // Update progress bars
        const vocabSlider = container.querySelector('#vocabSize').parentElement;
        const hiddenSlider = container.querySelector('#hiddenSize').parentElement;
        const modelSlider = container.querySelector('#modelSize').parentElement;

        const vocabProgress = ((vocabSize - 32000) / (256000 - 32000)) * 100;
        const hiddenProgress = ((hiddenSize - 512) / (8192 - 512)) * 100;
        const modelProgress = ((modelSize - 100) / (10000 - 100)) * 100;

        vocabSlider.style.setProperty('--progress-width', `${vocabProgress}%`);
        hiddenSlider.style.setProperty('--progress-width', `${hiddenProgress}%`);
        modelSlider.style.setProperty('--progress-width', `${modelProgress}%`);
      }

      function updateVisualizations() {
        const vocabSize = parseInt(container.querySelector('#vocabSize').value) || 0;
        const hiddenSize = parseInt(container.querySelector('#hiddenSize').value) || 0;

        // Get categorical colors for input and output projections
        let inputColor = 'var(--primary-color)';
        let outputColor = 'var(--primary-color)';

        try {
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            const colors = window.ColorPalettes.getColors('categorical', 2);
            if (colors && colors.length >= 2) {
              inputColor = colors[0];
              outputColor = colors[1];
            }
          }
        } catch (_) { }

        // Calculate display dimensions (scaled for visualization)
        const vocabDisplay = Math.min(Math.ceil(Math.sqrt(vocabSize / 5000)), 8);
        const hiddenDisplay = Math.min(Math.ceil(Math.sqrt(hiddenSize / 200)), 8);
        const neuronCount = Math.min(hiddenSize / 200, 12);

        // Update matrix visualizations with different colors
        createMatrix('inputMatrix1', vocabDisplay, hiddenDisplay, false, true, inputColor);
        createMatrix('outputMatrix1', hiddenDisplay, vocabDisplay, true, true, outputColor); // Transposed for output
        createMatrix('inputMatrix2', vocabDisplay, hiddenDisplay, false, false, inputColor);
        createMatrix('outputMatrix2', hiddenDisplay, vocabDisplay, true, false, inputColor); // Transposed, shared (same as input)

        // Update neurons
        createNeurons('neurons1', neuronCount);
        createNeurons('neurons2', neuronCount);
        createNeurons('neurons3', neuronCount);
        createNeurons('neurons4', neuronCount);

        // Update dimensions labels
        const vocabK = vocabSize >= 1000 ? `${Math.round(vocabSize / 1000)}k` : vocabSize;
        const hiddenK = hiddenSize >= 1000 ? `${Math.round(hiddenSize / 1000)}k` : hiddenSize;

        container.querySelector('#inputDim1').textContent = `${vocabK} × ${hiddenK}`;
        container.querySelector('#outputDim1').textContent = `${hiddenK} × ${vocabK}`;
        container.querySelector('#inputDim2').textContent = `${vocabK} × ${hiddenK}`;
        container.querySelector('#outputDim2').innerHTML = `${hiddenK} × ${vocabK}<br><span style="font-size: 0.8em; opacity: 0.7;">(Transposed)</span>`;
      }

      function updateCalculations() {
        const vocabSize = parseInt(container.querySelector('#vocabSize').value) || 0;
        const hiddenSize = parseInt(container.querySelector('#hiddenSize').value) || 0;
        const modelSize = parseInt(container.querySelector('#modelSize').value) || 0;

        updateSliderValues();

        const embeddingParams = vocabSize * hiddenSize;
        const totalEmbeddingParams = embeddingParams * 2; // Input + Output
        const percentage = modelSize > 0 ? ((totalEmbeddingParams / (modelSize * 1000000)) * 100).toFixed(0) : 0;
        const savings = embeddingParams;
        const savingsPercentage = modelSize > 0 ? ((savings / (modelSize * 1000000)) * 100).toFixed(0) : 0;

        // Calculate model sizes (assuming input model size is WITHOUT tying - untied)
        const untiedModelSize = modelSize; // Input model size (without tying)
        const tiedModelSize = modelSize - (savings / 1000000); // Subtract the embedding params saved

        // Format numbers with reduced opacity suffixes
        const formatNumber = (num) => {
          if (num >= 1000000000) return `${(num / 1000000000).toFixed(1)} <span style="opacity: 0.6;">B</span>`;
          if (num >= 1000000) return `${(num / 1000000).toFixed(1)} <span style="opacity: 0.6;">M</span>`;
          if (num >= 1000) return `${(num / 1000).toFixed(0)} <span style="opacity: 0.6;">k</span>`;
          return num.toString();
        };

        // Get categorical colors for model sizes
        let untiedColor = 'color-mix(in srgb, #cc6600 80%, var(--text-color))';
        let tiedColor = 'var(--primary-color)';

        try {
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            const colors = window.ColorPalettes.getColors('categorical', 2);
            if (colors && colors.length >= 2) {
              untiedColor = colors[1]; // Use second color for "DON'T"
              tiedColor = colors[0];   // Use first color for "DO"
            }
          }
        } catch (_) { }

        // Update model size displays with colors
        const untiedElement = container.querySelector('#modelSizeUntied');
        const tiedElement = container.querySelector('#modelSizeTied');

        untiedElement.innerHTML = formatNumber(untiedModelSize * 1000000);
        tiedElement.innerHTML = formatNumber(tiedModelSize * 1000000);

        untiedElement.style.color = untiedColor;
        tiedElement.style.color = tiedColor;

        container.querySelector('#totalEmbeddingTop').innerHTML = formatNumber(totalEmbeddingParams);
        container.querySelector('#percentageTop').innerHTML = `${percentage} <span style="opacity: 0.6;">%</span>`;
        container.querySelector('#savingsTop').innerHTML =
          `${formatNumber(savings)} <span style="opacity: 0.6;">(${savingsPercentage}%)</span>`;

        updateVisualizations();
      }

      // Add event listeners
      container.querySelector('#vocabSize').addEventListener('input', updateCalculations);
      container.querySelector('#hiddenSize').addEventListener('input', updateCalculations);
      container.querySelector('#modelSize').addEventListener('input', updateCalculations);

      // Initialize
      updateSliderValues();
      updateCalculations();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
    } else {
      bootstrap();
    }
  })();
</script></div></div></figure>
<p>Larger models don’t typically use this technique since embeddings represent a smaller fraction of their parameter budget. For example, total embeddings without sharing account for only 13% in Llama3.2 8B and 3% in Llama3.1 70B as show in the pie chart below.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-jek2zy9iesd"><div class="d3-parameter-comparison"></div>

<style>
  .d3-parameter-comparison {
    position: relative !important;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.5;
    color: var(--text-color);
    padding-bottom: 0;
  }

  .d3-parameter-comparison .model-selector {
    margin-bottom: 32px;
  }

  .d3-parameter-comparison .section-title {
    font-size: 1.1em;
    font-weight: 700;
    color: var(--text-color);
    margin: 0 0 12px 0;
  }

  .d3-parameter-comparison .button-group {
    display: flex;
    gap: 0;
    width: 100%;
    background: var(--page-bg);
    border: 0.25px solid var(--primary-color);
    border-radius: 8px;
    padding: 0;
    margin-bottom: 24px;
  }

  .d3-parameter-comparison .actions-group {
    display: flex;
    gap: 8px;
    width: 100%;
  }

  .d3-parameter-comparison .actions-group .button {
    flex: 1;
    margin: 0 !important;
    border-radius: var(--button-radius) !important;
    border: 1px solid var(--primary-color) !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    text-align: center !important;
    gap: 8px !important;
  }

  .d3-parameter-comparison .btn-icon {
    flex-shrink: 0;
    opacity: 0.8;
    transition: opacity 0.2s ease;
  }

  .d3-parameter-comparison .actions-group .button:hover .btn-icon {
    opacity: 1;
  }

  /* Utilisation des styles de boutons du template */
  .d3-parameter-comparison .button-group {
    display: flex;
    gap: 0;
    width: 100%;
    background: var(--page-bg);
    border: 0.25px solid var(--primary-color);
    border-radius: 8px;
    padding: 0;
    margin-bottom: 24px;
  }

  .d3-parameter-comparison .button-group .button {
    flex: 1;
    margin: 0 !important;
    border-radius: 0 !important;
    border: none !important;
    padding: calc(var(--button-padding-y) * 2) var(--button-padding-x) !important;
  }

  .d3-parameter-comparison .button-group .button:first-child {
    border-radius: 8px 0 0 8px !important;
  }

  .d3-parameter-comparison .button-group .button:last-child {
    border-radius: 0 8px 8px 0 !important;
  }

  .d3-parameter-comparison .button-group .button:not(:first-child) {
    border-left: 1px solid var(--primary-color) !important;
  }

  .d3-parameter-comparison .button-group .button.active {
    background: var(--primary-color) !important;
    color: var(--page-bg) !important;
    font-weight: 900 !important;
  }

  .d3-parameter-comparison .button-group .button.active:first-child {
    border-left: none !important;
  }


  .d3-parameter-comparison .model-info {
    margin: 10px 0;
  }

  .d3-parameter-comparison .model-size-card {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    margin: 16px 0 20px 0;
    text-align: center;
    width: 100%;
  }

  .d3-parameter-comparison .model-size-label {
    font-size: 0.8em;
    font-weight: 500;
    color: var(--muted-color);
    margin: 0 0 4px 0;
  }

  .d3-parameter-comparison .model-size {
    font-size: 1.8em;
    font-weight: bold;
    color: var(--primary-color);
    margin: 0 0 4px 0;
  }

  .d3-parameter-comparison .model-specs {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 12px;
    margin-bottom: 20px;
  }

  .d3-parameter-comparison .spec-card {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px 8px;
    text-align: center;
    position: relative;
    overflow: hidden;
  }

  .d3-parameter-comparison .spec-label {
    font-size: 0.65em;
    color: var(--muted-color);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    margin-bottom: 6px;
    line-height: 1.1;
  }

  .d3-parameter-comparison .spec-value {
    font-weight: 700;
    color: var(--primary-color);
    font-size: 1.0em;
    line-height: 1.1;
    word-break: break-all;
  }

  /* Special styling for different value types */
  .d3-parameter-comparison .spec-card[data-type="number"] .spec-value {
    font-size: 1.1em;
    font-variant-numeric: tabular-nums;
  }

  .d3-parameter-comparison .spec-card[data-type="ratio"] .spec-value {
    font-size: 0.95em;
    font-variant-numeric: tabular-nums;
  }

  .d3-parameter-comparison .spec-card[data-type="text"] .spec-value {
    font-size: 0.9em;
    text-transform: capitalize;
  }

  .d3-parameter-comparison .chart-container {
    margin: 20px 0 0 0;
  }

  .d3-parameter-comparison .chart-card {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 8px;
  }

  .d3-parameter-comparison .legend {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    margin: 8px 0 16px 0;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-parameter-comparison .legend .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-parameter-comparison .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-parameter-comparison .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-parameter-comparison .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Labels with contrast liseret */
  .d3-parameter-comparison .slice-label {
    font-size: 11px;
    font-weight: 700;
    fill: var(--text-color);
    paint-order: stroke;
    stroke: var(--transparent-page-contrast);
    stroke-width: 3px;
  }

  /* Hover effects */
  .d3-parameter-comparison.hovering .legend .item.ghost {
    opacity: .35;
  }

  .d3-parameter-comparison .slice {
    transition: opacity .15s ease;
  }

  .d3-parameter-comparison.hovering .slice.ghost {
    opacity: .25;
  }

  /* Tooltip */
  .d3-parameter-comparison .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.35;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, .18);
    opacity: 0;
    transition: opacity .12s ease;
    z-index: var(--z-elevated);
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-parameter-comparison .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
    text-align: left;
  }

  .d3-parameter-comparison .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-parameter-comparison .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-parameter-comparison .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-parameter-comparison .d3-tooltip .swatch {
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
    margin-right: 6px;
  }


  /* Responsive */
  @media (max-width: 768px) {
    .d3-parameter-comparison .model-specs {
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }

    .d3-parameter-comparison .button-group {
      flex-direction: column;
      gap: 4px;
    }

    .d3-parameter-comparison .actions-group {
      flex-direction: column;
      gap: 4px;
    }

    .d3-parameter-comparison .button-group .button,
    .d3-parameter-comparison .actions-group .button {
      padding: 8px 12px;
    }
  }

  @media (max-width: 480px) {
    .d3-parameter-comparison .model-specs {
      grid-template-columns: 1fr;
    }

    .d3-parameter-comparison .section-title {
      font-size: 1em;
    }
  }
</style>

<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-parameter-comparison'))) {
        const cs = Array.from(document.querySelectorAll('.d3-parameter-comparison')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      container.style.position = container.style.position || 'relative';


      // Model configurations
      const models = {
        'llama3.2-1b': {
          name: 'Llama 3.2 1B',
          configUrl: 'https://huggingface.co/meta-llama/Llama-3.2-1B/blob/main/config.json',
          vocab_size: 128256,
          hidden_size: 2048,
          num_hidden_layers: 16,
          num_attention_heads: 32,
          num_key_value_heads: 8,
          intermediate_size: 8192,
          tie_word_embeddings: true
        },
        'smollm3-3b': {
          name: 'SmolLM3 3B',
          configUrl: 'https://huggingface.co/HuggingFaceTB/SmolLM3-3B/blob/main/config.json',
          vocab_size: 128256,
          hidden_size: 2048,
          num_hidden_layers: 36,
          num_attention_heads: 16,
          num_key_value_heads: 4,
          intermediate_size: 11008,
          tie_word_embeddings: true
        },
        'llama3.1-8b': {
          name: 'Llama 3.1 8B',
          configUrl: 'https://huggingface.co/meta-llama/Llama-3.1-8B/blob/main/config.json',
          vocab_size: 128256,
          hidden_size: 4096,
          num_hidden_layers: 32,
          num_attention_heads: 32,
          num_key_value_heads: 8,
          intermediate_size: 14336,
          tie_word_embeddings: false
        },
        'llama3.1-70b': {
          name: 'Llama 3.1 70B',
          configUrl: 'https://huggingface.co/meta-llama/Llama-3.1-70B/blob/main/config.json',
          vocab_size: 128256,
          hidden_size: 8192,
          num_hidden_layers: 80,
          num_attention_heads: 64,
          num_key_value_heads: 8,
          intermediate_size: 28672,
          tie_word_embeddings: false
        }
      };

      function calculateParameters(config) {
        const { vocab_size, hidden_size, num_hidden_layers, num_attention_heads, num_key_value_heads, intermediate_size, tie_word_embeddings } = config;

        // Embeddings
        const embeddings = vocab_size * hidden_size * (tie_word_embeddings ? 1 : 2);

        // Attention
        const attention = num_hidden_layers * hidden_size * hidden_size * (2 + 2 * num_key_value_heads / num_attention_heads);

        // Feed Forward
        const ffn = num_hidden_layers * hidden_size * intermediate_size * 3;

        // Layer Norms
        const layernorm = num_hidden_layers * hidden_size * 2 + hidden_size;

        const total = embeddings + attention + ffn + layernorm;

        return { embeddings, attention, ffn, layernorm, total };
      }

      function formatNumber(num) {
        if (num >= 1000000000) return `${(num / 1000000000).toFixed(2)} <span style="opacity: 0.6;">B</span>`;
        if (num >= 1000000) return `${(num / 1000000).toFixed(0)} <span style="opacity: 0.6;">M</span>`;
        if (num >= 1000) return `${(num / 1000).toFixed(0)} <span style="opacity: 0.6;">K</span>`;
        return num.toString();
      }

      function formatPercent(part, total) {
        return `${((part / total) * 100).toFixed(1)} <span style="opacity: 0.6;">%</span>`;
      }

      function getColors() {
        try {
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            return window.ColorPalettes.getColors('categorical', 4);
          }
        } catch (_) { }
        return ['#E458B5', '#F3A4D3', '#55D09D', '#00B971'];
      }

      // Create HTML structure
      container.innerHTML = `
      <div class="model-selector">
        <h3 class="section-title">Choose a Model</h3>
        <div class="button-group" id="modelButtonGroup">
          <button class="button button--ghost active" data-model="llama3.2-1b">Llama 3.2 1B</button>
          <button class="button button--ghost" data-model="smollm3-3b">SmolLM3 3B</button>
          <button class="button button--ghost" data-model="llama3.1-8b">Llama 3.1 8B</button>
          <button class="button button--ghost" data-model="llama3.1-70b">Llama 3.1 70B</button>
        </div>
        <div class="actions-group">
          <button class="button button--ghost" id="exportBtn">
            <svg class="btn-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7,10 12,15 17,10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            <span class="btn-text">Export JSON</span>
          </button>
          <a href="#" class="button button--ghost" id="configLink" target="_blank">
            <svg class="btn-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
            </svg>
            <span class="btn-text">View Original</span>
          </a>
        </div>
      </div>

      <div class="model-info">
        <div class="model-size-card">
          <div class="model-size" id="modelSize">1.24B</div>
          <div class="model-size-label">Parameters</div>
        </div>
        <div class="model-specs">
          <div class="spec-card" data-type="number">
            <div class="spec-label">Layers</div>
            <div class="spec-value" id="specLayers">16</div>
          </div>
          <div class="spec-card" data-type="number">
            <div class="spec-label">Hidden Size</div>
            <div class="spec-value" id="specHidden">2048</div>
          </div>
          <div class="spec-card" data-type="ratio">
            <div class="spec-label">Heads (Q/KV)</div>
            <div class="spec-value" id="specHeads">32/8</div>
          </div>
          <div class="spec-card" data-type="number">
            <div class="spec-label">Intermediate</div>
            <div class="spec-value" id="specIntermediate">8192</div>
          </div>
          <div class="spec-card" data-type="text">
            <div class="spec-label">Embeddings</div>
            <div class="spec-value" id="specTied">Tied</div>
          </div>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-card">
          <div class="chart-svg"></div>
          <div class="legend">
            <div class="legend-title">Legend</div>
            <div class="items"></div>
          </div>
        </div>
      </div>
    `;

      // Create tooltip AFTER HTML structure
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) { tip = document.createElement('div'); tip.className = 'd3-tooltip'; tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tip.appendChild(tipInner); container.appendChild(tip); } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      const chartCard = container.querySelector('.chart-card');
      const chartSvg = container.querySelector('.chart-svg');
      const legend = container.querySelector('.legend');
      const items = legend.querySelector('.items');

      const svg = d3.select(chartSvg).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');

      let width = 400, height = 240; const DONUT_INNER_RATIO = 0.6;
      function updateSize() {
        width = chartSvg.clientWidth || 400;
        height = Math.min(width, 240); // Reduced from 300 to 240
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${width / 2},${height / 2})`);
        return { inner: Math.min(width, height) * 0.4 }; // Increased from 0.35 to 0.4 to compensate
      }

      function makeLegend(categories, colorOf, pieData, rawValues, total) {
        items.innerHTML = '';
        categories.forEach(name => {
          const el = document.createElement('span');
          el.className = 'item';
          el.dataset.category = name;
          const sw = document.createElement('span');
          sw.className = 'swatch';
          sw.style.background = colorOf(name);
          const txt = document.createElement('span');
          txt.textContent = name;
          el.appendChild(sw);
          el.appendChild(txt);

          // Add hover events for legend items
          el.addEventListener('mouseenter', (ev) => {
            container.classList.add('hovering');
            gRoot.selectAll('path.slice').classed('ghost', s => (s && s.data && s.data.category) !== name);
            items.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.dataset.category !== name));

            // Find the corresponding slice data
            const sliceData = pieData.find(d => d.data.category === name);
            if (sliceData) {
              const realValue = rawValues.find(r => r.category === name)?.value || sliceData.data.value;
              const realPct = (realValue / total) * 100;
              const colorSw = colorOf(name);
              const selectedModel = getSelectedModel();
              const modelName = models[selectedModel]?.name || selectedModel;

              tipInner.innerHTML = `<div style="display:flex;align-items:center;gap:8px;white-space:nowrap;"><span class="swatch" style="background:${colorSw}"></span><strong>${name}</strong></div>` +
                `<div style="font-size:11px;color:var(--muted-color);margin-top:-4px;">${modelName}</div>` +
                `<div style="padding-top:6px;border-top:1px solid var(--border-color);display:flex;justify-content:space-between;align-items:center;">` +
                `<span><strong>Parameters</strong></span>` +
                `<span style="font-weight:600;">${realValue.toLocaleString()}</span>` +
                `</div>` +
                `<div style="display:flex;justify-content:space-between;align-items:center;">` +
                `<span><strong>Percentage</strong></span>` +
                `<span style="font-weight:600;">${realPct.toFixed(1)}%</span>` +
                `</div>`;
              tip.style.opacity = '1';
            }
          });

          el.addEventListener('mouseleave', () => {
            tip.style.opacity = '0';
            tip.style.transform = 'translate(-9999px, -9999px)';
            container.classList.remove('hovering');
            gRoot.selectAll('path.slice').classed('ghost', false);
            items.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
          });

          items.appendChild(el);
        });
      }

      function render(data) {
        const { inner } = updateSize();
        const categories = ['Embeddings', 'Attention', 'Feed Forward', 'Layer Norms'];
        const colors = getColors();
        const color = d3.scaleOrdinal().domain(categories).range(colors);
        const colorOf = (c) => color(c || 'Unknown');

        const rawValues = [
          { category: 'Embeddings', value: data.embeddings },
          { category: 'Attention', value: data.attention },
          { category: 'Feed Forward', value: data.ffn },
          { category: 'Layer Norms', value: data.layernorm }
        ];

        const total = rawValues.reduce((sum, d) => sum + d.value, 0);
        const minVisiblePercent = 0.5; // 0.5% minimum
        const minVisibleValue = total * (minVisiblePercent / 100);

        const values = rawValues.map(d => ({
          category: d.category,
          value: Math.max(d.value, minVisibleValue)
        }));

        const sum = d3.sum(values, d => d.value) || 1;

        const radius = Math.max(60, Math.min(inner, 120));
        const innerR = Math.round(radius * DONUT_INNER_RATIO);
        const pie = d3.pie().sort(null).value(d => d.value).padAngle(0.02);
        const arc = d3.arc().innerRadius(innerR).outerRadius(radius).cornerRadius(3);
        const arcLabel = d3.arc().innerRadius((innerR + radius) / 2).outerRadius((innerR + radius) / 2);

        const pieData = pie(values);

        // Create legend with proper data
        makeLegend(categories, colorOf, pieData, rawValues, total);

        const slices = gRoot.selectAll('path.slice').data(pieData, d => d.data.category);

        slices.enter().append('path').attr('class', 'slice')
          .attr('fill', d => colorOf(d.data.category))
          .attr('stroke', getComputedStyle(document.documentElement).getPropertyValue('--page-bg').trim() || '#ffffff')
          .attr('stroke-width', 1)
          .attr('data-category', d => d.data.category)
          .on('mouseenter', (ev, d) => {
            // Find the real value (not forced)
            const realValue = rawValues.find(r => r.category === d.data.category)?.value || d.data.value;
            const realPct = (realValue / total) * 100;
            container.classList.add('hovering');
            gRoot.selectAll('path.slice').classed('ghost', s => (s && s.data && s.data.category) !== d.data.category);
            try { const items = legend.querySelectorAll('.item'); items.forEach(it => it.classList.toggle('ghost', it.dataset.category !== d.data.category)); } catch (_) { }
            const colorSw = colorOf(d.data.category);
            const selectedModel = getSelectedModel();
            const modelName = models[selectedModel]?.name || selectedModel;

            tipInner.innerHTML = `<div style="display:flex;align-items:center;gap:8px;white-space:nowrap;"><span class="swatch" style="background:${colorSw}"></span><strong>${d.data.category}</strong></div>` +
              `<div style="font-size:11px;color:var(--muted-color);margin-top:-4px;">${modelName}</div>` +
              `<div style="padding-top:6px;border-top:1px solid var(--border-color);display:flex;justify-content:space-between;align-items:center;">` +
              `<span><strong>Parameters</strong></span>` +
              `<span style="font-weight:600;">${realValue.toLocaleString()}</span>` +
              `</div>` +
              `<div style="display:flex;justify-content:space-between;align-items:center;">` +
              `<span><strong>Percentage</strong></span>` +
              `<span style="font-weight:600;">${realPct.toFixed(1)}%</span>` +
              `</div>`;
            tip.style.opacity = '1';
          })
          .on('mousemove', (ev) => { const [mx, my] = d3.pointer(ev, container); tip.style.transform = `translate(${Math.round(mx + 12)}px, ${Math.round(my + 12)}px)`; })
          .on('mouseleave', () => {
            tip.style.opacity = '0'; tip.style.transform = 'translate(-9999px, -9999px)';
            container.classList.remove('hovering');
            gRoot.selectAll('path.slice').classed('ghost', false);
            try { const items = legend.querySelectorAll('.item'); items.forEach(it => it.classList.remove('ghost')); } catch (_) { }
          })
          .merge(slices)
          .transition()
          .duration(750)
          .attrTween('d', function (d) {
            const interpolate = d3.interpolate(this._current || { startAngle: 0, endAngle: 0 }, d);
            this._current = interpolate(0);
            return function (t) {
              return arc(interpolate(t));
            };
          });

        slices.exit().remove();

        const labels = gRoot.selectAll('text.slice-label').data(pieData, d => d.data.category);
        labels.enter().append('text').attr('class', 'slice-label').attr('text-anchor', 'middle')
          .merge(labels)
          .transition()
          .duration(750)
          .attrTween('transform', function (d) {
            const interpolate = d3.interpolate(this._current || { startAngle: 0, endAngle: 0 }, d);
            this._current = interpolate(0);
            return function (t) {
              return `translate(${arcLabel.centroid(interpolate(t))})`;
            };
          })
          .attr('font-size', d => {
            const percentage = (d.data.value / sum) * 100;
            if (percentage >= 5) return '11px';
            if (percentage >= 2) return '9px';
            return '7px';
          })
          .text(d => {
            const realValue = rawValues.find(r => r.category === d.data.category)?.value || d.data.value;
            const realPct = (realValue / total) * 100;
            return realPct >= 1 ? `${realPct.toFixed(1)}%` : '';
          });
        labels.exit().remove();
      }

      function getSelectedModel() {
        const activeBtn = container.querySelector('.button-group .button.active');
        return activeBtn ? activeBtn.dataset.model : 'llama3.2-1b';
      }

      function updateDisplay() {
        const selectedModel = getSelectedModel();
        const config = models[selectedModel];
        const params = calculateParameters(config);

        container.querySelector('#modelSize').innerHTML = formatNumber(params.total);
        container.querySelector('#specLayers').textContent = config.num_hidden_layers;
        container.querySelector('#specHidden').textContent = config.hidden_size;
        container.querySelector('#specHeads').textContent = `${config.num_attention_heads}/${config.num_key_value_heads}`;
        container.querySelector('#specIntermediate').textContent = config.intermediate_size;
        container.querySelector('#specTied').textContent = config.tie_word_embeddings ? 'Tied' : 'Separate';

        // Update config link
        const configLink = container.querySelector('#configLink');
        configLink.href = config.configUrl;

        render(params);
      }

      function exportToJSON() {
        const selectedModel = getSelectedModel();
        const config = models[selectedModel];

        // Create JSON content with only the relevant parameters
        const jsonConfig = {
          vocab_size: config.vocab_size,
          hidden_size: config.hidden_size,
          num_hidden_layers: config.num_hidden_layers,
          num_attention_heads: config.num_attention_heads,
          num_key_value_heads: config.num_key_value_heads,
          intermediate_size: config.intermediate_size,
          tie_word_embeddings: config.tie_word_embeddings
        };

        // Convert to JSON string with proper formatting
        const jsonString = JSON.stringify(jsonConfig, null, 2);

        // Create and download file
        const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `${config.name.replace(/\s+/g, '_')}_config.json`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // Add event listeners
      const buttonGroup = container.querySelector('#modelButtonGroup');
      buttonGroup.addEventListener('click', (e) => {
        if (e.target.classList.contains('button')) {
          // Remove active class from all buttons
          buttonGroup.querySelectorAll('.button').forEach(btn => btn.classList.remove('active'));
          // Add active class to clicked button
          e.target.classList.add('active');
          updateDisplay();
        }
      });
      container.querySelector('#exportBtn').addEventListener('click', exportToJSON);

      // Initialize
      updateDisplay();

      // Resize observer
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => {
          const selectedModel = getSelectedModel();
          const config = models[selectedModel];
          const params = calculateParameters(config);
          render(params);
        });
        ro.observe(container);
      } else {
        window.addEventListener('resize', () => {
          const selectedModel = getSelectedModel();
          const config = models[selectedModel];
          const params = calculateParameters(config);
          render(params);
        });
      }
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<p><strong>Ablation - models with tied embeddings match larger untied variants</strong></p>
<p>Now we will assess the impact of embedding sharing on our ablation model. We draw insights from <a href="https://arxiv.org/abs/2402.14905">MobileLLM’s</a> comprehensive ablations on this technique at 125M scale, where they demonstrated that sharing reduced parameters by 11.8% with minimal accuracy degradation.</p>
<p>Since untied embeddings increase our parameter count from 1.2B to 1.46B, we will train another model with untied parameters but less layers so it matches the baseline 1.2B in parameters count. We will compare two 1.2B models: our baseline with tied embeddings (16 layers) versus an untied version with fewer layers (12 layers) to maintain the same parameter budget, and the 1.46B model with untied embeddings and the same layer count as our baseline (16) as an additional reference point. You can find the nanotron configs <a href="https://huggingface.co/datasets/HuggingFaceTB/training-guide-nanotron-configs/blob/main/baseline_config_1B.yaml">here</a>.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-s9mm3583l9" data-config="{&#34;dataUrl&#34;:&#34;./data/tied-embeddings_loss.csv&#34;,&#34;xDomain&#34;:[0,45000000000],&#34;yDomain&#34;:[2.1,2.7],&#34;smoothing&#34;:true,&#34;title&#34;:&#34;Tied Embeddings Loss&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-3sm54welr3w" data-config="{&#34;dataUrl&#34;:&#34;./data/tied-embeddings_evals.csv&#34;,&#34;charts&#34;:[{&#34;title&#34;:&#34;HellaSwag&#34;,&#34;metric&#34;:&#34;hellaswag&#34;},{&#34;title&#34;:&#34;MMLU&#34;,&#34;metric&#34;:&#34;mmlu&#34;},{&#34;title&#34;:&#34;ARC&#34;,&#34;metric&#34;:&#34;arc&#34;},{&#34;title&#34;:&#34;PIQA&#34;,&#34;metric&#34;:&#34;piqa&#34;},{&#34;title&#34;:&#34;OpenBookQA&#34;,&#34;metric&#34;:&#34;openbookqa&#34;},{&#34;title&#34;:&#34;WinoGrande&#34;,&#34;metric&#34;:&#34;winogrande&#34;}],&#34;smoothing&#34;:true,&#34;smoothingWindow&#34;:15}"><!-- 
  Multi-Line Charts Grid
  
  A configurable grid of line charts with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute:
  {
    "dataUrl": "./assets/data/your_data.csv",
    "charts": [
      { "title": "Chart 1", "metric": "metric1" },
      { "title": "Chart 2", "metric": "metric2" },
      ...
    ],
    "smoothingWindow": 15,
    "smoothingCurve": "monotoneX",
    "gridColumns": 3  // Optional: number of columns (default: 3)
  }
  
  CSV format: run_name, step, metric1, metric2, ...
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/d3-six-line-charts.html" 
    config={{ 
      dataUrl: "./assets/data/attention_evals.csv",
      charts: [
        { title: "HellaSwag", metric: "hellaswag" },
        { title: "MMLU", metric: "mmlu" },
        { title: "ARC", metric: "arc" },
        { title: "PIQA", metric: "piqa" },
        { title: "OpenBookQA", metric: "openbookqa" },
        { title: "WinoGrande", metric: "winogrande" }
      ],
      smoothingWindow: 15
    }} 
  />
-->
<div class="d3-multi-charts"></div>
<style>
  .d3-multi-charts {
    position: relative;
    container-type: inline-size;
  }

  /* Legend header */
  .d3-multi-charts__header {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
  }

  .d3-multi-charts__header .legend-bottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
    max-width: 80%;
  }

  .d3-multi-charts__header .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-multi-charts__header .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
    justify-content: center;
  }

  .d3-multi-charts__header .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-multi-charts__header .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  /* Grid */
  .d3-multi-charts__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }

  /* Container queries - basées sur la largeur du container parent, pas de la viewport */
  @container (max-width: 900px) {
    .d3-multi-charts__grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @container (max-width: 600px) {
    .d3-multi-charts__grid {
      grid-template-columns: 1fr;
    }
  }

  .chart-cell {
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
    box-shadow: inset 0 0 0 1px var(--border-color);
    border-radius: 8px;
  }

  .chart-cell__title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
    margin-bottom: 8px;
    padding-bottom: 8px;
  }

  .chart-cell__body {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .chart-cell__body svg {
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* Reset button */
  .chart-cell .reset-button {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
    display: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-size: 11px;
    padding: 3px 6px;
    border-radius: 4px;
    background: var(--surface-bg);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    cursor: pointer;
  }

  /* Axes */
  .d3-multi-charts .axes path {
    display: none;
  }

  .d3-multi-charts .axes line {
    stroke: var(--axis-color);
  }

  .d3-multi-charts .axes text {
    fill: var(--tick-color);
    font-size: 10px;
  }

  .d3-multi-charts .axis-label {
    fill: var(--text-color);
    font-size: 10px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    stroke-width: 3px;
    paint-order: stroke fill;
  }

  .d3-multi-charts .grid line {
    stroke: var(--grid-color);
  }

  /* Lines */
  .d3-multi-charts path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-multi-charts path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-multi-charts.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-multi-charts.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  .d3-multi-charts.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  /* Tooltip */
  .d3-multi-charts .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-multi-charts .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 200px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-multi-charts .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-multi-charts'))) {
        const cs = Array.from(document.querySelectorAll('.d3-multi-charts')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration
      const CONFIG = {
        dataUrl: embedConfig.dataUrl || './assets/data/attention_evals.csv',
        charts: embedConfig.charts || [],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        gridColumns: embedConfig.gridColumns || 3,
        chartHeight: 240,
        margin: { top: 20, right: 20, bottom: 40, left: 50 },
        zoomExtent: [1.0, 8],
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Value',
        xColumn: embedConfig.xColumn || 'tokens',
        runColumn: embedConfig.runColumn || 'run_name'
      };

      if (!CONFIG.charts.length) {
        container.innerHTML = '<p style="color: var(--danger); font-size: 12px;">Error: No charts configured</p>';
        return;
      }

      // Create legend header
      const header = document.createElement('div');
      header.className = 'd3-multi-charts__header';
      header.innerHTML = `
      <div class="legend-bottom">
        <div class="legend-title">Legend</div>
        <div class="items"></div>
      </div>
    `;
      container.appendChild(header);

      // Create grid
      const grid = document.createElement('div');
      grid.className = 'd3-multi-charts__grid';
      container.appendChild(grid);

      // Trackio footer removed

      // Create chart cells
      CONFIG.charts.forEach((chartConfig, idx) => {
        const cell = document.createElement('div');
        cell.className = 'chart-cell';
        cell.style.zIndex = CONFIG.charts.length - idx; // Stacking order
        cell.innerHTML = `
        <div class="chart-cell__title">${chartConfig.title}</div>
        <button class="reset-button">Reset</button>
        <div class="chart-cell__body"></div>
      `;
        grid.appendChild(cell);
      });

      // Data
      let allData = [];
      let runList = [];
      let runColorMap = {};

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].value)) { sum += values[j].value; count++; } }
          const avg = count ? (sum / count) : values[i].value;
          out[i] = { step: values[i].step, value: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Init each chart
      function initChart(cellElement, chartConfig) {
        const bodyEl = cellElement.querySelector('.chart-cell__body');
        const resetBtn = cellElement.querySelector('.reset-button');

        const metric = chartConfig.metric;
        let smoothEnabled = CONFIG.smoothing;
        let hasMoved = false;

        // Tooltip
        let tip = cellElement.querySelector('.d3-tooltip');
        let tipInner;
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'd3-tooltip';
          Object.assign(tip.style, {
            position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
            padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
            background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease', zIndex: '20'
          });
          tipInner = document.createElement('div');
          tipInner.className = 'd3-tooltip__inner';
          tip.appendChild(tipInner);
          cellElement.appendChild(tip);
        } else {
          tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
        }

        // Create SVG
        const svg = d3.select(bodyEl).append('svg').attr('width', '100%').style('display', 'block');

        // Clip path
        const clipId = 'clip-' + Math.random().toString(36).slice(2);
        const clipPath = svg.append('defs').append('clipPath').attr('id', clipId);
        const clipRect = clipPath.append('rect');

        // Groups
        const g = svg.append('g');
        const gGrid = g.append('g').attr('class', 'grid');
        const gAxes = g.append('g').attr('class', 'axes');
        const gPlot = g.append('g').attr('class', 'plot').attr('clip-path', `url(#${clipId})`);
        const gHover = g.append('g').attr('class', 'hover-layer');
        const overlay = g.append('rect').attr('class', 'overlay').attr('fill', 'none').attr('pointer-events', 'all').style('cursor', 'grab')
          .on('mousedown', function () {
            d3.select(this).style('cursor', 'grabbing');
            tip.style.opacity = '0';
            if (hoverLine) hoverLine.style('display', 'none');
          })
          .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

        // Scales
        const xScale = d3.scaleLinear();
        const yScale = d3.scaleLinear();

        // Hover state
        let hoverLine = null;
        let steps = [];
        let hideTipTimer = null;

        // Formatters (will be set in render())
        let formatStep = (v) => v;
        let formatValue = (v) => v;

        // Zoom
        const zoom = d3.zoom().scaleExtent(CONFIG.zoomExtent).on('zoom', zoomed);
        overlay.call(zoom);

        function zoomed(event) {
          const transform = event.transform;
          hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
          updateResetButton();

          const newXScale = transform.rescaleX(xScale);
          const newYScale = transform.rescaleY(yScale);

          const innerWidth = xScale.range()[1];

          // Update grid
          const gridTicks = newYScale.ticks(5);
          gGrid.selectAll('line').data(gridTicks).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => newYScale(d)).attr('y2', d => newYScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Update lines
          const line = d3.line()
            .x(d => newXScale(d.step))
            .y(d => newYScale(d.value))
            .curve(getCurve(smoothEnabled));

          gPlot.selectAll('path.ghost-line')
            .attr('d', d => {
              const rawLine = d3.line().x(d => newXScale(d.step)).y(d => newYScale(d.value)).curve(d3.curveLinear);
              return rawLine(d.values);
            });

          gPlot.selectAll('path.main-line')
            .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

          // Update axes
          gAxes.select('.x-axis').call(d3.axisBottom(newXScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.select('.y-axis').call(d3.axisLeft(newYScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
        }

        function updateResetButton() {
          if (hasMoved) {
            resetBtn.style.display = 'block';
            requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
          } else {
            resetBtn.style.opacity = '0';
            setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
          }
        }

        function render() {
          const rect = bodyEl.getBoundingClientRect();
          const width = Math.max(1, Math.round(rect.width || 400));
          const height = CONFIG.chartHeight;
          svg.attr('width', width).attr('height', height);

          const margin = CONFIG.margin;
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;

          g.attr('transform', `translate(${margin.left},${margin.top})`);

          // Filter data for this metric
          const metricData = allData.filter(d => d[metric] != null && !isNaN(d[metric]));

          if (!metricData.length) {
            return;
          }

          // Auto-compute domains from data
          const stepExtent = d3.extent(metricData, d => d.step);
          const valueExtent = d3.extent(metricData, d => d[metric]);

          xScale.domain(stepExtent).range([0, innerWidth]);
          yScale.domain(valueExtent).range([innerHeight, 0]);

          // Create smart formatters based on actual data
          const stepValues = metricData.map(d => d.step);
          const metricValues = metricData.map(d => d[metric]);
          formatStep = createSmartFormatter(stepValues);
          formatValue = createSmartFormatter(metricValues);

          // Update clip
          clipRect.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update overlay
          overlay.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update zoom extent
          zoom.extent([[0, 0], [innerWidth, innerHeight]])
            .translateExtent([[0, 0], [innerWidth, innerHeight]]);

          // Grid
          gGrid.selectAll('line').data(yScale.ticks(5)).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Axes
          gAxes.selectAll('*').remove();
          gAxes.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.append('g').attr('class', 'y-axis')
            .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
          gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');
          gAxes.selectAll('text').attr('fill', 'var(--tick-color)');

          // Axis labels
          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight + 32)
            .attr('text-anchor', 'middle')
            .text(CONFIG.xAxisLabel);

          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -38)
            .attr('text-anchor', 'middle')
            .text(CONFIG.yAxisLabel);

          // Group data by run
          const dataByRun = {};
          runList.forEach(run => { dataByRun[run] = []; });
          metricData.forEach(d => {
            if (dataByRun[d.run]) dataByRun[d.run].push({ step: d.step, value: d[metric] });
          });
          runList.forEach(run => { dataByRun[run].sort((a, b) => a.step - b.step); });

          const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] })).filter(s => s.values.length > 0);

          // Ghost lines
          const ghostLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(d3.curveLinear);
          gPlot.selectAll('path.ghost-line').data(series, d => d.run).join('path')
            .attr('class', 'ghost-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 1.5)
            .attr('opacity', smoothEnabled ? 0.15 : 0)
            .attr('pointer-events', 'none')
            .attr('d', d => ghostLine(d.values));

          // Main lines
          const mainLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(getCurve(smoothEnabled));
          gPlot.selectAll('path.main-line').data(series, d => d.run).join('path')
            .attr('class', 'main-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('opacity', 0.85)
            .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

          // Hover
          setupHover(series, innerWidth, innerHeight);
        }

        function setupHover(series, innerWidth, innerHeight) {
          gHover.selectAll('*').remove();

          hoverLine = gHover.append('line')
            .style('stroke', 'var(--text-color)')
            .attr('stroke-opacity', 0.25)
            .attr('stroke-width', 1)
            .attr('y1', 0)
            .attr('y2', innerHeight)
            .style('display', 'none')
            .attr('pointer-events', 'none');

          const stepSet = new Set();
          series.forEach(s => s.values.forEach(v => stepSet.add(v.step)));
          steps = Array.from(stepSet).sort((a, b) => a - b);

          overlay.on('mousemove', function (ev) {
            if (ev.buttons === 0) onHoverMove(ev, series);
          }).on('mouseleave', onHoverLeave);
        }

        function onHoverMove(ev, series) {
          if (hideTipTimer) { clearTimeout(hideTipTimer); hideTipTimer = null; }

          const [mx, my] = d3.pointer(ev, overlay.node());
          const targetStep = xScale.invert(mx);
          const nearest = steps.reduce((best, t) => Math.abs(t - targetStep) < Math.abs(best - targetStep) ? t : best, steps[0]);

          const xpx = xScale(nearest);
          hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

          let html = `<div><strong>${chartConfig.title}</strong></div>`;
          html += `<div>${formatStep(nearest)}</div>`;

          const entries = series.map(s => {
            const values = s.values;
            let before = null, after = null;
            for (let i = 0; i < values.length; i++) {
              if (values[i].step <= nearest) before = values[i];
              if (values[i].step >= nearest && !after) { after = values[i]; break; }
            }

            let interpolatedValue = null;
            if (before && after && before.step !== after.step) {
              const t = (nearest - before.step) / (after.step - before.step);
              interpolatedValue = before.value + t * (after.value - before.value);
            } else if (before && before.step === nearest) {
              interpolatedValue = before.value;
            } else if (after && after.step === nearest) {
              interpolatedValue = after.value;
            } else if (before) {
              interpolatedValue = before.value;
            } else if (after) {
              interpolatedValue = after.value;
            }

            return { run: s.run, color: s.color, value: interpolatedValue };
          }).filter(e => e.value != null);

          entries.sort((a, b) => b.value - a.value);

          entries.forEach(e => {
            html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.value.toFixed(4)}</span></div>`;
          });

          tipInner.innerHTML = html;
          const offsetX = 12, offsetY = 12;
          tip.style.opacity = '1';
          tip.style.transform = `translate(${Math.round(mx + offsetX + CONFIG.margin.left)}px, ${Math.round(my + offsetY + CONFIG.margin.top)}px)`;
        }

        function onHoverLeave() {
          hideTipTimer = setTimeout(() => {
            tip.style.opacity = '0';
            tip.style.transform = 'translate(-9999px, -9999px)';
            if (hoverLine) hoverLine.style('display', 'none');
          }, 100);
        }

        // Reset button
        resetBtn.addEventListener('click', () => {
          overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        });

        return { render };
      }

      // Load data
      async function load() {
        try {
          const response = await fetch(CONFIG.dataUrl, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);

          const csvText = await response.text();

          // Parse CSV (long format: run_name, metric, tokens, value)
          const rawRows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            metric: (d.metric || '').trim(),
            tokens: +d[CONFIG.xColumn],
            value: +d.value
          }));

          // Pivot data: group by run + tokens, create columns for each metric
          const pivotMap = new Map();
          rawRows.forEach(row => {
            if (isNaN(row.tokens) || isNaN(row.value)) return;

            const key = `${row.run}|${row.tokens}`;
            if (!pivotMap.has(key)) {
              pivotMap.set(key, { run: row.run, step: row.tokens });
            }
            const pivotRow = pivotMap.get(key);
            pivotRow[row.metric] = row.value;
          });

          allData = Array.from(pivotMap.values());

          runList = Array.from(new Set(allData.map(d => d.run))).sort();

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => { runColorMap[run] = colors[i % colors.length]; });

          // Build legend
          const legendItemsHost = header.querySelector('.legend-bottom .items');
          if (legendItemsHost) {
            legendItemsHost.innerHTML = runList.map(run => {
              const color = runColorMap[run];
              return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
            }).join('');

            // Add hover interactions
            legendItemsHost.querySelectorAll('.item').forEach(el => {
              el.addEventListener('mouseenter', () => {
                const run = el.getAttribute('data-run');
                container.classList.add('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                grid.querySelectorAll('path.ghost-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                legendItemsHost.querySelectorAll('.item').forEach(it => {
                  it.classList.toggle('ghost', it.getAttribute('data-run') !== run);
                });
              });

              el.addEventListener('mouseleave', () => {
                container.classList.remove('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => path.classList.remove('ghost'));
                grid.querySelectorAll('path.ghost-line').forEach(path => path.classList.remove('ghost'));
                legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
              });
            });
          }

          // Init all charts
          const cells = Array.from(grid.querySelectorAll('.chart-cell'));
          const chartInstances = cells.map((cell, idx) => initChart(cell, CONFIG.charts[idx]));

          // Render all
          chartInstances.forEach(chart => chart.render());

          // Responsive - observe container for resize
          let resizeTimer;
          const handleResize = () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              chartInstances.forEach(chart => chart.render());
            }, 100);
          };

          const ro = window.ResizeObserver ? new ResizeObserver(handleResize) : null;
          if (ro) {
            ro.observe(container);
          }

          // Also observe window resize as fallback
          window.addEventListener('resize', handleResize);

          // Force a re-render after a short delay to ensure proper sizing
          setTimeout(() => {
            chartInstances.forEach(chart => chart.render());
          }, 100);

        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure> </div>
<p>The loss and evaluation results demonstrate that our baseline 1.2B model with tied embeddings achieves comparable performance to the 1.46B untied equivalent, despite having 18% fewer parameters. The 1.2B model with untied embeddings and reduced layers (12 vs 16) underperforms both configurations, exhibiting higher loss and lower downstream evaluation scores. This suggests that increasing model depth provides greater benefits than untying embeddings at equivalent parameter budgets.</p>
<p>Based on these results, we kept tied embeddings for our SmolLM3 3B model.</p>
<p>We’ve now explored the main attention mechanisms and their tradeoffs. But attention alone does not capture the order of tokens in a sequence; providing this information is the role of positional encodings. In the next section, we will look at how positional encoding strategies have evolved, from standard RoPE to newer approaches like NoPE (No Position Embedding), which enable more effective modeling for long contexts.</p>
<h4 id="positional-encodings--long-context"><a href="#positional-encodings--long-context"><strong>Positional Encodings &amp; Long Context</strong></a></h4>
<p>When transformers process text, they face a fundamental challenge: they naturally have no sense of word order, since they consume entire sequences simultaneously through parallel attention operations. This enables efficient training but creates a problem. Without explicit position information, “Adam beats Muon” looks similar to “Muon beats Adam” from the model’s perspective.</p>
<p>The solution is positional embeddings: mathematical encodings that give each token a unique “address” in the sequence. But as we push toward longer and longer contexts - from the 512 tokens of early BERT to today’s million-token models - the choice of positional encoding becomes increasingly critical for both performance and computational efficiency.</p>
<p><strong>The Evolution of Position Encoding</strong></p>
<p>Early transformers used simple  <strong>Absolute Position Embeddings (APE)</strong> [@transformer <strong>]</strong> , essentially learned lookup tables that mapped each position (1, 2, 3…) to a vector that gets added to token embeddings. This worked fine for short sequences but had a major limitation: models max input sequence length was limited to the max input sequence length they were trained on. They had no out-of-the-box generalisation capabilities to longer sequences.</p>
<p>The field evolved toward  <strong>relative position encodings</strong>  that capture the distance between tokens rather than their absolute positions. This makes intuitive sense, whether two words are 3 positions apart matters more than whether they’re at positions (5,8) versus (105,108).</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>For a deeper dive into positional encoding, <a href="https://huggingface.co/blog/designing-positional-encoding">this blog</a> walks through the step-by-step development from basic positioning to rotational encoding.</p> </aside> </div>  
<p><strong>ALiBi</strong>  (Attention with Linear Biases) <span class="" id="citation--alibi--30">(<a href="https://arxiv.org/abs/2108.12409" id="refctx-bib-alibi-1" data-ref-id="bib-alibi" target="_blank" rel="noopener noreferrer">Press et al., 2022</a>)</span>, in particular, modifies the attention scores based on token distance. The further apart two tokens are, the more their attention gets penalized through simple linear biases applied to attention weights. For a detailed implementation of Alibi, check this <a href="https://nn.labml.ai/transformers/alibi/index.html">resource</a>.</p>
<p>But the technique that has dominated recent large language models is  <strong>Rotary Position Embedding (RoPE)</strong>  <span class="" id="citation--rope--31">(<a href="https://arxiv.org/abs/2104.09864" id="refctx-bib-rope-1" data-ref-id="bib-rope" target="_blank" rel="noopener noreferrer">Su et al., 2023</a>)</span>.</p>
<p><strong>RoPE: Position as Rotation</strong></p>
<p>RoPE’s core insight is to encode position information as rotation angles in a high-dimensional space. Instead of adding position vectors to token embeddings, RoPE rotates the query and key vectors by angles that depend on their absolute positions.</p>
<p>The intuition is that we treat each pair of dimensions in our embeddings as coordinates on a circle and rotate them by an angle determined by:</p>
<ul>
<li>The token’s position in the sequence</li>
<li>Which dimension pair we’re working with (different pairs rotate at different frequencies which are exponents of a base/reference frequency)</li>
</ul>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> torch</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> apply_rope_simplified</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(x, pos, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">10000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">):</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    Rotary Position Embedding (RoPE)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    Idea:</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    - Each token has a position index p (0, 1, 2, ...).</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    - Each pair of vector dimensions has an index k (0 .. dim/2 - 1).</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    - RoPE rotates every pair [x[2k], x[2k+1]] by an angle θ_{p,k}.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    Formula:</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">      θ_{p,k} = p * base^(-k / (dim/2))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    - Small k (early dimension pairs) → slow oscillations → capture long-range info.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    - Large k (later dimension pairs) → fast oscillations → capture fine detail.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    rotated </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> []</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, dim, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">//</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">  # index of this dimension pair</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">        # Frequency term: higher k → faster oscillation</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        inv_freq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 1.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (base </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (dim </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">//</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        theta </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> inv_freq  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D"># rotation angle for position p and pair k</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        cos_t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> torch.cos(torch.tensor(theta, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">dtype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">x.dtype, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">device</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">x.device))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        sin_t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> torch.sin(torch.tensor(theta, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">dtype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">x.dtype, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">device</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">x.device))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        x1, x2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> x[i], x[i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">        # Apply 2D rotation</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        rotated.extend([x1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> cos_t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> x2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> sin_t,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">                        x1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> sin_t </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> x2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> cos_t])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> torch.stack(rotated)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Q, K: [batch, heads, seq, d_head]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">Q </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> torch.randn(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">K </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> torch.randn(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## 👉 apply RoPE to Q and K *before* the dot product</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">Q_rope </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> torch.stack([apply_rope(Q[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,p], p) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(Q.size(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">))])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">K_rope </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> torch.stack([apply_rope(K[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,p], p) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(K.size(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">))])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">scores </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (Q_rope </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">@</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> K_rope.T) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> math.sqrt(Q.size(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">attn_weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> torch.softmax(scores, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"></span></code></pre></div>
<p>This code might seem complex so let’s break it down with a concrete example. Consider the word  <em>“fox”</em>  from the sentence  <em>“The quick brown fox”</em> . In our baseline 1B model, each attention head works with a 64-dimensional query/key vector. RoPE groups this vector into 32 pairs: (x₁, x₂), (x₃, x₄), (x₅, x₆), and so on. We work on pairs because we rotate around circles in 2D space. For simplicity, let’s focus on the first pair (x₁, x₂). The word “fox” appears at position 3 in our sentence, so RoPE will rotate this first dimension pair by:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">rotation_angle </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> position × θ₀ </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">                =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> × (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">10000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">                =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> × </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">                =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> radians </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">                =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 172</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">° degrees</span></span>
<span class="line"></span></code></pre></div>
<p>Our base frequency is 10000 but for the first dimension pair (k=0) our exponent is zero so the base frequency doesn’t affect the calculation (we raise to the power of 0). The visualization below illustrates this:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-rxm81lhj0cm"><div class="d3-rope-demo"></div>

<style>
  .d3-rope-demo {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.5;
    color: var(--text-color);
    padding: 20px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  .d3-rope-demo .subtitle {
    color: var(--text-color);
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 20px;
    text-align: center;
    max-width: 600px;
    line-height: 1.5;
  }
  
  .d3-rope-demo .sentence {
    display: flex;
    gap: 0;
    margin: 25px 0;
    flex-wrap: wrap;
    justify-content: center;
    font-size: 18px;
  }
  
  .d3-rope-demo .slider-container {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 15px 0;
  }
  
  .d3-rope-demo .slider-label {
    font-size: 14px;
    color: var(--muted-color);
    font-weight: 500;
    min-width: 80px;
  }
  
  .d3-rope-demo .slider {
    width: 200px;
    height: 6px;
    border-radius: 3px;
    background: var(--border-color);
    outline: none;
    cursor: pointer;
  }
  
  .d3-rope-demo .slider::-webkit-slider-thumb {
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--primary-color);
    cursor: pointer;
    border: 2px solid var(--page-bg);
    box-shadow: 0 2px 4px var(--border-color);
  }
  
  .d3-rope-demo .slider::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--primary-color);
    cursor: pointer;
    border: 2px solid var(--page-bg);
    box-shadow: 0 2px 4px var(--border-color);
  }
  
  .d3-rope-demo .slider-value {
    font-size: 14px;
    color: var(--text-color);
    font-weight: 600;
    min-width: 40px;
    text-align: center;
  }
  
  .d3-rope-demo .rotation-info {
    text-align: center;
    margin: 20px auto;
    font-size: 16px;
    font-weight: 500;
    color: var(--text-color);
    padding: 20px;
    background: var(--page-bg);
    border-radius: 8px;
    border: 1px solid var(--border-color) !important;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    max-width: 500px;
  }
  
  .d3-rope-demo .equation-gap {
    height: 15px;
  }
  
  .d3-rope-demo .word-highlight {
    color: var(--primary-color);
    font-weight: 700;
    background: var(--page-bg);
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid var(--border-color);
    display: inline-block;
    min-width: 60px;
    text-align: center;
  }
  
  .d3-rope-demo .position-highlight {
    color: var(--primary-color);
    font-weight: 700;
    background: var(--page-bg);
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid var(--border-color);
  }
  
  .d3-rope-demo .angle-highlight {
    color: var(--primary-color);
    font-weight: 600;
    font-family: 'Courier New', monospace;
    font-size: 20px;
    padding: 12px 16px;
    border-radius: 6px;
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    display: inline-block;
    width: 100%;
    text-align: center;
  }
  
  .d3-rope-demo .word {
    cursor: pointer;
    font-weight: 700;
    font-size: 18px;
    user-select: none;
    padding: 8px 12px;
    border-radius: 0;
    transition: all 0.2s ease;
    border: 1px solid var(--border-color);
    border-right: none;
  }
  
  .d3-rope-demo .word:first-child {
    border-radius: 6px 0 0 6px;
  }
  
  .d3-rope-demo .word:last-child {
    border-radius: 0 6px 6px 0;
    border-right: 1px solid var(--border-color);
  }
  
  .d3-rope-demo .word:only-child {
    border-radius: 6px;
    border-right: 1px solid var(--border-color);
  }


  .button {
    background: var(--primary-color)!important;
    color: var(--page-bg)!important;
    border: 1px solid var(--primary-color)!important;
  }
  
  .button--ghost {
    background: var(--page-bg)!important;
    color: var(--primary-color)!important;
    border: 1px solid var(--primary-color)!important;
  }

  .d3-rope-demo .svg-container {
    margin: 0;
    display: inline-block;
  }
  
  .d3-rope-demo svg {
    display: block;
  }
  
  .d3-rope-demo .explanation {
    max-width: 700px;
    text-align: center;
    margin-top: 20px;
    color: var(--text-color);
    font-size: 15px;
    line-height: 1.6;
  }
  
  /* Responsive design */
  @media (max-width: 768px) {
    .d3-rope-demo {
      padding: 16px 0;
    }
    
    .d3-rope-demo .sentence {
      gap: 10px;
    }
    
    .d3-rope-demo .word {
      font-size: 16px;
      padding: 6px 10px;
    }
    
    .d3-rope-demo .svg-container {
      width: 100%;
      max-width: 400px;
    }
    
    .d3-rope-demo svg {
      width: 100%;
      height: auto;
    }
    
    .d3-rope-demo .explanation {
      font-size: 14px;
    }
  }
</style>

<script>
  (() => {
    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-rope-demo'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-rope-demo'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      const sentence = ["The", "quick", "brown", "fox", "jumps", "..."];

      // Create the HTML structure
      container.innerHTML = `
        <div class="subtitle">RoPE rotation of the first (x₁, x₂) pair in Q/K vectors<br/> based on token position</div>
        <div class="sentence" id="sentence"></div>
        <div class="slider-container">
          <input type="range" class="slider" id="positionSlider" min="0" max="5" step="1" value="0">
        </div>
        <div class="svg-container">
          <svg id="ropeSvg" width="500" height="400" viewBox="0 0 500 400"></svg>
        </div>
        
        <div class="rotation-info" id="rotationInfo">
          <span class="word-highlight">The</span> at position <span class="position-highlight">0</span> gets rotated by
          <div class="equation-gap"></div>
          <span class="angle-highlight">θ = 0 rad (0°)</span>
        </div>
        <div class="explanation">
          <strong>RoPE Formula:</strong> θ (theta) = position × 1 / base<sup>2 × pair_index/h_dim</sup> (pair_index=0 here)
          <br><br>
          <strong>Key insight:</strong> The first dimension pair gets the largest rotations, and the relative angle between words depends only on their distance apart.
        </div>
      `;

      const svg = container.querySelector('#ropeSvg');
      const sentenceEl = container.querySelector('#sentence');
      const slider = container.querySelector('#positionSlider');
      const rotationInfo = container.querySelector('#rotationInfo');

      const R = 140;
      const R_LABELS = 180; // Cercle plus grand pour les labels
      const cx = 250;
      const cy = 200;
      const ANGLE_OFFSET = 5; // Offset en degrés pour mieux aligner les 6 mots

      // RoPE parameters
      const base = 10000;
      const d = 2048;
      const m = 0;
      
      function getRopeAngle(pos) {
        return pos * (1 / Math.pow(base, (2 * m) / d));
      }

      let activeIndex = 0;
      let animating = true;
      let animationTimeout = null;

      function renderSentence() {
        sentenceEl.innerHTML = "";
        sentence.forEach((word, i) => {
          const span = document.createElement("span");
          span.textContent = word;
          span.className = "word button" + (i === activeIndex ? "" : " button--ghost");
          span.addEventListener("click", () => {
            stopAnimation();
            activeIndex = i;
            slider.value = i;
            updateRotationInfo();
            draw();
            renderSentence();
          });
          sentenceEl.appendChild(span);
        });
      }

      function draw() {
        // Clear SVG
        svg.innerHTML = '';

        // Create arrays to store elements for proper layering
        const backgroundElements = [];
        const foregroundElements = [];
        const textElements = [];

        // Draw circle (background)
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', cx);
        circle.setAttribute('cy', cy);
        circle.setAttribute('r', R);
        circle.setAttribute('fill', 'none');
        circle.setAttribute('stroke', 'var(--border-color)');
        circle.setAttribute('stroke-width', '1.5');
        circle.setAttribute('opacity', '0.6');
        backgroundElements.push(circle);

        // Draw all word positions
        sentence.forEach((word, i) => {
          const theta = getRopeAngle(i) + (ANGLE_OFFSET * Math.PI / 180); // Ajouter l'offset en radians
          const x = cx + R * Math.cos(theta);
          const y = cy + R * Math.sin(theta);

          const isActive = (i === activeIndex);
          const isGhost = i > activeIndex; // Éléments après la position active sont en ghost
          
          // Draw point (background)
          const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          point.setAttribute('cx', x);
          point.setAttribute('cy', y);
          point.setAttribute('r', isActive ? 10 : 5);
          point.setAttribute('fill', isActive ? 'var(--primary-color)' : (isGhost ? 'var(--muted-color)' : 'var(--primary-color)'));
          point.setAttribute('stroke', isActive ? 'var(--page-bg)' : (isGhost ? 'var(--surface-bg)' : 'var(--page-bg)'));
          point.setAttribute('stroke-width', isActive ? '3' : '2');
          point.setAttribute('opacity', isActive ? '1' : (isGhost ? '0.3' : '0.7'));
          backgroundElements.push(point);

          // Draw arrow for active word (foreground)
          if (isActive) {
            const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            arrow.setAttribute('x1', cx);
            arrow.setAttribute('y1', cy);
            arrow.setAttribute('x2', x);
            arrow.setAttribute('y2', y);
            arrow.setAttribute('stroke', 'var(--primary-color)');
            arrow.setAttribute('stroke-width', '3');
            arrow.setAttribute('stroke-linecap', 'round');
            arrow.setAttribute('opacity', '0.8');
            foregroundElements.push(arrow);
          }
        });

        // Draw center point (foreground)
        const centerPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        centerPoint.setAttribute('cx', cx);
        centerPoint.setAttribute('cy', cy);
        centerPoint.setAttribute('r', 5);
        centerPoint.setAttribute('fill', 'var(--text-color)');
        centerPoint.setAttribute('stroke', 'var(--page-bg)');
        centerPoint.setAttribute('stroke-width', '2');
        centerPoint.setAttribute('opacity', '0.8');
        foregroundElements.push(centerPoint);

        // Draw angle arc for active word (foreground)
        if (activeIndex !== null && activeIndex > 0) {
          const theta = getRopeAngle(activeIndex) + (ANGLE_OFFSET * Math.PI / 180);
          const startAngle = ANGLE_OFFSET * Math.PI / 180;
          const endAngle = theta;
          
          // Create arc path
          const radius = R * 0.7;
          const startX = cx + radius * Math.cos(startAngle);
          const startY = cy + radius * Math.sin(startAngle);
          const endX = cx + radius * Math.cos(endAngle);
          const endY = cy + radius * Math.sin(endAngle);
          
          const largeArcFlag = theta > Math.PI ? 1 : 0;
          const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY}`;
          
          const arc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          arc.setAttribute('d', pathData);
          arc.setAttribute('fill', 'none');
          arc.setAttribute('stroke', 'var(--primary-color)');
          arc.setAttribute('stroke-width', '2.5');
          arc.setAttribute('stroke-dasharray', '6,4');
          arc.setAttribute('opacity', '0.8');
          foregroundElements.push(arc);
        }

        // Draw all text elements (top layer)
        sentence.forEach((word, i) => {
          const theta = getRopeAngle(i);
          const x = cx + R * Math.cos(theta);
          const y = cy + R * Math.sin(theta);

          const isActive = (i === activeIndex);
          const isGhost = i > activeIndex; // Éléments après la position active sont en ghost
          
          // Draw word label on larger circle
          const labelX = cx + R_LABELS * Math.cos(theta);
          const labelY = cy + R_LABELS * Math.sin(theta);
          const wordLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          wordLabel.setAttribute('x', labelX);
          wordLabel.setAttribute('y', labelY);
          wordLabel.setAttribute('text-anchor', 'middle');
          wordLabel.setAttribute('dominant-baseline', 'middle');
          wordLabel.setAttribute('fill', isActive ? 'var(--text-color)' : (isGhost ? 'var(--muted-color)' : 'var(--text-color)'));
          wordLabel.setAttribute('font-family', '-apple-system, BlinkMacSystemFont, sans-serif');
          wordLabel.setAttribute('font-size', isActive ? '18' : '15');
          wordLabel.setAttribute('font-weight', isActive ? '700' : '500');
          wordLabel.setAttribute('opacity', isActive ? '1' : (isGhost ? '0.3' : '0.8'));
          wordLabel.textContent = word;
          textElements.push(wordLabel);
        });

        // Add angle label (top layer)
        if (activeIndex !== null && activeIndex > 0) {
          const theta = getRopeAngle(activeIndex) + (ANGLE_OFFSET * Math.PI / 180);
          const radius = R * 0.7;
          const angleLabelX = cx + radius * 0.5 * Math.cos(theta / 2);
          const angleLabelY = cy + radius * 0.5 * Math.sin(theta / 2);
          
          // Create tspan elements for different styling
          const angleLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          angleLabel.setAttribute('x', angleLabelX);
          angleLabel.setAttribute('y', angleLabelY);
          angleLabel.setAttribute('text-anchor', 'middle');
          angleLabel.setAttribute('font-family', '-apple-system, BlinkMacSystemFont, sans-serif');
          angleLabel.setAttribute('font-size', '13');
          angleLabel.setAttribute('font-weight', '600');
          
          // θ in primary color
          const thetaSpan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
          thetaSpan.setAttribute('fill', 'var(--primary-color)');
          thetaSpan.textContent = 'θ';
          angleLabel.appendChild(thetaSpan);
          
          // = with reduced opacity
          const equalsSpan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
          equalsSpan.setAttribute('fill', 'var(--primary-color)');
          equalsSpan.setAttribute('opacity', '0.5');
          equalsSpan.textContent = ' = ';
          angleLabel.appendChild(equalsSpan);
          
          // Number in primary color
          const numberSpan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
          numberSpan.setAttribute('fill', 'var(--primary-color)');
          numberSpan.textContent = activeIndex.toString();
          angleLabel.appendChild(numberSpan);
          
          textElements.push(angleLabel);
        }

        // Append elements in correct order: background -> foreground -> text
        backgroundElements.forEach(el => svg.appendChild(el));
        foregroundElements.forEach(el => svg.appendChild(el));
        textElements.forEach(el => svg.appendChild(el));
      }

      function updateRotationInfo() {
        const theta = getRopeAngle(activeIndex);
        const degrees = Math.round(theta * 180 / Math.PI);
        rotationInfo.innerHTML = `
          <span class="word-highlight">${sentence[activeIndex]}</span> at position <span class="position-highlight">${activeIndex}</span> gets rotated by
          <div class="equation-gap"></div>
          <div class="angle-highlight">
            <span style="color: var(--muted-color); opacity: 0.6;">θ</span>
            <span style="color: var(--muted-color); opacity: 0.4; margin: 0 8px;">=</span>
            <span style="opacity: 1;">${activeIndex}</span>
            <span style="color: var(--muted-color); opacity: 0.6;">rad</span>
            <span style="color: var(--muted-color); opacity: 0.4;">(</span>
            <span style="opacity: 1;">${degrees}°</span>
            <span style="color: var(--muted-color); opacity: 0.4;">)</span>
          </div>
        `;
      }

      function stopAnimation() {
        animating = false;
        if (animationTimeout) {
          clearTimeout(animationTimeout);
          animationTimeout = null;
        }
      }

      function animate() {
        if (!animating) return;
        
        animationTimeout = setTimeout(() => {
          activeIndex = (activeIndex + 1) % sentence.length;
          slider.value = activeIndex;
          updateRotationInfo();
          renderSentence();
          draw();
          animate();
        }, 1500);
      }

      // Slider event listener
      slider.addEventListener('input', (e) => {
        stopAnimation();
        activeIndex = parseInt(e.target.value);
        updateRotationInfo();
        renderSentence();
        draw();
      });

      // Initialize and start
      renderSentence();
      updateRotationInfo();
      draw();
      animate();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
    } else {
      bootstrap();
    }
  })();
</script>
</div></div></figure>
<p>Now the magic happens when two tokens interact through attention. The dot product between their rotated representations directly encodes their relative distance through the phase difference between their rotation angles (where  <code>m</code>  and  <code>n</code>  are the token positions)</p>
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">dot_product(RoPE(x, m), RoPE(y, n)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> Σₖ [xₖ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> yₖ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> cos((m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">n) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> θₖ)]</span></span>
<span class="line"></span></code></pre></div>
<p>The attention pattern depends only on (m-n), so tokens that are 5 positions apart will always have the same angular relationship, regardless of their absolute positions in the sequence. Therefore, the model learns distance-based patterns that work at any absolute position in the sequence and can extrapolate to longer sequences.</p>
<p><strong>How to set RoPE Frequency?</strong></p>
<p>In practice, most LLM pretraining starts with relatively short context lengths (2K-4K tokens) using RoPE base frequencies of a few tens thousands like 10K or 50K.  Training with very long sequences from the start would be computationally expensive due to attention’s quadratic scaling with sequence length and the limited availability of long-context data (samples &gt; 4K context length) as we’ve seen before in the document masking section of <a href="#attention">Attention</a>. Research also suggests it can hurt short-context performance <span class="" id="citation--skyladder--32">(<a href="https://arxiv.org/abs/2503.15450" id="refctx-bib-skyladder-2" data-ref-id="bib-skyladder" target="_blank" rel="noopener noreferrer">Zhu et al., 2025</a>)</span>.  Models typically start by learning short range correlation between words so long sequences don’t help much. The typical approach is to do most pretraining with shorter sequences, then do continual pretraining or spend the final few hundred billion tokens on longer sequences. However, as sequence lengths grow, the rotation angles which are proportional to token positions, grow and can cause attention scores for distant tokens to decay too rapidly <span class="" id="citation--xiong2023effectivelongcontextscalingfoundation--33">(<a href="https://arxiv.org/abs/2309.16039" id="refctx-bib-xiong2023effectivelongcontextscalingfoundation-1" data-ref-id="bib-xiong2023effectivelongcontextscalingfoundation" target="_blank" rel="noopener noreferrer">Xiong et al., 2023</a>)</span>:</p>
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">θ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> position x </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)))</span></span>
<span class="line"></span></code></pre></div>
<p>The solution is to increase the base frequency as the sequence length is increased in order to prevent such decaying, using methods like ABF and YaRN.</p>
<p><strong>RoPE ABF (RoPE with Adjusted Base Frequency)</strong>  <span class="" id="citation--ropeabf--34">(<a href="https://arxiv.org/abs/2309.16039" id="refctx-bib-ropeabf-1" data-ref-id="bib-ropeabf" target="_blank" rel="noopener noreferrer">Xiong et al., 2023b</a>)</span>: addresses the attention decay problem in long contexts by increasing the base frequency in RoPE’s formulation. This adjustment slows down the rotation angles between token positions, preventing distant tokens’ attention scores from decaying too rapidly. ABF can be applied in a single stage (direct frequency boost) or multi-stage (gradual increases as context grows). The method is straightforward to implement and distributes embedded vectors with increased granularity, making distant positions easier for the model to differentiate. While simple and effective, ABF’s uniform scaling across all dimensions may not be optimal for extremely long contexts.</p>
<p><strong>YaRN (Yet another RoPE extensioN)</strong>  <span class="" id="citation--yarn--35">(<a href="https://arxiv.org/abs/2309.00071" id="refctx-bib-yarn-1" data-ref-id="bib-yarn" target="_blank" rel="noopener noreferrer">Peng et al., 2023</a>)</span>: takes a more sophisticated approach by interpolating frequencies unevenly across RoPE dimensions using a ramp or scaling function. Unlike ABF’s uniform adjustment, YaRN applies different scaling factors to different frequency components, optimizing the extended context window. It includes additional techniques like dynamic attention scaling and temperature adjustment in attention logits, which help preserve performance at very large context sizes. YaRN enables efficient “train short, test long” strategies, requiring fewer tokens and less fine-tuning for robust extrapolation. While more complex than ABF, YaRN generally delivers better empirical performance for extremely long contexts by providing smoother scaling and mitigating catastrophic attention loss. It can also be leveraged in inference alone without any finetuning.</p>
<p>These frequency adjustment methods slow down the attention score decay effect and maintain the contribution of distant tokens. For instance, the training of Qwen3 involved increasing the frequency from 10k to 1M using ABF as the sequence length was extended from 4k to 32k context (the team then applies YaRN to reach 131k, 4x extrapolation). Note that there’s no strong consensus on optimal values, and it’s usually good to experiment with different RoPE values during the context extension phase to find what works best for your specific setup and evaluation benchmarks.</p>
<p>Most major models today use RoPE: Llama, Qwen, Gemma, and many others. The technique has proven robust across different model sizes and architectures (dense, MoE, Hybrid). Let’s have a look at a few flavours of rope that have emerged recently.</p>
<p><strong>Hybrid Positional Encoding Approaches</strong></p>
<p>However as models push toward increasingly large contexts <span class="" id="citation--qwen1million--llama4--36">(<a href="https://ai.meta.com/blog/llama-4-multimodal-intelligence/" id="refctx-bib-llama4-1" data-ref-id="bib-llama4" target="_blank" rel="noopener noreferrer">Meta AI, 2025</a>; <a href="https://arxiv.org/abs/2501.15383" id="refctx-bib-qwen1million-1" data-ref-id="bib-qwen1million" target="_blank" rel="noopener noreferrer">Yang et al., 2025</a>)</span>, even RoPE started to hit performance challenges. The standard approach of increasing RoPE’s frequency during long context extension has limitations when evaluated on long context benchmarks more challenging than Needle in the Haystack (NIAH) <span class="" id="citation--niah--37">(<a href="https://github.com/gkamradt/LLMTest_NeedleInAHaystack" id="refctx-bib-niah-1" data-ref-id="bib-niah" target="_blank" rel="noopener noreferrer">Kamradt, 2023</a>)</span>, such as Ruler and HELMET <span class="" id="citation--ruler--helmet--38">(<a href="https://arxiv.org/abs/2404.06654" id="refctx-bib-ruler-1" data-ref-id="bib-ruler" target="_blank" rel="noopener noreferrer">Hsieh et al., 2024</a>; <a href="https://arxiv.org/abs/2410.02694" id="refctx-bib-helmet-1" data-ref-id="bib-helmet" target="_blank" rel="noopener noreferrer">Yen et al., 2025</a>)</span>. Newer techniques have been introduced to help.</p>
<p>We started this section by saying that transformers need positional information to understand token order but recent research has challenged this assumption. What if explicit positional encodings weren’t necessary after all?</p>
<p><strong>NoPE (No Position Embedding)</strong>  <span class="" id="citation--nope--39">(<a href="https://arxiv.org/abs/2305.19466" id="refctx-bib-nope-1" data-ref-id="bib-nope" target="_blank" rel="noopener noreferrer">Kazemnejad et al., 2023</a>)</span> trains transformers without any explicit positional encoding, allowing the model to implicitly learn positional information through causal masking and attention patterns. The authors show that this approach demonstrates better length generalisetion compared to ALiBi and RoPE. Without explicit position encoding to extrapolate beyond training lengths, NoPE naturally handles longer contexts. In practice though, NoPE models tend to show weaker performance on short context reasoning and knowledge tasks compared to RoPE  (<a href="https://arxiv.org/pdf/2501.18795">Yang et al</a>.). This suggests that while explicit positional encodings may limit extrapolation, they provide useful inductive biases for tasks within the training context length.</p>
<p><strong>RNoPE Hybrid Approach:</strong>  Given these trade-offs; <span class="" id="citation--rnope--40"><a href="https://arxiv.org/abs/2501.18795" id="refctx-bib-rnope-1" data-ref-id="bib-rnope" target="_blank" rel="noopener noreferrer">B. Yang et al. (2025)</a></span> suggest that combining different positional encoding strategies might be interesting. They introduce, RNoPE alternates between RoPE and NoPE layers throughout the model. RoPE layers provide explicit positional information and handle local context with recency bias, while NoPE layers improve information retrieval across long distances. This technique was recently used in Llama4, Command A and  <strong>SmolLM3</strong> .</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>Naming convention</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>We’ll call RNoPE “NoPE” for the rest of this blog to keep things simple. (You’ll often see people use “NoPE” to mean RNoPE in discussions).</p> </div> </div> </div> 
<p><strong>Ablation - NoPE matches RoPE on short context</strong></p>
<p>Let’s test the hybrid NoPE approach. We’ll compare a pure RoPE 1B ablation baseline against a NoPE variant that removes positional encoding every 4th layer, and a third configuration combining NoPE with document masking to test the interaction between these techniques. Our base question is: can we maintain strong short-context performance while gaining long-context capabilities?</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-znemzbgvlso" data-config="{&#34;dataUrl&#34;:&#34;./data/nope_loss.csv&#34;,&#34;xDomain&#34;:[0,45000000000],&#34;yDomain&#34;:[2.1,2.7],&#34;smoothing&#34;:true,&#34;title&#34;:&#34;NoPE Loss&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-7htbhj783m3" data-config="{&#34;dataUrl&#34;:&#34;./data/nope_evals.csv&#34;,&#34;charts&#34;:[{&#34;title&#34;:&#34;HellaSwag&#34;,&#34;metric&#34;:&#34;hellaswag&#34;},{&#34;title&#34;:&#34;MMLU&#34;,&#34;metric&#34;:&#34;mmlu&#34;},{&#34;title&#34;:&#34;ARC&#34;,&#34;metric&#34;:&#34;arc&#34;},{&#34;title&#34;:&#34;PIQA&#34;,&#34;metric&#34;:&#34;piqa&#34;},{&#34;title&#34;:&#34;OpenBookQA&#34;,&#34;metric&#34;:&#34;openbookqa&#34;},{&#34;title&#34;:&#34;WinoGrande&#34;,&#34;metric&#34;:&#34;winogrande&#34;}],&#34;smoothing&#34;:true,&#34;smoothingWindow&#34;:15}"><!-- 
  Multi-Line Charts Grid
  
  A configurable grid of line charts with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute:
  {
    "dataUrl": "./assets/data/your_data.csv",
    "charts": [
      { "title": "Chart 1", "metric": "metric1" },
      { "title": "Chart 2", "metric": "metric2" },
      ...
    ],
    "smoothingWindow": 15,
    "smoothingCurve": "monotoneX",
    "gridColumns": 3  // Optional: number of columns (default: 3)
  }
  
  CSV format: run_name, step, metric1, metric2, ...
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/d3-six-line-charts.html" 
    config={{ 
      dataUrl: "./assets/data/attention_evals.csv",
      charts: [
        { title: "HellaSwag", metric: "hellaswag" },
        { title: "MMLU", metric: "mmlu" },
        { title: "ARC", metric: "arc" },
        { title: "PIQA", metric: "piqa" },
        { title: "OpenBookQA", metric: "openbookqa" },
        { title: "WinoGrande", metric: "winogrande" }
      ],
      smoothingWindow: 15
    }} 
  />
-->
<div class="d3-multi-charts"></div>
<style>
  .d3-multi-charts {
    position: relative;
    container-type: inline-size;
  }

  /* Legend header */
  .d3-multi-charts__header {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
  }

  .d3-multi-charts__header .legend-bottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
    max-width: 80%;
  }

  .d3-multi-charts__header .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-multi-charts__header .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
    justify-content: center;
  }

  .d3-multi-charts__header .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-multi-charts__header .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  /* Grid */
  .d3-multi-charts__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }

  /* Container queries - basées sur la largeur du container parent, pas de la viewport */
  @container (max-width: 900px) {
    .d3-multi-charts__grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @container (max-width: 600px) {
    .d3-multi-charts__grid {
      grid-template-columns: 1fr;
    }
  }

  .chart-cell {
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
    box-shadow: inset 0 0 0 1px var(--border-color);
    border-radius: 8px;
  }

  .chart-cell__title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
    margin-bottom: 8px;
    padding-bottom: 8px;
  }

  .chart-cell__body {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .chart-cell__body svg {
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* Reset button */
  .chart-cell .reset-button {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
    display: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-size: 11px;
    padding: 3px 6px;
    border-radius: 4px;
    background: var(--surface-bg);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    cursor: pointer;
  }

  /* Axes */
  .d3-multi-charts .axes path {
    display: none;
  }

  .d3-multi-charts .axes line {
    stroke: var(--axis-color);
  }

  .d3-multi-charts .axes text {
    fill: var(--tick-color);
    font-size: 10px;
  }

  .d3-multi-charts .axis-label {
    fill: var(--text-color);
    font-size: 10px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    stroke-width: 3px;
    paint-order: stroke fill;
  }

  .d3-multi-charts .grid line {
    stroke: var(--grid-color);
  }

  /* Lines */
  .d3-multi-charts path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-multi-charts path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-multi-charts.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-multi-charts.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  .d3-multi-charts.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  /* Tooltip */
  .d3-multi-charts .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-multi-charts .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 200px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-multi-charts .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-multi-charts'))) {
        const cs = Array.from(document.querySelectorAll('.d3-multi-charts')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration
      const CONFIG = {
        dataUrl: embedConfig.dataUrl || './assets/data/attention_evals.csv',
        charts: embedConfig.charts || [],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        gridColumns: embedConfig.gridColumns || 3,
        chartHeight: 240,
        margin: { top: 20, right: 20, bottom: 40, left: 50 },
        zoomExtent: [1.0, 8],
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Value',
        xColumn: embedConfig.xColumn || 'tokens',
        runColumn: embedConfig.runColumn || 'run_name'
      };

      if (!CONFIG.charts.length) {
        container.innerHTML = '<p style="color: var(--danger); font-size: 12px;">Error: No charts configured</p>';
        return;
      }

      // Create legend header
      const header = document.createElement('div');
      header.className = 'd3-multi-charts__header';
      header.innerHTML = `
      <div class="legend-bottom">
        <div class="legend-title">Legend</div>
        <div class="items"></div>
      </div>
    `;
      container.appendChild(header);

      // Create grid
      const grid = document.createElement('div');
      grid.className = 'd3-multi-charts__grid';
      container.appendChild(grid);

      // Trackio footer removed

      // Create chart cells
      CONFIG.charts.forEach((chartConfig, idx) => {
        const cell = document.createElement('div');
        cell.className = 'chart-cell';
        cell.style.zIndex = CONFIG.charts.length - idx; // Stacking order
        cell.innerHTML = `
        <div class="chart-cell__title">${chartConfig.title}</div>
        <button class="reset-button">Reset</button>
        <div class="chart-cell__body"></div>
      `;
        grid.appendChild(cell);
      });

      // Data
      let allData = [];
      let runList = [];
      let runColorMap = {};

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].value)) { sum += values[j].value; count++; } }
          const avg = count ? (sum / count) : values[i].value;
          out[i] = { step: values[i].step, value: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Init each chart
      function initChart(cellElement, chartConfig) {
        const bodyEl = cellElement.querySelector('.chart-cell__body');
        const resetBtn = cellElement.querySelector('.reset-button');

        const metric = chartConfig.metric;
        let smoothEnabled = CONFIG.smoothing;
        let hasMoved = false;

        // Tooltip
        let tip = cellElement.querySelector('.d3-tooltip');
        let tipInner;
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'd3-tooltip';
          Object.assign(tip.style, {
            position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
            padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
            background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease', zIndex: '20'
          });
          tipInner = document.createElement('div');
          tipInner.className = 'd3-tooltip__inner';
          tip.appendChild(tipInner);
          cellElement.appendChild(tip);
        } else {
          tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
        }

        // Create SVG
        const svg = d3.select(bodyEl).append('svg').attr('width', '100%').style('display', 'block');

        // Clip path
        const clipId = 'clip-' + Math.random().toString(36).slice(2);
        const clipPath = svg.append('defs').append('clipPath').attr('id', clipId);
        const clipRect = clipPath.append('rect');

        // Groups
        const g = svg.append('g');
        const gGrid = g.append('g').attr('class', 'grid');
        const gAxes = g.append('g').attr('class', 'axes');
        const gPlot = g.append('g').attr('class', 'plot').attr('clip-path', `url(#${clipId})`);
        const gHover = g.append('g').attr('class', 'hover-layer');
        const overlay = g.append('rect').attr('class', 'overlay').attr('fill', 'none').attr('pointer-events', 'all').style('cursor', 'grab')
          .on('mousedown', function () {
            d3.select(this).style('cursor', 'grabbing');
            tip.style.opacity = '0';
            if (hoverLine) hoverLine.style('display', 'none');
          })
          .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

        // Scales
        const xScale = d3.scaleLinear();
        const yScale = d3.scaleLinear();

        // Hover state
        let hoverLine = null;
        let steps = [];
        let hideTipTimer = null;

        // Formatters (will be set in render())
        let formatStep = (v) => v;
        let formatValue = (v) => v;

        // Zoom
        const zoom = d3.zoom().scaleExtent(CONFIG.zoomExtent).on('zoom', zoomed);
        overlay.call(zoom);

        function zoomed(event) {
          const transform = event.transform;
          hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
          updateResetButton();

          const newXScale = transform.rescaleX(xScale);
          const newYScale = transform.rescaleY(yScale);

          const innerWidth = xScale.range()[1];

          // Update grid
          const gridTicks = newYScale.ticks(5);
          gGrid.selectAll('line').data(gridTicks).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => newYScale(d)).attr('y2', d => newYScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Update lines
          const line = d3.line()
            .x(d => newXScale(d.step))
            .y(d => newYScale(d.value))
            .curve(getCurve(smoothEnabled));

          gPlot.selectAll('path.ghost-line')
            .attr('d', d => {
              const rawLine = d3.line().x(d => newXScale(d.step)).y(d => newYScale(d.value)).curve(d3.curveLinear);
              return rawLine(d.values);
            });

          gPlot.selectAll('path.main-line')
            .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

          // Update axes
          gAxes.select('.x-axis').call(d3.axisBottom(newXScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.select('.y-axis').call(d3.axisLeft(newYScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
        }

        function updateResetButton() {
          if (hasMoved) {
            resetBtn.style.display = 'block';
            requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
          } else {
            resetBtn.style.opacity = '0';
            setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
          }
        }

        function render() {
          const rect = bodyEl.getBoundingClientRect();
          const width = Math.max(1, Math.round(rect.width || 400));
          const height = CONFIG.chartHeight;
          svg.attr('width', width).attr('height', height);

          const margin = CONFIG.margin;
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;

          g.attr('transform', `translate(${margin.left},${margin.top})`);

          // Filter data for this metric
          const metricData = allData.filter(d => d[metric] != null && !isNaN(d[metric]));

          if (!metricData.length) {
            return;
          }

          // Auto-compute domains from data
          const stepExtent = d3.extent(metricData, d => d.step);
          const valueExtent = d3.extent(metricData, d => d[metric]);

          xScale.domain(stepExtent).range([0, innerWidth]);
          yScale.domain(valueExtent).range([innerHeight, 0]);

          // Create smart formatters based on actual data
          const stepValues = metricData.map(d => d.step);
          const metricValues = metricData.map(d => d[metric]);
          formatStep = createSmartFormatter(stepValues);
          formatValue = createSmartFormatter(metricValues);

          // Update clip
          clipRect.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update overlay
          overlay.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update zoom extent
          zoom.extent([[0, 0], [innerWidth, innerHeight]])
            .translateExtent([[0, 0], [innerWidth, innerHeight]]);

          // Grid
          gGrid.selectAll('line').data(yScale.ticks(5)).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Axes
          gAxes.selectAll('*').remove();
          gAxes.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.append('g').attr('class', 'y-axis')
            .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
          gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');
          gAxes.selectAll('text').attr('fill', 'var(--tick-color)');

          // Axis labels
          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight + 32)
            .attr('text-anchor', 'middle')
            .text(CONFIG.xAxisLabel);

          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -38)
            .attr('text-anchor', 'middle')
            .text(CONFIG.yAxisLabel);

          // Group data by run
          const dataByRun = {};
          runList.forEach(run => { dataByRun[run] = []; });
          metricData.forEach(d => {
            if (dataByRun[d.run]) dataByRun[d.run].push({ step: d.step, value: d[metric] });
          });
          runList.forEach(run => { dataByRun[run].sort((a, b) => a.step - b.step); });

          const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] })).filter(s => s.values.length > 0);

          // Ghost lines
          const ghostLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(d3.curveLinear);
          gPlot.selectAll('path.ghost-line').data(series, d => d.run).join('path')
            .attr('class', 'ghost-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 1.5)
            .attr('opacity', smoothEnabled ? 0.15 : 0)
            .attr('pointer-events', 'none')
            .attr('d', d => ghostLine(d.values));

          // Main lines
          const mainLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(getCurve(smoothEnabled));
          gPlot.selectAll('path.main-line').data(series, d => d.run).join('path')
            .attr('class', 'main-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('opacity', 0.85)
            .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

          // Hover
          setupHover(series, innerWidth, innerHeight);
        }

        function setupHover(series, innerWidth, innerHeight) {
          gHover.selectAll('*').remove();

          hoverLine = gHover.append('line')
            .style('stroke', 'var(--text-color)')
            .attr('stroke-opacity', 0.25)
            .attr('stroke-width', 1)
            .attr('y1', 0)
            .attr('y2', innerHeight)
            .style('display', 'none')
            .attr('pointer-events', 'none');

          const stepSet = new Set();
          series.forEach(s => s.values.forEach(v => stepSet.add(v.step)));
          steps = Array.from(stepSet).sort((a, b) => a - b);

          overlay.on('mousemove', function (ev) {
            if (ev.buttons === 0) onHoverMove(ev, series);
          }).on('mouseleave', onHoverLeave);
        }

        function onHoverMove(ev, series) {
          if (hideTipTimer) { clearTimeout(hideTipTimer); hideTipTimer = null; }

          const [mx, my] = d3.pointer(ev, overlay.node());
          const targetStep = xScale.invert(mx);
          const nearest = steps.reduce((best, t) => Math.abs(t - targetStep) < Math.abs(best - targetStep) ? t : best, steps[0]);

          const xpx = xScale(nearest);
          hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

          let html = `<div><strong>${chartConfig.title}</strong></div>`;
          html += `<div>${formatStep(nearest)}</div>`;

          const entries = series.map(s => {
            const values = s.values;
            let before = null, after = null;
            for (let i = 0; i < values.length; i++) {
              if (values[i].step <= nearest) before = values[i];
              if (values[i].step >= nearest && !after) { after = values[i]; break; }
            }

            let interpolatedValue = null;
            if (before && after && before.step !== after.step) {
              const t = (nearest - before.step) / (after.step - before.step);
              interpolatedValue = before.value + t * (after.value - before.value);
            } else if (before && before.step === nearest) {
              interpolatedValue = before.value;
            } else if (after && after.step === nearest) {
              interpolatedValue = after.value;
            } else if (before) {
              interpolatedValue = before.value;
            } else if (after) {
              interpolatedValue = after.value;
            }

            return { run: s.run, color: s.color, value: interpolatedValue };
          }).filter(e => e.value != null);

          entries.sort((a, b) => b.value - a.value);

          entries.forEach(e => {
            html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.value.toFixed(4)}</span></div>`;
          });

          tipInner.innerHTML = html;
          const offsetX = 12, offsetY = 12;
          tip.style.opacity = '1';
          tip.style.transform = `translate(${Math.round(mx + offsetX + CONFIG.margin.left)}px, ${Math.round(my + offsetY + CONFIG.margin.top)}px)`;
        }

        function onHoverLeave() {
          hideTipTimer = setTimeout(() => {
            tip.style.opacity = '0';
            tip.style.transform = 'translate(-9999px, -9999px)';
            if (hoverLine) hoverLine.style('display', 'none');
          }, 100);
        }

        // Reset button
        resetBtn.addEventListener('click', () => {
          overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        });

        return { render };
      }

      // Load data
      async function load() {
        try {
          const response = await fetch(CONFIG.dataUrl, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);

          const csvText = await response.text();

          // Parse CSV (long format: run_name, metric, tokens, value)
          const rawRows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            metric: (d.metric || '').trim(),
            tokens: +d[CONFIG.xColumn],
            value: +d.value
          }));

          // Pivot data: group by run + tokens, create columns for each metric
          const pivotMap = new Map();
          rawRows.forEach(row => {
            if (isNaN(row.tokens) || isNaN(row.value)) return;

            const key = `${row.run}|${row.tokens}`;
            if (!pivotMap.has(key)) {
              pivotMap.set(key, { run: row.run, step: row.tokens });
            }
            const pivotRow = pivotMap.get(key);
            pivotRow[row.metric] = row.value;
          });

          allData = Array.from(pivotMap.values());

          runList = Array.from(new Set(allData.map(d => d.run))).sort();

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => { runColorMap[run] = colors[i % colors.length]; });

          // Build legend
          const legendItemsHost = header.querySelector('.legend-bottom .items');
          if (legendItemsHost) {
            legendItemsHost.innerHTML = runList.map(run => {
              const color = runColorMap[run];
              return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
            }).join('');

            // Add hover interactions
            legendItemsHost.querySelectorAll('.item').forEach(el => {
              el.addEventListener('mouseenter', () => {
                const run = el.getAttribute('data-run');
                container.classList.add('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                grid.querySelectorAll('path.ghost-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                legendItemsHost.querySelectorAll('.item').forEach(it => {
                  it.classList.toggle('ghost', it.getAttribute('data-run') !== run);
                });
              });

              el.addEventListener('mouseleave', () => {
                container.classList.remove('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => path.classList.remove('ghost'));
                grid.querySelectorAll('path.ghost-line').forEach(path => path.classList.remove('ghost'));
                legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
              });
            });
          }

          // Init all charts
          const cells = Array.from(grid.querySelectorAll('.chart-cell'));
          const chartInstances = cells.map((cell, idx) => initChart(cell, CONFIG.charts[idx]));

          // Render all
          chartInstances.forEach(chart => chart.render());

          // Responsive - observe container for resize
          let resizeTimer;
          const handleResize = () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              chartInstances.forEach(chart => chart.render());
            }, 100);
          };

          const ro = window.ResizeObserver ? new ResizeObserver(handleResize) : null;
          if (ro) {
            ro.observe(container);
          }

          // Also observe window resize as fallback
          window.addEventListener('resize', handleResize);

          // Force a re-render after a short delay to ensure proper sizing
          setTimeout(() => {
            chartInstances.forEach(chart => chart.render());
          }, 100);

        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure> </div>
<p>The loss and evaluation results show similar performance across all three configurations, indicating that NoPE maintains strong short-context capabilities while providing the foundation for better long-context handling. Given these results, we adopted the NoPE + document masking combination for SmolLM3.</p>
<p><strong>Partial/Fractional RoPE:</strong>  Another complementary idea is to only apply RoPE on a subset of the model dimension. Unlike RNoPE, which alternates entire layers between RoPE and NoPE, Partial RoPE mixes them within the same layer. Recent models such as GLM‑4.5 <span class="" id="citation--glm45--41">(<a href="https://arxiv.org/abs/2508.06471" id="refctx-bib-glm45-1" data-ref-id="bib-glm45" target="_blank" rel="noopener noreferrer">5 Team et al., 2025</a>)</span> or Minimax-01 <span class="" id="citation--minimax01--42">(<a href="https://arxiv.org/abs/2501.08313" id="refctx-bib-minimax01-1" data-ref-id="bib-minimax01" target="_blank" rel="noopener noreferrer">MiniMax et al., 2025</a>)</span> adopt this strategy but this was also present in older models such as gpt-j <span class="" id="citation--gptj--43">(<a href="https://github.com/kingoflolz/mesh-transformer-jax" id="refctx-bib-gptj-1" data-ref-id="bib-gptj" target="_blank" rel="noopener noreferrer">Wang &amp; Komatsuzaki, 2021</a>)</span>. You will also see this in every model using MLA since it’s a must have to have reasonable inference cost.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>🔧</span> <div class="note__title" data-astro-cid-qg6lmfty>Technical explanation: Why Partial RoPE is essential for MLA</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>MLA makes inference efficient with projection absorption: instead of storing per-head keys  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>k</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">k_i^{(h)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3217em;vertical-align:-0.2769em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.4231em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em"><span></span></span></span></span></span></span></span></span></span> , it caches a small shared latent  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><msub><mi>W</mi><mi>c</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><msub><mi>d</mi><mi>c</mi></msub></msup></mrow><annotation encoding="application/x-tex">c_i = x_i W_c \in \mathbb{R}^{d_c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>  and merges the head’s query/key maps so each score is cheap. With  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>q</mi><mi>t</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><msub><mi>x</mi><mi>t</mi></msub><msubsup><mi>W</mi><mi>q</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">q_t^{(h)} = x_t W_q^{(h)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2906em;vertical-align:-0.2458em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.4542em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2458em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.2975em;vertical-align:-0.2527em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.5834em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">q</span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2527em"><span></span></span></span></span></span></span></span></span></span>  and  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>k</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><msub><mi>c</mi><mi>i</mi></msub><msup><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">k_i^{(h)} = c_i E^{(h)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3217em;vertical-align:-0.2769em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.4231em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.038em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> , define  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>U</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><msubsup><mi>W</mi><mi>q</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup><msup><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">U^{(h)} = W_q^{(h)} E^{(h)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.2975em;vertical-align:-0.2527em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.5834em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">q</span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2527em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>  to get:</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>s</mi><mrow><mi>t</mi><mo separator="true">,</mo><mi>i</mi></mrow><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>1</mn><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac></mstyle><mtext> </mtext><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><msubsup><mi>q</mi><mi>t</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup><msup><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mi mathvariant="normal">⊤</mi></msup><msubsup><mi>k</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>1</mn><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac></mstyle><mtext> </mtext><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><msub><mi>x</mi><mi>t</mi></msub><msup><mi>U</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msup><msup><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mi mathvariant="normal">⊤</mi></msup><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_{t,i}^{(h)} \;=\; \tfrac{1}{\sqrt{d_k}}\,\big(q_t^{(h)}\big)^\top k_i^{(h)}\;=\; \tfrac{1}{\sqrt{d_k}}\,\big(x_t U^{(h)}\big)^\top c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4578em;vertical-align:-0.413em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.627em;vertical-align:-0.538em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em"><span style="top:-2.5864em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8622em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mtight" style="padding-left:0.833em"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span><span style="top:-2.8222em"><span class="pstrut" style="height:3em"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1778em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.538em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.4542em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2458em"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="delimsizing size1">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.089em"><span style="top:-3.3029em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.4231em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.627em;vertical-align:-0.538em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em"><span style="top:-2.5864em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8622em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mtight" style="padding-left:0.833em"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span><span style="top:-2.8222em"><span class="pstrut" style="height:3em"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1778em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.538em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="delimsizing size1">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.089em"><span style="top:-3.3029em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span><p>so you compute with  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover accent="true"><mi>q</mi><mo>~</mo></mover><mi>t</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><msub><mi>x</mi><mi>t</mi></msub><msup><mi>U</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><msub><mi>d</mi><mi>c</mi></msub></msup></mrow><annotation encoding="application/x-tex">\tilde q_t^{(h)} = x_t U^{(h)} \in \mathbb{R}^{d_c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2906em;vertical-align:-0.2458em"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:0.03588em">q</span></span><span style="top:-3.35em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-0.1667em"><span class="mord">~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.4542em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2458em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.038em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>  against the tiny cache  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  (no per-head k stored). RoPE breaks this because it inserts a pair-dependent rotation between the two maps: with full-dim RoPE,</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>s</mi><mrow><mi>t</mi><mo separator="true">,</mo><mi>i</mi></mrow><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mstyle displaystyle="false" scriptlevel="0"><mfrac><mn>1</mn><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac></mstyle><mtext> </mtext><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><msub><mi>x</mi><mi>t</mi></msub><msubsup><mi>W</mi><mi>q</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup><msup><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mi mathvariant="normal">⊤</mi></msup><munder><munder><msub><mi>R</mi><mrow><mi>t</mi><mo>−</mo><mi>i</mi></mrow></msub><mo stretchy="true">⏟</mo></munder><mrow><mtext>depends on </mtext><mi>t</mi><mo>−</mo><mi>i</mi></mrow></munder><mtext> </mtext><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><msub><mi>c</mi><mi>i</mi></msub><msup><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo></mrow><annotation encoding="application/x-tex">s_{t,i}^{(h)} \;=\; \tfrac{1}{\sqrt{d_k}}\,\big(x_t W_q^{(h)}\big)^\top
\underbrace{R_{t-i}}_{\text{depends on } t-i}\,\big(c_i E^{(h)}\big)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4578em;vertical-align:-0.413em"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.4231em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.7676em;vertical-align:-1.6785em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em"><span style="top:-2.5864em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8622em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mtight" style="padding-left:0.833em"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span><span style="top:-2.8222em"><span class="pstrut" style="height:3em"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1778em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.538em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.938em"><span style="top:-2.453em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">q</span></span></span><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="delimsizing size1">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.089em"><span style="top:-3.3029em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em"><span style="top:-1.4576em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">depends on </span></span><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em"><span class="svg-align" style="top:-2.1437em"><span class="pstrut" style="height:3em"></span><span class="stretchy" style="height:0.548em;min-width:1.6em"><span class="brace-left" style="height:0.548em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"></path></svg></span><span class="brace-center" style="height:0.548em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"></path></svg></span><span class="brace-right" style="height:0.548em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"></path></svg></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8563em"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.6785em"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="delimsizing size1">)</span></span></span></span></span></span><p>so you can’t pre-merge  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>W</mi><mi>q</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">W_q^{(h)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2975em;vertical-align:-0.2527em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.5834em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">q</span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2527em"><span></span></span></span></span></span></span></span></span></span>  and  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">E^{(h)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>  into a fixed  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>U</mi><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">U^{(h)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> . Fix: partial RoPE. Split head dims  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>=</mo><msub><mi>d</mi><mtext>nope</mtext></msub><mo>+</mo><msub><mi>d</mi><mtext>rope</mtext></msub></mrow><annotation encoding="application/x-tex">d_k = d_{\text{nope}} + d_{\text{rope}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">nope</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">rope</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span> , apply no rotation on the big block (absorb as before:  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>t</mi></msub><msubsup><mi>U</mi><mtext>nope</mtext><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></msubsup><msup><mo stretchy="false">)</mo><mi mathvariant="normal">⊤</mi></msup><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(x_t U_{\text{nope}}^{(h)})^\top c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2975em;vertical-align:-0.2527em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.5834em;margin-left:-0.109em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">nope</span></span></span></span></span><span style="top:-3.2198em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">h</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2527em"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> ) and apply RoPE only on a small block.</p> </div> </div> </div> 
<p><strong>Limiting Attention Scope for Long Contexts</strong></p>
<p>So far, we’ve explored how to handle positional information for long contexts: activating RoPE, disabling it (NoPE), applying it partially on some layers (RNoPE) or on some hidden dimensions (Partial RoPE), or adjusting its frequency (ABF, YaRN). These approaches modify how the model encodes position to handle sequences longer than those seen during training. But there’s a complementary strategy: instead of adjusting positional encodings, we can limit which tokens attend to each other.</p>
<p>To see why this matters, consider a model pretrained with sequences of 8 tokens. At inference time, we want to process 16 tokens (more than the training length). Positions 8-15 are out of distribution for the model’s positional encodings. While techniques like RoPE ABF address this by adjusting position frequencies, attention scope methods take a different approach: they strategically restrict which tokens can attend to each other, keeping attention patterns within familiar ranges while still processing the full sequence. This reduces both computational cost and memory requirements. The diagram below compares five strategies for handling our 16-token sequence with a pretraining window of 8:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-wglrk0h7i"><div class="position-masking"></div>

<style>
    .position-masking {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        line-height: 1.5;
        color: var(--text-color);
        padding: 20px 0;
    }

    .position-masking .sentence-display {
        padding: 15px;
        margin: 0 auto 30px auto;
        text-align: center;
        max-width: 90%;
    }

    .position-masking .section-title {
        font-size: 1.2rem;
        font-weight: 600;
        margin-bottom: 15px;
        color: var(--text-color);
    }

    .position-masking .token-sequence {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        margin-bottom: 10px;
        justify-content: center;
    }

    .position-masking .token {
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 500;
        white-space: nowrap;
        cursor: pointer;
        transition: all 0.2s ease;
        background: var(--page-bg);
        border: 1px solid var(--border-color);
        color: var(--text-color);
    }


    .position-masking .token-index {
        font-size: 0.65rem;
        color: var(--muted-color);
        margin-top: 2px;
    }

    .position-masking .controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        margin-bottom: 20px;
    }

    .position-masking .controls label {
        font-size: 14px;
        color: var(--text-color);
        font-weight: 700;
    }

    .position-masking .controls select {
        width: 60%;
    }


    .position-masking .configs-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 30px;
        margin-top: 20px;
    }

    .position-masking .config-section {
        text-align: center;
    }

    .position-masking .config-title {
        font-weight: 600;
        font-size: 1.1rem;
        margin-bottom: 10px;
        color: var(--text-color);
    }

    .position-masking .config-description {
        font-size: 0.85rem;
        color: var(--muted-color);
        margin-bottom: 10px;
        min-height: 20px;
    }

    .position-masking .matrix-container {
        display: grid;
        grid-template-columns: 30px 1fr;
        grid-template-rows: 1fr 20px;
        gap: 4px;
        justify-self: center;
        align-items: center;
        background: var(--page-bg) !important;
        border: 0.5px solid var(--border-color);
        border-radius: 4px;
        padding: 8px;
        /* box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); */
        margin: 0 auto;
        max-width: 600px;
    }

    .position-masking .row-labels {
        display: grid;
        gap: 2px;
        font-size: 0.7rem;
        font-weight: 600;
        color: var(--muted-color);
    }

    .position-masking .row-label {
        height: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 3px;
    }

    .position-masking .col-labels {
        display: grid;
        gap: 2px;
        font-size: 0.7rem;
        font-weight: 600;
        color: var(--muted-color);
        grid-column: 2;
    }

    .position-masking .col-label {
        width: 18px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .position-masking .attention-matrix {
        display: grid;
        gap: 2px;
        justify-items: stretch;
        align-items: stretch;
        grid-column: 2;
        grid-row: 1;
        position: relative;
    }

    .position-masking .position-cell {
        width: 18px;
        height: 18px;
        border-radius: 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        font-weight: 600;
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .position-masking .position-cell.empty {
        background: var(--page-bg);
        color: transparent;
    }

    .position-masking .position-cell.causal-mask {
        background-color: var(--border-color);
    }

    .position-masking .tooltip {
        position: absolute;
        background: var(--surface-bg);
        color: var(--text-color);
        padding: 8px 10px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        border: 1px solid var(--border-color);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        pointer-events: none;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.2s ease;
        max-width: 280px;
        text-align: left;
        line-height: 1.3;
    }

    .position-masking .tooltip.show {
        opacity: 1;
    }

    /* Color scale will be set dynamically using diverging palette */

    /* Responsive design */
    @media (max-width: 1200px) {
        .position-masking .configs-grid {
            grid-template-columns: 1fr;
        }
    }

    @media (max-width: 600px) {
        .position-masking .position-cell {
            width: 18px;
            height: 18px;
            font-size: 8px;
        }

        .position-masking .matrix-container {
            grid-template-columns: 40px 1fr;
            padding: 10px;
        }
    }
</style>

<script>
    (() => {
        const bootstrap = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;
            if (!(container && container.classList && container.classList.contains('position-masking'))) {
                const candidates = Array.from(document.querySelectorAll('.position-masking'))
                    .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
                container = candidates[candidates.length - 1] || null;
            }
            if (!container) return;
            if (container.dataset) {
                if (container.dataset.mounted === 'true') return;
                container.dataset.mounted = 'true';
            }

            const WINDOW_SIZE = 8;
            const CHUNK_SIZE = 4;
            const LOCAL_WINDOW = 3;

            // Define the 16 tokens
            const tokens = [
                'The', 'history', 'of', 'artificial', 'intelligence', 'began', 'in', 'the',
                'twentieth', 'century', 'with', 'fundamental', 'research', 'into', 'computation', 'and'
            ];

            // Configuration definitions
            const configs = [
                {
                    name: 'Causal Masking (window=8)',
                    description: 'Model can only attend to past 8 tokens',
                    compute: (row, col) => {
                        if (col < WINDOW_SIZE) return null; // Columns 0-7 are empty
                        if (col > row) return null; // Future tokens
                        if (row - col >= WINDOW_SIZE) return null; // Beyond window
                        return row - col;
                    }
                },
                {
                    name: 'RoPE ABF',
                    description: 'Adjusted Base Frequency dividing by 2',
                    compute: (row, col) => {
                        if (col === 0) return null; // First column empty
                        if (col > row) return null;
                        return (row - col) * 0.5;
                    }
                },
                {
                    name: 'Chunked Attention',
                    description: 'Process sample in chunks of size 8',
                    compute: (row, col) => {
                        if (col > row) return null;
                        const rowChunk = Math.floor(row / WINDOW_SIZE);
                        const colChunk = Math.floor(col / WINDOW_SIZE);
                        if (rowChunk !== colChunk) return null;
                        return row - col;
                    }
                },
                {
                    name: 'Sliding Window Attention',
                    description: 'Each token attends to past 8 tokens',
                    compute: (row, col) => {
                        if (col > row) return null;
                        if (row - col >= WINDOW_SIZE) return null;
                        return row - col;
                    }
                },
                {
                    name: 'DCA (Dual Chunk Attention)',
                    description: 'c=8, s=4, w=3 combining Pintra, Pinter, Successive',
                    compute: (row, col) => {
                        if (col > row) return null;

                        const rowChunk = Math.floor(row / CHUNK_SIZE);
                        const colChunk = Math.floor(col / CHUNK_SIZE);
                        const posInChunk = row % CHUNK_SIZE;
                        const colPosInChunk = col % CHUNK_SIZE;

                        // First two chunks (0-7): normal causal
                        if (rowChunk <= 1) {
                            return row - col;
                        }

                        // For chunks 2 and beyond (rows 8+)
                        if (rowChunk === colChunk) {
                            // Intra-chunk (Pintra): normal causal within chunk
                            return row - col;
                        } else if (colChunk === rowChunk - 1) {
                            // Previous chunk (chunk 1, positions 4-7)
                            // For first LOCAL_WINDOW positions (0,1,2) in current chunk: modified values
                            if (posInChunk < LOCAL_WINDOW) {
                                // Row 8 (pos 0): 4,3,2,1 for cols 4,5,6,7
                                // Row 9 (pos 1): 5,4,3,2 for cols 4,5,6,7
                                // Row 10 (pos 2): 6,5,4,3 for cols 4,5,6,7
                                return (posInChunk + CHUNK_SIZE) - colPosInChunk;
                            } else {
                                // Last position (3) in chunk: successive attention 7,6,5,4
                                return 7 - colPosInChunk;
                            }
                        } else if (colChunk < rowChunk - 1) {
                            // Earlier chunks (chunk 0, positions 0-3): always 7,6,5,4
                            return 7 - colPosInChunk;
                        }

                        return null;
                    }
                }
            ];

            // Helper function to get color class from position value
            function getColorClass(value) {
                if (value === null) return 'empty';
                if (value === 0) return 'pos-0';
                if (value === 0.5) return 'pos-0-5';
                if (value === 1) return 'pos-1';
                if (value === 1.5) return 'pos-1-5';
                if (value === 2) return 'pos-2';
                if (value === 2.5) return 'pos-2-5';
                if (value === 3) return 'pos-3';
                if (value === 3.5) return 'pos-3-5';
                if (value === 4) return 'pos-4';
                if (value === 4.5) return 'pos-4-5';
                if (value === 5) return 'pos-5';
                if (value === 5.5) return 'pos-5-5';
                if (value === 6) return 'pos-6';
                if (value === 6.5) return 'pos-6-5';
                if (value === 7) return 'pos-7';
                if (value > 7) return 'pos-7-plus';
                return 'empty';
            }

            // Create the HTML structure
            const configSections = configs.map((config, idx) => `
        <div class="config-section">
          <div class="config-title">${config.name}</div>
          <div class="config-description">${config.description}</div>
          <div class="matrix-container">
            <div class="row-labels" id="rowLabels${idx}"></div>
            <div class="attention-matrix" id="matrix${idx}"></div>
            <div class="col-labels" id="colLabels${idx}"></div>
          </div>
        </div>
      `).join('');

            container.innerHTML = `
                <div class="sentence-display">
                  <div class="section-title">Single Document (16 tokens)</div>
                  <div class="token-sequence" id="tokenSequence">
                    ${tokens.map((token, i) => `
                      <span class="token">
                        ${token}
                        <div class="token-index">${i}</div>
                      </span>
                    `).join('')}
                  </div>
                  <div style="margin-top: 10px; font-size: 0.9rem; color: var(--muted-color);">
                    Pre-training window = 8
                  </div>
                </div>

                <div class="controls">
                  <label>Attention Pattern</label>
                  <select id="configSelect">
                    ${configs.map((config, idx) => `<option value="${idx}">${config.name}</option>`).join('')}
                  </select>
                </div>

                <div class="configs-grid">
                  <div class="config-section" id="currentConfig">
                    <!-- Will be populated dynamically -->
                  </div>
                </div>

                <div class="tooltip" id="tooltip"></div>
              `;

            // Get diverging colors (inverted)
            function getDivergingColors() {
                try {
                    if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
                        const colors = window.ColorPalettes.getColors('diverging', 9);
                        return colors.reverse(); // Invert the color order
                    }
                } catch (e) { }
                // Fallback diverging colors (red to blue - inverted)
                return [
                    '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7',
                    '#d1e5f0', '#92c5de', '#4393c3', '#2166ac'
                ];
            }

            // Get color for a position value
            function getColorForValue(value) {
                if (value === null) return 'var(--page-bg)';

                const colors = getDivergingColors();
                // Map value to color index (0-8)
                const maxValue = 7;
                const normalizedValue = Math.min(value / maxValue, 1);
                const colorIndex = Math.round(normalizedValue * (colors.length - 1));
                return colors[colorIndex];
            }

            // Get text color for better contrast
            function getTextColorForValue(value) {
                if (value === null) return 'transparent';

                const colors = getDivergingColors();
                const maxValue = 7;
                const normalizedValue = Math.min(value / maxValue, 1);
                const colorIndex = Math.round(normalizedValue * (colors.length - 1));
                const color = colors[colorIndex];

                // Calculate luminance to determine if we need light or dark text
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

                return luminance > 0.5 ? '#333' : 'white';
            }

            // Create matrix for a specific configuration
            function createMatrix(config, configIdx) {
                const currentConfigDiv = document.getElementById('currentConfig');
                const size = tokens.length;

                currentConfigDiv.innerHTML = `
                <div class="config-description">${config.description}</div>
                <div class="matrix-container">
                  <div class="row-labels" id="rowLabels"></div>
                  <div class="attention-matrix" id="matrix"></div>
                  <div class="col-labels" id="colLabels"></div>
                </div>
              `;

                const matrixContainer = document.getElementById('matrix');
                const rowLabelsContainer = document.getElementById('rowLabels');
                const colLabelsContainer = document.getElementById('colLabels');

                // Setup labels
                rowLabelsContainer.style.gridTemplateRows = `repeat(${size}, 18px)`;
                colLabelsContainer.style.gridTemplateColumns = `repeat(${size}, 18px)`;

                for (let i = 0; i < size; i++) {
                    const rowLabel = document.createElement('div');
                    rowLabel.className = 'row-label';
                    rowLabel.textContent = i;
                    rowLabelsContainer.appendChild(rowLabel);

                    const colLabel = document.createElement('div');
                    colLabel.className = 'col-label';
                    colLabel.textContent = i;
                    colLabelsContainer.appendChild(colLabel);
                }

                // Create matrix
                matrixContainer.style.gridTemplateColumns = `repeat(${size}, 18px)`;
                matrixContainer.style.gridTemplateRows = `repeat(${size}, 18px)`;

                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        const cell = document.createElement('div');
                        const value = config.compute(row, col);
                        const isCausalMask = col <= row;

                        cell.className = `position-cell`;
                        if (isCausalMask) {
                            cell.classList.add('causal-mask');
                        }
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.dataset.value = value !== null ? value : '';

                        if (value !== null) {
                            // Set background color using diverging palette
                            cell.style.backgroundColor = getColorForValue(value);
                            cell.style.color = getTextColorForValue(value);

                            // Format display value
                            const displayValue = value % 1 === 0 ? value.toString() : value.toFixed(1);
                            cell.textContent = displayValue;

                            // Add hover events
                            cell.addEventListener('mouseenter', (e) => {
                                const tooltip = document.getElementById('tooltip');
                                const fromToken = tokens[row];
                                const toToken = tokens[col];

                                tooltip.innerHTML = `
                        <div style="font-weight: 600; margin-bottom: 4px;">Relative Position: ${displayValue}</div>
                        <div style="font-size: 11px; color: var(--muted-color);">
                          Query: "${fromToken}" (pos ${row})<br>
                          Key: "${toToken}" (pos ${col})<br>
                          Distance: ${row - col} tokens
                        </div>
                      `;
                                tooltip.classList.add('show');

                                const rect = cell.getBoundingClientRect();
                                const containerRect = document.querySelector('.position-masking').getBoundingClientRect();
                                tooltip.style.left = (rect.left - containerRect.left + rect.width / 2) + 'px';
                                tooltip.style.top = (rect.top - containerRect.top - 10) + 'px';
                                tooltip.style.transform = 'translate(-50%, -100%)';
                            });

                            cell.addEventListener('mouseleave', () => {
                                const tooltip = document.getElementById('tooltip');
                                tooltip.classList.remove('show');
                            });
                        }

                        matrixContainer.appendChild(cell);
                    }
                }
            }

            // Initialize with first configuration
            createMatrix(configs[0], 0);

            // Handle select change
            const select = document.getElementById('configSelect');
            select.addEventListener('change', (e) => {
                const selectedIdx = parseInt(e.target.value);
                createMatrix(configs[selectedIdx], selectedIdx);
            });

            // Load color palettes script if not already loaded
            if (!window.ColorPalettes) {
                const script = document.createElement('script');
                script.src = '/scripts/color-palettes.js';
                script.onload = () => {
                    // Re-render with proper colors
                    const currentIdx = parseInt(select.value);
                    createMatrix(configs[currentIdx], currentIdx);
                };
                document.head.appendChild(script);
            }
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
            bootstrap();
        }
    })();
</script></div></div></figure>
<p><strong>Chunked Attention</strong>  divides the sequence into fixed size chunks, where tokens can only attend within their chunk. In our example, the 16 tokens are split into two 8 token chunks (0 to 7 and 8 to 15), and each token can only see others within its own chunk. Notice how tokens 8 through 15 cannot attend back to the earlier chunk at all. This creates isolated attention windows that reset at chunk boundaries. Llama 4 <span class="" id="citation--llama4--44">(<a href="https://ai.meta.com/blog/llama-4-multimodal-intelligence/" id="refctx-bib-llama4-2" data-ref-id="bib-llama4" target="_blank" rel="noopener noreferrer">Meta AI, 2025</a>)</span> uses chunked attention with 8192 token chunks in RoPE layers (three out of four decoder layers), while NoPE layers maintain full context access. This reduces memory requirements by limiting the KV cache size per layer, though it means tokens cannot attend to previous chunks, which may impact some long context tasks.</p>
<p><strong>Sliding Window Attention (SWA)</strong> , popularized by Mistral 7B <span class="" id="citation--jiang2023mistral7b--child2019generating--45">(<a href="#bib-child2019generating" id="refctx-bib-child2019generating-1">Child et al., 2019</a>; <a href="https://arxiv.org/abs/2310.06825" id="refctx-bib-jiang2023mistral7b-1" data-ref-id="bib-jiang2023mistral7b" target="_blank" rel="noopener noreferrer">Jiang et al., 2023</a>)</span>, takes a different approach based on the intuition that recent tokens are most relevant. Instead of hard chunk boundaries, each token attends only to the most recent N tokens. In the diagram, every token can see up to 8 positions back, creating a sliding window that moves continuously through the sequence. Notice how token 15 can attend to positions 8 through 15, while token 10 attends to positions 3 through 10. The window slides forward, maintaining local context across the entire sequence without the artificial barriers of chunking. Gemma 3 combines SWA with full attention in alternating layers, similar to how hybrid positional encoding approaches mix different strategies.</p>
<p><strong>Dual Chunk Attention (DCA)</strong>  <span class="" id="citation--dca--46">(<a href="https://arxiv.org/abs/2402.17463" id="refctx-bib-dca-1" data-ref-id="bib-dca" target="_blank" rel="noopener noreferrer">An et al., 2024</a>)</span> is a training free method that extends  <strong>chunked attention</strong>  while maintaining cross chunk information flow. In our example, we use chunk size s=4, dividing the 16 tokens into 4 chunks (visualize 4×4 squares along the diagonal). DCA combines three mechanisms: (1) Intra chunk attention where tokens attend normally within their chunk (the diagonal pattern). (2) Inter chunk attention where queries use position index c−1=7 to attend to previous chunks, creating relative positions capped at 7. (3) Successive chunk attention with local window w=3 that preserves locality between neighboring chunks. This keeps all relative positions within the training distribution (0 to 7) while maintaining smooth transitions across chunk boundaries. DCA enables models like Qwen2.5 to support ultra-long context windows up to 1 million tokens at inference time, without requiring continual training on million-token sequences.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📊</span> <div class="note__title" data-astro-cid-qg6lmfty>Attention Sinks</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>An interesting phenomenon emerges in transformer models with long contexts: the model assigns unusually high attention scores to the initial tokens in the sequence, even when these tokens aren’t semantically important. This behavior is called <strong>attention sinks</strong> (<a href="https://arxiv.org/abs/2309.17453">Xiao et al.</a>). These initial tokens act as a stabilisetion mechanism for the attention distribution, serving as a “sink” where attention can accumulate.</p><p>The practical insight is that keeping the KV cache of just the initial few tokens alongside a sliding window of recent tokens largely recovers performance when context exceeds the cache size. This simple modification enables models to handle much longer sequences without fine-tuning or performance degradation.</p><p>Modern implementations leverage attention sinks in different ways. The original research suggests adding a dedicated placeholder token during pretraining to serve as an explicit attention sink. More recently, models like <strong>gpt-oss</strong> implement attention sinks as <strong>learned per-head bias logits</strong> that are appended to the attention scores rather than actual tokens in the input sequence. This approach achieves the same stabilisetion effect without modifying the tokenized inputs.</p><p>Interestingly, gpt-oss also uses bias units in the attention layers themselves, a design choice rarely seen since GPT-2. While these bias units are generally considered redundant for standard attention operations (empirical results from <a href="https://arxiv.org/pdf/2302.08626">Dehghani et al.</a> show minimal impact on test loss), they can serve the specialized function of implementing attention sinks. The key insight: whether implemented as special tokens, learned biases, or per-head logits, attention sinks provide a stable “anchor” for attention distributions in long-context scenarios, allowing the model to store generally useful information about the entire sequence even as context grows arbitrarily long.</p> </div> </div> </div> 
<p>We’ve now covered the core components of attention: the different head configurations that balance memory and compute (MHA, GQA, MLA), the positional encoding strategies that help models understand token order (RoPE, NoPE, and their variants), and the attention scope techniques that make long contexts tractable (sliding windows, chunking, and attention sinks). We’ve also examined how embedding layers should be configured and initialized. These architectural choices define how your model processes and represents sequences.</p>
<p>But having the right architecture is only half the battle. Even well-designed models can suffer from training instability, especially at scale. Let’s look at techniques that help keep training stable.</p>
<h4 id="improving-stability"><a href="#improving-stability">Improving stability</a></h4>
<p>Let’s now turn to one of the biggest challenges in LLM pretraining: instabilities. Often manifesting as loss spikes or sudden jumps in training loss, these issues become especially common at scale.</p>
<p>While we’ll dive deeper into the different types of spikes and how to handle them in the <a href="#training-marathon">Training Marathon</a> section (diving in floating point precision, optimizers and learning rate), certain architectural and training techniques can also help us reduce instability so let’s take a moment to study them here. We’ll cover a few simple techniques used in recent large-scale training runs (e.g., Olmo2 [@olmo2] and Qwen3 [@qwen3]) to improve stability: Z-loss, removing weight decay from embeddings, and QK-norm.</p>
<p><strong>Z-loss</strong></p>
<p>Z-loss <span class="" id="citation--palm--47">(<a href="https://arxiv.org/abs/2204.02311" id="refctx-bib-palm-1" data-ref-id="bib-palm" target="_blank" rel="noopener noreferrer">Chowdhery et al., 2022</a>)</span> is a regularisation technique that prevents the final output logits from growing too large by adding a penalty term to the loss function. The regularisation encourages the denominator of the softmax over the logits to stay within a reasonable range, which helps maintain numerical stability during training.</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="script">L</mi><mtext>z-loss</mtext></msub><mo>=</mo><mi>λ</mi><mo>⋅</mo><msup><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msup><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{L}_{\text{z-loss}} = \lambda \cdot \log^2(Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathcal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">z-loss</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.1484em;vertical-align:-0.25em"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984em"><span style="top:-3.1473em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em">Z</span><span class="mclose">)</span></span></span></span></span>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-a0kfiv4n22q" data-config="{&#34;dataUrl&#34;:&#34;./data/zloss_comparison.csv&#34;,&#34;xColumn&#34;:&#34;tokens&#34;,&#34;yColumn&#34;:&#34;loss&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;xScaleType&#34;:&#34;linear&#34;,&#34;yScaleType&#34;:&#34;linear&#34;,&#34;xAxisLabel&#34;:&#34;Consumed tokens&#34;,&#34;yAxisLabel&#34;:&#34;Training Loss&#34;,&#34;xDomain&#34;:[0,45000000000],&#34;yDomain&#34;:[1,5]}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-0b4zptl3mqm" data-config="{&#34;dataUrl&#34;:&#34;./data/zloss_evals.csv&#34;,&#34;charts&#34;:[{&#34;title&#34;:&#34;HellaSwag&#34;,&#34;metric&#34;:&#34;hellaswag&#34;},{&#34;title&#34;:&#34;MMLU&#34;,&#34;metric&#34;:&#34;mmlu&#34;},{&#34;title&#34;:&#34;ARC&#34;,&#34;metric&#34;:&#34;arc&#34;},{&#34;title&#34;:&#34;PIQA&#34;,&#34;metric&#34;:&#34;piqa&#34;},{&#34;title&#34;:&#34;OpenBookQA&#34;,&#34;metric&#34;:&#34;openbookqa&#34;},{&#34;title&#34;:&#34;WinoGrande&#34;,&#34;metric&#34;:&#34;winogrande&#34;}],&#34;smoothing&#34;:false,&#34;smoothingWindow&#34;:15}"><!-- 
  Multi-Line Charts Grid
  
  A configurable grid of line charts with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute:
  {
    "dataUrl": "./assets/data/your_data.csv",
    "charts": [
      { "title": "Chart 1", "metric": "metric1" },
      { "title": "Chart 2", "metric": "metric2" },
      ...
    ],
    "smoothingWindow": 15,
    "smoothingCurve": "monotoneX",
    "gridColumns": 3  // Optional: number of columns (default: 3)
  }
  
  CSV format: run_name, step, metric1, metric2, ...
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/d3-six-line-charts.html" 
    config={{ 
      dataUrl: "./assets/data/attention_evals.csv",
      charts: [
        { title: "HellaSwag", metric: "hellaswag" },
        { title: "MMLU", metric: "mmlu" },
        { title: "ARC", metric: "arc" },
        { title: "PIQA", metric: "piqa" },
        { title: "OpenBookQA", metric: "openbookqa" },
        { title: "WinoGrande", metric: "winogrande" }
      ],
      smoothingWindow: 15
    }} 
  />
-->
<div class="d3-multi-charts"></div>
<style>
  .d3-multi-charts {
    position: relative;
    container-type: inline-size;
  }

  /* Legend header */
  .d3-multi-charts__header {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
  }

  .d3-multi-charts__header .legend-bottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
    max-width: 80%;
  }

  .d3-multi-charts__header .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-multi-charts__header .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
    justify-content: center;
  }

  .d3-multi-charts__header .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-multi-charts__header .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  /* Grid */
  .d3-multi-charts__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }

  /* Container queries - basées sur la largeur du container parent, pas de la viewport */
  @container (max-width: 900px) {
    .d3-multi-charts__grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @container (max-width: 600px) {
    .d3-multi-charts__grid {
      grid-template-columns: 1fr;
    }
  }

  .chart-cell {
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
    box-shadow: inset 0 0 0 1px var(--border-color);
    border-radius: 8px;
  }

  .chart-cell__title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
    margin-bottom: 8px;
    padding-bottom: 8px;
  }

  .chart-cell__body {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .chart-cell__body svg {
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* Reset button */
  .chart-cell .reset-button {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
    display: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-size: 11px;
    padding: 3px 6px;
    border-radius: 4px;
    background: var(--surface-bg);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    cursor: pointer;
  }

  /* Axes */
  .d3-multi-charts .axes path {
    display: none;
  }

  .d3-multi-charts .axes line {
    stroke: var(--axis-color);
  }

  .d3-multi-charts .axes text {
    fill: var(--tick-color);
    font-size: 10px;
  }

  .d3-multi-charts .axis-label {
    fill: var(--text-color);
    font-size: 10px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    stroke-width: 3px;
    paint-order: stroke fill;
  }

  .d3-multi-charts .grid line {
    stroke: var(--grid-color);
  }

  /* Lines */
  .d3-multi-charts path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-multi-charts path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-multi-charts.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-multi-charts.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  .d3-multi-charts.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  /* Tooltip */
  .d3-multi-charts .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-multi-charts .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 200px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-multi-charts .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-multi-charts'))) {
        const cs = Array.from(document.querySelectorAll('.d3-multi-charts')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration
      const CONFIG = {
        dataUrl: embedConfig.dataUrl || './assets/data/attention_evals.csv',
        charts: embedConfig.charts || [],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        gridColumns: embedConfig.gridColumns || 3,
        chartHeight: 240,
        margin: { top: 20, right: 20, bottom: 40, left: 50 },
        zoomExtent: [1.0, 8],
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Value',
        xColumn: embedConfig.xColumn || 'tokens',
        runColumn: embedConfig.runColumn || 'run_name'
      };

      if (!CONFIG.charts.length) {
        container.innerHTML = '<p style="color: var(--danger); font-size: 12px;">Error: No charts configured</p>';
        return;
      }

      // Create legend header
      const header = document.createElement('div');
      header.className = 'd3-multi-charts__header';
      header.innerHTML = `
      <div class="legend-bottom">
        <div class="legend-title">Legend</div>
        <div class="items"></div>
      </div>
    `;
      container.appendChild(header);

      // Create grid
      const grid = document.createElement('div');
      grid.className = 'd3-multi-charts__grid';
      container.appendChild(grid);

      // Trackio footer removed

      // Create chart cells
      CONFIG.charts.forEach((chartConfig, idx) => {
        const cell = document.createElement('div');
        cell.className = 'chart-cell';
        cell.style.zIndex = CONFIG.charts.length - idx; // Stacking order
        cell.innerHTML = `
        <div class="chart-cell__title">${chartConfig.title}</div>
        <button class="reset-button">Reset</button>
        <div class="chart-cell__body"></div>
      `;
        grid.appendChild(cell);
      });

      // Data
      let allData = [];
      let runList = [];
      let runColorMap = {};

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].value)) { sum += values[j].value; count++; } }
          const avg = count ? (sum / count) : values[i].value;
          out[i] = { step: values[i].step, value: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Init each chart
      function initChart(cellElement, chartConfig) {
        const bodyEl = cellElement.querySelector('.chart-cell__body');
        const resetBtn = cellElement.querySelector('.reset-button');

        const metric = chartConfig.metric;
        let smoothEnabled = CONFIG.smoothing;
        let hasMoved = false;

        // Tooltip
        let tip = cellElement.querySelector('.d3-tooltip');
        let tipInner;
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'd3-tooltip';
          Object.assign(tip.style, {
            position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
            padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
            background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease', zIndex: '20'
          });
          tipInner = document.createElement('div');
          tipInner.className = 'd3-tooltip__inner';
          tip.appendChild(tipInner);
          cellElement.appendChild(tip);
        } else {
          tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
        }

        // Create SVG
        const svg = d3.select(bodyEl).append('svg').attr('width', '100%').style('display', 'block');

        // Clip path
        const clipId = 'clip-' + Math.random().toString(36).slice(2);
        const clipPath = svg.append('defs').append('clipPath').attr('id', clipId);
        const clipRect = clipPath.append('rect');

        // Groups
        const g = svg.append('g');
        const gGrid = g.append('g').attr('class', 'grid');
        const gAxes = g.append('g').attr('class', 'axes');
        const gPlot = g.append('g').attr('class', 'plot').attr('clip-path', `url(#${clipId})`);
        const gHover = g.append('g').attr('class', 'hover-layer');
        const overlay = g.append('rect').attr('class', 'overlay').attr('fill', 'none').attr('pointer-events', 'all').style('cursor', 'grab')
          .on('mousedown', function () {
            d3.select(this).style('cursor', 'grabbing');
            tip.style.opacity = '0';
            if (hoverLine) hoverLine.style('display', 'none');
          })
          .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

        // Scales
        const xScale = d3.scaleLinear();
        const yScale = d3.scaleLinear();

        // Hover state
        let hoverLine = null;
        let steps = [];
        let hideTipTimer = null;

        // Formatters (will be set in render())
        let formatStep = (v) => v;
        let formatValue = (v) => v;

        // Zoom
        const zoom = d3.zoom().scaleExtent(CONFIG.zoomExtent).on('zoom', zoomed);
        overlay.call(zoom);

        function zoomed(event) {
          const transform = event.transform;
          hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
          updateResetButton();

          const newXScale = transform.rescaleX(xScale);
          const newYScale = transform.rescaleY(yScale);

          const innerWidth = xScale.range()[1];

          // Update grid
          const gridTicks = newYScale.ticks(5);
          gGrid.selectAll('line').data(gridTicks).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => newYScale(d)).attr('y2', d => newYScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Update lines
          const line = d3.line()
            .x(d => newXScale(d.step))
            .y(d => newYScale(d.value))
            .curve(getCurve(smoothEnabled));

          gPlot.selectAll('path.ghost-line')
            .attr('d', d => {
              const rawLine = d3.line().x(d => newXScale(d.step)).y(d => newYScale(d.value)).curve(d3.curveLinear);
              return rawLine(d.values);
            });

          gPlot.selectAll('path.main-line')
            .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

          // Update axes
          gAxes.select('.x-axis').call(d3.axisBottom(newXScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.select('.y-axis').call(d3.axisLeft(newYScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
        }

        function updateResetButton() {
          if (hasMoved) {
            resetBtn.style.display = 'block';
            requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
          } else {
            resetBtn.style.opacity = '0';
            setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
          }
        }

        function render() {
          const rect = bodyEl.getBoundingClientRect();
          const width = Math.max(1, Math.round(rect.width || 400));
          const height = CONFIG.chartHeight;
          svg.attr('width', width).attr('height', height);

          const margin = CONFIG.margin;
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;

          g.attr('transform', `translate(${margin.left},${margin.top})`);

          // Filter data for this metric
          const metricData = allData.filter(d => d[metric] != null && !isNaN(d[metric]));

          if (!metricData.length) {
            return;
          }

          // Auto-compute domains from data
          const stepExtent = d3.extent(metricData, d => d.step);
          const valueExtent = d3.extent(metricData, d => d[metric]);

          xScale.domain(stepExtent).range([0, innerWidth]);
          yScale.domain(valueExtent).range([innerHeight, 0]);

          // Create smart formatters based on actual data
          const stepValues = metricData.map(d => d.step);
          const metricValues = metricData.map(d => d[metric]);
          formatStep = createSmartFormatter(stepValues);
          formatValue = createSmartFormatter(metricValues);

          // Update clip
          clipRect.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update overlay
          overlay.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update zoom extent
          zoom.extent([[0, 0], [innerWidth, innerHeight]])
            .translateExtent([[0, 0], [innerWidth, innerHeight]]);

          // Grid
          gGrid.selectAll('line').data(yScale.ticks(5)).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Axes
          gAxes.selectAll('*').remove();
          gAxes.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.append('g').attr('class', 'y-axis')
            .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
          gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');
          gAxes.selectAll('text').attr('fill', 'var(--tick-color)');

          // Axis labels
          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight + 32)
            .attr('text-anchor', 'middle')
            .text(CONFIG.xAxisLabel);

          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -38)
            .attr('text-anchor', 'middle')
            .text(CONFIG.yAxisLabel);

          // Group data by run
          const dataByRun = {};
          runList.forEach(run => { dataByRun[run] = []; });
          metricData.forEach(d => {
            if (dataByRun[d.run]) dataByRun[d.run].push({ step: d.step, value: d[metric] });
          });
          runList.forEach(run => { dataByRun[run].sort((a, b) => a.step - b.step); });

          const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] })).filter(s => s.values.length > 0);

          // Ghost lines
          const ghostLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(d3.curveLinear);
          gPlot.selectAll('path.ghost-line').data(series, d => d.run).join('path')
            .attr('class', 'ghost-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 1.5)
            .attr('opacity', smoothEnabled ? 0.15 : 0)
            .attr('pointer-events', 'none')
            .attr('d', d => ghostLine(d.values));

          // Main lines
          const mainLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(getCurve(smoothEnabled));
          gPlot.selectAll('path.main-line').data(series, d => d.run).join('path')
            .attr('class', 'main-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('opacity', 0.85)
            .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

          // Hover
          setupHover(series, innerWidth, innerHeight);
        }

        function setupHover(series, innerWidth, innerHeight) {
          gHover.selectAll('*').remove();

          hoverLine = gHover.append('line')
            .style('stroke', 'var(--text-color)')
            .attr('stroke-opacity', 0.25)
            .attr('stroke-width', 1)
            .attr('y1', 0)
            .attr('y2', innerHeight)
            .style('display', 'none')
            .attr('pointer-events', 'none');

          const stepSet = new Set();
          series.forEach(s => s.values.forEach(v => stepSet.add(v.step)));
          steps = Array.from(stepSet).sort((a, b) => a - b);

          overlay.on('mousemove', function (ev) {
            if (ev.buttons === 0) onHoverMove(ev, series);
          }).on('mouseleave', onHoverLeave);
        }

        function onHoverMove(ev, series) {
          if (hideTipTimer) { clearTimeout(hideTipTimer); hideTipTimer = null; }

          const [mx, my] = d3.pointer(ev, overlay.node());
          const targetStep = xScale.invert(mx);
          const nearest = steps.reduce((best, t) => Math.abs(t - targetStep) < Math.abs(best - targetStep) ? t : best, steps[0]);

          const xpx = xScale(nearest);
          hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

          let html = `<div><strong>${chartConfig.title}</strong></div>`;
          html += `<div>${formatStep(nearest)}</div>`;

          const entries = series.map(s => {
            const values = s.values;
            let before = null, after = null;
            for (let i = 0; i < values.length; i++) {
              if (values[i].step <= nearest) before = values[i];
              if (values[i].step >= nearest && !after) { after = values[i]; break; }
            }

            let interpolatedValue = null;
            if (before && after && before.step !== after.step) {
              const t = (nearest - before.step) / (after.step - before.step);
              interpolatedValue = before.value + t * (after.value - before.value);
            } else if (before && before.step === nearest) {
              interpolatedValue = before.value;
            } else if (after && after.step === nearest) {
              interpolatedValue = after.value;
            } else if (before) {
              interpolatedValue = before.value;
            } else if (after) {
              interpolatedValue = after.value;
            }

            return { run: s.run, color: s.color, value: interpolatedValue };
          }).filter(e => e.value != null);

          entries.sort((a, b) => b.value - a.value);

          entries.forEach(e => {
            html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.value.toFixed(4)}</span></div>`;
          });

          tipInner.innerHTML = html;
          const offsetX = 12, offsetY = 12;
          tip.style.opacity = '1';
          tip.style.transform = `translate(${Math.round(mx + offsetX + CONFIG.margin.left)}px, ${Math.round(my + offsetY + CONFIG.margin.top)}px)`;
        }

        function onHoverLeave() {
          hideTipTimer = setTimeout(() => {
            tip.style.opacity = '0';
            tip.style.transform = 'translate(-9999px, -9999px)';
            if (hoverLine) hoverLine.style('display', 'none');
          }, 100);
        }

        // Reset button
        resetBtn.addEventListener('click', () => {
          overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        });

        return { render };
      }

      // Load data
      async function load() {
        try {
          const response = await fetch(CONFIG.dataUrl, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);

          const csvText = await response.text();

          // Parse CSV (long format: run_name, metric, tokens, value)
          const rawRows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            metric: (d.metric || '').trim(),
            tokens: +d[CONFIG.xColumn],
            value: +d.value
          }));

          // Pivot data: group by run + tokens, create columns for each metric
          const pivotMap = new Map();
          rawRows.forEach(row => {
            if (isNaN(row.tokens) || isNaN(row.value)) return;

            const key = `${row.run}|${row.tokens}`;
            if (!pivotMap.has(key)) {
              pivotMap.set(key, { run: row.run, step: row.tokens });
            }
            const pivotRow = pivotMap.get(key);
            pivotRow[row.metric] = row.value;
          });

          allData = Array.from(pivotMap.values());

          runList = Array.from(new Set(allData.map(d => d.run))).sort();

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => { runColorMap[run] = colors[i % colors.length]; });

          // Build legend
          const legendItemsHost = header.querySelector('.legend-bottom .items');
          if (legendItemsHost) {
            legendItemsHost.innerHTML = runList.map(run => {
              const color = runColorMap[run];
              return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
            }).join('');

            // Add hover interactions
            legendItemsHost.querySelectorAll('.item').forEach(el => {
              el.addEventListener('mouseenter', () => {
                const run = el.getAttribute('data-run');
                container.classList.add('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                grid.querySelectorAll('path.ghost-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                legendItemsHost.querySelectorAll('.item').forEach(it => {
                  it.classList.toggle('ghost', it.getAttribute('data-run') !== run);
                });
              });

              el.addEventListener('mouseleave', () => {
                container.classList.remove('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => path.classList.remove('ghost'));
                grid.querySelectorAll('path.ghost-line').forEach(path => path.classList.remove('ghost'));
                legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
              });
            });
          }

          // Init all charts
          const cells = Array.from(grid.querySelectorAll('.chart-cell'));
          const chartInstances = cells.map((cell, idx) => initChart(cell, CONFIG.charts[idx]));

          // Render all
          chartInstances.forEach(chart => chart.render());

          // Responsive - observe container for resize
          let resizeTimer;
          const handleResize = () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              chartInstances.forEach(chart => chart.render());
            }, 100);
          };

          const ro = window.ResizeObserver ? new ResizeObserver(handleResize) : null;
          if (ro) {
            ro.observe(container);
          }

          // Also observe window resize as fallback
          window.addEventListener('resize', handleResize);

          // Force a re-render after a short delay to ensure proper sizing
          setTimeout(() => {
            chartInstances.forEach(chart => chart.render());
          }, 100);

        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure> </div>
<p>The ablation results below on our 1B model show that adding z-loss doesn’t impact the training loss or downstream performance. For SmolLM3, we ended up not using it because our implementation introduced some training overhead that we didn’t optimized by the time we started training.</p>
<p><strong>Removing weight decay from embeddings</strong></p>
<p>Weight decay is commonly applied to all model parameters as a regularization technique, but @olmo2<a href="https://arxiv.org/abs/2501.00656"> </a>found that excluding embeddings from weight decay improves training stability. The reasoning is that weight decay causes embedding norms to gradually decrease during training, which can lead to larger gradients in early layers since the Jacobian of layer normalization is inversely proportional to the input norm <span class="" id="citation--takase2025spikemorestabilizingpretraining--48">(<a href="https://arxiv.org/abs/2312.16903" id="refctx-bib-takase2025spikemorestabilizingpretraining-1" data-ref-id="bib-takase2025spikemorestabilizingpretraining" target="_blank" rel="noopener noreferrer">Takase et al., 2025</a>)</span>.</p>
<p>We tested this approach by training three configurations: our baseline with standard weight decay, a variant with no weight decay on embeddings, and a third configuration combining all our adopted changes (no weight decay on embeddings + NoPE + document masking) to ensure no negative interactions between techniques. The loss curves and evaluation results were nearly identical across all three configurations. So we adopted all 3 changes in SmolLM3 training.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-aik0qa0lciq" data-config="{&#34;dataUrl&#34;:&#34;./data/no_wd_comparison.csv&#34;,&#34;xColumn&#34;:&#34;tokens&#34;,&#34;yColumn&#34;:&#34;loss&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;xScaleType&#34;:&#34;linear&#34;,&#34;yScaleType&#34;:&#34;linear&#34;,&#34;xAxisLabel&#34;:&#34;Consumed tokens&#34;,&#34;yAxisLabel&#34;:&#34;Training Loss&#34;,&#34;xDomain&#34;:[0,45000000000],&#34;yDomain&#34;:[1,5]}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-vvn4wpy10g" data-config="{&#34;dataUrl&#34;:&#34;./data/no-wd_evals.csv&#34;,&#34;charts&#34;:[{&#34;title&#34;:&#34;HellaSwag&#34;,&#34;metric&#34;:&#34;hellaswag&#34;},{&#34;title&#34;:&#34;MMLU&#34;,&#34;metric&#34;:&#34;mmlu&#34;},{&#34;title&#34;:&#34;ARC&#34;,&#34;metric&#34;:&#34;arc&#34;},{&#34;title&#34;:&#34;PIQA&#34;,&#34;metric&#34;:&#34;piqa&#34;},{&#34;title&#34;:&#34;OpenBookQA&#34;,&#34;metric&#34;:&#34;openbookqa&#34;},{&#34;title&#34;:&#34;WinoGrande&#34;,&#34;metric&#34;:&#34;winogrande&#34;}],&#34;smoothing&#34;:false,&#34;smoothingWindow&#34;:15}"><!-- 
  Multi-Line Charts Grid
  
  A configurable grid of line charts with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute:
  {
    "dataUrl": "./assets/data/your_data.csv",
    "charts": [
      { "title": "Chart 1", "metric": "metric1" },
      { "title": "Chart 2", "metric": "metric2" },
      ...
    ],
    "smoothingWindow": 15,
    "smoothingCurve": "monotoneX",
    "gridColumns": 3  // Optional: number of columns (default: 3)
  }
  
  CSV format: run_name, step, metric1, metric2, ...
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/d3-six-line-charts.html" 
    config={{ 
      dataUrl: "./assets/data/attention_evals.csv",
      charts: [
        { title: "HellaSwag", metric: "hellaswag" },
        { title: "MMLU", metric: "mmlu" },
        { title: "ARC", metric: "arc" },
        { title: "PIQA", metric: "piqa" },
        { title: "OpenBookQA", metric: "openbookqa" },
        { title: "WinoGrande", metric: "winogrande" }
      ],
      smoothingWindow: 15
    }} 
  />
-->
<div class="d3-multi-charts"></div>
<style>
  .d3-multi-charts {
    position: relative;
    container-type: inline-size;
  }

  /* Legend header */
  .d3-multi-charts__header {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
  }

  .d3-multi-charts__header .legend-bottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
    max-width: 80%;
  }

  .d3-multi-charts__header .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-multi-charts__header .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
    justify-content: center;
  }

  .d3-multi-charts__header .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-multi-charts__header .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  /* Grid */
  .d3-multi-charts__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }

  /* Container queries - basées sur la largeur du container parent, pas de la viewport */
  @container (max-width: 900px) {
    .d3-multi-charts__grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @container (max-width: 600px) {
    .d3-multi-charts__grid {
      grid-template-columns: 1fr;
    }
  }

  .chart-cell {
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
    box-shadow: inset 0 0 0 1px var(--border-color);
    border-radius: 8px;
  }

  .chart-cell__title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
    margin-bottom: 8px;
    padding-bottom: 8px;
  }

  .chart-cell__body {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .chart-cell__body svg {
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* Reset button */
  .chart-cell .reset-button {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
    display: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-size: 11px;
    padding: 3px 6px;
    border-radius: 4px;
    background: var(--surface-bg);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    cursor: pointer;
  }

  /* Axes */
  .d3-multi-charts .axes path {
    display: none;
  }

  .d3-multi-charts .axes line {
    stroke: var(--axis-color);
  }

  .d3-multi-charts .axes text {
    fill: var(--tick-color);
    font-size: 10px;
  }

  .d3-multi-charts .axis-label {
    fill: var(--text-color);
    font-size: 10px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    stroke-width: 3px;
    paint-order: stroke fill;
  }

  .d3-multi-charts .grid line {
    stroke: var(--grid-color);
  }

  /* Lines */
  .d3-multi-charts path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-multi-charts path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-multi-charts.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-multi-charts.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  .d3-multi-charts.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  /* Tooltip */
  .d3-multi-charts .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-multi-charts .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 200px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-multi-charts .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-multi-charts'))) {
        const cs = Array.from(document.querySelectorAll('.d3-multi-charts')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration
      const CONFIG = {
        dataUrl: embedConfig.dataUrl || './assets/data/attention_evals.csv',
        charts: embedConfig.charts || [],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        gridColumns: embedConfig.gridColumns || 3,
        chartHeight: 240,
        margin: { top: 20, right: 20, bottom: 40, left: 50 },
        zoomExtent: [1.0, 8],
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Value',
        xColumn: embedConfig.xColumn || 'tokens',
        runColumn: embedConfig.runColumn || 'run_name'
      };

      if (!CONFIG.charts.length) {
        container.innerHTML = '<p style="color: var(--danger); font-size: 12px;">Error: No charts configured</p>';
        return;
      }

      // Create legend header
      const header = document.createElement('div');
      header.className = 'd3-multi-charts__header';
      header.innerHTML = `
      <div class="legend-bottom">
        <div class="legend-title">Legend</div>
        <div class="items"></div>
      </div>
    `;
      container.appendChild(header);

      // Create grid
      const grid = document.createElement('div');
      grid.className = 'd3-multi-charts__grid';
      container.appendChild(grid);

      // Trackio footer removed

      // Create chart cells
      CONFIG.charts.forEach((chartConfig, idx) => {
        const cell = document.createElement('div');
        cell.className = 'chart-cell';
        cell.style.zIndex = CONFIG.charts.length - idx; // Stacking order
        cell.innerHTML = `
        <div class="chart-cell__title">${chartConfig.title}</div>
        <button class="reset-button">Reset</button>
        <div class="chart-cell__body"></div>
      `;
        grid.appendChild(cell);
      });

      // Data
      let allData = [];
      let runList = [];
      let runColorMap = {};

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].value)) { sum += values[j].value; count++; } }
          const avg = count ? (sum / count) : values[i].value;
          out[i] = { step: values[i].step, value: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Init each chart
      function initChart(cellElement, chartConfig) {
        const bodyEl = cellElement.querySelector('.chart-cell__body');
        const resetBtn = cellElement.querySelector('.reset-button');

        const metric = chartConfig.metric;
        let smoothEnabled = CONFIG.smoothing;
        let hasMoved = false;

        // Tooltip
        let tip = cellElement.querySelector('.d3-tooltip');
        let tipInner;
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'd3-tooltip';
          Object.assign(tip.style, {
            position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
            padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
            background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease', zIndex: '20'
          });
          tipInner = document.createElement('div');
          tipInner.className = 'd3-tooltip__inner';
          tip.appendChild(tipInner);
          cellElement.appendChild(tip);
        } else {
          tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
        }

        // Create SVG
        const svg = d3.select(bodyEl).append('svg').attr('width', '100%').style('display', 'block');

        // Clip path
        const clipId = 'clip-' + Math.random().toString(36).slice(2);
        const clipPath = svg.append('defs').append('clipPath').attr('id', clipId);
        const clipRect = clipPath.append('rect');

        // Groups
        const g = svg.append('g');
        const gGrid = g.append('g').attr('class', 'grid');
        const gAxes = g.append('g').attr('class', 'axes');
        const gPlot = g.append('g').attr('class', 'plot').attr('clip-path', `url(#${clipId})`);
        const gHover = g.append('g').attr('class', 'hover-layer');
        const overlay = g.append('rect').attr('class', 'overlay').attr('fill', 'none').attr('pointer-events', 'all').style('cursor', 'grab')
          .on('mousedown', function () {
            d3.select(this).style('cursor', 'grabbing');
            tip.style.opacity = '0';
            if (hoverLine) hoverLine.style('display', 'none');
          })
          .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

        // Scales
        const xScale = d3.scaleLinear();
        const yScale = d3.scaleLinear();

        // Hover state
        let hoverLine = null;
        let steps = [];
        let hideTipTimer = null;

        // Formatters (will be set in render())
        let formatStep = (v) => v;
        let formatValue = (v) => v;

        // Zoom
        const zoom = d3.zoom().scaleExtent(CONFIG.zoomExtent).on('zoom', zoomed);
        overlay.call(zoom);

        function zoomed(event) {
          const transform = event.transform;
          hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
          updateResetButton();

          const newXScale = transform.rescaleX(xScale);
          const newYScale = transform.rescaleY(yScale);

          const innerWidth = xScale.range()[1];

          // Update grid
          const gridTicks = newYScale.ticks(5);
          gGrid.selectAll('line').data(gridTicks).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => newYScale(d)).attr('y2', d => newYScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Update lines
          const line = d3.line()
            .x(d => newXScale(d.step))
            .y(d => newYScale(d.value))
            .curve(getCurve(smoothEnabled));

          gPlot.selectAll('path.ghost-line')
            .attr('d', d => {
              const rawLine = d3.line().x(d => newXScale(d.step)).y(d => newYScale(d.value)).curve(d3.curveLinear);
              return rawLine(d.values);
            });

          gPlot.selectAll('path.main-line')
            .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

          // Update axes
          gAxes.select('.x-axis').call(d3.axisBottom(newXScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.select('.y-axis').call(d3.axisLeft(newYScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
        }

        function updateResetButton() {
          if (hasMoved) {
            resetBtn.style.display = 'block';
            requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
          } else {
            resetBtn.style.opacity = '0';
            setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
          }
        }

        function render() {
          const rect = bodyEl.getBoundingClientRect();
          const width = Math.max(1, Math.round(rect.width || 400));
          const height = CONFIG.chartHeight;
          svg.attr('width', width).attr('height', height);

          const margin = CONFIG.margin;
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;

          g.attr('transform', `translate(${margin.left},${margin.top})`);

          // Filter data for this metric
          const metricData = allData.filter(d => d[metric] != null && !isNaN(d[metric]));

          if (!metricData.length) {
            return;
          }

          // Auto-compute domains from data
          const stepExtent = d3.extent(metricData, d => d.step);
          const valueExtent = d3.extent(metricData, d => d[metric]);

          xScale.domain(stepExtent).range([0, innerWidth]);
          yScale.domain(valueExtent).range([innerHeight, 0]);

          // Create smart formatters based on actual data
          const stepValues = metricData.map(d => d.step);
          const metricValues = metricData.map(d => d[metric]);
          formatStep = createSmartFormatter(stepValues);
          formatValue = createSmartFormatter(metricValues);

          // Update clip
          clipRect.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update overlay
          overlay.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update zoom extent
          zoom.extent([[0, 0], [innerWidth, innerHeight]])
            .translateExtent([[0, 0], [innerWidth, innerHeight]]);

          // Grid
          gGrid.selectAll('line').data(yScale.ticks(5)).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Axes
          gAxes.selectAll('*').remove();
          gAxes.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.append('g').attr('class', 'y-axis')
            .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
          gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');
          gAxes.selectAll('text').attr('fill', 'var(--tick-color)');

          // Axis labels
          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight + 32)
            .attr('text-anchor', 'middle')
            .text(CONFIG.xAxisLabel);

          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -38)
            .attr('text-anchor', 'middle')
            .text(CONFIG.yAxisLabel);

          // Group data by run
          const dataByRun = {};
          runList.forEach(run => { dataByRun[run] = []; });
          metricData.forEach(d => {
            if (dataByRun[d.run]) dataByRun[d.run].push({ step: d.step, value: d[metric] });
          });
          runList.forEach(run => { dataByRun[run].sort((a, b) => a.step - b.step); });

          const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] })).filter(s => s.values.length > 0);

          // Ghost lines
          const ghostLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(d3.curveLinear);
          gPlot.selectAll('path.ghost-line').data(series, d => d.run).join('path')
            .attr('class', 'ghost-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 1.5)
            .attr('opacity', smoothEnabled ? 0.15 : 0)
            .attr('pointer-events', 'none')
            .attr('d', d => ghostLine(d.values));

          // Main lines
          const mainLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(getCurve(smoothEnabled));
          gPlot.selectAll('path.main-line').data(series, d => d.run).join('path')
            .attr('class', 'main-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('opacity', 0.85)
            .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

          // Hover
          setupHover(series, innerWidth, innerHeight);
        }

        function setupHover(series, innerWidth, innerHeight) {
          gHover.selectAll('*').remove();

          hoverLine = gHover.append('line')
            .style('stroke', 'var(--text-color)')
            .attr('stroke-opacity', 0.25)
            .attr('stroke-width', 1)
            .attr('y1', 0)
            .attr('y2', innerHeight)
            .style('display', 'none')
            .attr('pointer-events', 'none');

          const stepSet = new Set();
          series.forEach(s => s.values.forEach(v => stepSet.add(v.step)));
          steps = Array.from(stepSet).sort((a, b) => a - b);

          overlay.on('mousemove', function (ev) {
            if (ev.buttons === 0) onHoverMove(ev, series);
          }).on('mouseleave', onHoverLeave);
        }

        function onHoverMove(ev, series) {
          if (hideTipTimer) { clearTimeout(hideTipTimer); hideTipTimer = null; }

          const [mx, my] = d3.pointer(ev, overlay.node());
          const targetStep = xScale.invert(mx);
          const nearest = steps.reduce((best, t) => Math.abs(t - targetStep) < Math.abs(best - targetStep) ? t : best, steps[0]);

          const xpx = xScale(nearest);
          hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

          let html = `<div><strong>${chartConfig.title}</strong></div>`;
          html += `<div>${formatStep(nearest)}</div>`;

          const entries = series.map(s => {
            const values = s.values;
            let before = null, after = null;
            for (let i = 0; i < values.length; i++) {
              if (values[i].step <= nearest) before = values[i];
              if (values[i].step >= nearest && !after) { after = values[i]; break; }
            }

            let interpolatedValue = null;
            if (before && after && before.step !== after.step) {
              const t = (nearest - before.step) / (after.step - before.step);
              interpolatedValue = before.value + t * (after.value - before.value);
            } else if (before && before.step === nearest) {
              interpolatedValue = before.value;
            } else if (after && after.step === nearest) {
              interpolatedValue = after.value;
            } else if (before) {
              interpolatedValue = before.value;
            } else if (after) {
              interpolatedValue = after.value;
            }

            return { run: s.run, color: s.color, value: interpolatedValue };
          }).filter(e => e.value != null);

          entries.sort((a, b) => b.value - a.value);

          entries.forEach(e => {
            html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.value.toFixed(4)}</span></div>`;
          });

          tipInner.innerHTML = html;
          const offsetX = 12, offsetY = 12;
          tip.style.opacity = '1';
          tip.style.transform = `translate(${Math.round(mx + offsetX + CONFIG.margin.left)}px, ${Math.round(my + offsetY + CONFIG.margin.top)}px)`;
        }

        function onHoverLeave() {
          hideTipTimer = setTimeout(() => {
            tip.style.opacity = '0';
            tip.style.transform = 'translate(-9999px, -9999px)';
            if (hoverLine) hoverLine.style('display', 'none');
          }, 100);
        }

        // Reset button
        resetBtn.addEventListener('click', () => {
          overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        });

        return { render };
      }

      // Load data
      async function load() {
        try {
          const response = await fetch(CONFIG.dataUrl, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);

          const csvText = await response.text();

          // Parse CSV (long format: run_name, metric, tokens, value)
          const rawRows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            metric: (d.metric || '').trim(),
            tokens: +d[CONFIG.xColumn],
            value: +d.value
          }));

          // Pivot data: group by run + tokens, create columns for each metric
          const pivotMap = new Map();
          rawRows.forEach(row => {
            if (isNaN(row.tokens) || isNaN(row.value)) return;

            const key = `${row.run}|${row.tokens}`;
            if (!pivotMap.has(key)) {
              pivotMap.set(key, { run: row.run, step: row.tokens });
            }
            const pivotRow = pivotMap.get(key);
            pivotRow[row.metric] = row.value;
          });

          allData = Array.from(pivotMap.values());

          runList = Array.from(new Set(allData.map(d => d.run))).sort();

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => { runColorMap[run] = colors[i % colors.length]; });

          // Build legend
          const legendItemsHost = header.querySelector('.legend-bottom .items');
          if (legendItemsHost) {
            legendItemsHost.innerHTML = runList.map(run => {
              const color = runColorMap[run];
              return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
            }).join('');

            // Add hover interactions
            legendItemsHost.querySelectorAll('.item').forEach(el => {
              el.addEventListener('mouseenter', () => {
                const run = el.getAttribute('data-run');
                container.classList.add('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                grid.querySelectorAll('path.ghost-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                legendItemsHost.querySelectorAll('.item').forEach(it => {
                  it.classList.toggle('ghost', it.getAttribute('data-run') !== run);
                });
              });

              el.addEventListener('mouseleave', () => {
                container.classList.remove('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => path.classList.remove('ghost'));
                grid.querySelectorAll('path.ghost-line').forEach(path => path.classList.remove('ghost'));
                legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
              });
            });
          }

          // Init all charts
          const cells = Array.from(grid.querySelectorAll('.chart-cell'));
          const chartInstances = cells.map((cell, idx) => initChart(cell, CONFIG.charts[idx]));

          // Render all
          chartInstances.forEach(chart => chart.render());

          // Responsive - observe container for resize
          let resizeTimer;
          const handleResize = () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              chartInstances.forEach(chart => chart.render());
            }, 100);
          };

          const ro = window.ResizeObserver ? new ResizeObserver(handleResize) : null;
          if (ro) {
            ro.observe(container);
          }

          // Also observe window resize as fallback
          window.addEventListener('resize', handleResize);

          // Force a re-render after a short delay to ensure proper sizing
          setTimeout(() => {
            chartInstances.forEach(chart => chart.render());
          }, 100);

        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure> </div>
<p><strong>QKnorm</strong></p>
<p>QK-norm <span class="" id="citation--dehghani2023scalingvisiontransformers22--49">(<a href="https://arxiv.org/abs/2302.05442" id="refctx-bib-dehghani2023scalingvisiontransformers22-1" data-ref-id="bib-dehghani2023scalingvisiontransformers22" target="_blank" rel="noopener noreferrer">Dehghani et al., 2023</a>)</span> applies layer normalization to both the query and key vectors before computing attention. This technique helps prevent attention logits from becoming too large and was used in many recent models to improve stability.</p>
<p>However, <span class="" id="citation--rnope--50"><a href="https://arxiv.org/abs/2501.18795" id="refctx-bib-rnope-2" data-ref-id="bib-rnope" target="_blank" rel="noopener noreferrer">B. Yang et al. (2025)</a></span> found that QK-norm hurts long-context tasks. Their analysis revealed that QK-norm results in lower attention mass on relevant tokens (needles) and higher attention mass on irrelevant context. They argue this occurs because the normalization operation removes magnitude information from the query-key dot product, which makes the attention logits closer in terms of magnitude. Due to this reason, we didn’t use QK-norm in SmolLM3. Additionally, as a small 3B parameter model, it faces less risk of training instability compared to the larger models where QK-norm has proven most beneficial.</p>
<p>We’ve now covered the core building blocks of the transformer: attention mechanisms, positional encodings, embeddings, and stability techniques. Next, we’ll discuss broader architectural decisions like choosing between dense models, sparse MoEs, or Hybrid architectures. After that, we’ll end with the tokenizer, a crucial component in LLM training.</p>
<h4 id="other-core-components"><a href="#other-core-components">Other core components</a></h4>
<p>Beyond the components we’ve covered, there are a couple other architectural decisions worth noting for completeness.</p>
<p>To initialize parameters, modern models typically use truncated normal initialization (mean=0, std=0.02 or std=0.006) or initialization scheme like muP (Cohere, grok) that can be another topic of ablations.</p>
<p>In terms of  <strong>activation functions</strong> , SwiGLU has become a de facto standard in modern LLMs (except Gemma2 using GeGLU and nvidia using relu^2 <span class="" id="citation--nvidia2025nvidianemotronnano2--51">(<a href="https://arxiv.org/abs/2508.14444" id="refctx-bib-nvidia2025nvidianemotronnano2-1" data-ref-id="bib-nvidia2025nvidianemotronnano2" target="_blank" rel="noopener noreferrer">NVIDIA et al., 2025</a>)</span>), replacing older choices like ReLU or GELU.</p>
<p>At a broader scale, architectural layout choices also play a role in shaping model behavior. Although the total parameter count largely determines a language model’s capacity, how those parameters are distributed across depth and width also matters. <a href="https://arxiv.org/abs/2310.19956">Petty et al</a>. found that deeper models outperform equally sized wider ones on language-modeling and compositional tasks until the benefit saturates. This “deep-and-thin” strategy works well for sub-billion-parameter LLMs in MobileLLM ablations <span class="" id="citation--mobilellm--52">(<a href="https://arxiv.org/abs/2402.14905" id="refctx-bib-mobilellm-1" data-ref-id="bib-mobilellm" target="_blank" rel="noopener noreferrer">Z. Liu et al., 2024</a>)</span>, whereas wider models tend to offer faster inference thanks to greater parallelism. Modern architectures reflect this trade-off differently as noted in this<a href="https://sebastianraschka.com/blog/2025/the-big-llm-architecture-comparison.html"> blog post</a>.</p>
<p>We now covered the most important aspects of the dense transformer architecture worth optimizing for you training run. However, recently other architecture interventions that concern the model as a whole have emerged, namely MoE and hybrid models. Let’s have a look what they have to offer, starting with the MoEs.</p>
<h4 id="going-sparse-moe"><a href="#going-sparse-moe">Going Sparse: MoE</a></h4>
<p>The intuition of  <em>Mixture-of-Experts (MoEs)</em> is that we don’t need the full model for every token prediction, similarly to how our brain activates different areas depending on the task at hand (e.g. the visual or motor cortex). For an LLM this could mean that the parts that learned about coding syntax don’t need to be used when the model performs a translation task. If we can do this well, it means we can save a lot of compute as we only need to run parts of the full model at inference time.</p>
<p>On a technical level MoEs have a simple goal: grow total parameters without increasing the number of “active” parameters for each token. Somewhat simplified the total parameters impact the total learning capacity of the model while the active parameters determine the training cost and inference speed. That’s why you see many frontier systems (e.g., DeepSeek V3, K2, and in closed-source models like Gemini, Grok…) using MoE architectures these days. This plot from Ling 1.5 paper <span class="" id="citation--ling15--53">(<a href="https://arxiv.org/abs/2503.05139" id="refctx-bib-ling15-1" data-ref-id="bib-ling15" target="_blank" rel="noopener noreferrer">L. Team et al., 2025</a>)</span> compares the scaling laws of MoE and dense models:</p>
<div class="ri-root" data-ri-root="ri_jkvrg9gphng" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/image_2931384e-bcac-80c4-ab02-f22c53e6fdee.dhphF60f_Z1Pe0ji.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/image_2931384e-bcac-80c4-ab02-f22c53e6fdee.dhphF60f.png" data-astro-cid-6kov3kig width="996" height="661" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script> 
<p>If this is your first time encountering MoE, don’t worry, the mechanics are not complicated. Let’s start with the standard dense architecture and have a look at the necessary changes for the MoE (figure by <a href="https://github.com/rasbt/LLMs-from-scratch/tree/main/ch04/07_moe">Sebastian Raschka</a>):</p>
<div class="wide"> <div class="ri-root" data-ri-root="ri_r0cfj35gfrs" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/image_2931384e-bcac-8062-bc11-d1ee3706d996.D6CeK-45_10lKF5.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/image_2931384e-bcac-8062-bc11-d1ee3706d996.D6CeK-45.png" data-astro-cid-6kov3kig width="1800" height="1013" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script>  </div>
<p>With MoEs, we replace that single MLP with multiple MLPs (“experts”) and add a learnable router before the MLPs. For each token, the router selects a small subset of experts to execute. This is where the distinction between total parameters and active parameters comes from: the model has many experts, but any given token only uses a few.</p>
<p>Designing an MoE layer raises a few core questions:</p>
<ul>
<li>Expert shape &amp; sparsity: Should you use many small experts or fewer large ones? How many experts should be active per token, how many do you need in total experts (i.e., the sparsity or “top-k”)? Should some experts be universal and thus always active?</li>
<li>Utilization &amp; specialization: How do you select the routed experts and keep them well-used (avoid idle capacity) while still encouraging them to specialize? In practice this is a load-balancing problem and has a significant impact on training and inference efficiency.</li>
</ul>
<p>Here we focus on one objective: given a fixed compute budget, how do we choose an MoE configuration that minimizes loss? That’s a different question from pure systems efficiency (throughput/latency), and we’ll come back to that later. Much of this section follows the analysis in Ant Group’s MoE scaling laws paper <span class="" id="citation--antgroup--54">(<a href="https://arxiv.org/abs/2507.17702" id="refctx-bib-antgroup-1" data-ref-id="bib-antgroup" target="_blank" rel="noopener noreferrer">Tian et al., 2025</a>)</span>.</p>
<p>We’ll use their notion of  <em>Efficiency Leverage (EL)</em> . Simply put, EL measures how much dense compute you’d need to match the loss achieved by an MoE design where the unit of measurement is FLOPs. A higher EL means the MoE configuration is delivering more loss improvement per unit of compute compared to dense training.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-mx5qfp7hp8"><!-- 
  Efficiency Leverage Chart
  
  Graphique spécifique montrant la définition de l'Efficiency Leverage (EL)
  avec deux courbes de scaling de loss (Ling-Dense et Ling-MoE)
-->
<div class="efficiency-leverage-chart"></div>
<style>
    .efficiency-leverage-chart {
        position: relative;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    .efficiency-leverage-chart .axis-label {
        fill: var(--text-color);
        font-size: 13px;
        font-weight: 500;
        opacity: 0.9;
        stroke: var(--page-bg, white);
        stroke-width: 6px;
        paint-order: stroke fill;
    }

    .efficiency-leverage-chart .axes path {
        display: none;
    }

    .efficiency-leverage-chart .axes line {
        stroke: var(--axis-color, #999);
    }

    .efficiency-leverage-chart .axes text {
        fill: var(--tick-color, #666);
        font-size: 11px;
    }

    .efficiency-leverage-chart .grid line {
        stroke: var(--grid-color, #e0e0e0);
        stroke-opacity: 0.5;
    }

    .efficiency-leverage-chart .loss-curve {
        fill: none;
        stroke-width: 2.5;
    }

    .efficiency-leverage-chart .reference-line {
        stroke: #333;
        stroke-width: 2;
        stroke-dasharray: 8, 4;
    }

    .efficiency-leverage-chart .marker-circle {
        stroke-width: 2.5;
        fill: white;
    }

    .efficiency-leverage-chart .marker-line {
        stroke-width: 1.5;
        stroke-dasharray: 4, 3;
    }

    .efficiency-leverage-chart .curve-label {
        font-size: 12px;
        font-weight: 600;
        stroke: var(--page-bg, white);
        stroke-width: 4px;
        paint-order: stroke fill;
    }

    .efficiency-leverage-chart .formula-container {
        text-align: center;
        margin-top: 20px;
        font-size: 18px;
        color: var(--text-color);
    }

    .efficiency-leverage-chart .formula-container sub {
        font-size: 0.7em;
        vertical-align: sub;
        line-height: 0;
    }

    .efficiency-leverage-chart .formula-fraction {
        display: inline-block;
        vertical-align: middle;
        text-align: center;
    }

    .efficiency-leverage-chart .formula-numerator,
    .efficiency-leverage-chart .formula-denominator {
        display: block;
        padding: 3px 8px;
        font-weight: 600;
    }

    .efficiency-leverage-chart .formula-numerator {
        border-bottom: 2px solid var(--text-color);
        background: #4c8bb8;
        color: white;
        border-radius: 6px 6px 0 0;
    }

    .efficiency-leverage-chart .formula-denominator {
        background: #e8904f;
        color: white;
        border-radius: 0 0 6px 6px;
    }

    .efficiency-leverage-chart .chart-title {
        text-align: center;
        font-size: 14px;
        font-weight: 700;
        margin-top: 16px;
        color: var(--text-color);
    }

    .efficiency-leverage-chart__header {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
    }

    .efficiency-leverage-chart__header .legend-bottom {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: var(--text-color);
    }

    .efficiency-leverage-chart__header .legend-bottom .legend-title {
        font-size: 12px;
        font-weight: 700;
        color: var(--text-color);
    }

    .efficiency-leverage-chart__header .legend-bottom .items {
        display: flex;
        flex-wrap: wrap;
        gap: 8px 16px;
        justify-content: center;
    }

    .efficiency-leverage-chart__header .legend-bottom .item {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
        font-size: 12px;
    }

    .efficiency-leverage-chart__header .legend-bottom .swatch {
        width: 14px;
        height: 14px;
        border-radius: 3px;
        border: 1px solid var(--border-color);
        display: inline-block;
    }
</style>
<script>
    (() => {
        const ensureD3 = (cb) => {
            if (window.d3 && typeof window.d3.select === 'function') return cb();
            let s = document.getElementById('d3-cdn-script');
            if (!s) {
                s = document.createElement('script');
                s.id = 'd3-cdn-script';
                s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
                document.head.appendChild(s);
            }
            const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
            s.addEventListener('load', onReady, { once: true });
            if (window.d3) onReady();
        };

        const bootstrap = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;

            if (!(container && container.classList && container.classList.contains('efficiency-leverage-chart'))) {
                let currentEl = scriptEl;
                while (currentEl && currentEl.parentNode) {
                    currentEl = currentEl.parentNode;
                    const found = currentEl.querySelector && currentEl.querySelector('.efficiency-leverage-chart:not([data-mounted="true"])');
                    if (found) {
                        container = found;
                        break;
                    }
                }

                if (!container) {
                    const cs = Array.from(document.querySelectorAll('.efficiency-leverage-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
                    container = cs[0] || null;
                }
            }

            if (!container) return;
            if (container.dataset) {
                if (container.dataset.mounted === 'true') return;
                container.dataset.mounted = 'true';
            }

            const d3 = window.d3;

            // Les deux courbes sont parallèles (même forme) mais décalées horizontalement
            // MoE est plus efficace = atteint la même loss avec moins de FLOPs

            const denseFlopMarker = 5e22;
            const moeFlopMarker = 1e22;
            const targetLoss = 1.6;

            // Décalage horizontal en log-space (MoE est ~5x plus efficace)
            const efficiencyRatio = denseFlopMarker / moeFlopMarker; // ~5

            // Coefficients pour Ling-Dense (bleue)
            // Points: (10^19, 2.65), (5e22, 1.6), (10^25, 1.15)
            const x1_dense = 19, y1_dense = 2.85;
            const x2_dense = Math.log10(5e22), y2_dense = 1.6;
            const x3_dense = 25, y3_dense = 1.15;

            const denom_dense = (x1_dense - x2_dense) * (x1_dense - x3_dense) * (x2_dense - x3_dense);
            const a_dense = (x3_dense * (y2_dense - y1_dense) + x2_dense * (y1_dense - y3_dense) + x1_dense * (y3_dense - y2_dense)) / denom_dense;
            const b_dense = (x3_dense * x3_dense * (y1_dense - y2_dense) + x2_dense * x2_dense * (y3_dense - y1_dense) + x1_dense * x1_dense * (y2_dense - y3_dense)) / denom_dense;
            const c_dense = (x2_dense * x3_dense * (x2_dense - x3_dense) * y1_dense + x3_dense * x1_dense * (x3_dense - x1_dense) * y2_dense + x1_dense * x2_dense * (x1_dense - x2_dense) * y3_dense) / denom_dense;

            // Coefficients pour Ling-MoE (orange) - descend plus vite
            // Points: (10^19, 2.5), (1e22, 1.6), (10^25, 1.02)
            const x1_moe = 19.4, y1_moe = 2.5;
            const x2_moe = Math.log10(1e22), y2_moe = 1.6;
            const x3_moe = 25, y3_moe = 1.01;

            const denom_moe = (x1_moe - x2_moe) * (x1_moe - x3_moe) * (x2_moe - x3_moe);
            const a_moe = (x3_moe * (y2_moe - y1_moe) + x2_moe * (y1_moe - y3_moe) + x1_moe * (y3_moe - y2_moe)) / denom_moe;
            const b_moe = (x3_moe * x3_moe * (y1_moe - y2_moe) + x2_moe * x2_moe * (y3_moe - y1_moe) + x1_moe * x1_moe * (y2_moe - y3_moe)) / denom_moe;
            const c_moe = (x2_moe * x3_moe * (x2_moe - x3_moe) * y1_moe + x3_moe * x1_moe * (x3_moe - x1_moe) * y2_moe + x1_moe * x2_moe * (x1_moe - x2_moe) * y3_moe) / denom_moe;

            // Génération de courbe Dense
            const generateDenseCurve = (numPoints = 200) => {
                const data = [];
                const logStart = 19;
                const logEnd = 25;  // Limité à 10^25
                const step = (logEnd - logStart) / (numPoints - 1);

                for (let i = 0; i < numPoints; i++) {
                    const logFlops = logStart + i * step;
                    const flops = Math.pow(10, logFlops);
                    const logF = Math.log10(flops);
                    const loss = a_dense * logF * logF + b_dense * logF + c_dense;

                    // Ne garder que les points dans les limites du graphique
                    if (loss >= 0.9 && loss <= 2.6) {
                        data.push({ flops, loss });
                    }
                }
                return data;
            };

            // Génération de courbe MoE (utilise ses propres coefficients)
            const generateMoeCurve = (numPoints = 200) => {
                const data = [];
                const logStart = 19;
                const logEnd = 25;  // Limité à 10^25
                const step = (logEnd - logStart) / (numPoints - 1);

                for (let i = 0; i < numPoints; i++) {
                    const logFlops = logStart + i * step;
                    const flops = Math.pow(10, logFlops);
                    const logF = Math.log10(flops);
                    const loss = a_moe * logF * logF + b_moe * logF + c_moe;

                    // Ne garder que les points dans les limites du graphique
                    if (loss >= 0.9 && loss <= 2.6) {
                        data.push({ flops, loss });
                    }
                }
                return data;
            };

            const lingDenseData = generateDenseCurve();
            const lingMoeData = generateMoeCurve();

            // Points marqués (calculés avec les fonctions pour être précis)
            const denseMarker = {
                flops: denseFlopMarker,
                loss: targetLoss
            };
            const moeMarker = {
                flops: moeFlopMarker,
                loss: targetLoss
            };

            // Couleurs
            const denseColor = '#4c8bb8';  // Bleu
            const moeColor = '#e8904f';    // Orange

            // Dimensions
            const margin = { top: 30, right: 40, bottom: 60, left: 60 };
            let width = 700;
            let height = 420;

            function render() {
                container.innerHTML = '';

                // Légende en haut (créée en premier)
                const headerDiv = document.createElement('div');
                headerDiv.className = 'efficiency-leverage-chart__header';
                headerDiv.innerHTML = `
          <div class="legend-bottom">
            <div class="legend-title">Loss Scaling Curve</div>
            <div class="items">
              <span class="item">
                <span class="swatch" style="background: ${denseColor}"></span>
                <span>Ling-Dense</span>
              </span>
              <span class="item">
                <span class="swatch" style="background: ${moeColor}"></span>
                <span>Ling-MoE</span>
              </span>
            </div>
          </div>
        `;
                container.appendChild(headerDiv);

                const rect = container.getBoundingClientRect();
                width = Math.max(500, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 700)));
                height = Math.max(380, Math.round(width / 1.75));

                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;

                // SVG
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const g = svg.append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);

                // Échelles
                const xScale = d3.scaleLog()
                    .domain([1e19, 1e25])
                    .range([0, innerWidth]);

                const yScale = d3.scaleLinear()
                    .domain([0.9, 2.6])
                    .range([innerHeight, 0]);

                // Grille horizontale
                const yTicks = [1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2, 2.4];
                g.append('g')
                    .attr('class', 'grid')
                    .selectAll('line')
                    .data(yTicks)
                    .join('line')
                    .attr('x1', 0)
                    .attr('x2', innerWidth)
                    .attr('y1', d => yScale(d))
                    .attr('y2', d => yScale(d));

                // Axes
                const xAxis = d3.axisBottom(xScale)
                    .tickValues([1e19, 1e20, 1e21, 1e22, 1e23, 1e24]);

                const yAxis = d3.axisLeft(yScale)
                    .tickValues(yTicks)
                    .tickFormat(d3.format('.1f'));

                const xAxisG = g.append('g')
                    .attr('class', 'axes')
                    .attr('transform', `translate(0,${innerHeight})`)
                    .call(xAxis);

                // Remplacer les labels de l'axe X par des tspans avec exposants
                xAxisG.selectAll('.tick text')
                    .text('')
                    .each(function (d) {
                        const exp = Math.round(Math.log10(d));
                        const textEl = d3.select(this);
                        textEl.append('tspan').text('10');
                        textEl.append('tspan')
                            .attr('font-size', '0.7em')
                            .attr('dy', '-0.5em')
                            .text(exp);
                    });

                g.append('g')
                    .attr('class', 'axes')
                    .call(yAxis);

                // Labels des axes
                g.append('text')
                    .attr('class', 'axis-label')
                    .attr('x', innerWidth / 2)
                    .attr('y', innerHeight + 45)
                    .attr('text-anchor', 'middle')
                    .text('FLOPs');

                g.append('text')
                    .attr('class', 'axis-label')
                    .attr('transform', 'rotate(-90)')
                    .attr('x', -innerHeight / 2)
                    .attr('y', -45)
                    .attr('text-anchor', 'middle')
                    .text('Loss');

                // Ligne de référence à 1.6
                g.append('line')
                    .attr('class', 'reference-line')
                    .attr('x1', 0)
                    .attr('x2', innerWidth)
                    .attr('y1', yScale(1.6))
                    .attr('y2', yScale(1.6));

                // Générateur de courbe
                const lineGen = d3.line()
                    .x(d => xScale(d.flops))
                    .y(d => yScale(d.loss))
                    .curve(d3.curveMonotoneX);

                // Courbe Ling-Dense
                g.append('path')
                    .datum(lingDenseData)
                    .attr('class', 'loss-curve')
                    .attr('d', lineGen)
                    .attr('stroke', denseColor);

                // Courbe Ling-MoE
                g.append('path')
                    .datum(lingMoeData)
                    .attr('class', 'loss-curve')
                    .attr('d', lineGen)
                    .attr('stroke', moeColor);

                // Lignes verticales pointillées pour les marqueurs
                g.append('line')
                    .attr('class', 'marker-line')
                    .attr('x1', xScale(denseMarker.flops))
                    .attr('x2', xScale(denseMarker.flops))
                    .attr('y1', yScale(denseMarker.loss))
                    .attr('y2', innerHeight)
                    .attr('stroke', denseColor);

                g.append('line')
                    .attr('class', 'marker-line')
                    .attr('x1', xScale(moeMarker.flops))
                    .attr('x2', xScale(moeMarker.flops))
                    .attr('y1', yScale(moeMarker.loss))
                    .attr('y2', innerHeight)
                    .attr('stroke', moeColor);

                // Cercles marqueurs
                g.append('circle')
                    .attr('class', 'marker-circle')
                    .attr('cx', xScale(denseMarker.flops))
                    .attr('cy', yScale(denseMarker.loss))
                    .attr('r', 7)
                    .attr('stroke', denseColor);

                g.append('circle')
                    .attr('class', 'marker-circle')
                    .attr('cx', xScale(moeMarker.flops))
                    .attr('cy', yScale(moeMarker.loss))
                    .attr('r', 7)
                    .attr('stroke', moeColor);

                // Labels des courbes (avec fond blanc)
                const denseLabel = g.append('text')
                    .attr('class', 'curve-label')
                    .attr('x', xScale(5e22))
                    .attr('y', yScale(1.1))
                    .attr('text-anchor', 'middle')
                    .attr('fill', denseColor);
                denseLabel.append('tspan').text('C');
                denseLabel.append('tspan')
                    .attr('font-size', '9px')
                    .attr('dy', '4')
                    .text('dense');

                const moeLabel = g.append('text')
                    .attr('class', 'curve-label')
                    .attr('x', xScale(1e22))
                    .attr('y', yScale(1.1))
                    .attr('text-anchor', 'middle')
                    .attr('fill', moeColor);
                moeLabel.append('tspan').text('C');
                moeLabel.append('tspan')
                    .attr('font-size', '9px')
                    .attr('dy', '4')
                    .text('moe');

                // Formule en dessous
                const formulaDiv = document.createElement('div');
                formulaDiv.className = 'formula-container';
                formulaDiv.innerHTML = `
          <div style="display: inline-flex; align-items: center; gap: 12px;">
            <span style="font-style: italic; font-size: 16px;">EL</span>
            <span style="font-size: 16px;">(</span>
            <span style="display: inline-flex; align-items: baseline;">
              <span style="font-style: italic; font-size: 14px;">𝒳</span>
              <span style="font-size: 10px; transform: translateY(3px); display: inline-block;">MoE</span>
            </span>
            <span style="font-size: 16px;">|</span>
            <span style="display: inline-flex; align-items: baseline;">
              <span style="font-style: italic; font-size: 14px;">𝒳</span>
              <span style="font-size: 10px; transform: translateY(3px); display: inline-block;">Dense</span>
            </span>
            <span style="font-size: 16px;">) =</span>
            <div class="formula-fraction">
              <span class="formula-numerator">C<sub>Dense</sub></span>
              <span class="formula-denominator">C<sub>MoE</sub></span>
            </div>
          </div>
        `;
                container.appendChild(formulaDiv);

                // Titre
                const titleDiv = document.createElement('div');
                titleDiv.className = 'chart-title';
                titleDiv.textContent = 'Definition of Efficiency Leverage (EL)';
                container.appendChild(titleDiv);
            }

            render();

            // Responsive
            const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
            if (ro) ro.observe(container);
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
        } else {
            ensureD3(bootstrap);
        }
    })();
</script></div></div></figure>
<p>Let’s have a closer look how we can setup the sparsity of the MoE to improve the efficiency leverage.</p>
<p><strong>Sparsity / activation ratio</strong></p>
<blockquote class="quote" data-astro-cid-arj5dyob> <div class="quote__text" data-astro-cid-arj5dyob> <p><b>TL;DR:</b> more sparsity → better FLOPs efficiency → diminishing returns at very high sparsity → sweetspot depends on your compute budget.</p> </div>  </blockquote> 
<p>In this section we want to find out which MoE setting is best. Asymptotically it’s easy to see that the two extremes are not ideal settings. On the one hand, activating all experts all the time brings us back to the dense setting where all parameters are used all the time. On the other hand if the active parameters are very low (as an extreme think just of just 1 parameter being active) clearly it won’t be enough to solve a task even in a narrow domain. So clearly we need to find some middle ground. Before we get deeper into finding the optimal setup it is useful to define two quantities:  <em><strong>activation ratio</strong></em>  and its inverse the  <em><strong>sparsity</strong></em>  <em>:</em></p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>activation ratio</mtext><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mfrac><mrow><mi mathvariant="normal">#</mi><mtext>activated experts</mtext></mrow><mrow><mi mathvariant="normal">#</mi><mtext>total experts</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{activation ratio} \;=\; \frac{\#\text{activated experts}}{\#\text{total experts}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em"></span><span class="mord text"><span class="mord">activation ratio</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.2519em;vertical-align:-0.8804em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">#</span><span class="mord text"><span class="mord">total experts</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">#</span><span class="mord text"><span class="mord">activated experts</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>sparsity</mtext><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mfrac><mrow><mi mathvariant="normal">#</mi><mtext>total experts</mtext></mrow><mrow><mi mathvariant="normal">#</mi><mtext>activated experts</mtext></mrow></mfrac><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mfrac><mn>1</mn><mtext>activation ratio</mtext></mfrac></mrow><annotation encoding="application/x-tex">\text{sparsity} \;=\; \frac{\#\text{total experts}}{\#\text{activated experts}} \;=\; \frac{1}{\text{activation ratio}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord">sparsity</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.2519em;vertical-align:-0.8804em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">#</span><span class="mord text"><span class="mord">activated experts</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">#</span><span class="mord text"><span class="mord">total experts</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord text"><span class="mord">activation ratio</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<p>From a compute perspective the cost is driven by active parameters only. If you keep the number (and size) of activated experts fixed and increase the total number of experts, your inference/training FLOPs budget stays somewhat the same, but you’re adding model capacity so the model should be generally better as long as you train long enough.</p>
<p>There are some interesting empirical takeaways if you survey the recent MoE papers: Holding the number and size of active experts fixed, increasing the total number of experts (i.e., lowering activation ratio / increasing sparsity) improves loss, with diminishing returns once sparsity gets very high.</p>
<p>Two examples:</p>
<ul>
<li>Kimi K2 plot <span class="" id="citation--kimik2--55">(<a href="https://arxiv.org/abs/2507.20534" id="refctx-bib-kimik2-3" data-ref-id="bib-kimik2" target="_blank" rel="noopener noreferrer">K. Team et al., 2025</a>)</span>: shows both effects: higher sparsity improves performance, but gains taper off as sparsity grows.</li>
<li>Ant Group plot <span class="" id="citation--antgroup--56">(<a href="https://arxiv.org/abs/2507.17702" id="refctx-bib-antgroup-2" data-ref-id="bib-antgroup" target="_blank" rel="noopener noreferrer">Tian et al., 2025</a>)</span>: Same conclusion as K2, with additional result that higher sparsity MoE benefit more from increasing compute.</li>
</ul>
<div class="ri-root" data-ri-root="ri_wy6vfwho2" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/Capture_decran_2025-10-20_a_13_25_47_2921384e-bcac-8087-83e5-fa7a40c1f342.asYkEXKU_1s8wtB.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/Capture_decran_2025-10-20_a_13_25_47_2921384e-bcac-8087-83e5-fa7a40c1f342.asYkEXKU.png" data-astro-cid-6kov3kig width="798" height="796" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script> 
<div class="wide"> <div class="ri-root" data-ri-root="ri_x0gpro41mye" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/Capture_decran_2025-10-20_a_13_26_08_2921384e-bcac-80b5-ac36-fb73d6374208.D-BBIjb7_Zs7nQa.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/Capture_decran_2025-10-20_a_13_26_08_2921384e-bcac-80b5-ac36-fb73d6374208.D-BBIjb7.png" data-astro-cid-6kov3kig width="1684" height="812" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script>  </div>
<p>Here is a table with the sparsity of some MoE model:</p>
<div class="wide"> 




































































































<div class="table-scroll"><table><thead><tr><th>Model</th><th>Total experts</th><th>Activated per token (incl. shared)</th><th>Sparsity</th></tr></thead><tbody><tr><td>Mixtral-8×7B</td><td>8</td><td>2</td><td>4.0</td></tr><tr><td>Grok-1</td><td>8</td><td>2</td><td>4.0</td></tr><tr><td>Grok-2</td><td>8</td><td>2</td><td>4.0</td></tr><tr><td>OLMoE-1B-7B-0924</td><td>64</td><td>8</td><td>8.0</td></tr><tr><td>gpt-oss 20b</td><td>32</td><td>4</td><td>8</td></tr><tr><td>Step-3</td><td>48 routed + 1 shared = 49</td><td>3 routed + 1 shared = 4</td><td>12.25</td></tr><tr><td>GLM-4.5-Air</td><td>128 routed + 1 shared = 129</td><td>8 routed + 1 shared = 9</td><td>14.3</td></tr><tr><td>Qwen3-30B-A3B</td><td>128</td><td>8</td><td>16.0</td></tr><tr><td>Qwen3-235B-A22B</td><td>128</td><td>8</td><td>16.0</td></tr><tr><td>GLM-4.5</td><td>160 routed + 1 shared = 161</td><td>8 routed + 1 shared = 9</td><td>17.8</td></tr><tr><td>DeepSeek-V2</td><td>160 routed + 2 shared = 162</td><td>6 routed + 2 shared = 8</td><td>20.25</td></tr><tr><td>DeepSeek-V3</td><td>256 routed + 1 shared = 257</td><td>8 routed + 1 shared = 9</td><td>28.6</td></tr><tr><td>gpt-oss 120b</td><td>128</td><td>4</td><td>32</td></tr><tr><td>Kimi K2</td><td>384 routed + 1 shared = 385</td><td>8 routed + 1 shared = 9</td><td>42.8</td></tr><tr><td>Qwen3-Next-80B-A3B-Instruct</td><td>512 routed + 1 shared = 513</td><td>10 total active + 1 shared = 11</td><td>46.6</td></tr></tbody></table></div> </div>
<p>The recent trend is clear: MoE models are getting sparser. That said, the optimal sparsity still depends on hardware and end-to-end efficiency. For example, Step-3 targets peak efficiency and intentionally doesn’t max out sparsity to fit their specific hardware and bandwidth constraints, while gpt-oss-20b have a low sparsity due to on-device memory constraints (the passive expert still take some memory).</p>
<p><strong>Granularity</strong></p>
<p>Beyond sparsity, we need to decide how large each expert should be. This is captured by granularity, a metric introduced by Ant Group. Let’s pin down what we mean by this term. Terminology varies across papers, and some use slightly different formulas. Here, we’ll use the definition that matches the plots we reference:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo>=</mo><mfrac><mrow><mi>α</mi><mo>∗</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mrow><msub><mi>d</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub></mfrac><mtext> with </mtext><mi>α</mi><mo>=</mo><mn>2</mn><mtext> or </mtext><mn>4</mn></mrow><annotation encoding="application/x-tex">G = \frac{\alpha*d_{model}}{d_{expert}} \text{ with } \alpha = 2 \text{ or } 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.3435em;vertical-align:-0.9721em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:0.02778em">er</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9721em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord text"><span class="mord"> with </span></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span><span class="mord text"><span class="mord"> or </span></span><span class="mord">4</span></span></span></span></span>
<p>A higher granularity value corresponds to having more experts with smaller dimension (given a fixed number of parameters). This metric is a ratio between the expert dimension ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{expert}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:0.02778em">er</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span> ) and the model dimension ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{model}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> ).</p>
<p>In dense models, a common rule of thumb is to have the dimension of the MLP set to  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></msub><mo>=</mo><mn>4</mn><mo>∗</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{intermediate} = 4 * d_{model}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">in</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em">er</span><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">ia</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> . If  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\alpha = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">4</span></span></span></span>  (like <span class="" id="citation--krajewski2024scalinglawsfinegrainedmixture--57"><a href="https://arxiv.org/abs/2402.07871" id="refctx-bib-krajewski2024scalinglawsfinegrainedmixture-1" data-ref-id="bib-krajewski2024scalinglawsfinegrainedmixture" target="_blank" rel="noopener noreferrer">Krajewski et al. (2024)</a></span>) you can loosely view granularity as  <strong>how many experts it would take to match the dense MLP width (</strong>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mtext> </mtext><msub><mi>d</mi><mtext>model</mtext></msub><mo>=</mo><msub><mi>d</mi><mtext>intermediate</mtext></msub><mo>=</mo><mi>G</mi><mtext> </mtext><msub><mi>d</mi><mtext>expert</mtext></msub></mrow><annotation encoding="application/x-tex">4\, d_{\text{model}} = d_{\text{intermediate}} = G\, d_{\text{expert}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">intermediate</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">expert</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>  <strong>)</strong> . That interpretation is only a rough heuristic: modern MoE designs often allocate much larger total capacity than a single dense MLP, so the one-to-one match breaks down in practice. The Ant team setup choose  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\alpha = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span>   which is simply a  <strong>different normalization choice</strong> . For consistency we will pick this convention and stick to it.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Because G scales with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mtext>model</mtext></msub></mrow><annotation encoding="application/x-tex">d_{\text{model}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>, cross-model comparisons can be tricky when model widths differ.</p> </aside> </div>  
<p>Still here is a table with the different value for some of the MoE release:</p>














































































































<div class="table-scroll"><table><thead><tr><th>Model</th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mtext>model</mtext></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d_\text{model})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mtext>expert</mtext></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d_\text{expert})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">expert</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></th><th><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo>=</mo><mn>2</mn><msub><mi>d</mi><mtext>model</mtext></msub><mi mathvariant="normal">/</mi><msub><mi>d</mi><mtext>expert</mtext></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G = 2 d_\text{model} / d_\text{expert})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">expert</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></th><th>Year</th></tr></thead><tbody><tr><td>Mixtral-8×7B</td><td>4,096</td><td>14,336</td><td>0.571</td><td>2023</td></tr><tr><td>gpt-oss-120b</td><td>2880</td><td>2880</td><td>0.5</td><td>2025</td></tr><tr><td>gpt-oss-20b</td><td>2880</td><td>2880</td><td>0.5</td><td>2025</td></tr><tr><td>Grok 2</td><td>8,192</td><td>16,384</td><td>1.0</td><td>2024</td></tr><tr><td>StepFun Step-3</td><td>7,168</td><td>5,120</td><td>2.8</td><td>2025</td></tr><tr><td>OLMoE-1B-7B</td><td>2,048</td><td>1,024</td><td>4.0</td><td>2025</td></tr><tr><td>Qwen3-30B-A3B</td><td>2,048</td><td>768</td><td>5.3</td><td>2025</td></tr><tr><td>Qwen3-235B-A22B</td><td>4,096</td><td>1,536</td><td>5.3</td><td>2025</td></tr><tr><td>GLM-4.5-Air</td><td>4,096</td><td>1,408</td><td>5.8</td><td>2025</td></tr><tr><td>DeepSeek V2</td><td>5,120</td><td>1,536</td><td>6.6</td><td>2024</td></tr><tr><td>GLM-4.5</td><td>5,120</td><td>1,536</td><td>6.6</td><td>2025</td></tr><tr><td>Kimi K2</td><td>7,168</td><td>2,048</td><td>7.0</td><td>2025</td></tr><tr><td>DeepSeek V3</td><td>7168</td><td>2048</td><td>7.0</td><td>2024</td></tr><tr><td>Qwen3-Next-80B-A3B</td><td>2048</td><td>512</td><td>8.0</td><td>2025</td></tr></tbody></table></div>
<p>Let’s talk about how granularity shapes behavior (from <a href="https://arxiv.org/pdf/2507.17702">Ant Group’s paper</a>):</p>
<div class="ri-root" data-ri-root="ri_f46do0r9ner" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/75ae60ff-50be-48e1-aad2-a8fc56120d3d_2921384e-bcac-80c2-984b-d81404e4bb7c.8nxVv-OC_25NHa.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/75ae60ff-50be-48e1-aad2-a8fc56120d3d_2921384e-bcac-80c2-984b-d81404e4bb7c.8nxVv-OC.png" data-astro-cid-6kov3kig width="1017" height="665" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script> 
<p>Granularity doesn’t look like the primary driver of EL—it helps, especially going above 2, but it’s not the dominant factor determining the loss. There’s a sweet spot though: pushing granularity higher helps up to a point, and then gains flatten. So granularity is a useful tuning knob with a clear trend toward higher values in recent releases, but it shouldn’t be optimized in isolation.</p>
<p>Another method that is used widely to improve MoEs is the concept of shared experts. Let’s have a look!</p>
<p><strong>Shared experts</strong></p>
<p>A shared-expert setup routes every token to a small set of always-on experts. These shared experts absorb the basic, recurring patterns in the data so the remaining experts can specialize more aggressively. In practice, you usually don’t need many of them; model designers commonly choose one, at most two. As granularity increases (e.g., moving from a Qwen3-style setting to something closer to Qwen3-Next), shared experts tend to become more useful. Looking at the following plot, the overall impact is modest, it doesn’t dramatically change the EL. A simple rule of thumb works well in most cases: just use one shared expert, which matches choices in models like DeepSeek V3, K2, and Qwen3-Next and tends to maximize efficiency without adding unnecessary complexity. Figure from <span class="" id="citation--antgroup--58"><a href="https://arxiv.org/abs/2507.17702" id="refctx-bib-antgroup-3" data-ref-id="bib-antgroup" target="_blank" rel="noopener noreferrer">Tian et al. (2025)</a></span> .</p>
<div class="wide"> <div class="ri-root" data-ri-root="ri_0syirm767ec" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/Capture_decran_2025-10-21_a_11_11_38_2931384e-bcac-8008-ad8d-d5ab0c539d3a.ZeQ4Aq4n_Z3EACl.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/Capture_decran_2025-10-21_a_11_11_38_2931384e-bcac-8008-ad8d-d5ab0c539d3a.ZeQ4Aq4n.png" data-astro-cid-6kov3kig width="1602" height="604" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script>  </div>
<p>So a shared expert is an expert where some tokens are always routed through. What about the other experts? How do we learn when to rout to each expert and make sure that we don’t just use a handful of experts? Next we’ll discuss load balancing which tackles exactly that problem.</p>
<p><strong>Load balancing</strong></p>
<p>Load balancing is the critical piece in MoE. If it is set up poorly, it can undermine every other design choice. We can see why poor load balancing will cause us a lot of pain on the following example. Consider a very simple distributed training setup where we have 4 GPUs and we distribute the 4 experts of our model evenly across the GPUs. If the routing collapses and all tokens are routed to expert 1 this means that only 1/4 of our GPUs is utilized which is very bad for training and inference efficiency. Besides that, it means that the effective learning capacity of our model also decreased as not all experts are activated.</p>
<p>To address this issue we can we can add an extra loss term to the router. Below you can see the standard auxiliary loss–based load balancing (LBL):</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="script">L</mi><mtext>Bal</mtext></msub><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mi>α</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>N</mi><mi>r</mi></msub></munderover><msub><mi>f</mi><mi>i</mi></msub><mtext> </mtext><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{L}_{\text{Bal}} \;=\; \alpha \sum_{i=1}^{N_{r}} f_{i}\, P_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathcal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Bal</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:3.1171em;vertical-align:-1.2777em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8394em"><span style="top:-1.8723em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3111em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em"><span style="top:-2.357em;margin-left:-0.109em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>
<p>This simple formula just uses three factors: the coefficient  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>  determines the strength of the loss,  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  is the traffic fraction so just the fraction of tokens going through expert  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em"></span><span class="mord mathnormal">i</span></span></span></span>  and finally  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  which is the probability mass and simply sums the probability of the tokens going through the expert. They are both necessary,  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  correspond to the actual balancing, while  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  is smooth and differentiable allowing the gradient to flows. If we achieve perfect load balancing we get  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>P</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><msub><mi>N</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">f_i=P_i=1/N_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1/</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> , however we need to be careful how we tune  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span>  as a value too small we don’t guide routing enough and if it’s too big routing uniformity becomes more important than the primary language model loss.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>💡</span> <div class="note__title" data-astro-cid-qg6lmfty>Loss free load balancing</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>It is also possible to achieve balancing without an explicit loss term. DeepSeek v3 <span class="" id="citation--deepseekv3--59">(<a href="https://arxiv.org/abs/2412.19437" id="refctx-bib-deepseekv3-1" data-ref-id="bib-deepseekv3" target="_blank" rel="noopener noreferrer">DeepSeek-AI et al., 2025</a>)</span> introduced a simple bias term added to the affinity scores that go into the routing softmax. If a router is overloaded they decrease the score a bit (a constant factor  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span></span></span></span> ) thus making it less likely to be selected and increase it by  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span></span></span></span>  if the expert is underutilized. With this simple adaptive rule they also achieve load balancing.</p> </div> </div> </div> 
<p>A key detail is the scope at which you compute routing statistics: are  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  and  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  computed per local batch (each worker’s mini-batch) or globally (aggregated across workers/devices)? The Qwen team’s analysis <span class="" id="citation--qiu2025demonsdetailimplementingload--60">(<a href="https://arxiv.org/abs/2501.11873" id="refctx-bib-qiu2025demonsdetailimplementingload-1" data-ref-id="bib-qiu2025demonsdetailimplementingload" target="_blank" rel="noopener noreferrer">Qiu et al., 2025</a>)</span> shows that when there isn’t enough token diversity in each local batch and that local computation can hurt both expert specialization (a good proxy for routing health) and overall model performance. Expert specialization is the phenomenon where one or more experts are activated more often than others for a specific domain. In other words, if a local batch is narrow, its routing stats become noisy/biased, and don’t lead to good balancing. This implies that we should use global statistics (or at least cross-device aggregation) whenever feasible. Notably, at the time of that paper, many frameworks—including Megatron—computed these statistics locally by default.</p>
<p>The following plot from Qwen’s paper illustrates the difference of micro-batch vs global batch aggregation and it’s impact on performance and specialization:</p>
<div class="wide"> <div class="ri-root" data-ri-root="ri_8ht5dit77ff" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/Capture_decran_2025-10-21_a_15_34_27_2931384e-bcac-8066-834b-c485ae8d1fa5.Cix986wE_ZLIDik.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/Capture_decran_2025-10-21_a_15_34_27_2931384e-bcac-8066-834b-c485ae8d1fa5.Cix986wE.png" data-astro-cid-6kov3kig width="1096" height="506" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script>  </div>
<p>Generally, ablating architecture choices around MoE is tricky as there is an interplay with many aspects. For example the usefulness of a shared expert might depend on the granularity of the model. So it’s worth spending some time to make sure you have a good set of experiments to really get the insights you are looking for!</p>
<p>We have now covered the fundamentals of MoEs, however there is still more to discover. A non-exhaustive list of items to further study:</p>
<ul>
<li>
<p>Zero-computation experts, MoE layer rescaling and training monitoring (LongCat-Flash paper).</p>
</li>
<li>
<p>Orthogonal loss load balancing (as in ERNIE 4.5).</p>
</li>
<li>
<p>Scheduling the load-balancing coefficient over training.</p>
</li>
<li>
<p>Architecture/optimization interactions with MoE, like:</p>
<ul>
<li>Whether optimizer rankings change for MoE.</li>
<li>How to apply MuP to MoE.</li>
<li>How to adapt the learning rate for MoE (since they don’t see the same number of token per batch).</li>
</ul>
</li>
<li>
<p>Number of dense layers at the start.</p>
</li>
<li>
<p>Many more..</p>
</li>
</ul>
<p>We leave it up to you, eager reader, to follow the rabbit whole further down, while we now move on to the last major architecture choice: hybrid models!</p>
<h4 id="excursion-hybrid-models"><a href="#excursion-hybrid-models">Excursion: Hybrid Models</a></h4>
<p>A recent trend is to augment the standard dense or MoE architecture with state space models (SSM) or linear attention mechanisms <span class="" id="citation--falconh1--minimax01--61">(<a href="https://arxiv.org/abs/2501.08313" id="refctx-bib-minimax01-2" data-ref-id="bib-minimax01" target="_blank" rel="noopener noreferrer">MiniMax et al., 2025</a>; <a href="https://arxiv.org/abs/2507.22448" id="refctx-bib-falconh1-1" data-ref-id="bib-falconh1" target="_blank" rel="noopener noreferrer">Zuo et al., 2025</a>)</span>. ** These new classes of models try to address some of the fundamental weaknesses of transformers: dealing efficiently with very long context. They take a middle ground between recurrent models, that can efficiently deal with arbitrary length context and scale linearly, but might suffer to keep utilize the information in context and transformers that get very expensive with long context but can leverage the patterns in context very well.</p>
<p>There have been some studies <span class="" id="citation--waleffe2024empiricalstudymambabasedlanguage--62">(<a href="https://arxiv.org/abs/2406.07887" id="refctx-bib-waleffe2024empiricalstudymambabasedlanguage-1" data-ref-id="bib-waleffe2024empiricalstudymambabasedlanguage" target="_blank" rel="noopener noreferrer">Waleffe et al., 2024</a>)</span> to understand the weaknesses for example of Mamba models (a form of SSM) and found that such models perform well on many benchmarks but for example underperform on MMLU and hypothesize that it’s the lack of in-context learning causing the gap. That’s the reason that they are combined with blocks from dense or MoE models to get the best of both worlds, thus the name hybrid models.</p>
<p>The core idea behind these linear attention methods is to reorder computations so attention no longer costs O(n^2d), which becomes intractable at long context. How does that work? First, recall the attention formulation at inference. Producing the output for token t looks like:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="bold">o</mi><mi>t</mi></msub><mtext>  </mtext><mo>=</mo><mtext>  </mtext><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></munderover><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mtext> ⁣</mtext><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><msubsup><mi mathvariant="bold">q</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">k</mi><mi>j</mi></msub><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><msub><mi mathvariant="bold">v</mi><mi>j</mi></msub></mrow><mrow><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></munderover><mi>exp</mi><mo>⁡</mo><mtext> ⁣</mtext><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><msubsup><mi mathvariant="bold">q</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold">k</mi><mi>l</mi></msub><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo></mrow></mfrac><mtext> </mtext></mrow><annotation encoding="application/x-tex">\mathbf{o}_{t} \;=\; \sum_{j=1}^{t} \frac{\exp\!\big(\mathbf{q}_{t}^{\top}\mathbf{k}_{j}\big) \mathbf{v}_{j}}{\sum_{l=1}^{t} \exp\!\big(\mathbf{q}_{t}^{\top}\mathbf{k}_{l}\big)} \,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5944em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:3.1943em;vertical-align:-1.4138em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7806em"><span style="top:-1.8723em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.59em"><span style="top:-2.1765em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9335em"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop">exp</span><span class="mspace" style="margin-right:-0.1667em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathbf">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8309em"><span style="top:-2.4542em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.0448em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊤</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2458em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="delimsizing size1">)</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.74em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mop">exp</span><span class="mspace" style="margin-right:-0.1667em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathbf">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊤</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1735em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em"></span></span></span></span></span>
<p>Now drop the softmax:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>o</mi><mi>t</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></munderover><mo stretchy="false">(</mo><msubsup><mi>q</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi>k</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mtext> </mtext><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">o_t = \sum_{j=1}^{t} (q_t^\top k_j)\, v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:3.1943em;vertical-align:-1.4138em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7806em"><span style="top:-1.8723em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span></span>
<p>Reordering gives:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mspace width="1em"></mspace><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></munderover><mo stretchy="false">(</mo><msubsup><mi>q</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi>k</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mtext> </mtext><msub><mi>v</mi><mi>j</mi></msub><mo>=</mo><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">(</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></munderover><msub><mi>v</mi><mi>j</mi></msub><msubsup><mi>k</mi><mi>j</mi><mi mathvariant="normal">⊤</mi></msubsup><mo fence="false" stretchy="true" minsize="1.8em" maxsize="1.8em">)</mo><msub><mi>q</mi><mi>t</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\quad\sum_{j=1}^{t}(q_t^\top k_j)\,v_j = \Big(\sum_{j=1}^{t} v_j k_j^\top\Big) q_t.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.1943em;vertical-align:-1.4138em"></span><span class="mspace" style="margin-right:1em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7806em"><span style="top:-1.8723em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:3.1943em;vertical-align:-1.4138em"></span><span class="mord"><span class="delimsizing size2">(</span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7806em"><span style="top:-1.8723em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-2.453em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em"><span></span></span></span></span></span></span><span class="mord"><span class="delimsizing size2">)</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span>
<p>Define the running state:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mi>t</mi></msub><mo>≜</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></munderover><msub><mi>k</mi><mi>j</mi></msub><msubsup><mi>v</mi><mi>j</mi><mi mathvariant="normal">⊤</mi></msubsup><mo>=</mo><msubsup><mi>K</mi><mrow><mn>1</mn><mo>:</mo><mi>t</mi></mrow><mi mathvariant="normal">⊤</mi></msubsup><msub><mi>V</mi><mrow><mn>1</mn><mo>:</mo><mi>t</mi></mrow></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">S_t \triangleq \sum_{j=1}^{t} k_j v_j^\top = K_{1:t}^\top V_{1:t} \in \mathbb{R}^{d\times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0667em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel amsrm">≜</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:3.1943em;vertical-align:-1.4138em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7806em"><span style="top:-1.8723em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.1461em;vertical-align:-0.247em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-2.453em;margin-left:-0.0715em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">:</span><span class="mord mathnormal mtight">t</span></span></span></span><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">:</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8991em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span></span>
<p>with the simple update:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mi>t</mi></msub><mo>=</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>k</mi><mi>t</mi></msub><msubsup><mi>v</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup></mrow><annotation encoding="application/x-tex">S_t = S_{t-1} + k_t v_t^\top </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.1461em;vertical-align:-0.247em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span></span></span></span></span>
<p>So we can write:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>o</mi><mi>t</mi></msub><mo>=</mo><msub><mi>S</mi><mi>t</mi></msub><msub><mi>q</mi><mi>t</mi></msub><mtext>  </mtext><mo>=</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>q</mi><mi>t</mi></msub><mo>+</mo><msub><mi>v</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msubsup><mi>k</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi>q</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o_t = S_t q_t    = S_{t-1} q_t + v_t (k_t^\top q_t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord">  </span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.1491em;vertical-align:-0.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-2.453em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>
<p>Why is the reordering important: the left form  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>j</mi><mo>≤</mo><mi>t</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>q</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi>k</mi><mi>j</mi></msub><mo stretchy="false">)</mo><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{j\le t}(q_t^\top k_j)v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2849em;vertical-align:-0.4358em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>  means “for each past token j, take a dot  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>q</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi>k</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">q_t^\top k_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1352em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>  (a scalar), use it to scale  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span> , and add those t vectors up”—that’s about  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>t</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(td)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>  work at step t. The right form rewrites this as  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><msub><mo>∑</mo><mrow><mi>j</mi><mo>≤</mo><mi>t</mi></mrow></msub><msub><mi>v</mi><mi>j</mi></msub><msubsup><mi>k</mi><mi>j</mi><mi mathvariant="normal">⊤</mi></msubsup><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><msub><mi>q</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\big(\sum_{j\le t} v_j k_j^\top\big) q_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2858em;vertical-align:-0.4358em"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-2.4413em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em"><span></span></span></span></span></span></span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> : you keep a single running state matrix  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>t</mi></msub><mo>=</mo><msub><mo>∑</mo><mrow><mi>j</mi><mo>≤</mo><mi>t</mi></mrow></msub><msub><mi>v</mi><mi>j</mi></msub><msubsup><mi>k</mi><mi>j</mi><mi mathvariant="normal">⊤</mi></msubsup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">S_t=\sum_{j\le t} v_j k_j^\top\in\mathbb{R}^{d\times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.2849em;vertical-align:-0.4358em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-2.4413em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span>  that already summarizes all past  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>k</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k_j,v_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> . Each new token updates it with one outer product  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>t</mi></msub><msubsup><mi>k</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup></mrow><annotation encoding="application/x-tex">v_t k_t^\top</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0961em;vertical-align:-0.247em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-2.453em;margin-left:-0.0315em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span></span></span></span>  cost  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>d</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> , then the output is just one matrix–vector multiply  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>t</mi></msub><msub><mi>q</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">S_t q_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  (another  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>d</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ). So generating T tokens by the left form from scratch is  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>T</mi><mn>2</mn></msup><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(T^2 d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> , while maintaining  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">S_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  and using the right form is  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>T</mi><msup><mi>d</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(T d^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> . Intuitively: left = “many small dot-scale-adds each step”; right = “one pre-summarized matrix times the query,” trading dependence on sequence length for dependence on dimension. We here focus on inference and recurring form, but it’s also more efficient in training, where the reordering is as simple as the following equation:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi><munder><mo><mo stretchy="false">(</mo><mi>Q</mi><msup><mi>K</mi><mi mathvariant="normal">⊤</mi></msup><mo stretchy="false">)</mo></mo><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow></munder></mi><mtext> </mtext><mi>V</mi><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mi>Q</mi><mtext> </mtext><mi><munder><mo><mo stretchy="false">(</mo><msup><mi>K</mi><mi mathvariant="normal">⊤</mi></msup><mi>V</mi><mo stretchy="false">)</mo></mo><mrow><mi>d</mi><mo>×</mo><mi>d</mi></mrow></munder></mi></mrow><annotation encoding="application/x-tex">\underset{n\times n}{(QK^\top)}\,V \;=\; Q\,\underset{d\times d}{(K^\top V)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.9074em;vertical-align:-1.0083em"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-2.15em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop"><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0083em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.9595em;vertical-align:-1.0604em"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-2.0979em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="mclose">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0604em"><span></span></span></span></span></span></span></span></span></span></span>
<p>So we can see that this looks now very similar to an RNN like structure. This solved our issue, right? Almost. In practice, the softmax plays an important stabilizing role, and the naïve linear form can be unstable without some normalization. This motivates a practical variant called lightning or norm attention!</p>
<p><strong>Lightning and norm attention</strong></p>
<p>This family appears in Minimax01 <span class="" id="citation--minimax01--63">(<a href="https://arxiv.org/abs/2501.08313" id="refctx-bib-minimax01-3" data-ref-id="bib-minimax01" target="_blank" rel="noopener noreferrer">MiniMax et al., 2025</a>)</span> and, more recently, in Ring-linear <span class="" id="citation--lingteam2025attentionmattersefficienthybrid--64">(<a href="https://arxiv.org/abs/2510.19338" id="refctx-bib-lingteam2025attentionmattersefficienthybrid-1" data-ref-id="bib-lingteam2025attentionmattersefficienthybrid" target="_blank" rel="noopener noreferrer">L. Team, Han, et al., 2025</a>)</span>. Building on the Norm Attention idea <span class="" id="citation--qin2022devillineartransformer--65">(<a href="https://arxiv.org/abs/2210.10340" id="refctx-bib-qin2022devillineartransformer-1" data-ref-id="bib-qin2022devillineartransformer" target="_blank" rel="noopener noreferrer">Qin et al., 2022</a>)</span>. The key step is simple:  <strong>normalize the output</strong> . The “Lightning” variant focuses on making the implementation fast and efficient and make the formula a bit different. Here is the formula for both:</p>
<p>NormAttention:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>RMSNorm</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">(</mo><msup><mi>K</mi><mi>T</mi></msup><mi>V</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{RMSNorm}(Q(K^TV))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord">RMSNorm</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="mclose">))</span></span></span></span></span>
<p>LightningAttention:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Q</mi><mo>=</mo><mtext>Silu(Q)</mtext><mo separator="true">,</mo><mtext>  </mtext><mi>K</mi><mo>=</mo><mtext>Silu(K)</mtext><mo separator="true">,</mo><mtext>  </mtext><mi>V</mi><mo>=</mo><mtext>Silu(V)</mtext></mrow><annotation encoding="application/x-tex">Q= \text{Silu(Q)}, \; K = \text{Silu(K)}, \; V = \text{Silu(V)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord">Silu(Q)</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.07153em">K</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord">Silu(K)</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord">Silu(V)</span></span></span></span></span></span>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo>=</mo><mtext>SRMSNorm</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>K</mi><msup><mi>V</mi><mi>T</mi></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O = \text{SRMSNorm}(Q(KV^T))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord">SRMSNorm</span></span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em">K</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em">T</span></span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></span>
<p>Empirically, hybrid model with Norm attention match softmax on most of the tasks according to Minimax01.</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-ou5bpigapi"><div class="benchmark-performance"></div>
<style>
    .benchmark-performance {
        font-family: 'Arial', sans-serif;
        margin: 0px 0;
        padding: 0;
    }

    .benchmark-performance__grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
        margin-top: 20px;
    }

    @media (max-width: 1000px) {
        .benchmark-performance__grid {
            grid-template-columns: 1fr;
        }
    }

    .benchmark-performance__chart {
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 20px;
        background: var(--page-bg);
    }

    .benchmark-performance__title {
        font-size: 16px;
        font-weight: 700;
        color: var(--text-color);
        margin-bottom: 16px;
        text-align: center;
    }

    .benchmark-performance__legend {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        margin-bottom: 20px;
    }

    .benchmark-performance__legend-title {
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--muted-color);
    }

    .benchmark-performance__legend-items {
        display: flex;
        justify-content: center;
        gap: 20px;
        flex-wrap: wrap;
    }

    .benchmark-performance__legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: var(--text-color);
    }

    .benchmark-performance__legend-swatch {
        width: 16px;
        height: 16px;
        border-radius: 3px;
    }

    .benchmark-performance svg {
        width: 100%;
        height: auto;
        display: block;
    }

    .benchmark-performance .axis path {
        display: none;
    }

    .benchmark-performance .axis line {
        stroke: var(--axis-color);
    }

    .benchmark-performance .axis text {
        fill: var(--tick-color);
        font-size: 11px;
    }

    .benchmark-performance .grid line {
        stroke: var(--grid-color);
        stroke-opacity: 1;
        stroke-width: 1.5;
    }

    .benchmark-performance .bar {
        transition: opacity 0.2s ease;
        cursor: pointer;
    }

    .benchmark-performance .bar-label {
        transition: opacity 0.2s ease;
    }

    .benchmark-performance.hovering .bar.ghost {
        opacity: 0.15;
    }

    .benchmark-performance.hovering .bar-label.ghost {
        opacity: 0.15;
    }

    .benchmark-performance.hovering .benchmark-performance__legend-item.ghost {
        opacity: 0.3;
    }

    .benchmark-performance__legend-item {
        cursor: pointer;
        transition: opacity 0.2s ease;
    }
</style>
<script>
    (() => {
        // Données extraites de l'image
        const data = {
            '410M': {
                'PIQA': { 'Softmax Attention': 67.0, 'Lightning Attention': 67.0, 'Hybrid-lightning': 67.5 },
                'H5': { 'Softmax Attention': 39.0, 'Lightning Attention': 39.2, 'Hybrid-lightning': 39.6 },
                'WG': { 'Softmax Attention': 52, 'Lightning Attention': 51.6, 'Hybrid-lightning': 51.8 },
                'ARC-E': { 'Softmax Attention': 50.0, 'Lightning Attention': 52.5, 'Hybrid-lightning': 52.1 },
                'ARC-C': { 'Softmax Attention': 24.0, 'Lightning Attention': 25.5, 'Hybrid-lightning': 26.2 },
                'OBQA': { 'Softmax Attention': 29.5, 'Lightning Attention': 29.8, 'Hybrid-lightning': 30.0 },
                'CSR-AVG': { 'Softmax Attention': 43.5, 'Lightning Attention': 44.0, 'Hybrid-lightning': 44.5 },
                'NIAH': { 'Softmax Attention': 52.0, 'Lightning Attention': 14.0, 'Hybrid-lightning': 84.2 },
                'SCR': { 'Softmax Attention': 10.0, 'Lightning Attention': 8.0, 'Hybrid-lightning': 10.9 }
            },
            '1B': {
                'PIQA': { 'Softmax Attention': 70.0, 'Lightning Attention': 71.0, 'Hybrid-lightning': 70.7 },
                'H5': { 'Softmax Attention': 47.5, 'Lightning Attention': 48.5, 'Hybrid-lightning': 50.4 },
                'WG': { 'Softmax Attention': 52.0, 'Lightning Attention': 51.5, 'Hybrid-lightning': 55.8 },
                'ARC-E': { 'Softmax Attention': 57.5, 'Lightning Attention': 57.5, 'Hybrid-lightning': 59.9 },
                'ARC-C': { 'Softmax Attention': 28.0, 'Lightning Attention': 28.0, 'Hybrid-lightning': 27.6 },
                'OBQA': { 'Softmax Attention': 33.0, 'Lightning Attention': 33.5, 'Hybrid-lightning': 32.8 },
                'CSR-AVG': { 'Softmax Attention': 47.5, 'Lightning Attention': 48.0, 'Hybrid-lightning': 49.5 },
                'NIAH': { 'Softmax Attention': 44.0, 'Lightning Attention': 29.0, 'Hybrid-lightning': 95.7 },
                'SCR': { 'Softmax Attention': 11.5, 'Lightning Attention': 10.5, 'Hybrid-lightning': 13.3 }
            },
            '3B': {
                'PIQA': { 'Softmax Attention': 72.2, 'Lightning Attention': 76.2, 'Hybrid-lightning': 74.2 },
                'H5': { 'Softmax Attention': 58.5, 'Lightning Attention': 60.5, 'Hybrid-lightning': 61.1 },
                'WG': { 'Softmax Attention': 59.0, 'Lightning Attention': 61.0, 'Hybrid-lightning': 59.5 },
                'ARC-E': { 'Softmax Attention': 63.0, 'Lightning Attention': 65.0, 'Hybrid-lightning': 65.0 },
                'ARC-C': { 'Softmax Attention': 33.0, 'Lightning Attention': 34.0, 'Hybrid-lightning': 34.9 },
                'OBQA': { 'Softmax Attention': 33.0, 'Lightning Attention': 36.2, 'Hybrid-lightning': 35.8 },
                'CSR-AVG': { 'Softmax Attention': 50.5, 'Lightning Attention': 55.2, 'Hybrid-lightning': 55.2 },
                'NIAH': { 'Softmax Attention': 46.0, 'Lightning Attention': 11.0, 'Hybrid-lightning': 98.0 },
                'SCR': { 'Softmax Attention': 13.7, 'Lightning Attention': 13.2, 'Hybrid-lightning': 14.7 }
            },
            '7B': {
                'PIQA': { 'Softmax Attention': 74.5, 'Lightning Attention': 76.25, 'Hybrid-lightning': 76.5 },
                'H5': { 'Softmax Attention': 64.3, 'Lightning Attention': 66.4, 'Hybrid-lightning': 66.3 },
                'WG': { 'Softmax Attention': 62, 'Lightning Attention': 61.4, 'Hybrid-lightning': 62.4 },
                'ARC-E': { 'Softmax Attention': 67.1, 'Lightning Attention': 67.5, 'Hybrid-lightning': 68.5 },
                'ARC-C': { 'Softmax Attention': 36.9, 'Lightning Attention': 38.4, 'Hybrid-lightning': 38.9 },
                'OBQA': { 'Softmax Attention': 35.2, 'Lightning Attention': 38, 'Hybrid-lightning': 37.2 },
                'CSR-AVG': { 'Softmax Attention': 55.0, 'Lightning Attention': 57.5, 'Hybrid-lightning': 58.3 },
                'NIAH': { 'Softmax Attention': 60.0, 'Lightning Attention': 20.0, 'Hybrid-lightning': 97.7 },
                'SCR': { 'Softmax Attention': 14, 'Lightning Attention': 12.5, 'Hybrid-lightning': 15.5 }
            }
        };

        const methods = ['Softmax Attention', 'Lightning Attention', 'Hybrid-lightning'];

        // Get categorical colors with fallback
        function getMethodColors(count) {
            try {
                if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
                    return window.ColorPalettes.getColors('categorical', count);
                }
            } catch (_) { }
            // Fallback colors
            return ['#FFD97D', '#B4A7D6', '#E74C3C'];
        }

        const ensureD3AndColors = (cb) => {
            // Wait for both D3 and ColorPalettes
            const checkReady = () => {
                const d3Ready = window.d3 && typeof window.d3.select === 'function';
                const colorsReady = window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function';

                if (d3Ready && colorsReady) {
                    cb();
                } else if (!d3Ready) {
                    // Load D3 if needed
                    let s = document.getElementById('d3-cdn-script');
                    if (!s) {
                        s = document.createElement('script');
                        s.id = 'd3-cdn-script';
                        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
                        document.head.appendChild(s);
                        s.addEventListener('load', () => setTimeout(checkReady, 100), { once: true });
                    } else {
                        setTimeout(checkReady, 100);
                    }
                } else {
                    // D3 is ready but ColorPalettes isn't yet, wait a bit
                    setTimeout(checkReady, 100);
                }
            };
            checkReady();
        };

        const ensureD3 = (cb) => {
            if (window.d3 && typeof window.d3.select === 'function') return cb();
            let s = document.getElementById('d3-cdn-script');
            if (!s) {
                s = document.createElement('script');
                s.id = 'd3-cdn-script';
                s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
                document.head.appendChild(s);
            }
            const onReady = () => {
                if (window.d3 && typeof window.d3.select === 'function') cb();
            };
            s.addEventListener('load', onReady, { once: true });
            if (window.d3) onReady();
        };

        const bootstrap = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;
            if (!(container && container.classList && container.classList.contains('benchmark-performance'))) {
                const cs = Array.from(document.querySelectorAll('.benchmark-performance')).filter(
                    el => !(el.dataset && el.dataset.mounted === 'true')
                );
                container = cs[cs.length - 1] || null;
            }
            if (!container) return;
            if (container.dataset) {
                if (container.dataset.mounted === 'true') return;
                container.dataset.mounted = 'true';
            }

            // Get colors
            const colors = getMethodColors(methods.length);

            // Create legend
            const legend = document.createElement('div');
            legend.className = 'benchmark-performance__legend';
            legend.innerHTML = `
                <div class="benchmark-performance__legend-title">Attention Methods</div>
                <div class="benchmark-performance__legend-items">
                    ${methods
                    .map(
                        (method, i) => `
                        <div class="benchmark-performance__legend-item" data-method="${method}">
                          <div class="benchmark-performance__legend-swatch" style="background: ${colors[i]}"></div>
                          <span>${method}</span>
                        </div>
                      `
                    )
                    .join('')}
                </div>
            `;
            container.appendChild(legend);

            // Legend hover interactions
            const legendItems = legend.querySelectorAll('.benchmark-performance__legend-item');
            legendItems.forEach(item => {
                const method = item.getAttribute('data-method');
                item.addEventListener('mouseenter', () => {
                    container.classList.add('hovering');
                    // Ghost all bars and legend items except this method
                    document.querySelectorAll('.benchmark-performance .bar').forEach(bar => {
                        if (bar.getAttribute('data-method') !== method) {
                            bar.classList.add('ghost');
                        }
                    });
                    legendItems.forEach(otherItem => {
                        if (otherItem.getAttribute('data-method') !== method) {
                            otherItem.classList.add('ghost');
                        }
                    });
                });
                item.addEventListener('mouseleave', () => {
                    container.classList.remove('hovering');
                    document.querySelectorAll('.benchmark-performance .bar').forEach(bar => {
                        bar.classList.remove('ghost');
                    });
                    legendItems.forEach(otherItem => {
                        otherItem.classList.remove('ghost');
                    });
                });
            });

            // Create grid
            const grid = document.createElement('div');
            grid.className = 'benchmark-performance__grid';
            container.appendChild(grid);

            // Create chart for each model size
            Object.keys(data).forEach(modelSize => {
                const chartDiv = document.createElement('div');
                chartDiv.className = 'benchmark-performance__chart';

                const title = document.createElement('div');
                title.className = 'benchmark-performance__title';
                title.textContent = `${modelSize} Benchmark Performance`;
                chartDiv.appendChild(title);

                grid.appendChild(chartDiv);

                // Render chart
                renderChart(chartDiv, data[modelSize], modelSize, colors);
            });
        };

        const renderChart = (container, chartData, modelSize, colors) => {
            const margin = { top: 40, right: 10, bottom: 60, left: 50 };
            const width = 400;
            const height = 270;
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            const svg = d3
                .select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

            const benchmarks = Object.keys(chartData);
            const x0 = d3.scaleBand().domain(benchmarks).range([0, innerWidth]).padding(0.2);

            const x1 = d3.scaleBand().domain(methods).range([0, x0.bandwidth()]).padding(0.15);

            const y = d3.scaleLinear().domain([0, 100]).range([innerHeight, 0]);

            // Grid
            const grid = g.append('g').attr('class', 'grid');
            grid
                .selectAll('line')
                .data(y.ticks(5))
                .enter()
                .append('line')
                .attr('x1', 0)
                .attr('x2', innerWidth)
                .attr('y1', d => y(d))
                .attr('y2', d => y(d))
                .attr('stroke', 'var(--grid-color, #e0e0e0)')
                .attr('stroke-dasharray', '2,2');

            // X axis
            const xAxis = g.append('g').attr('class', 'axis').attr('transform', `translate(0,${innerHeight})`);

            xAxis
                .call(d3.axisBottom(x0))
                .selectAll('text')
                .attr('transform', 'rotate(-45)')
                .style('text-anchor', 'end')
                .attr('dx', '-0.8em')
                .attr('dy', '0.15em');

            // Y axis
            g.append('g').attr('class', 'axis').call(d3.axisLeft(y).ticks(5));

            // Bars
            const groups = g
                .selectAll('.benchmark-group')
                .data(benchmarks)
                .enter()
                .append('g')
                .attr('class', 'benchmark-group')
                .attr('transform', d => `translate(${x0(d)},0)`);

            // Helper function to create rounded top bar path
            const roundedTopBarPath = (x, y, width, height, radius) => {
                const r = Math.min(radius, height / 2, width / 2);
                return `
                    M ${x},${y + height}
                    L ${x},${y + r}
                    Q ${x},${y} ${x + r},${y}
                    L ${x + width - r},${y}
                    Q ${x + width},${y} ${x + width},${y + r}
                    L ${x + width},${y + height}
                    Z
                `;
            };

            groups
                .selectAll('.bar')
                .data(benchmark => {
                    return methods.map(method => ({
                        method,
                        value: chartData[benchmark][method],
                        benchmark
                    }));
                })
                .enter()
                .append('path')
                .attr('class', 'bar')
                .attr('data-method', d => d.method)
                .attr('d', d => {
                    const x = x1(d.method);
                    const yPos = y(d.value);
                    const width = x1.bandwidth();
                    const height = innerHeight - yPos;
                    return roundedTopBarPath(x, yPos, width, height, 1.5);
                })
                .attr('fill', (d, i) => colors[methods.indexOf(d.method)])
                .on('mouseenter', function (event, d) {
                    const mainContainer = container.closest('.benchmark-performance');
                    if (!mainContainer) return;

                    mainContainer.classList.add('hovering');

                    // Ghost all bars and legend items except this method
                    document.querySelectorAll('.benchmark-performance .bar').forEach(bar => {
                        if (bar.getAttribute('data-method') !== d.method) {
                            bar.classList.add('ghost');
                        }
                    });

                    const legendItems = document.querySelectorAll('.benchmark-performance__legend-item');
                    legendItems.forEach(item => {
                        if (item.getAttribute('data-method') !== d.method) {
                            item.classList.add('ghost');
                        }
                    });

                    // Ghost labels if not hovering Hybrid-lightning
                    document.querySelectorAll('.benchmark-performance .bar-label').forEach(label => {
                        if (label.getAttribute('data-method') !== d.method) {
                            label.classList.add('ghost');
                        }
                    });
                })
                .on('mouseleave', function (event, d) {
                    const mainContainer = container.closest('.benchmark-performance');
                    if (!mainContainer) return;

                    mainContainer.classList.remove('hovering');

                    document.querySelectorAll('.benchmark-performance .bar').forEach(bar => {
                        bar.classList.remove('ghost');
                    });

                    const legendItems = document.querySelectorAll('.benchmark-performance__legend-item');
                    legendItems.forEach(item => {
                        item.classList.remove('ghost');
                    });

                    document.querySelectorAll('.benchmark-performance .bar-label').forEach(label => {
                        label.classList.remove('ghost');
                    });
                });

            // Bar labels - afficher uniquement sur Hybrid-lightning
            groups.each(function (benchmark) {
                const hybridLightningValue = chartData[benchmark]['Hybrid-lightning'];

                // Ajouter le label uniquement pour Hybrid-lightning
                d3.select(this)
                    .append('text')
                    .attr('class', 'bar-label')
                    .attr('data-method', 'Hybrid-lightning')
                    .attr('x', x1('Hybrid-lightning') + x1.bandwidth() / 2)
                    .attr('y', y(hybridLightningValue) - 5)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '10px')
                    .attr('font-weight', '600')
                    .attr('fill', 'var(--text-color)')
                    .text(hybridLightningValue.toFixed(1));
            });
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => ensureD3AndColors(bootstrap), { once: true });
        } else {
            ensureD3AndColors(bootstrap);
        }
    })();
</script></div></div></figure> </div>
<p>What’s interesting here is that on retrieval tasks like Needle in a Haystack (NIAH) it can do much much better than full softmax attention, which seems surprising but might indicate that there is some synergy when the softmax and the linear layer work together!</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty>  <div class="note__title" data-astro-cid-qg6lmfty>MiniMax M2</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Surprisingly, the recently released MiniMax M2 does not use hybrid or linear Attention. According to their lead NLP researcher, they found it <a href="https://x.com/zpysky1125/status/1982847594926911984">hurts performance on reasoning-related tasks</a>. This highlights the complexity of architecture ablations. We’ll update this section once MiniMax releases their technical report with detailed ablations.</p> </div> </div> </div> 
<p>Now let’s have a look at some more of these methods and how they can be understood with a unified framework.</p>
<p><strong>Advanced linear attention</strong></p>
<p>A helpful lesson from recurrent models is to let the state occasionally let go of the past. In practice, that means introducing a gate  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{G}_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span>  for the previous state:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="bold">S</mi><mi>t</mi></msub><mtext>  </mtext><mo>=</mo><mtext>  </mtext><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub><mo>⊙</mo><msub><mi mathvariant="bold">S</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext>  </mtext><mo>+</mo><mtext>  </mtext><msub><mi mathvariant="bold">v</mi><mi>t</mi></msub><msubsup><mi mathvariant="bold">k</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathbf{S}_t \;=\; \mathbf{G}_t \odot \mathbf{S}_{t-1} \;+\; \mathbf{v}_t \mathbf{k}_t^{\top}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8944em;vertical-align:-0.2083em"></span><span class="mord"><span class="mord mathbf">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.1461em;vertical-align:-0.247em"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊤</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span></span></span></span></span>
<p>Almost all recent linear attention methods have this gating component with just different implementations of  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{G}_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> . Here is a list of the different variants for the gate and the corresponding architecture from <a href="arxiv.org/abs/2312.06635">this paper</a>:</p>
<div class="wide"> <div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> 






















































<div class="table-scroll"><table><thead><tr><th>Model</th><th>Parameterization</th><th>Learnable parameters</th></tr></thead><tbody><tr><td>Mamba <span class="" id="citation--mamba--66">(<a href="https://arxiv.org/abs/2312.00752" id="refctx-bib-mamba-1" data-ref-id="bib-mamba" target="_blank" rel="noopener noreferrer">A. Gu &amp; Dao, 2024</a>)</span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub><mo>=</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mo stretchy="false">(</mo><msup><mn mathvariant="bold">1</mn><mi mathvariant="normal">⊤</mi></msup><msub><mi mathvariant="bold-italic">α</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mo>⊙</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="bold">A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace width="1em"></mspace><mi mathvariant="bold-italic">α</mi><mi>t</mi><mo>=</mo><mtext>softplus</mtext><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mi>t</mi><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>1</mn></msub><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{G}_t = \exp(-(\mathbf{1}^\top \boldsymbol{\alpha}_t) \odot \exp(\mathbf{A})), \quad \boldsymbol{\alpha}t = \text{softplus}(\mathbf{x}t \mathbf{W}{\alpha_1} \mathbf{W}{\alpha_2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord mathbf">A</span><span class="mclose">))</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord">softplus</span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathnormal">t</span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><msub><mi>d</mi><mi>k</mi></msub><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup><mo separator="true">,</mo><mspace width="1em"></mspace><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>1</mn></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><mfrac><mi>d</mi><mn>16</mn></mfrac></mrow></msup><mo separator="true">,</mo><mspace width="1em"></mspace><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>2</mn></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mfrac><mi>d</mi><mn>16</mn></mfrac><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{A} \in \mathbb{R}^{d_k \times d_v}, \quad \mathbf{W}{\alpha_1} \in \mathbb{R}^{d \times \frac{d}{16}}, \quad \mathbf{W}{\alpha_2} \in \mathbb{R}^{\frac{d}{16} \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7252em;vertical-align:-0.0391em"></span><span class="mord mathbf">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.1735em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.979em"><span style="top:-3.363em;margin-right:0.05em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.88em"><span style="top:-2.656em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span><span style="top:-3.2255em"><span class="pstrut" style="height:3em"></span><span class="frac-line mtight" style="border-bottom-width:0.049em"></span></span><span style="top:-3.384em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.979em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.979em"><span style="top:-3.363em;margin-right:0.05em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.88em"><span style="top:-2.656em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span><span style="top:-3.2255em"><span class="pstrut" style="height:3em"></span><span class="frac-line mtight" style="border-bottom-width:0.049em"></span></span><span style="top:-3.384em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>Mamba-2 <span class="" id="citation--mamba2--67">(<a href="https://arxiv.org/abs/2405.21060" id="refctx-bib-mamba2-1" data-ref-id="bib-mamba2" target="_blank" rel="noopener noreferrer">Dao &amp; Gu, 2024</a>)</span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub><mo>=</mo><msub><mi>γ</mi><mi>t</mi></msub><msup><mn mathvariant="bold">1</mn><mi mathvariant="normal">⊤</mi></msup><mn mathvariant="bold">1</mn><mo separator="true">,</mo><mspace width="1em"></mspace><msub><mi>γ</mi><mi>t</mi></msub><mo>=</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mtext>softplus</mtext><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mi>t</mi><mi mathvariant="bold">W</mi><mi>γ</mi><mo stretchy="false">)</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{G}_t = \gamma_t \mathbf{1}^\top \mathbf{1}, \quad \gamma_t = \exp(-\text{softplus}(\mathbf{x}t \mathbf{W}{\gamma})\exp(a))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord mathbf">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mord text"><span class="mord">softplus</span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathnormal">t</span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em">γ</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">))</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">W</mi><mi>γ</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mspace width="1em"></mspace><mi>a</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbf{W}_{\gamma} \in \mathbb{R}^{d \times 1}, \quad a \in \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9722em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05556em">γ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6889em"></span><span class="mord mathbb">R</span></span></span></span></td></tr><tr><td>mLSTM <span class="" id="citation--beck2025tiledflashlinearattention--peng2021randomfeatureattention--68">(<a href="https://arxiv.org/abs/2503.14376" id="refctx-bib-beck2025tiledflashlinearattention-1" data-ref-id="bib-beck2025tiledflashlinearattention" target="_blank" rel="noopener noreferrer">Beck et al., 2025</a>; H. <a href="https://arxiv.org/abs/2103.02143" id="refctx-bib-peng2021randomfeatureattention-1" data-ref-id="bib-peng2021randomfeatureattention" target="_blank" rel="noopener noreferrer">Peng et al., 2021</a>)</span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub><mo>=</mo><msub><mi>γ</mi><mi>t</mi></msub><msup><mn mathvariant="bold">1</mn><mi mathvariant="normal">⊤</mi></msup><mn mathvariant="bold">1</mn><mo separator="true">,</mo><mspace width="1em"></mspace><msub><mi>γ</mi><mi>t</mi></msub><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mi>t</mi><mi mathvariant="bold">W</mi><mi>γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{G}_t = \gamma_t \mathbf{1}^\top \mathbf{1}, \quad \gamma_t = \sigma(\mathbf{x}t \mathbf{W}{\gamma})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord mathbf">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.03588em">σ</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathnormal">t</span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em">γ</span></span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">W</mi><mi>γ</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{W}_{\gamma} \in \mathbb{R}^{d \times 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9722em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05556em">γ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>Gated Retention <span class="" id="citation--sun2024cacheoncedecoderdecoderarchitectures--69">(<a href="https://arxiv.org/abs/2405.05254" id="refctx-bib-sun2024cacheoncedecoderdecoderarchitectures-1" data-ref-id="bib-sun2024cacheoncedecoderdecoderarchitectures" target="_blank" rel="noopener noreferrer">Sun et al., 2024</a>)</span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub><mo>=</mo><msub><mi>γ</mi><mi>t</mi></msub><msup><mn mathvariant="bold">1</mn><mi mathvariant="normal">⊤</mi></msup><mn mathvariant="bold">1</mn><mo separator="true">,</mo><mspace width="1em"></mspace><msub><mi>γ</mi><mi>t</mi></msub><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mi>t</mi><mi mathvariant="bold">W</mi><mi>γ</mi><msup><mo stretchy="false">)</mo><mfrac><mn>1</mn><mi>τ</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">\mathbf{G}_t = \gamma_t \mathbf{1}^\top \mathbf{1}, \quad \gamma_t = \sigma(\mathbf{x}t \mathbf{W}{\gamma})^{\frac{1}{\tau}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord mathbf">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.204em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.03588em">σ</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathnormal">t</span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em">γ</span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em"><span style="top:-3.363em;margin-right:0.05em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em"><span style="top:-2.656em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.1132em">τ</span></span></span></span><span style="top:-3.2255em"><span class="pstrut" style="height:3em"></span><span class="frac-line mtight" style="border-bottom-width:0.049em"></span></span><span style="top:-3.384em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">W</mi><mi>γ</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{W}_{\gamma} \in \mathbb{R}^{d \times 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9722em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05556em">γ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>DFW (Mao, 2022; Pramanik et al., 2023) <span class="" id="citation--mao2022finetuningpretrainedtransformersdecaying--70">(<a href="https://arxiv.org/abs/2210.04243" id="refctx-bib-mao2022finetuningpretrainedtransformersdecaying-1" data-ref-id="bib-mao2022finetuningpretrainedtransformersdecaying" target="_blank" rel="noopener noreferrer">Mao, 2022</a>)</span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub><mo>=</mo><msubsup><mi mathvariant="bold-italic">α</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><msub><mi mathvariant="bold-italic">β</mi><mi>t</mi></msub><mo separator="true">,</mo><mspace width="1em"></mspace><msub><mi mathvariant="bold-italic">α</mi><mi>t</mi></msub><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mi>t</mi><mi mathvariant="bold">W</mi><mi>α</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mspace width="1em"></mspace><msub><mi mathvariant="bold-italic">β</mi><mi>t</mi></msub><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mi>t</mi><mi mathvariant="bold">W</mi><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{G}_t = \boldsymbol{\alpha}_t^\top \boldsymbol{\beta}_t, \quad \boldsymbol{\alpha}_t = \sigma(\mathbf{x}t \mathbf{W}{\alpha}), \quad \boldsymbol{\beta}_t = \sigma(\mathbf{x}t \mathbf{W}{\beta})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0961em;vertical-align:-0.247em"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-2.453em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03403em">β</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em"><span style="top:-2.4559em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.03588em">σ</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathnormal">t</span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03403em">β</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em"><span style="top:-2.4559em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.03588em">σ</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathnormal">t</span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em">β</span></span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">W</mi><mi>α</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup><mo separator="true">,</mo><mspace width="1em"></mspace><mi mathvariant="bold">W</mi><mi>β</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><msub><mi>d</mi><mi>v</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{W}{\alpha} \in \mathbb{R}^{d \times d_k}, \quad \mathbf{W}{\beta} \in \mathbb{R}^{d \times d_v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7252em;vertical-align:-0.0391em"></span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em">β</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>GateLoop <span class="" id="citation--katsch2024gateloopfullydatacontrolledlinear--71">(<a href="https://arxiv.org/abs/2311.01927" id="refctx-bib-katsch2024gateloopfullydatacontrolledlinear-1" data-ref-id="bib-katsch2024gateloopfullydatacontrolledlinear" target="_blank" rel="noopener noreferrer">Katsch, 2024</a>)</span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub><mo>=</mo><msubsup><mi mathvariant="bold-italic">α</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><mn mathvariant="bold">1</mn><mo separator="true">,</mo><mspace width="1em"></mspace><msub><mi mathvariant="bold-italic">α</mi><mi>t</mi></msub><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mi>t</mi><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mi>t</mi><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>2</mn></msub><mi mathvariant="normal">i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{G}_t = \boldsymbol{\alpha}_t^\top \mathbf{1}, \quad \boldsymbol{\alpha}_t = \sigma(\mathbf{x}t \mathbf{W}{\alpha_1})\exp(\mathbf{x}t \mathbf{W}{\alpha_2} \mathrm{i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0961em;vertical-align:-0.247em"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-2.453em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord mathbf">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.03588em">σ</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathnormal">t</span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathnormal">t</span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mord mathrm">i</span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>1</mn></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup><mo separator="true">,</mo><mspace width="1em"></mspace><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>2</mn></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{W}{\alpha_1} \in \mathbb{R}^{d \times d_k}, \quad \mathbf{W}{\alpha_2} \in \mathbb{R}^{d \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>HGRN-2 <span class="" id="citation--qin2024hgrn2gatedlinearrnns--72">(<a href="https://arxiv.org/abs/2404.07904" id="refctx-bib-qin2024hgrn2gatedlinearrnns-1" data-ref-id="bib-qin2024hgrn2gatedlinearrnns" target="_blank" rel="noopener noreferrer">Qin et al., 2024</a>)</span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub><mo>=</mo><msubsup><mi mathvariant="bold-italic">α</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><mn mathvariant="bold">1</mn><mo separator="true">,</mo><mspace width="1em"></mspace><msub><mi mathvariant="bold-italic">α</mi><mi>t</mi></msub><mo>=</mo><mi>γ</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>γ</mi><mo stretchy="false">)</mo><mi>σ</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mi>t</mi><mi mathvariant="bold">W</mi><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{G}_t = \boldsymbol{\alpha}_t^\top \mathbf{1}, \quad \boldsymbol{\alpha}_t = \gamma + (1-\gamma)\sigma(\mathbf{x}t \mathbf{W}{\alpha})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0961em;vertical-align:-0.247em"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-2.453em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord mathbf">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em">σ</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathnormal">t</span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span><span class="mclose">)</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">W</mi><mi>α</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup><mo separator="true">,</mo><mspace width="1em"></mspace><mi>γ</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">)</mo><msub><mi>d</mi><mi>k</mi></msub></msup></mrow><annotation encoding="application/x-tex">\mathbf{W}_{\alpha} \in \mathbb{R}^{d \times d_k}, \quad \gamma \in (0,1)^{d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em">α</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>RWKV-6 <span class="" id="citation--peng2024eaglefinchrwkvmatrixvalued--73">(<a href="https://arxiv.org/abs/2404.05892" id="refctx-bib-peng2024eaglefinchrwkvmatrixvalued-1" data-ref-id="bib-peng2024eaglefinchrwkvmatrixvalued" target="_blank" rel="noopener noreferrer">B. Peng et al., 2024</a>)</span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub><mo>=</mo><msubsup><mi mathvariant="bold-italic">α</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><mn mathvariant="bold">1</mn><mo separator="true">,</mo><mspace width="1em"></mspace><msub><mi mathvariant="bold-italic">α</mi><mi>t</mi></msub><mo>=</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mi>t</mi><mi mathvariant="bold">W</mi><mi>α</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{G}_t = \boldsymbol{\alpha}_t^\top \mathbf{1}, \quad \boldsymbol{\alpha}_t = \exp(-\exp(\mathbf{x}t \mathbf{W}{\alpha}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0961em;vertical-align:-0.247em"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-2.453em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord mathbf">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathnormal">t</span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span><span class="mclose">))</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">W</mi><mi>α</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{W}_{\alpha} \in \mathbb{R}^{d \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.016em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em">α</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td>Gated Linear Attention (GLA)</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">G</mi><mi>t</mi></msub><mo>=</mo><msubsup><mi mathvariant="bold-italic">α</mi><mi>t</mi><mi mathvariant="normal">⊤</mi></msubsup><mn mathvariant="bold">1</mn><mo separator="true">,</mo><mspace width="1em"></mspace><mi mathvariant="bold-italic">α</mi><mi>t</mi><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mi>t</mi><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>1</mn></msub><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mfrac><mn>1</mn><mi>τ</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">\mathbf{G}_t = \boldsymbol{\alpha}_t^\top \mathbf{1}, \quad \boldsymbol{\alpha}t = \sigma(\mathbf{x}t \mathbf{W}{\alpha_1} \mathbf{W}{\alpha_2})^{\frac{1}{\tau}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathbf">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0961em;vertical-align:-0.247em"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-2.453em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em"><span></span></span></span></span></span></span><span class="mord mathbf">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">α</span></span></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.204em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.03588em">σ</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mord mathnormal">t</span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em"><span style="top:-3.363em;margin-right:0.05em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em"><span style="top:-2.656em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.1132em">τ</span></span></span></span><span style="top:-3.2255em"><span class="pstrut" style="height:3em"></span><span class="frac-line mtight" style="border-bottom-width:0.049em"></span></span><span style="top:-3.384em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>1</mn></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><mn>16</mn></mrow></msup><mo separator="true">,</mo><mspace width="1em"></mspace><mi mathvariant="bold">W</mi><msub><mi>α</mi><mn>2</mn></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mn>16</mn><mo>×</mo><msub><mi>d</mi><mi>k</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{W}{\alpha_1} \in \mathbb{R}^{d \times 16}, \quad \mathbf{W}{\alpha_2} \in \mathbb{R}^{16 \times d_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em"></span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0435em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathbf" style="margin-right:0.01597em">W</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></td></tr></tbody></table></div> </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Gated linear attention formulation of recent models, which vary in their parameterization of  $\mathbf{G}_t$ . The bias terms are omitted.</figcaption> </figure> </div>  </div>
<p>One notable variant is Mamba-2 <span class="" id="citation--mamba2--74">(<a href="https://arxiv.org/abs/2405.21060" id="refctx-bib-mamba2-2" data-ref-id="bib-mamba2" target="_blank" rel="noopener noreferrer">Dao &amp; Gu, 2024</a>)</span> on the list. It’s used in many of the hybrid models like Nemotron-H, Falcon H1, and Granite-4.0-h <span class="" id="citation--nemotronh--falconh1--granite4--75">(<a href="https://www.ibm.com/new/announcements/ibm-granite-4-0-hyper-efficient-high-performance-hybrid-models" id="refctx-bib-granite4-1" data-ref-id="bib-granite4" target="_blank" rel="noopener noreferrer">IBM Research, 2025</a>; NVIDIA, :, Blakeman, et al., 2025; Zuo et al., 2025<a href="https://arxiv.org/abs/2504.03624" id="refctx-bib-nemotronh-1" data-ref-id="bib-nemotronh" target="_blank" rel="noopener noreferrer">)</a><a href="https://arxiv.org/abs/2507.22448" id="refctx-bib-falconh1-2" data-ref-id="bib-falconh1" target="_blank" rel="noopener noreferrer"></a></span>. Overall, hybrid models are moving quickly and are a solid choice for frontier training. Qwen3-Next (with a gated DeltaNet update) <span class="" id="citation--qwen3next--76">(<a href="https://qwen.ai/blog?id=4074cca80393150c248e508aa62983f9cb7d27cd&from=research.latest-advancements-list" id="refctx-bib-qwen3next-1" data-ref-id="bib-qwen3next" target="_blank" rel="noopener noreferrer">Qwen Team, 2025</a>)</span> reports they are:</p>
<ul>
<li>faster at inference for long context (the primary goal)</li>
<li>faster to train</li>
<li>and stronger on benchmarks</li>
</ul>
<p>However, it’s a bit too early for definitive consensus but they are definitely a choice to carefully consider for your next models!</p>
<p>We’ll wrap up the architecture choices before moving to tokenizers by building a small decision tree to determine weather to train a dense, a MoE or a Hybrid model.</p>
<h4 id="to-moe-or-not-moe-choosing-a-base-architecture"><a href="#to-moe-or-not-moe-choosing-a-base-architecture"><strong>To MoE or not MoE: Choosing a Base Architecture</strong></a></h4>
<p>We’ve now seen dense, MoE and hybrid models so you might naturally be curious to know which one you should use? Your architecture choice typically depends on where you’ll deploy the model, your team’s expertise, and your timeline. Let’s go briefly over the pros and cons of each architecture and come up with a simple guiding process to find the right architecture for you.</p>
<p><strong>Dense transformers</strong>  are the foundation standard decoder-only transformers where every parameter activates for every token. See <a href="https://nlp.seas.harvard.edu/2018/04/03/attention.html">The Annotated Transformers</a> for the math and <a href="https://jalammar.github.io/illustrated-transformer/">The Illustrated Transformers</a> to build your intuition.</p>
<p>Pros: Widely supported, well-understood, stable training, good performance per parameter.</p>
<p>Cons: Compute scales linearly with size, a 70B model costs ~23× more than 3B.</p>
<div class="note note--success" data-astro-cid-qg6lmfty> <!-- When there's no title, emoji is above content -->
    <div class="note__layout" data-astro-cid-qg6lmfty>  <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__content" data-astro-cid-qg6lmfty> <p>This is usually the default choice for memory-contrained use cases or new LLM trainers.</p> </div> </div> </div> </div> 
<p><strong>Mixture of Experts (MoE)</strong>  replaces feed-forward layers in the transformer with multiple “experts”. For each token, a gating network routes it to only a few experts. The result is the capacity of a large network at a fraction of the compute. For example <a href="https://huggingface.co/moonshotai/Kimi-K2-Instruct">Kimi K2</a> has 1T total parameters but only 32B active per token. The catch is that all experts must be loaded in memory. For a visual guide and reminder, check <a href="https://newsletter.maartengrootendorst.com/p/a-visual-guide-to-mixture-of-experts">this blog</a>.</p>
<p>Pros: Better performance per compute for training and inference.</p>
<p>Cons: High memory (all experts must be loaded). More complex training than dense transformers. Framework support is improving but less mature than dense models. And distributed training is a nightmare with expert placement, load balancing, and all-to-all communication challenges.</p>
<div class="note note--success" data-astro-cid-qg6lmfty> <!-- When there's no title, emoji is above content -->
    <div class="note__layout" data-astro-cid-qg6lmfty>  <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__content" data-astro-cid-qg6lmfty> <p>Use when you’re not memory-constrained and want maximum performance per compute.</p> </div> </div> </div> </div> 
<p><strong>Hybrid models</strong>  combine transformers with State Space Models (SSMs) like Mamba, offering linear complexity for some operations versus attention’s quadratic scaling. (<a href="https://srush.github.io/annotated-mamba/hard.html">Mathy blog</a> | <a href="https://newsletter.maartengrootendorst.com/p/a-visual-guide-to-mamba-and-state">Visual guide</a>)</p>
<p>Pros: Potentially better long-context handling. More efficient for very long sequences.</p>
<p>Cons: Less mature with fewer proven training recipes. Limited framework support.</p>
<div class="note note--success" data-astro-cid-qg6lmfty> <!-- When there's no title, emoji is above content -->
    <div class="note__layout" data-astro-cid-qg6lmfty>  <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__content" data-astro-cid-qg6lmfty> <p>Use if you want to scale to very large contexts while reducing the inference overhead of standard transformers.</p> </div> </div> </div> </div> 
<div class="sidenote-container"> <aside class="sidenote"> <p>We’re also now seeing some teams explore diffusion models for text, but these models (and other experimental alternatives) are very early stage that we consider them out of scope for the document.</p> </aside> </div>  
<p>So to recap, start by asking where your model will be deployed. Then consider your team’s expertise and your training timeline to assess how much exploration you can afford:</p>
<pre class="mermaid">flowchart TD
    A[&quot;Where will this model run?&quot;] --&gt; B[&quot;Edge/Phones
     Memory-constrained environments&quot;]
    A --&gt; C[&quot;Other
     More memory available&quot;]
    
    B --&gt; D[&quot;Dense (most cases)
     Hybrid or other (for experienced teams)&quot;]
    
    C --&gt; E[&quot;What&#39;s your team&#39;s expertise?&quot;]
    
    E --&gt; F[&quot;First LLM training&quot;]
    E --&gt; G[&quot;Experienced
     Comfortable with dense&quot;]
    E --&gt; H[&quot;Very experienced&quot;]
    
    F --&gt; I[&quot;Dense
     (Focus on basics)&quot;]
    
    G --&gt; J[&quot;What&#39;s your timeline?&quot;]
    
    J --&gt; K[&quot;Tight
     Proven path required&quot;]
    J --&gt; L[&quot;Flexible
     Open to exploration&quot;]
    
    K --&gt; M[&quot;Dense&quot;]
    L --&gt; N[&quot;MoE or MoE + Hybrid: better perf/compute&quot;]
    
    H --&gt; O[&quot;MoE or MoE + Hybrid: better perf/compute&quot;]
    
    classDef question fill:#ffd0c5,stroke:#ffb9b7,stroke-width:2px,color:#2d3748
    classDef decision fill:#f9f9f9,stroke:#e5e5e5,stroke-width:2px,color:#374151
    classDef success fill:#d1f2eb,stroke:#a3e4d7,stroke-width:2px,color:#0e5132
    classDef danger fill:#fef3c7,stroke:#fbbf24,stroke-width:2px,color:#78350f
    classDef category fill:#fef3c7,stroke:#fbbf24,stroke-width:2px,color:#78350f
    
    class A,E,J question
    class B,C,F,G,H,K,L decision
    class D,I,M success
    class N,O category</pre>
<p>For SmolLM3 we wanted to build a strong small model for on-device deployment, we had roughly a 3-month timeline, and have mostly trained dense models in the past. This ruled out MoE (memory constraints) and hybrid (short timeline to explore a new architecture, and dense models could get the long context we targeted of 128k tokens max), so we went for a dense model llama-style.</p>
<p>Now that we have studied the internals of the model architecture let’s look at the tokenizer which forms the bridge between the data and our model.</p>
<h4 id="the-tokenizer"><a href="#the-tokenizer">The tokenizer</a></h4>
<p>While it rarely steals the spotlight from architecture innovations, the tokenization scheme is likely one of the most underrated components of any language model. Think of it as the translator between human language and the mathematical world our model lives in, and just like any translator, the quality of the translation matters a lot. So how do we build or choose the right tokenizer for our needs?</p>
<p><strong>Tokenizer fundamentals</strong></p>
<p>At its core, a tokenizer converts raw text into sequences of numbers that our model can process, by segmenting a running text into individual processable units called tokens. Before diving into the technical details, we should first answer some fundamental questions that will guide our tokenizer design:</p>
<ul>
<li><strong>What languages do we want to support?</strong>  If we’re building a multilingual model but our tokenizer has only seen English, the model will be inefficient when encountering non-English text, which will get split into many more tokens than necessary. This directly impacts performance, training cost and inference speed.</li>
<li><strong>Which domains matter to us?</strong>  Beyond languages, domains like math and code require careful representation of digits.</li>
<li><strong>Do we know our target data mixture?</strong>  If we plan to train our tokenizer from scratch, ideally, we should train it on a sample that mirrors our final training mixture.</li>
</ul>
<p>Once we have answered these questions, we can examine the main design decisions:</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>For a deep dive into tokenization fundamentals, Andrej Karpathy’s <a href="https://www.youtube.com/watch?v=zduSFxRajkE">“Let’s build the GPT Tokenizer”</a> is an excellent hands-on tutorial. You can also check this <a href="https://github.com/huggingface/evaluation-guidebook/blob/main/contents/general-knowledge/tokenization.md">resource</a> which provides an introduction to tokenizers and a number of external resources.</p> </aside> </div>  
<p><strong>Vocabulary size</strong></p>
<p>The vocabulary is essentially a dictionary listing all tokens (minimal text units, like words, subwords, or symbols) our model recognizes.</p>
<p>Larger vocabularies compress text more efficiently since we generate fewer tokens per sentence, but there’s a computational trade-off. The vocabulary size directly affects the size of our embedding matrices. If we have vocabulary size V and hidden dimension h, the input embeddings have V × h parameters, and the output layer has another V × h parameters. For smaller models, this becomes a significant chunk of total parameters as we’ve seen in the “Embedding Sharing” section, but the relative cost shrinks as models scale up.</p>
<p>The sweet spot depends on our target coverage and model size. For English-only models, around 50k tokens usually suffices, but multilingual models often need 100k+ to efficiently handle diverse writing systems and languages. Modern state-of-the-art models like Llama3 have adopted vocabularies in the 128k+ range to improve token efficiency across diverse languages. Smaller models in the same family apply embedding sharing to reduce the percentage of embedding parameters while still benefiting from the larger vocabulary.
<span class="" id="citation--dagan2024gettingtokenizerpretrainingdomain--77"><a href="https://arxiv.org/abs/2402.01035" id="refctx-bib-dagan2024gettingtokenizerpretrainingdomain-1" data-ref-id="bib-dagan2024gettingtokenizerpretrainingdomain" target="_blank" rel="noopener noreferrer">Dagan et al. (2024)</a></span> analyze the impact of vocabulary size on compression, inference and memory. They observe that compression gains from larger vocabularies decrease exponentially, suggesting an optimal size exists. For inference, larger models benefit from bigger vocabularies because compression saves more on the forward pass than the additional embedding tokens cost in softmax. For memory, optimal size depends on sequence length and batch size: longer contexts and large batches benefit from larger vocabs due to KV cache savings from having fewer tokens.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Set vocabulary size to a multiple of 128 (e.g., 50,304 instead of 50,000) to optimize throughput. Modern GPUs perform matrix operations better when dimensions are divisible by higher powers of 2, as this ensures efficient memory alignment and reduces overhead from misaligned memory accesses. More details in this <a href="https://www.thonking.ai/p/what-shapes-do-matrix-multiplications">blog</a>.</p> </aside> </div>  
<p><strong>Tokenization algorithm</strong></p>
<p>BPE (Byte-Pair Encoding) <span class="" id="citation--sennrich2016neuralmachinetranslationrare--78">(<a href="https://arxiv.org/abs/1508.07909" id="refctx-bib-sennrich2016neuralmachinetranslationrare-1" data-ref-id="bib-sennrich2016neuralmachinetranslationrare" target="_blank" rel="noopener noreferrer">Sennrich et al., 2016</a>)</span> remains the most popular choice, other algorithms like WordPiece or SentencePiece exist but are less adopted. There’s also growing research interest in tokenizer-free approaches that work directly on bytes or characters, potentially eliminating tokenization altogether.</p>
<p>Now that we’ve seen the key parameters that define a tokenizer, we face a practical decision: should we use an existing tokenizer or train from scratch? The answer depends on coverage: whether existing tokenizers with our target vocabulary size handle our languages and domains well.</p>
<p>The figure below compares how GPT-2’s English-only tokenizer <span class="" id="citation--gpt2--79">(<a href="#bib-gpt2" id="refctx-bib-gpt2-1">Radford et al., 2019</a>)</span> and Gemma 3’s multilingual tokenizer <span class="" id="citation--gemma3--80">(<a href="https://arxiv.org/abs/2503.19786" id="refctx-bib-gemma3-1" data-ref-id="bib-gemma3" target="_blank" rel="noopener noreferrer">G. Team, Kamath, et al., 2025</a>)</span> segment the same English and Arabic sentence.</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-j1zq55zy81i"><div class="d3-tokenization-comparison"></div>

<style>
  .d3-tokenization-comparison {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.5;
    color: var(--text-color);
  }

  .d3-tokenization-comparison .comparison-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
    align-items: start;
  }

  .d3-tokenization-comparison .tokenizer-section {
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    position: relative;
    overflow: hidden;
  }

  .d3-tokenization-comparison .gpt2-section {
    border: 1px solid #e74c3c;
  }

  .d3-tokenization-comparison .gemma-section {
    border: 1px solid #27ae60;
  }

  .d3-tokenization-comparison .tokenizer-header {
    padding: 16px 20px;
    border-bottom: 1px solid var(--border-color);
    background: var(--surface-bg);
  }

  .d3-tokenization-comparison .gpt2-section .tokenizer-header {
    background: var(--surface-bg);
    border-bottom-color: rgba(231, 76, 60, 0.2);
  }

  .d3-tokenization-comparison .gemma-section .tokenizer-header {
    background: var(--surface-bg);
    border-bottom-color: rgba(39, 174, 96, 0.2);
  }

  .d3-tokenization-comparison .tokenizer-title {
    font-size: 1.5em;
    font-weight: 700;
    margin: 0;
    text-align: left;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .d3-tokenization-comparison .gpt2-title {
    color: #e74c3c;
  }

  .d3-tokenization-comparison .gemma-title {
    color: #27ae60;
  }

  .d3-tokenization-comparison .tokenizer-content {
    padding: 20px;
  }

  .d3-tokenization-comparison .language-section {
    margin-bottom: 20px;
    padding-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
  }

  .d3-tokenization-comparison .language-section:last-child {
    border-bottom: none;
    padding-bottom: 0;
  }

  .d3-tokenization-comparison .language-name {
    font-size: 1.2em;
    font-weight: 700;
    margin-bottom: 12px;
    color: var(--text-color);
  }

  .d3-tokenization-comparison .text-label {
    font-size: 0.9em;
    font-weight: 600;
    color: var(--text-color);
    text-transform: uppercase;
    letter-spacing: 0.3px;
    margin-bottom: 8px;
  }

  .d3-tokenization-comparison .sentence-text {
    font-size: 0.85em;
    margin-bottom: 12px;
    padding: 12px;
    background: var(--page-bg);
    border-radius: 6px;
    border: 1px solid var(--border-color);
    line-height: 1.5;
  }

  .d3-tokenization-comparison .arabic-text {
    direction: rtl;
    text-align: right;
    font-family: 'Noto Sans Arabic', 'Arial Unicode MS', sans-serif;
  }

  .d3-tokenization-comparison .tokens-header {
    display: flex;
    align-items: baseline;
    gap: 8px;
    margin-bottom: 12px;
    margin-top: 16px;
  }

  .d3-tokenization-comparison .tokens-label {
    font-size: 0.9em;
    font-weight: 600;
    color: var(--text-color);
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }

  .d3-tokenization-comparison .token-count {
    font-size: 0.85em;
    color: var(--muted-color);
    font-weight: 400;
  }

  .d3-tokenization-comparison .token-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 3px;
    margin-bottom: 12px;
    justify-content: flex-start;
  }

  .d3-tokenization-comparison .token {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.75em;
    font-weight: 500;
    color: white;
    cursor: pointer;
    transition: transform 0.2s;
    border: 1px solid rgba(255, 255, 255, 0.2);
    min-width: 16px;
    text-align: center;
    position: relative;
  }

  .d3-tokenization-comparison .token:hover {
    transform: scale(1.05);
    z-index: 10;
  }

  .d3-tokenization-comparison .token-id {
    font-size: 0.7em;
    color: rgba(255, 255, 255, 0.8);
    margin-top: 1px;
    line-height: 1;
  }

  .d3-tokenization-comparison .delimited-text {
    display: none;
  }



  /* Responsive design */
  @media (max-width: 768px) {
    .d3-tokenization-comparison .comparison-grid {
      grid-template-columns: 1fr;
      gap: 16px;
    }


    .d3-tokenization-comparison .tokenizer-section {
      padding: 16px;
    }
  }

  @media (max-width: 480px) {
    .d3-tokenization-comparison {
      padding: 12px;
    }

    .d3-tokenization-comparison .tokenizer-section {
      padding: 12px;
    }


  }
</style>

<script>
  (() => {
    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-tokenization-comparison'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-tokenization-comparison'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Sample data
      const sampleData = {
        english_text: "The development of large language models has revolutionized artificial intelligence research and applications across multiple domains especially education.",
        arabic_text: "لقد أحدث تطوير النماذج اللغوية الكبيرة ثورة في مجال أبحاث الذكاء الاصطناعي وتطبيقاته في مجالات متعددة، وخاصة في مجال التعليم.",
        gpt2: {
          english: {
            tokens: ["The", "development", "of", "large", "language", "models", "has", "revolution", "ized", "artificial", "intelligence", "research", "and", "applications", "across", "multiple", "domains", "especially", "education", "."],
            token_ids: [464, 2478, 286, 1588, 3303, 4981, 468, 5854, 1143, 11666, 4430, 2267, 290, 5479, 1973, 3294, 18209, 2592, 3707, 13],
            token_count: 20,
            delimited_text: "The|development|of|large|language|models|has|revolution|ized|artificial|intelligence|research|and|applications|across|multiple|domains|especially|education|."
          },
          arabic: {
            tokens: ["ÙĦ", "Ù", "Ĥ", "Ø¯", "Ø", "£", "Ø", "Ń", "Ø¯", "Ø", "«", "Ø", "ª", "Ø", "·", "ÙĪ", "ÙĬ", "Ø±", "Ø§ÙĦ", "ÙĨ", "Ùħ", "Ø§Ø", "°", "Ø", "¬", "Ø§ÙĦ", "ÙĦ", "Ø", "º", "ÙĪ", "ÙĬ", "Ø©", "Ø§ÙĦ", "Ù", "ĥ", "Ø¨", "ÙĬ", "Ø±", "Ø©", "Ø", "«", "ÙĪ", "Ø±", "Ø©", "Ù", "ģ", "ÙĬ", "Ùħ", "Ø", "¬", "Ø§ÙĦ", "Ø", "£", "Ø¨", "Ø", "Ń", "Ø§Ø", "«", "Ø§ÙĦ", "Ø", "°", "Ù", "ĥ", "Ø§Ø", "¡", "Ø§ÙĦ", "Ø§Ø", "µ", "Ø", "·", "ÙĨ", "Ø§Ø", "¹", "ÙĬ", "ÙĪ", "Øª", "Ø", "·", "Ø¨", "ÙĬ", "Ù", "Ĥ", "Ø§Ø", "ª", "Ùĩ", "Ù", "ģ", "ÙĬ", "Ùħ", "Ø", "¬", "Ø§ÙĦ", "Ø§Ø", "ª", "Ùħ", "Øª", "Ø¹", "Ø¯", "Ø¯", "Ø©", "Ø", "Į", "ÙĪ", "Ø", "®", "Ø§Ø", "µ", "Ø©", "Ù", "ģ", "ÙĬ", "Ùħ", "Ø", "¬", "Ø§ÙĦ", "Ø§ÙĦ", "Øª", "Ø¹", "ÙĦ", "ÙĬ", "Ùħ", "."],
            token_ids: [13862, 149, 224, 38843, 17550, 96, 148, 255, 38843, 148, 104, 17550, 103, 148, 115, 30335, 22654, 26897, 28981, 23338, 25405, 34247, 108, 148, 105, 28981, 13862, 148, 118, 30335, 22654, 45632, 28981, 149, 225, 39848, 22654, 26897, 45632, 17550, 104, 30335, 26897, 45632, 18923, 223, 22654, 47048, 148, 105, 23525, 17550, 96, 39848, 148, 255, 34247, 104, 28981, 148, 108, 149, 225, 34247, 94, 28981, 34247, 113, 148, 115, 23338, 34247, 117, 22654, 42092, 41486, 148, 115, 39848, 22654, 149, 224, 34247, 103, 29519, 18923, 223, 22654, 47048, 148, 105, 23525, 34247, 103, 47048, 41486, 44690, 38843, 38843, 45632, 148, 234, 42092, 148, 106, 34247, 113, 45632, 18923, 223, 22654, 47048, 148, 105, 23525, 28981, 41486, 44690, 13862, 22654, 25405, 13],
            token_count: 122,
            delimited_text: "ÙĦ|Ù|Ĥ|Ø¯|Ø|£|Ø|Ń|Ø¯|Ø|«|Ø|ª|Ø|·|ÙĪ|ÙĬ|Ø±|Ø§ÙĦ|ÙĨ|Ùħ|Ø§Ø|°|Ø|¬|Ø§ÙĦ|ÙĦ|Ø|º|ÙĪ|ÙĬ|Ø©|Ø§ÙĦ|Ù|ĥ|Ø¨|ÙĬ|Ø±|Ø©|Ø|«|ÙĪ|Ø±|Ø©|Ù|ģ|ÙĬ|Ùħ|Ø|¬|Ø§ÙĦ|Ø|£|Ø¨|Ø|Ń|Ø§Ø|«|Ø§ÙĦ|Ø|°|Ù|ĥ|Ø§Ø|¡|Ø§ÙĦ|Ø§Ø|µ|Ø|·|ÙĨ|Ø§Ø|¹|ÙĬ|ÙĪ|Øª|Ø|·|Ø¨|ÙĬ|Ù|Ĥ|Ø§Ø|ª|Ùĩ|Ù|ģ|ÙĬ|Ùħ|Ø|¬|Ø§ÙĦ|Ø§Ø|ª|Ùħ|Øª|Ø¹|Ø¯|Ø¯|Ø©|Ø|Į|ÙĪ|Ø|®|Ø§Ø|µ|Ø©|Ù|ģ|ÙĬ|Ùħ|Ø|¬|Ø§ÙĦ|Ø§ÙĦ|Øª|Ø¹|ÙĦ|ÙĬ|Ùħ|."
          }
        },
        gemma: {
          english: {
            tokens: ["The", "development", "of", "large", "language", "models", "has", "revolutionized", "artificial", "intelligence", "research", "and", "applications", "across", "multiple", "domains", "especially", "education", "."],
            token_ids: [818, 2913, 529, 2455, 5192, 4681, 815, 176839, 16477, 14020, 2958, 532, 6182, 3418, 5065, 26104, 4285, 4993, 236761],
            token_count: 19,
            delimited_text: "The|development|of|large|language|models|has|revolutionized|artificial|intelligence|research|and|applications|across|multiple|domains|especially|education|."
          },
          arabic: {
            tokens: ["لق", "د", "أ", "حدث", "تطوير", "الن", "ما", "ذج", "الل", "غ", "وية", "الك", "بيرة", "ث", "ورة", "في", "مجال", "أ", "بح", "اث", "الذ", "ك", "اء", "الاص", "ط", "نا", "عي", "وت", "ط", "بيقات", "ه", "في", "مج", "الات", "متعدد", "ة", "،", "وخ", "اص", "ة", "في", "مجال", "التعليم", "."],
            token_ids: [16659, 236897, 3506, 53963, 225742, 9602, 4697, 146343, 4753, 237334, 63704, 11420, 83373, 13292, 37930, 3170, 124198, 3506, 54694, 132498, 19337, 237005, 9751, 176504, 237076, 2932, 33210, 19065, 237076, 127065, 236910, 3170, 18263, 47481, 138367, 237049, 237108, 78471, 17009, 237049, 3170, 124198, 70948, 236761],
            token_count: 44,
            delimited_text: "لق|د|أ|حدث|تطوير|الن|ما|ذج|الل|غ|وية|الك|بيرة|ث|ورة|في|مجال|أ|بح|اث|الذ|ك|اء|الاص|ط|نا|عي|وت|ط|بيقات|ه|في|مج|الات|متعدد|ة|،|وخ|اص|ة|في|مجال|التعليم|."
          }
        }
      };

      // Create the interface
      container.innerHTML = `
        <div class="comparison-grid">
          <div class="tokenizer-section gpt2-section">
            <div class="tokenizer-header">
              <div class="tokenizer-title gpt2-title">GPT-2</div>
            </div>
            <div class="tokenizer-content">
            <div class="language-section">
              <div class="language-name">English</div>
              <div class="text-label">Text</div>
              <div class="sentence-text" id="gpt2EnglishText">${sampleData.english_text}</div>
              <div class="tokens-header">
                <div class="tokens-label">Tokens</div>
                <div class="token-count" id="gpt2EnglishTokenCount">20</div>
              </div>
              <div class="token-grid" id="gpt2EnglishTokens"></div>
              <div class="delimited-text" id="gpt2EnglishDelimited">${sampleData.gpt2.english.delimited_text}</div>
            </div>
            
            <div class="language-section">
              <div class="language-name">Arabic</div>
              <div class="text-label">Text</div>
              <div class="sentence-text arabic-text" id="gpt2ArabicText">${sampleData.arabic_text}</div>
              <div class="tokens-header">
                <div class="tokens-label">Tokens</div>
                <div class="token-count" id="gpt2ArabicTokenCount">122</div>
              </div>
              <div class="token-grid" id="gpt2ArabicTokens"></div>
              <div class="delimited-text arabic-text" id="gpt2ArabicDelimited">${sampleData.gpt2.arabic.delimited_text}</div>
            </div>
            </div>
          </div>
          
          <div class="tokenizer-section gemma-section">
            <div class="tokenizer-header">
              <div class="tokenizer-title gemma-title">Gemma</div>
            </div>
            <div class="tokenizer-content">
            <div class="language-section">
              <div class="language-name">English</div>
              <div class="text-label">Text</div>
              <div class="sentence-text" id="gemmaEnglishText">${sampleData.english_text}</div>
              <div class="tokens-header">
                <div class="tokens-label">Tokens</div>
                <div class="token-count" id="gemmaEnglishTokenCount">19</div>
              </div>
              <div class="token-grid" id="gemmaEnglishTokens"></div>
              <div class="delimited-text" id="gemmaEnglishDelimited">${sampleData.gemma.english.delimited_text}</div>
            </div>
            
            <div class="language-section">
              <div class="language-name">Arabic</div>
              <div class="text-label">Text</div>
              <div class="sentence-text arabic-text" id="gemmaArabicText">${sampleData.arabic_text}</div>
              <div class="tokens-header">
                <div class="tokens-label">Tokens</div>
                <div class="token-count" id="gemmaArabicTokenCount">44</div>
              </div>
              <div class="token-grid" id="gemmaArabicTokens"></div>
              <div class="delimited-text arabic-text" id="gemmaArabicDelimited">${sampleData.gemma.arabic.delimited_text}</div>
            </div>
            </div>
          </div>
        </div>
      `;

      // Cache for randomized palette
      let randomizedColors = null;

      function getRandomizedColors() {
        if (!randomizedColors) {
          const baseColors = window.ColorPalettes ? window.ColorPalettes.getColors('categorical', 20) : [
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57',
            '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43',
            '#10ac84', '#ee5a24', '#0984e3', '#6c5ce7', '#a29bfe',
            '#fd79a8', '#fdcb6e', '#e17055', '#74b9ff', '#00b894'
          ];

          // Fisher-Yates shuffle algorithm
          randomizedColors = [...baseColors];
          for (let i = randomizedColors.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [randomizedColors[i], randomizedColors[j]] = [randomizedColors[j], randomizedColors[i]];
          }
        }
        return randomizedColors;
      }

      function getTokenColor(index) {
        const colors = getRandomizedColors();
        return colors[index % colors.length];
      }

      function hasArabicChars(token) {
        const arabicChars = 'ابتثجحخدذرزسشصضطظعغفقكلمنهوي';
        return [...token].some(char => arabicChars.includes(char));
      }

      function generateTokensHTML(tokens, tokenIds, language) {
        return tokens.map((token, index) => {
          const color = getTokenColor(index);
          const isArabic = hasArabicChars(token);
          const borderStyle = isArabic ? '2px solid #27ae60' : '1px solid rgba(255,255,255,0.2)';
          return `
            <div class="token" style="background-color: ${color}; border: ${borderStyle};" 
                 title="Token: ${token} | ID: ${tokenIds[index]}">
              ${token}
              <div class="token-id">${tokenIds[index]}</div>
            </div>
          `;
        }).join('');
      }

      function updateVisualization(data) {
        // Update texts
        container.querySelector('#gpt2EnglishText').textContent = data.english_text;
        container.querySelector('#gpt2ArabicText').textContent = data.arabic_text;
        container.querySelector('#gemmaEnglishText').textContent = data.english_text;
        container.querySelector('#gemmaArabicText').textContent = data.arabic_text;

        // Update token counts
        container.querySelector('#gpt2EnglishTokenCount').textContent = data.gpt2.english.token_count;
        container.querySelector('#gpt2ArabicTokenCount').textContent = data.gpt2.arabic.token_count;
        container.querySelector('#gemmaEnglishTokenCount').textContent = data.gemma.english.token_count;
        container.querySelector('#gemmaArabicTokenCount').textContent = data.gemma.arabic.token_count;

        // Update token grids
        container.querySelector('#gpt2EnglishTokens').innerHTML = generateTokensHTML(data.gpt2.english.tokens, data.gpt2.english.token_ids, 'english');
        container.querySelector('#gpt2ArabicTokens').innerHTML = generateTokensHTML(data.gpt2.arabic.tokens, data.gpt2.arabic.token_ids, 'arabic');
        container.querySelector('#gemmaEnglishTokens').innerHTML = generateTokensHTML(data.gemma.english.tokens, data.gemma.english.token_ids, 'english');
        container.querySelector('#gemmaArabicTokens').innerHTML = generateTokensHTML(data.gemma.arabic.tokens, data.gemma.arabic.token_ids, 'arabic');

        // Update delimited texts
        container.querySelector('#gpt2EnglishDelimited').textContent = data.gpt2.english.delimited_text;
        container.querySelector('#gpt2ArabicDelimited').textContent = data.gpt2.arabic.delimited_text;
        container.querySelector('#gemmaEnglishDelimited').textContent = data.gemma.english.delimited_text;
        container.querySelector('#gemmaArabicDelimited').textContent = data.gemma.arabic.delimited_text;

      }

      // Load color palettes script if not already loaded
      if (!window.ColorPalettes) {
        const script = document.createElement('script');
        script.src = '/scripts/color-palettes.js';
        script.onload = () => {
          // Re-render with proper colors after palette script loads
          if (container && container.querySelector) {
            updateVisualization(sampleData);
          }
        };
        document.head.appendChild(script);
      }

      // Initialize with sample data
      updateVisualization(sampleData);
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
    } else {
      bootstrap();
    }
  })();
</script></div></div></figure> </div>
<p>While both tokenizers seem to perform similarly on English, the difference becomes striking for Arabic: GPT2 breaks the text into over a hundred fragments, while Gemma3 produces far fewer tokens thanks to its multilingual training data and larger, more inclusive vocabulary.</p>
<p>But to measure a tokenizer’s quality we can’t just eyeball a few tokenization examples and call it good, the same way we can’t make architecture changes based on intuition without running ablations. We need concrete metrics to evaluate tokenizer quality.</p>
<p><strong>Measuring Tokenizer Quality</strong></p>
<p>To evaluate how well a tokenizer performs, we can use two key metrics used in FineWeb2 <span class="" id="citation--fineweb2--81">(<a href="https://arxiv.org/abs/2506.20920" id="refctx-bib-fineweb2-1" data-ref-id="bib-fineweb2" target="_blank" rel="noopener noreferrer">Penedo et al., 2025</a>)</span>.</p>
<p><strong>Fertility:</strong></p>
<p>It measures the average number of tokens needed to encode a word. Lower fertility means better compression, which translates to faster training and inference. Think of it this way: if one tokenizer needs one or two more tokens to encode most words while another does it in less tokens, the second one is clearly more efficient.</p>
<p>The standard approach for measuring fertility is to calculate  <strong>words-to-tokens ratio</strong>  (word fertility), which measures how many tokens are needed per word on average. This metric is defined around the concept of words because it provides meaningful cross-linguistic comparisons when appropriate word tokenizers are available, for example in <a href="https://spacy.io/">Spacy</a> and <a href="https://stanfordnlp.github.io/stanza">Stanza</a> <span class="" id="citation--fineweb2--82">(<a href="https://arxiv.org/abs/2506.20920" id="refctx-bib-fineweb2-2" data-ref-id="bib-fineweb2" target="_blank" rel="noopener noreferrer">Penedo et al., 2025</a>)</span>.</p>
<p>When comparing tokenizers for a single language, you can also use the number of characters or bytes instead of words to get the characters-to-tokens ratio or bytes-to-tokens ratio <span class="" id="citation--dagan2024gettingtokenizerpretrainingdomain--83">(<a href="https://arxiv.org/abs/2402.01035" id="refctx-bib-dagan2024gettingtokenizerpretrainingdomain-2" data-ref-id="bib-dagan2024gettingtokenizerpretrainingdomain" target="_blank" rel="noopener noreferrer">Dagan et al., 2024</a>)</span>. However, these metrics have limitations for cross-linguistic comparison. Bytes can be skewed since characters in different scripts require different byte representations (e.g., Chinese characters use three bytes in UTF-8 while Latin characters use one to two). Similarly, using the number of characters doesn’t account for the fact that words vary dramatically in length across languages. For instance, Chinese words tend to be much shorter than German compound words.</p>
<p><strong>Proportion of continued words:</strong></p>
<p>This metric tells us what percentage of words get split into multiple pieces. Lower percentages are better since it means fewer words get fragmented, leading to more efficient tokenization.</p>
<p>Let’s implement these metrics:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> numpy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> np</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0"> compute_tokenizer_metrics</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(tokenizer, word_tokenizer, text):</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    Computes fertility and proportion of continued words.</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    Returns:</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        tuple: (fertility, proportion_continued_words)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">            - fertility: average tokens per word (lower is better)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">            - proportion_continued_words: percentage of words split into 2+ tokens (lower is better)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    words </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> word_tokenizer.word_tokenize(text)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    tokens </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> tokenizer.batch_encode_plus(words, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">add_special_tokens</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">False</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    tokens_per_word </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> np.array(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">list</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, tokens[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;input_ids&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">])))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    fertility </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> np.mean(tokens_per_word).item()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    proportion_continued_words </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (tokens_per_word </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">).sum() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(tokens_per_word)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> fertility, proportion_continued_words</span></span>
<span class="line"></span></code></pre></div>
<p>For specialized domains like code and math, though, besides fertility we need to dig deeper and look at how well the tokenizer handles domain-specific patterns. Most modern tokenizers do single-digit splitting (so “123” becomes [“1”, “2”, “3”]) <span class="" id="citation--palm--deepseekv2--84">(<a href="https://arxiv.org/abs/2204.02311" id="refctx-bib-palm-2" data-ref-id="bib-palm" target="_blank" rel="noopener noreferrer">Chowdhery et al., 2022</a>; <a href="https://arxiv.org/abs/2405.04434" id="refctx-bib-deepseekv2-1" data-ref-id="bib-deepseekv2" target="_blank" rel="noopener noreferrer">DeepSeek-AI et al., 2024</a>)</span>. It might seem counterintuitive to break numbers apart, but it actually helps models learn arithmetic patterns more effectively. If “342792” is encoded as one indivisible token, the model must memorize what happens when you add, subtract, or multiply that specific token with every other number token. But when it’s split, the model learns how digit-level operations work. Some tokenizers like Llama3 <span class="" id="citation--llama3--85">(<a href="https://arxiv.org/abs/2407.21783" id="refctx-bib-llama3-2" data-ref-id="bib-llama3" target="_blank" rel="noopener noreferrer">Grattafiori et al., 2024</a>)</span> encode numbers from 1 to 999 as unique tokens and the rest are composed of these tokens.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>For a deeper dive into how tokenization impacts arithmetic performance, <a href="https://huggingface.co/spaces/huggingface/number-tokenization-blog" target="_blank">From Digits to Decisions: How Tokenization Impacts Arithmetic in LLMs</a> compares different tokenization schemes on math tasks.</p> </aside> </div>  
<p>So we can measure fertility on our target domains to assess the weaknesses and strengths of a tokenizer. The table below compares fertility across popular tokenizers for different languages and domains.</p>
<p><strong>Evaluating tokenizers</strong></p>
<p>To compare tokenizers across different languages, we’ll use the setup from <a href="https://arxiv.org/abs/2506.20920">FineWeb2</a> tokenizer analysis, using Wikipedia articles as our evaluation corpus. For each language, we’ll sample 100 articles to get a meaningful sample while keeping computation manageable.</p>
<p>First, let’s install dependencies and define which tokenizers and languages we want to compare:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="bash"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">pip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> transformers</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> datasets</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> sentencepiece</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> &#39;datatrove[multilingual]&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## we need datatrove to load word tokenizers</span></span>
<span class="line"></span></code></pre></div>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">tokenizers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;Llama3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;meta-llama/Llama-3.2-1B&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;Gemma3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;google/gemma-3-1b-pt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;Mistral (S)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;mistralai/Mistral-Small-24B-Instruct-2501&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;Qwen3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;Qwen/Qwen3-4B&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">languages </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;English&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;eng_Latn&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;en&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;Chinese&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;cmn_Hani&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;zh&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;French&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;fra_Latn&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;fr&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;Arabic&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;arb_Arab&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;ar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">]</span></span>
<span class="line"></span></code></pre></div>
<p>Now let’s load our Wikipedia samples, we use streaming to avoid downloading entire datasets:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> datasets </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> load_dataset</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">wikis </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> lang_name, lang_code, short_lang_code </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> languages:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">	wiki_ds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> load_dataset(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;wikimedia/wikipedia&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;20231101.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">{</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">short_lang_code</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">}</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">streaming</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">split</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;train&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">	wiki_ds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> wiki_ds.shuffle(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">seed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">buffer_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">10_000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">	# Sample 100 articles per language</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  ds_iter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> iter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(wiki_ds)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  wikis[lang_code] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">.join([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(ds_iter)[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;text&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)])</span></span>
<span class="line"></span></code></pre></div>
<p>With our data ready, we can now evaluate each tokenizer on each language. For each combination, we load the appropriate word tokenizer from <a href="https://github.com/huggingface/datatrove">datatrove</a>  and compute both metrics:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> transformers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> AutoTokenizer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> datatrove.utils.word_tokenizers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> load_word_tokenizer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> pandas </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> pd</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">results </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">	</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> tokenizer_name, tokenizer_path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> tokenizers:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    tokenizer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> AutoTokenizer.from_pretrained(tokenizer_path, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">trust_remote_code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> lang_name, lang_code, short_lang_code </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> languages:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        word_tokenizer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> load_word_tokenizer(lang_code)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">        # Compute metrics on Wikipedia</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        fertility, pcw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> compute_tokenizer_metrics(tokenizer, word_tokenizer, wikis[lang_code])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        results.append({</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">            &quot;tokenizer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: tokenizer_name,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">            &quot;language&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: lang_name,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">            &quot;fertility&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: fertility,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">            &quot;pcw&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: pcw</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">df </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> pd.DataFrame(results)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(df)</span></span>
<span class="line"></span></code></pre></div>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="bash"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">      tokenizer</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    language</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  fertility</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">       pcw</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Llama3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     English</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.481715</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.322058</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Llama3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     Chinese</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.601615</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.425918</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Llama3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">      French</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.728040</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.482036</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Llama3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     Spanish</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.721480</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.463431</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">4</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Llama3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  Portuguese</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.865398</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.491938</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Llama3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     Italian</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.811955</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.541326</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">6</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Llama3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">      Arabic</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   2.349994</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.718284</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">7</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Gemma3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     English</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.412533</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.260423</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">8</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Gemma3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     Chinese</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.470705</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.330617</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">9</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Gemma3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">      French</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.562824</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.399101</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">       Gemma3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     Spanish</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.586070</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.407092</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">11</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">       Gemma3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  Portuguese</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.905458</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.460791</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">12</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">       Gemma3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     Italian</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.696459</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.484186</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">13</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">       Gemma3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">      Arabic</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   2.253702</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.700607</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">14</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  Mistral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (S)     English   1.590875  0.367867</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">15</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  Mistral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (S)     Chinese   1.782379  0.471219</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">16</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  Mistral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (S)      French   1.686307  0.465154</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">17</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  Mistral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (S)     Spanish   1.702656  0.456864</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">18</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  Mistral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (S)  Portuguese   2.013821  0.496445</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">19</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  Mistral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (S)     Italian   1.816314  0.534061</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">20</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  Mistral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> (S)      Arabic   2.148934  0.659853</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">21</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Qwen3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     English</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.543511</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.328073</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">22</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Qwen3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     Chinese</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.454369</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.307489</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">23</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Qwen3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">      French</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.749418</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.477866</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">24</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Qwen3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     Spanish</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.757938</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.468954</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">25</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Qwen3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  Portuguese</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   2.064296</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.500651</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">26</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Qwen3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">     Italian</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1.883456</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.549402</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">27</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        Qwen3</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">      Arabic</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   2.255253</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  0.660318</span></span>
<span class="line"></span></code></pre></div>
<p>The results reveal some winners and trade-offs depending on your priorities:</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-fdp98cfmhro"><!DOCTYPE html>
<html>

<head>
    <style>
        .tables-container {
            display: flex;
            gap: 20px;
            margin-top: 0px;
        }

        .table-wrapper {
            flex: 1;
        }

        table {
            width: 100%;
            background-color: var(--page-bg) !important;
            border: 1px solid var(--border-color);
            border-radius: 3px !important;
        }

        @media (max-width: 768px) {
            .tables-container {
                flex-direction: column;
                gap: 20px;
            }
        }

        .best-value {
            color: var(--success-color);
            font-weight: bold;
        }

        .worst-value {
            color: var(--danger-color);
            font-weight: bold;
        }

        .metric-title {
            margin: 0;

        }

        .subtitle {
            margin-bottom: 12px;
        }
    </style>
</head>

<body>

    <div class="tables-container">
        <div class="table-wrapper">
            <h5 class="metric-title">Fertility (tokens per word)</h5>
            <label class="subtitle">Lower is better</label>
            <table id="fertility-table"></table>
        </div>

        <div class="table-wrapper">
            <h5 class="metric-title">Proportion of Continued Words (%)</h5>
            <label class="subtitle">Lower is better</label>
            <table id="pcw-table"></table>
        </div>
    </div>

    <script>
        const data = [
            { tokenizer: "Llama3", language: "English", fertility: 1.481715, pcw: 0.322058 },
            { tokenizer: "Llama3", language: "Chinese", fertility: 1.601615, pcw: 0.425918 },
            { tokenizer: "Llama3", language: "French", fertility: 1.728040, pcw: 0.482036 },
            { tokenizer: "Llama3", language: "Arabic", fertility: 2.349994, pcw: 0.718284 },
            { tokenizer: "Gemma3", language: "English", fertility: 1.412533, pcw: 0.260423 },
            { tokenizer: "Gemma3", language: "Chinese", fertility: 1.470705, pcw: 0.330617 },
            { tokenizer: "Gemma3", language: "French", fertility: 1.562824, pcw: 0.399101 },
            { tokenizer: "Gemma3", language: "Arabic", fertility: 2.253702, pcw: 0.700607 },
            { tokenizer: "Mistral Small", language: "English", fertility: 1.590875, pcw: 0.367867 },
            { tokenizer: "Mistral Small", language: "Chinese", fertility: 1.782379, pcw: 0.471219 },
            { tokenizer: "Mistral Small", language: "French", fertility: 1.686307, pcw: 0.465154 },
            { tokenizer: "Mistral Small", language: "Arabic", fertility: 2.148934, pcw: 0.659853 },
            { tokenizer: "Qwen3", language: "English", fertility: 1.543511, pcw: 0.328073 },
            { tokenizer: "Qwen3", language: "Chinese", fertility: 1.454369, pcw: 0.307489 },
            { tokenizer: "Qwen3", language: "French", fertility: 1.749418, pcw: 0.477866 },
            { tokenizer: "Qwen3", language: "Arabic", fertility: 2.255253, pcw: 0.660318 }
        ];

        const vocabSizes = {
            "Llama3": "128k",
            "Gemma3": "262k",
            "Mistral Small": "131k",
            "Qwen3": "151k"
        };

        const tokenizers = ["Llama3", "Mistral Small", "Qwen3", "Gemma3"];
        const languages = ["English", "Chinese", "French", "Arabic"];

        function createTable(tableId, metric) {
            const table = document.getElementById(tableId);

            // Create header
            let headerHTML = '<thead><tr><th>Tokenizer (Vocab Size)</th>';
            languages.forEach(lang => {
                headerHTML += `<th>${lang}</th>`;
            });
            headerHTML += '</tr></thead><tbody>';

            // Create rows
            tokenizers.forEach(tok => {
                headerHTML += `<tr><td>${tok} <span class="vocab-size">(${vocabSizes[tok]})</span></td>`;

                languages.forEach(lang => {
                    const item = data.find(d => d.language === lang && d.tokenizer === tok);
                    const value = item ? item[metric] : null;

                    if (value !== null) {
                        // Find min and max values for this language
                        const langValues = tokenizers.map(t => {
                            const i = data.find(d => d.language === lang && d.tokenizer === t);
                            return i ? i[metric] : Infinity;
                        });
                        const minValue = Math.min(...langValues);
                        const maxValue = Math.max(...langValues);

                        const isBest = value === minValue;
                        const isWorst = value === maxValue;

                        const displayValue = metric === 'pcw'
                            ? (value * 100).toFixed(1) + '%'
                            : value.toFixed(2);

                        let cellClass = '';
                        if (isBest) cellClass = 'best-value';
                        else if (isWorst) cellClass = 'worst-value';

                        headerHTML += `<td class="${cellClass}">${displayValue}</td>`;
                    } else {
                        headerHTML += '<td>—</td>';
                    }
                });

                headerHTML += '</tr>';
            });

            headerHTML += '</tbody>';
            table.innerHTML = headerHTML;
        }

        createTable('fertility-table', 'fertility');
        createTable('pcw-table', 'pcw');
    </script>

</body>

</html></div></div></figure> </div>
<p>Gemma3 tokenizer achieves low fertilities and word-splitting rates across multiple languages, notably on English, French, and Spanish, which can be explained by its tokenizer training data and very large vocabulary size of 262k, roughly 2x larger than Llama3’s 128k. Qwen3 tokenizer excels on Chinese, but falls behind Llama3’s tokenizer on English, French and Spanish. Mistral Small’s tokenizer <span class="" id="citation--mistralsmall--86">(<a href="https://mistral.ai/news/mistral-small-3-1" id="refctx-bib-mistralsmall-1" data-ref-id="bib-mistralsmall" target="_blank" rel="noopener noreferrer">Mistral AI, 2025</a>)</span> performs best on Arabic but falls short of the other tokenizers on English and Chinese.</p>
<p><strong>Choosing Between Existing and Custom Tokenizers</strong></p>
<p>Currently, there’s a good selection of strong tokenizers available. Many recent models start with something like GPT4’s tokenizer <span class="" id="citation--gpt4--87">(<a href="https://arxiv.org/abs/2303.08774" id="refctx-bib-gpt4-1" data-ref-id="bib-gpt4" target="_blank" rel="noopener noreferrer">OpenAI et al., 2024</a>)</span> and augment it with additional multilingual tokens. As we can see in the table above, Llama 3’s tokenizer performs well on average across multilingual text and code, while Qwen 2.5 excels particularly on Chinese and some low-resource languages.</p>
<ul>
<li><strong>When to use existing tokenizers:</strong>  If our target use case matches the language or domain coverage of the best tokenizers above (Llama, Qwen, Gemma), then they are solid choices that were battle-tested. For SmolLM3 training we chose Llama3’s tokenizer: it offers competitive tokenization quality on our target languages (English, French, Spanish, Portuguese, Italian)  with a modest vocabulary size that made sense for our small model size. For larger models where embeddings are a smaller fraction of total parameters, Gemma3’s efficiency gains become more attractive.</li>
<li><strong>When to train our own:</strong>  If we’re training for low-resource languages or have a very different data mixture, we’ll likely need to train our own tokenizer to ensure good coverage.  In which case it’s important that we train the tokenizer on a dataset close to what we believe the final training mixture will look like. This creates a bit of a chicken-and-egg problem since we need a tokenizer to run data ablations and find the mixture. But we can retrain the tokenizer before launching the final run and verify that downstream performance improves and fertilities are still good.</li>
</ul>
<p>Your tokenizer choice might seem like a technical detail, but it ripples through every aspect of your model’s performance. So don’t be afraid to invest time in getting it right.</p>
<h4 id="smollm3"><a href="#smollm3">SmolLM3</a></h4>
<p>Now that we’ve explored the architectural landscape and run our systematic ablations, let’s see how this all comes together in practice for a model like SmolLM3.</p>
<p>The SmolLM family is about pushing the boundaries of what’s possible with small models. SmolLM2 delivered three capable models at 135M, 360M, and 1.7B parameters, all designed to run efficiently on-device. For SmolLM3, we wanted to scale up performance while staying small enough for phones, and tackle SmolLM2’s weak spots: multilinguality, very long context handling, and strong reasoning capabilities. We chose 3B parameters as the sweet spot for this balance.</p>
<p>Since we were scaling up a proven recipe, we naturally gravitated toward dense transformers. MoE wasn’t implemented in nanotron yet, and we already had the expertise and infrastructure for training strong small dense models. More importantly, for edge device deployment we’re memory-bound, an MoE with many parameters even if only a few are active would be limiting since we still need to load all experts into memory, making dense models more practical for our edge deployment targets.</p>
<p><strong>Ablations:</strong> We started with SmolLM2 1.7B’s architecture as our foundation, then trained a 3B ablation model on 100B tokens using Qwen2.5-3B layout. This gave us a solid baseline to test each modification individually. Each architecture change needed to either improve the loss and downstream performance on English benchmarks or provide measurable benefits like inference speed without quality degradation.</p>
<p>Here’s what we tested before launching the run that made the cut:</p>
<p><strong>Tokenizer:</strong>  Before diving into architecture modifications, we needed to choose a tokenizer. We found a good set of tokenizers that covered our target languages and domains. Based on our fertility analysis, Llama3.2’s tokenizer gave us the best tradeoff between our 6 target languages while keeping the vocabulary at 128k, large enough for multilingual efficiency but not so large that it bloated our 3B parameter count with embedding weights.</p>
<p><strong>Grouped Query Attention (GQA)</strong> : We reconfirmed our earlier finding that GQA with 4 groups matches Multi-Head Attention performance, but this time at 3B scale with 100B tokens. The KV cache efficiency gains were too good to pass up, especially for on-device deployment where memory is precious.</p>
<p><strong>NoPE for long context</strong> : We implemented NoPE, by removing RoPE every 4th layer. Our 3B ablation confirmed the findings in the section above. NoPE improved long context handling without sacrificing short context performance.</p>
<p><strong>Intra-document attention masking</strong> : We prevent cross-document attention during training to help with training speed and stability when training on very large sequences, again we find that this doesn’t impact downstream performance.</p>
<p><strong>Model layout optimization</strong> : We compared layouts from recent 3B models in the literature, some prioritizing depth, others width. We tested Qwen2.5-3B (3.1B), Llama3.2-3B (3.2B), and Falcon3-H1-3B (3.1B) layouts on our training setup, where depth and width varied. The results were interesting: all layouts achieved nearly identical loss and downstream performance, despite Qwen2.5-3B actually having fewer parameters. But Qwen2.5-3B’s deeper architecture aligned with research showing that network depth benefits generalization <span class="" id="citation--petty2024impactdepthcompositionalgeneralization--88">(<a href="https://arxiv.org/abs/2310.19956" id="refctx-bib-petty2024impactdepthcompositionalgeneralization-1" data-ref-id="bib-petty2024impactdepthcompositionalgeneralization" target="_blank" rel="noopener noreferrer">Petty et al., 2024</a>)</span>. Therefore, we went with the deeper layout, betting it would help as training progressed.</p>
<p><strong>Stability improvements</strong> : We kept tied embeddings from SmolLM2 but added a new trick inspired by OLMo2, removing weight decay from embeddings. Our ablations showed this didn’t hurt performance while lowering embedding norms, which can help for preventing training divergence.</p>
<p>The beauty of this systematic ablations approach is that we could confidently combine all these modifications, knowing each had been validated.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>💡</span> <div class="note__title" data-astro-cid-qg6lmfty>Combining changes in ablations</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>In practice we test changes incrementally: once a feature was validated, it became part of the baseline for testing the next feature. Testing order matters: start with the battle-tested features first (tie embeddings → GQA → document masking → NoPE → remove weight decay).</p> </div> </div> </div> 
<h4 id="rules-of-engagement-1"><a href="#rules-of-engagement-1">Rules of engagement</a></h4>
<blockquote class="quote" data-astro-cid-arj5dyob> <div class="quote__text" data-astro-cid-arj5dyob> <p>TL;DR: Your use case drives your choices.</p> </div>  </blockquote> 
<p><strong>Let your deployment target guide architectural decisions.</strong>  Consider how and where your model will actually run when evaluating new architectural innovations.</p>
<p><strong>Strike the right balance between innovation and pragmatism.</strong>  We can’t afford to ignore major architectural advances - using Multi-Head Attention today when GQA and better alternatives exist would be a poor technical choice. Stay informed about the latest research and adopt techniques that offer clear, validated benefits at scale. But resist the temptation to chase every new paper that promises marginal gains (unless you have the resources to do so or your goal is architecture research).</p>
<p><strong>Systematic beats intuitive.</strong>  Validate every architecture change, no matter how promising it looks on paper. Then test modifications individually before combining them to understand their impact.</p>
<p><strong>Scale effects are real - re-ablate at target size when possible.</strong>  Don’t assume your small-scale ablations will hold perfectly at your target model size. If you have the compute, try to reconfirm them.</p>
<p><strong>Validate tokenizer efficiency on your actual domains.</strong>  Fertility metrics across your target languages and domains matter more than following what the latest model used. A 50k English tokenizer won’t cut it for serious multilingual work, but you don’t need a 256k vocab if you’re not covering that many languages either.</p>
<p>Now that the model architecture is now decided, it’s time to tackle the optimizer and hyperparameters that will drive the learning process.</p>
<h3 id="optimiser-and-training-hyperparameters"><a href="#optimiser-and-training-hyperparameters">Optimiser and training hyperparameters</a></h3>
<p>The pieces are coming into place. We’ve run our ablations, settled on the architecture, and chosen a tokenizer. But before we can actually launch the training, there are still some crucial missing pieces: which optimizer should we use? What learning rate and batch size? How should we schedule the learning rate over training?</p>
<p>The tempting approach here is to just borrow values from another strong model in the literature. After all, if it worked for big labs, it should work for us, right? And for many cases that will work just fine if we’re taking values from a similar architecture and model size.</p>
<p>However, we risk leaving performance on the table by not tuning these values for our specific setup. Literature hyperparameters were optimized for specific data and constraints, and sometimes those constraints aren’t even about performance. Maybe that learning rate was picked early in development and never revisited. Even when model authors do thorough hyperparameter sweeps, those optimal values were found for their exact combination of architecture, data, and training regime, not ours. Literature values are always a good starting point, but it’s a good idea to explore if we can find better values in the neighbourhood.</p>
<p>In this chapter, we’ll explore the latest optimizers (and see if trusty old AdamW <span class="" id="citation--kingma2014adam--89">(<a href="#bib-kingma2014adam" id="refctx-bib-kingma2014adam-1">Kingma, 2014</a>)</span> still stands the <a href="https://blog.iclr.cc/2025/04/14/announcing-the-test-of-time-award-winners-from-iclr-2015/">test of time</a> 🎉), dive into learning rate schedules that go beyond the standard cosine decay and figure out how to tune the learning rate and batch size given a model and data size.</p>
<p>Let’s start with the the optimizer wars.</p>
<h4 id="optimizers-adamw-and-beyond"><a href="#optimizers-adamw-and-beyond">Optimizers: AdamW and beyond</a></h4>
<p>The optimizer is at the heart of the whole LLM training operation. It decides for every parameter what the actual update step will be based on the past updates, the current weights and the gradients derived from the loss. At the same time it is also a <a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook?section=profiling_the_memory_usage">memory and compute hungry beast</a> and thus can impact how many GPUs you need and how fast your training is.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>If you’re uncertain what an optimizer is and what it’s useful for, check Ruder’s <a href="https://www.ruder.io/optimizing-gradient-descent/">blog on Gradient Descent and optimizers</a>, which notably compares cool optimizers</p> </aside> </div>  
<p>We didn’t spare any efforts to summarize the current landscape of optimizers used for LLM pretraining:</p>

















<div class="table-scroll"><table><thead><tr><th>Model</th><th>Optimizer</th></tr></thead><tbody><tr><td>Kimi K2, GLM 4.5</td><td>Muon</td></tr><tr><td>Everyone else</td><td>AdamW</td></tr></tbody></table></div>
<p>So, you might wonder why everyone is using AdamW?</p>
<p>The person writing this part of the blog post thinks it’s because “people are lazy” (hi, it’s <a href="https://x.com/eliebakouch">Elie</a>), but others might more realistically say that AdamW has been working well/better at different scales for a long time, and it’s always a bit scary to change such a core component especially if it’s hard (ie expensive) to test how well it does in very long trainings.</p>
<p>Moreover, comparing optimizers fairly is harder than it looks. Scale changes the dynamics in ways that can be hard to simulate in small ablations, so hyperparameter tuning is complex. You could say:  <em>“it’s ok, I’ve tuned my AdamW for weeks, I can just reuse the same hyperparameters to compare!”</em>  and we wish so much this would be true. But unfortunately, for each optimizer, you need to do proper hyperparameter search (1D? 2D? 3D?), which makes optimizer research hard and costly.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Often, the baseline is not tuned very well, so new optimizers are compared against a weak AdamW settings. A recent study <span class="" id="citation--wen2025fantasticpretrainingoptimizers--90">(<a href="https://arxiv.org/abs/2509.02046" id="refctx-bib-wen2025fantasticpretrainingoptimizers-1" data-ref-id="bib-wen2025fantasticpretrainingoptimizers" target="_blank" rel="noopener noreferrer">Wen et al., 2025</a>)</span> shows how much that alone skews reported gains.</p> </aside> </div>  
<p>So let’s start with the classic and the foundation of Durk Kingma’s scary <a href="https://scholar.google.com/citations?user=yyIoQu4AAAAJ&hl=en">Google scholar </a>domination: AdamW.</p>
<p><strong>AdamW</strong></p>
<p>Adam (Adaptive Momentum Estimation) is a first order optimization technique. It means that in addition to looking at the gradients alone, we also consider how much the weights changed in the previous steps. This makes the learning rate for each parameter adapt based on the momentum.</p>
<p>The careful reader might wonder: hey there, aren’t you missing a W? Indeed! The reason we specifically add the W (=weight decay) is the following. In standard SGD we can simply add a  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><msup><mi>θ</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\lambda \theta^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>  (where  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span></span></span></span>  are the weights) to the loss to apply L2 regularization. However, if we do the same with Adam, the adaptive learning rate will also affect the L2 regularization. This means the regularization strength becomes dependent on gradient magnitudes, weakening its effect. This is not what we want and that’s why AdamW applies it decoupled from the main optimization loop to fix this.</p>
<p>Interestingly, across the last few years the AdamW hyperparameters have barely moved:</p>
<ul>
<li>β₁ = 0.9, β₂ = 0.95</li>
<li>grad norm clipping = 1.0</li>
<li>weight decay = 0.1 (Llama-3-405B drops this to 0.01)</li>
</ul>
<p>The same triplet is almost reused from Llama 1,2,3 to DeepSeek-V1,2,3 671B, no change. Was Durk Kingma right all along or can we do better?</p>
<p><strong>Muon in one line</strong></p>
<p>Adam is a first-order methods, as it is only uses the gradients. Muon is a second-order optimizer that acts on the  <em>matrix</em>  view of a parameter tensor.</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>G</mi><mi>t</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi mathvariant="normal">∇</mi><mi>θ</mi></msub><msub><mi mathvariant="script">L</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msub><mi>θ</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>B</mi><mi>t</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>μ</mi><mtext> </mtext><msub><mi>B</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>G</mi><mi>t</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>O</mi><mi>t</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mi mathvariant="normal">N</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">S</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">z</mi><mn>5</mn></mrow><mo stretchy="false">(</mo><msub><mi>B</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mtext> </mtext><mo>≈</mo><mtext> </mtext><mi>U</mi><msup><mi>V</mi><mi mathvariant="normal">⊤</mi></msup><mspace width="1em"></mspace><mtext>if </mtext><msub><mi>B</mi><mi>t</mi></msub><mo>=</mo><mi>U</mi><mi mathvariant="normal">Σ</mi><msup><mi>V</mi><mi mathvariant="normal">⊤</mi></msup><mtext> (SVD)</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>θ</mi><mi>t</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>θ</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>η</mi><mtext> </mtext><msub><mi>O</mi><mi>t</mi></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
G_t &amp;= \nabla_{\theta}\mathcal{L}_t(\theta_{t-1}) \\
B_t &amp;= \mu\, B_{t-1} + G_t \\
O_t &amp;= \mathrm{NewtonSchulz5}(B_t) \ \approx\ U V^\top \quad \text{if } B_t = U\Sigma V^\top \text{ (SVD)} \\
\theta_t &amp;= \theta_{t-1} - \eta\, O_t
\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.0591em;vertical-align:-2.7796em"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2796em"><span style="top:-5.4396em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span><span style="top:-3.9396em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.3804em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span><span style="top:-0.8804em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7796em"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2796em"><span style="top:-5.4396em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord"><span class="mord">∇</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathcal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.9396em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.3804em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord"><span class="mord mathrm">NewtonSchulz5</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≈</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em"></span><span class="mord text"><span class="mord">if </span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="mord">Σ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> (SVD)</span></span></span></span><span style="top:-0.8804em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord mathnormal" style="margin-right:0.03588em">η</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7796em"><span></span></span></span></span></span></span></span></span></span></span></span>
<p>Looking at these equations you might wonder why is this a second order method, I only see gradients and no higher oder terms. The second order optimization actually happens inside the Newton Schulz step, but we won’t go into further details here. There are already high-quality blogs that explain Muon in depth, so here we’ll just list the three key ideas of Muon:</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>To learn more about Muon, we recommend checking out this <a href="https://kellerjordan.github.io/posts/muon/">blog</a> by Keller Jordan,  this <a href="https://jeremybernste.in/writing/deriving-muon">one</a> by Jeremy Bernstein and this <a href="https://www.youtube.com/watch?v=bO5nvE289ec">video</a> by Jia-Bin Huang which is a great starting point.</p> </aside> </div>  
<ol>
<li><strong>Matrix-wise geometry vs. parameter-wise updates:</strong> AdamW preconditions  <em>per parameter</em>  (diagonal second moment). Muon treats each weight  <strong>matrix</strong>  as a single object and updates along  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mi>U</mi><msup><mi>V</mi><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">G=UV^{\top}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span></span> , which captures row/column subspace structure.</li>
<li><strong>Isotropic steps via orthogonalization:</strong> Decomposing  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mi>U</mi><mi mathvariant="normal">Σ</mi><msup><mi>V</mi><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">G=U\Sigma V^{\top}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="mord">Σ</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span></span>   with singular value decomposition (SVD) separates magnitude ( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Σ</span></span></span></span> ) from directions (the left/right subspaces  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo separator="true">,</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">U,V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.22222em">V</span></span></span></span>  ). Replacing  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">G</span></span></span></span>  by  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><msup><mi>V</mi><mi mathvariant="normal">⊤</mi></msup></mrow><annotation encoding="application/x-tex">UV^{\top}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em"></span><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span></span></span></span></span>  discards singular values and makes the step  <em>isotropic</em>  in the active subspaces. It’s a bit counterintuitive at first—since throwing away  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Σ</span></span></span></span>  looks like losing information—but it reduces axis-aligned bias and encourages exploration of directions that would otherwise be suppressed by very small singular values. There’s still an open question on whether this kind of exploration bakes different capabilities into the model that aren’t obvious if you only look at the loss.</li>
<li><strong>Empirical tolerance to larger batch sizes:</strong> In practice, Muon often tolerates higher batch sizes. We’ll talk about this more in depth in the batch size section, but this might be a key point of Muon adoption!</li>
</ol>
<p>For years, the community mostly settled on AdamW and the optimizer recipes of frontier labs are often kept secret (Qwen doesn’t talk about theirs, for instance), but recently Muon has seen uptake in high-profile releases (e.g., Kimi K2, GLM-4.5). Hopefully we’ll see more open and robust recipes to use</p>
<p>There is a wild zoo of optimizers and the only thing researchers are more creative at than combining all possible momentums and derivates is coming up with names for them: Shampoo, SOAP, PSGD, CASPR, DION, Sophia, Lion… even AdamW has its own variants like NAdamW, StableAdamW, etc. Diving into all these optimizers would be worth its own blog, but we’ll keep that for another time. In the meantime, we recommend this amazing paper by the stanford/marin team <span class="" id="citation--wen2025fantasticpretrainingoptimizers--91">(<a href="https://arxiv.org/abs/2509.02046" id="refctx-bib-wen2025fantasticpretrainingoptimizers-2" data-ref-id="bib-wen2025fantasticpretrainingoptimizers" target="_blank" rel="noopener noreferrer">Wen et al., 2025</a>)</span> who benchmarked many different optimizer to show how important hyperparemeter tuning is when doing comparisons.</p>
<p>Hand in hand with almost every optimizer is the question on how strongly we should update the weights determined by the learning rate which typically appears as a scalar value in the optimizer equations. Let’s have a look how this seemingly simple topic still has many facets to it.</p>
<h4 id="learning-rate"><a href="#learning-rate">Learning Rate</a></h4>
<p>The learning rate is one of the most important hyperparameters we’ll have to set. At each training step, it controls how much we adjust our model weights based on the computed gradients. Choosing a learning rate too low and our training gets painfully slow and we can get trapped in a bad local minima. The loss curves will look flat, and we’ll burn through our compute budget without making meaningful progress. On the other hand if we set the learning rate too high we cause the optimizer to take massive steps that overshoot optimal solutions and never converge or, the unimaginable happens, the loss diverges and the loss shoots to the moon.</p>
<p>But the best learning rate isn’t even constant since the learning dynamics change during training. High learning rates work early when we’re far from good solutions, but cause instability near convergence. This is where learning rate schedules come in: warmup from zero to avoid early chaos, then decay to settle into a good minimum. These patterns (warmup + cosine decay, for example) have been validated for neural networks training for many years.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>💡</span> <div class="note__title" data-astro-cid-qg6lmfty>Warmup steps</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Most modern LLMs use a fixed number of warmup steps (for example 2000) regardless of model size and length of training, as shown in <a href="#llms-landscape-pretrain">Table 1</a>. We’ve found that for long trainings, increasing the number of warmup steps doens’t have an impact on performance, but for very short trainings people usually use 1% to 5% of training steps.</p> </div> </div> </div> 
<p>Let’s look at the common schedules, then discuss how to pick the peak value.</p>
<p><strong>Learning Rate Schedules: Beyond Cosine Decay</strong></p>
<p>It has been known for years that changing the learning rate helps convergence <span class="" id="citation--smith2018superconvergencefasttrainingneural--92">(<a href="https://arxiv.org/abs/1708.07120" id="refctx-bib-smith2018superconvergencefasttrainingneural-1" data-ref-id="bib-smith2018superconvergencefasttrainingneural" target="_blank" rel="noopener noreferrer">Smith &amp; Topin, 2018</a>)</span> and the cosine decay <span class="" id="citation--loshchilov2017sgdrstochasticgradientdescent--93">(<a href="https://arxiv.org/abs/1608.03983" id="refctx-bib-loshchilov2017sgdrstochasticgradientdescent-1" data-ref-id="bib-loshchilov2017sgdrstochasticgradientdescent" target="_blank" rel="noopener noreferrer">Loshchilov &amp; Hutter, 2017</a>)</span> was the go-to schedule for training LLMs: start at a peak learning rate after warmup, then smoothly decrease following a cosine curve. It’s simple and works well. But its main disadvantage is inflexibility; we need to know our total training steps upfront, as the cosine cycle length must match your total training duration. This becomes a problem in common scenarios: your model hasn’t plateaued yet or you get access to more compute and want to train longer, or you’re running scaling laws and need to train the same model on different token counts.  Cosine decay forces you to restart from scratch.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Interestingly, this inflexibility skewed early scaling laws research <span class="" id="citation--kaplan2020scalinglawsneurallanguage--94">(<a href="https://arxiv.org/abs/2001.08361" id="refctx-bib-kaplan2020scalinglawsneurallanguage-1" data-ref-id="bib-kaplan2020scalinglawsneurallanguage" target="_blank" rel="noopener noreferrer">Kaplan et al., 2020</a>)</span>, because they used a fixed cosine schedule length when training models on varying token counts, underestimating the impact of data size. The Chinchilla study <span class="" id="citation--hoffmann2022trainingcomputeoptimallargelanguage--95">(<a href="https://arxiv.org/abs/2203.15556" id="refctx-bib-hoffmann2022trainingcomputeoptimallargelanguage-1" data-ref-id="bib-hoffmann2022trainingcomputeoptimallargelanguage" target="_blank" rel="noopener noreferrer">Hoffmann et al., 2022</a>)</span> corrected this and matched the schedule length to each model’s actual training duration.</p> </aside> </div>  
<p>Many teams now use schedules where you don’t need to start decaying immediately after warmup. This is the case for  <strong>Warmup-Stable-Decay (</strong> WSD) <span class="" id="citation--hu2024minicpmunveilingpotentialsmall--96">(<a href="https://arxiv.org/abs/2404.06395" id="refctx-bib-hu2024minicpmunveilingpotentialsmall-1" data-ref-id="bib-hu2024minicpmunveilingpotentialsmall" target="_blank" rel="noopener noreferrer">Hu et al., 2024</a>)</span> and  <strong>Multi-Step</strong>  <span class="" id="citation--deepseekai2024deepseekllmscalingopensource--97">(<a href="https://arxiv.org/abs/2401.02954" id="refctx-bib-deepseekai2024deepseekllmscalingopensource-1" data-ref-id="bib-deepseekai2024deepseekllmscalingopensource" target="_blank" rel="noopener noreferrer">DeepSeek-AI, :, et al., 2024</a>)</span> variants shown in the plot below. You maintain a constant high learning rate for most of training, and either sharply decay in the final phase (typically the last 10-20% of tokens) for WSD, or do discrete drops (steps) to decrease the learning rate, for example after 80% of training and then after 90% as it was done in <a href="https://arxiv.org/abs/2401.02954">DeepSeek LLM</a>’s Multi-Step schedule.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-u8wq5mytz6k" data-config="{&#34;dataUrl&#34;:&#34;./data/learning_rate_schedules.csv&#34;,&#34;xColumn&#34;:&#34;steps&#34;,&#34;yColumn&#34;:&#34;learning_rate&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;xScaleType&#34;:&#34;linear&#34;,&#34;yScaleType&#34;:&#34;linear&#34;,&#34;xAxisLabel&#34;:&#34;Step&#34;,&#34;yAxisLabel&#34;:&#34;Learning Rate&#34;,&#34;title&#34;:&#34;Learning Rate Schedules&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<p>These schedules offer practical advantages over cosine decay. We can extend training mid-run without restarting, whether we want to train longer than initially planned, are decay early to get a more measure of training progress and we can run scaling law experiments across different token counts with one main training run. Moreover, studies show that both WSD and Multi-Step match cosine decay <span class="" id="citation--deepseekai2024deepseekllmscalingopensource--98">(<a href="https://arxiv.org/abs/2401.02954" id="refctx-bib-deepseekai2024deepseekllmscalingopensource-2" data-ref-id="bib-deepseekai2024deepseekllmscalingopensource" target="_blank" rel="noopener noreferrer">@hägele2024scalinglawscomputeoptimaltraining, DeepSeek-AI, :, et al., 2024</a>)</span> while being more practical for real-world training scenarios.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>recently GLM 4.5 mentions that WSD perform worse on general benchmarks (SimpleQA, MMLU), but they don’t provide any results.</p> </aside> </div>  
<p>But you probably noticed that these schedules introduce new hyperparameters compared to cosine: How long should the decay phase last in WSD? And how long should each step be in the Multi-Step variant?</p>
<ul>
<li>For WSD:   The required cooldown duration to match cosine performance decreases with longer training runs, and it is recommended to allocate 10-20% of total tokens to the decay phase <span class="" id="citation--hägele2024scalinglawscomputeoptimaltraining--99">(<a href="https://arxiv.org/abs/2405.18392" id="refctx-bib-hägele2024scalinglawscomputeoptimaltraining-1" data-ref-id="bib-hägele2024scalinglawscomputeoptimaltraining" target="_blank" rel="noopener noreferrer">Hägele et al., 2024</a>)</span>. We will confirm this setup matches cosine in our ablations below.</li>
<li>For Multi-Step: DeepSeek LLM’s ablations found that while their baseline 80/10/10 split (stable until 80%, first step from 80-90%, second step from 90-100%) matches cosine, tweaking these proportions can even outperform it, for instance when using 70/15/15 and 60/20/20 splits.</li>
</ul>
<p>But we can get even more creative with these schedules. Let’s look at the schedules used in each family of the DeepSeek models:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-ds8gj8risbu" data-config="{&#34;dataUrl&#34;:&#34;./data/deepseek_schedules.csv&#34;,&#34;xColumn&#34;:&#34;steps&#34;,&#34;yColumn&#34;:&#34;learning_rate&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;xScaleType&#34;:&#34;linear&#34;,&#34;yScaleType&#34;:&#34;linear&#34;,&#34;xAxisLabel&#34;:&#34;Step&#34;,&#34;yAxisLabel&#34;:&#34;Learning Rate (×10⁻⁴)&#34;,&#34;title&#34;:&#34;DeepSeek Multi-Step Learning Rate Schedules Comparison&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<p>DeepSeek LLM used the baseline Multi-Step schedule (80/10/10). <a href="https://arxiv.org/abs/2405.04434">DeepSeek V2</a> adjusted the proportions to 60/30/10, giving more time to the first decay step. <a href="https://arxiv.org/abs/2412.19437">DeepSeek V3</a> took the most creative approach:  instead of maintaining a constant learning rate followed by two sharp steps, they transition from the constant phase with a cosine decay (from 67% to 97% of training), then apply a brief constant phase before the final sharp step.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty>  <div class="note__title" data-astro-cid-qg6lmfty>DeepSeek Schedules Change</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>DeepSeek-V2 and V3’s technical reports don’t include ablations on these schedule changes. For your setup, start with simple WSD or Multi-Step schedules, then consider tuning the parameters through ablations.</p> </div> </div> </div> 
<p>Let’s stop our survey of exotic learning rate schedules here and burn some GPU hours to determine what works in practice!</p>
<p><strong>Ablation - WSD matches Cosine</strong></p>
<p>Now it’s time for an ablation! Let’s test whether WSD actually matches cosine’s performance in practice. We won’t show Multi-Step ablations here but we recommend DeepSeek LLM’s ablations where they showed that Multi-Step matches cosine with different phase splits. In this section, we’ll compare cosine decay against WSD with two decay windows: 10% and 20%.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-xsqx7ivkvo8" data-config="{&#34;dataUrl&#34;:&#34;./data/wsd_loss.csv&#34;,&#34;xDomain&#34;:[0,46000000000],&#34;yDomain&#34;:[2.1,2.7],&#34;smoothing&#34;:true,&#34;title&#34;:&#34;WSD Loss&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-tunchr5ff3k" data-config="{&#34;dataUrl&#34;:&#34;./data/wsd_evals.csv&#34;,&#34;charts&#34;:[{&#34;title&#34;:&#34;HellaSwag&#34;,&#34;metric&#34;:&#34;hellaswag&#34;},{&#34;title&#34;:&#34;MMLU&#34;,&#34;metric&#34;:&#34;mmlu&#34;},{&#34;title&#34;:&#34;ARC&#34;,&#34;metric&#34;:&#34;arc&#34;},{&#34;title&#34;:&#34;PIQA&#34;,&#34;metric&#34;:&#34;piqa&#34;},{&#34;title&#34;:&#34;OpenBookQA&#34;,&#34;metric&#34;:&#34;openbookqa&#34;},{&#34;title&#34;:&#34;WinoGrande&#34;,&#34;metric&#34;:&#34;winogrande&#34;}],&#34;smoothing&#34;:true,&#34;smoothingWindow&#34;:5}"><!-- 
  Multi-Line Charts Grid
  
  A configurable grid of line charts with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute:
  {
    "dataUrl": "./assets/data/your_data.csv",
    "charts": [
      { "title": "Chart 1", "metric": "metric1" },
      { "title": "Chart 2", "metric": "metric2" },
      ...
    ],
    "smoothingWindow": 15,
    "smoothingCurve": "monotoneX",
    "gridColumns": 3  // Optional: number of columns (default: 3)
  }
  
  CSV format: run_name, step, metric1, metric2, ...
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/d3-six-line-charts.html" 
    config={{ 
      dataUrl: "./assets/data/attention_evals.csv",
      charts: [
        { title: "HellaSwag", metric: "hellaswag" },
        { title: "MMLU", metric: "mmlu" },
        { title: "ARC", metric: "arc" },
        { title: "PIQA", metric: "piqa" },
        { title: "OpenBookQA", metric: "openbookqa" },
        { title: "WinoGrande", metric: "winogrande" }
      ],
      smoothingWindow: 15
    }} 
  />
-->
<div class="d3-multi-charts"></div>
<style>
  .d3-multi-charts {
    position: relative;
    container-type: inline-size;
  }

  /* Legend header */
  .d3-multi-charts__header {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
  }

  .d3-multi-charts__header .legend-bottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
    max-width: 80%;
  }

  .d3-multi-charts__header .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-multi-charts__header .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
    justify-content: center;
  }

  .d3-multi-charts__header .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-multi-charts__header .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  /* Grid */
  .d3-multi-charts__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }

  /* Container queries - basées sur la largeur du container parent, pas de la viewport */
  @container (max-width: 900px) {
    .d3-multi-charts__grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @container (max-width: 600px) {
    .d3-multi-charts__grid {
      grid-template-columns: 1fr;
    }
  }

  .chart-cell {
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
    box-shadow: inset 0 0 0 1px var(--border-color);
    border-radius: 8px;
  }

  .chart-cell__title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
    margin-bottom: 8px;
    padding-bottom: 8px;
  }

  .chart-cell__body {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .chart-cell__body svg {
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* Reset button */
  .chart-cell .reset-button {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
    display: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-size: 11px;
    padding: 3px 6px;
    border-radius: 4px;
    background: var(--surface-bg);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    cursor: pointer;
  }

  /* Axes */
  .d3-multi-charts .axes path {
    display: none;
  }

  .d3-multi-charts .axes line {
    stroke: var(--axis-color);
  }

  .d3-multi-charts .axes text {
    fill: var(--tick-color);
    font-size: 10px;
  }

  .d3-multi-charts .axis-label {
    fill: var(--text-color);
    font-size: 10px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    stroke-width: 3px;
    paint-order: stroke fill;
  }

  .d3-multi-charts .grid line {
    stroke: var(--grid-color);
  }

  /* Lines */
  .d3-multi-charts path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-multi-charts path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-multi-charts.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-multi-charts.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  .d3-multi-charts.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  /* Tooltip */
  .d3-multi-charts .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-multi-charts .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 200px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-multi-charts .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-multi-charts'))) {
        const cs = Array.from(document.querySelectorAll('.d3-multi-charts')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration
      const CONFIG = {
        dataUrl: embedConfig.dataUrl || './assets/data/attention_evals.csv',
        charts: embedConfig.charts || [],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        gridColumns: embedConfig.gridColumns || 3,
        chartHeight: 240,
        margin: { top: 20, right: 20, bottom: 40, left: 50 },
        zoomExtent: [1.0, 8],
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Value',
        xColumn: embedConfig.xColumn || 'tokens',
        runColumn: embedConfig.runColumn || 'run_name'
      };

      if (!CONFIG.charts.length) {
        container.innerHTML = '<p style="color: var(--danger); font-size: 12px;">Error: No charts configured</p>';
        return;
      }

      // Create legend header
      const header = document.createElement('div');
      header.className = 'd3-multi-charts__header';
      header.innerHTML = `
      <div class="legend-bottom">
        <div class="legend-title">Legend</div>
        <div class="items"></div>
      </div>
    `;
      container.appendChild(header);

      // Create grid
      const grid = document.createElement('div');
      grid.className = 'd3-multi-charts__grid';
      container.appendChild(grid);

      // Trackio footer removed

      // Create chart cells
      CONFIG.charts.forEach((chartConfig, idx) => {
        const cell = document.createElement('div');
        cell.className = 'chart-cell';
        cell.style.zIndex = CONFIG.charts.length - idx; // Stacking order
        cell.innerHTML = `
        <div class="chart-cell__title">${chartConfig.title}</div>
        <button class="reset-button">Reset</button>
        <div class="chart-cell__body"></div>
      `;
        grid.appendChild(cell);
      });

      // Data
      let allData = [];
      let runList = [];
      let runColorMap = {};

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].value)) { sum += values[j].value; count++; } }
          const avg = count ? (sum / count) : values[i].value;
          out[i] = { step: values[i].step, value: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Init each chart
      function initChart(cellElement, chartConfig) {
        const bodyEl = cellElement.querySelector('.chart-cell__body');
        const resetBtn = cellElement.querySelector('.reset-button');

        const metric = chartConfig.metric;
        let smoothEnabled = CONFIG.smoothing;
        let hasMoved = false;

        // Tooltip
        let tip = cellElement.querySelector('.d3-tooltip');
        let tipInner;
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'd3-tooltip';
          Object.assign(tip.style, {
            position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
            padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
            background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease', zIndex: '20'
          });
          tipInner = document.createElement('div');
          tipInner.className = 'd3-tooltip__inner';
          tip.appendChild(tipInner);
          cellElement.appendChild(tip);
        } else {
          tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
        }

        // Create SVG
        const svg = d3.select(bodyEl).append('svg').attr('width', '100%').style('display', 'block');

        // Clip path
        const clipId = 'clip-' + Math.random().toString(36).slice(2);
        const clipPath = svg.append('defs').append('clipPath').attr('id', clipId);
        const clipRect = clipPath.append('rect');

        // Groups
        const g = svg.append('g');
        const gGrid = g.append('g').attr('class', 'grid');
        const gAxes = g.append('g').attr('class', 'axes');
        const gPlot = g.append('g').attr('class', 'plot').attr('clip-path', `url(#${clipId})`);
        const gHover = g.append('g').attr('class', 'hover-layer');
        const overlay = g.append('rect').attr('class', 'overlay').attr('fill', 'none').attr('pointer-events', 'all').style('cursor', 'grab')
          .on('mousedown', function () {
            d3.select(this).style('cursor', 'grabbing');
            tip.style.opacity = '0';
            if (hoverLine) hoverLine.style('display', 'none');
          })
          .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

        // Scales
        const xScale = d3.scaleLinear();
        const yScale = d3.scaleLinear();

        // Hover state
        let hoverLine = null;
        let steps = [];
        let hideTipTimer = null;

        // Formatters (will be set in render())
        let formatStep = (v) => v;
        let formatValue = (v) => v;

        // Zoom
        const zoom = d3.zoom().scaleExtent(CONFIG.zoomExtent).on('zoom', zoomed);
        overlay.call(zoom);

        function zoomed(event) {
          const transform = event.transform;
          hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
          updateResetButton();

          const newXScale = transform.rescaleX(xScale);
          const newYScale = transform.rescaleY(yScale);

          const innerWidth = xScale.range()[1];

          // Update grid
          const gridTicks = newYScale.ticks(5);
          gGrid.selectAll('line').data(gridTicks).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => newYScale(d)).attr('y2', d => newYScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Update lines
          const line = d3.line()
            .x(d => newXScale(d.step))
            .y(d => newYScale(d.value))
            .curve(getCurve(smoothEnabled));

          gPlot.selectAll('path.ghost-line')
            .attr('d', d => {
              const rawLine = d3.line().x(d => newXScale(d.step)).y(d => newYScale(d.value)).curve(d3.curveLinear);
              return rawLine(d.values);
            });

          gPlot.selectAll('path.main-line')
            .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

          // Update axes
          gAxes.select('.x-axis').call(d3.axisBottom(newXScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.select('.y-axis').call(d3.axisLeft(newYScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
        }

        function updateResetButton() {
          if (hasMoved) {
            resetBtn.style.display = 'block';
            requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
          } else {
            resetBtn.style.opacity = '0';
            setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
          }
        }

        function render() {
          const rect = bodyEl.getBoundingClientRect();
          const width = Math.max(1, Math.round(rect.width || 400));
          const height = CONFIG.chartHeight;
          svg.attr('width', width).attr('height', height);

          const margin = CONFIG.margin;
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;

          g.attr('transform', `translate(${margin.left},${margin.top})`);

          // Filter data for this metric
          const metricData = allData.filter(d => d[metric] != null && !isNaN(d[metric]));

          if (!metricData.length) {
            return;
          }

          // Auto-compute domains from data
          const stepExtent = d3.extent(metricData, d => d.step);
          const valueExtent = d3.extent(metricData, d => d[metric]);

          xScale.domain(stepExtent).range([0, innerWidth]);
          yScale.domain(valueExtent).range([innerHeight, 0]);

          // Create smart formatters based on actual data
          const stepValues = metricData.map(d => d.step);
          const metricValues = metricData.map(d => d[metric]);
          formatStep = createSmartFormatter(stepValues);
          formatValue = createSmartFormatter(metricValues);

          // Update clip
          clipRect.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update overlay
          overlay.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update zoom extent
          zoom.extent([[0, 0], [innerWidth, innerHeight]])
            .translateExtent([[0, 0], [innerWidth, innerHeight]]);

          // Grid
          gGrid.selectAll('line').data(yScale.ticks(5)).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Axes
          gAxes.selectAll('*').remove();
          gAxes.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.append('g').attr('class', 'y-axis')
            .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
          gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');
          gAxes.selectAll('text').attr('fill', 'var(--tick-color)');

          // Axis labels
          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight + 32)
            .attr('text-anchor', 'middle')
            .text(CONFIG.xAxisLabel);

          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -38)
            .attr('text-anchor', 'middle')
            .text(CONFIG.yAxisLabel);

          // Group data by run
          const dataByRun = {};
          runList.forEach(run => { dataByRun[run] = []; });
          metricData.forEach(d => {
            if (dataByRun[d.run]) dataByRun[d.run].push({ step: d.step, value: d[metric] });
          });
          runList.forEach(run => { dataByRun[run].sort((a, b) => a.step - b.step); });

          const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] })).filter(s => s.values.length > 0);

          // Ghost lines
          const ghostLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(d3.curveLinear);
          gPlot.selectAll('path.ghost-line').data(series, d => d.run).join('path')
            .attr('class', 'ghost-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 1.5)
            .attr('opacity', smoothEnabled ? 0.15 : 0)
            .attr('pointer-events', 'none')
            .attr('d', d => ghostLine(d.values));

          // Main lines
          const mainLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(getCurve(smoothEnabled));
          gPlot.selectAll('path.main-line').data(series, d => d.run).join('path')
            .attr('class', 'main-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('opacity', 0.85)
            .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

          // Hover
          setupHover(series, innerWidth, innerHeight);
        }

        function setupHover(series, innerWidth, innerHeight) {
          gHover.selectAll('*').remove();

          hoverLine = gHover.append('line')
            .style('stroke', 'var(--text-color)')
            .attr('stroke-opacity', 0.25)
            .attr('stroke-width', 1)
            .attr('y1', 0)
            .attr('y2', innerHeight)
            .style('display', 'none')
            .attr('pointer-events', 'none');

          const stepSet = new Set();
          series.forEach(s => s.values.forEach(v => stepSet.add(v.step)));
          steps = Array.from(stepSet).sort((a, b) => a - b);

          overlay.on('mousemove', function (ev) {
            if (ev.buttons === 0) onHoverMove(ev, series);
          }).on('mouseleave', onHoverLeave);
        }

        function onHoverMove(ev, series) {
          if (hideTipTimer) { clearTimeout(hideTipTimer); hideTipTimer = null; }

          const [mx, my] = d3.pointer(ev, overlay.node());
          const targetStep = xScale.invert(mx);
          const nearest = steps.reduce((best, t) => Math.abs(t - targetStep) < Math.abs(best - targetStep) ? t : best, steps[0]);

          const xpx = xScale(nearest);
          hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

          let html = `<div><strong>${chartConfig.title}</strong></div>`;
          html += `<div>${formatStep(nearest)}</div>`;

          const entries = series.map(s => {
            const values = s.values;
            let before = null, after = null;
            for (let i = 0; i < values.length; i++) {
              if (values[i].step <= nearest) before = values[i];
              if (values[i].step >= nearest && !after) { after = values[i]; break; }
            }

            let interpolatedValue = null;
            if (before && after && before.step !== after.step) {
              const t = (nearest - before.step) / (after.step - before.step);
              interpolatedValue = before.value + t * (after.value - before.value);
            } else if (before && before.step === nearest) {
              interpolatedValue = before.value;
            } else if (after && after.step === nearest) {
              interpolatedValue = after.value;
            } else if (before) {
              interpolatedValue = before.value;
            } else if (after) {
              interpolatedValue = after.value;
            }

            return { run: s.run, color: s.color, value: interpolatedValue };
          }).filter(e => e.value != null);

          entries.sort((a, b) => b.value - a.value);

          entries.forEach(e => {
            html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.value.toFixed(4)}</span></div>`;
          });

          tipInner.innerHTML = html;
          const offsetX = 12, offsetY = 12;
          tip.style.opacity = '1';
          tip.style.transform = `translate(${Math.round(mx + offsetX + CONFIG.margin.left)}px, ${Math.round(my + offsetY + CONFIG.margin.top)}px)`;
        }

        function onHoverLeave() {
          hideTipTimer = setTimeout(() => {
            tip.style.opacity = '0';
            tip.style.transform = 'translate(-9999px, -9999px)';
            if (hoverLine) hoverLine.style('display', 'none');
          }, 100);
        }

        // Reset button
        resetBtn.addEventListener('click', () => {
          overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        });

        return { render };
      }

      // Load data
      async function load() {
        try {
          const response = await fetch(CONFIG.dataUrl, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);

          const csvText = await response.text();

          // Parse CSV (long format: run_name, metric, tokens, value)
          const rawRows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            metric: (d.metric || '').trim(),
            tokens: +d[CONFIG.xColumn],
            value: +d.value
          }));

          // Pivot data: group by run + tokens, create columns for each metric
          const pivotMap = new Map();
          rawRows.forEach(row => {
            if (isNaN(row.tokens) || isNaN(row.value)) return;

            const key = `${row.run}|${row.tokens}`;
            if (!pivotMap.has(key)) {
              pivotMap.set(key, { run: row.run, step: row.tokens });
            }
            const pivotRow = pivotMap.get(key);
            pivotRow[row.metric] = row.value;
          });

          allData = Array.from(pivotMap.values());

          runList = Array.from(new Set(allData.map(d => d.run))).sort();

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => { runColorMap[run] = colors[i % colors.length]; });

          // Build legend
          const legendItemsHost = header.querySelector('.legend-bottom .items');
          if (legendItemsHost) {
            legendItemsHost.innerHTML = runList.map(run => {
              const color = runColorMap[run];
              return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
            }).join('');

            // Add hover interactions
            legendItemsHost.querySelectorAll('.item').forEach(el => {
              el.addEventListener('mouseenter', () => {
                const run = el.getAttribute('data-run');
                container.classList.add('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                grid.querySelectorAll('path.ghost-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                legendItemsHost.querySelectorAll('.item').forEach(it => {
                  it.classList.toggle('ghost', it.getAttribute('data-run') !== run);
                });
              });

              el.addEventListener('mouseleave', () => {
                container.classList.remove('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => path.classList.remove('ghost'));
                grid.querySelectorAll('path.ghost-line').forEach(path => path.classList.remove('ghost'));
                legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
              });
            });
          }

          // Init all charts
          const cells = Array.from(grid.querySelectorAll('.chart-cell'));
          const chartInstances = cells.map((cell, idx) => initChart(cell, CONFIG.charts[idx]));

          // Render all
          chartInstances.forEach(chart => chart.render());

          // Responsive - observe container for resize
          let resizeTimer;
          const handleResize = () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              chartInstances.forEach(chart => chart.render());
            }, 100);
          };

          const ro = window.ResizeObserver ? new ResizeObserver(handleResize) : null;
          if (ro) {
            ro.observe(container);
          }

          // Also observe window resize as fallback
          window.addEventListener('resize', handleResize);

          // Force a re-render after a short delay to ensure proper sizing
          setTimeout(() => {
            chartInstances.forEach(chart => chart.render());
          }, 100);

        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure> </div>
<p>The evaluation results show similar final performance across all three configurations. Looking at the loss and evaluation curves (specifically HellaSwag), we see an interesting pattern: cosine achieves better loss and evaluation scores during the stable phase (before WSD’s decay begins). However, once WSD enters its decay phase, there’s an almost linear improvement in both loss and downstream metrics allowing WSD to catch up to cosine by the end of training.</p>
<p>This confirms that WSD’s 10-20% decay window is sufficient to match cosine’s final performance while maintaining the flexibility to extend training mid-run. We opted for WSD with 10% decay for SmolLM3.</p>
<div class="note note--danger" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>⚠️</span> <div class="note__title" data-astro-cid-qg6lmfty>Comparing models trained with different schedulers mid-run</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>If you’re comparing intermediate checkpoints between cosine and WSD during the stable phase, make sure to apply a decay to the WSD checkpoint for a fair comparison.</p> </div> </div> </div> 
<p>Now that we have a good overview of popular learning rate schedules, the next question is: what should the peak learning rate actually be?</p>
<p><strong>Finding The Optimal Learning Rate</strong></p>
<p>How do we pick the right learning rates for our specific learning rate scheduler and training setups?</p>
<p>We could run learning rate sweeps on short ablations like we did for architecture choices. But optimal learning rate depends on training duration: a learning rate that converges fastest in a short ablation might not be the best one for the full run. And we can’t afford to run expensive multi-week trainings multiple times just to test different learning rates.</p>
<p>Let’s first look at simple sweeps we can quickly run that help us rule out learning rates that are much too high or low and then we’ll discuss scaling laws for hyperparameters.</p>
<p><strong>Ablation - LR sweeps</strong></p>
<p>To illustrate the impact of different learning rates, let’s look at a sweep on our 1B ablation model trained on 45B tokens. We train the same model, under the same setup with 4 different learning rates: 1e-4, 5e-4, 5e-3, 5e-2. The results clearly show the dangers at both extremes:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-3alfuwp9rs5" data-config="{&#34;dataUrl&#34;:&#34;./data/lr_loss.csv&#34;,&#34;xDomain&#34;:[0,45000000000],&#34;yDomain&#34;:[2.1,10],&#34;smoothing&#34;:true,&#34;title&#34;:&#34;Learning Rate Loss&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-v88jera4zl9" data-config="{&#34;dataUrl&#34;:&#34;./data/lr_evals.csv&#34;,&#34;charts&#34;:[{&#34;title&#34;:&#34;HellaSwag&#34;,&#34;metric&#34;:&#34;hellaswag&#34;},{&#34;title&#34;:&#34;MMLU&#34;,&#34;metric&#34;:&#34;mmlu&#34;},{&#34;title&#34;:&#34;ARC&#34;,&#34;metric&#34;:&#34;arc&#34;},{&#34;title&#34;:&#34;PIQA&#34;,&#34;metric&#34;:&#34;piqa&#34;},{&#34;title&#34;:&#34;OpenBookQA&#34;,&#34;metric&#34;:&#34;openbookqa&#34;},{&#34;title&#34;:&#34;WinoGrande&#34;,&#34;metric&#34;:&#34;winogrande&#34;}],&#34;smoothing&#34;:true,&#34;smoothingWindow&#34;:15}"><!-- 
  Multi-Line Charts Grid
  
  A configurable grid of line charts with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute:
  {
    "dataUrl": "./assets/data/your_data.csv",
    "charts": [
      { "title": "Chart 1", "metric": "metric1" },
      { "title": "Chart 2", "metric": "metric2" },
      ...
    ],
    "smoothingWindow": 15,
    "smoothingCurve": "monotoneX",
    "gridColumns": 3  // Optional: number of columns (default: 3)
  }
  
  CSV format: run_name, step, metric1, metric2, ...
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/d3-six-line-charts.html" 
    config={{ 
      dataUrl: "./assets/data/attention_evals.csv",
      charts: [
        { title: "HellaSwag", metric: "hellaswag" },
        { title: "MMLU", metric: "mmlu" },
        { title: "ARC", metric: "arc" },
        { title: "PIQA", metric: "piqa" },
        { title: "OpenBookQA", metric: "openbookqa" },
        { title: "WinoGrande", metric: "winogrande" }
      ],
      smoothingWindow: 15
    }} 
  />
-->
<div class="d3-multi-charts"></div>
<style>
  .d3-multi-charts {
    position: relative;
    container-type: inline-size;
  }

  /* Legend header */
  .d3-multi-charts__header {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
  }

  .d3-multi-charts__header .legend-bottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
    max-width: 80%;
  }

  .d3-multi-charts__header .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-multi-charts__header .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
    justify-content: center;
  }

  .d3-multi-charts__header .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-multi-charts__header .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  /* Grid */
  .d3-multi-charts__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }

  /* Container queries - basées sur la largeur du container parent, pas de la viewport */
  @container (max-width: 900px) {
    .d3-multi-charts__grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @container (max-width: 600px) {
    .d3-multi-charts__grid {
      grid-template-columns: 1fr;
    }
  }

  .chart-cell {
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
    box-shadow: inset 0 0 0 1px var(--border-color);
    border-radius: 8px;
  }

  .chart-cell__title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
    margin-bottom: 8px;
    padding-bottom: 8px;
  }

  .chart-cell__body {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .chart-cell__body svg {
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* Reset button */
  .chart-cell .reset-button {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
    display: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-size: 11px;
    padding: 3px 6px;
    border-radius: 4px;
    background: var(--surface-bg);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    cursor: pointer;
  }

  /* Axes */
  .d3-multi-charts .axes path {
    display: none;
  }

  .d3-multi-charts .axes line {
    stroke: var(--axis-color);
  }

  .d3-multi-charts .axes text {
    fill: var(--tick-color);
    font-size: 10px;
  }

  .d3-multi-charts .axis-label {
    fill: var(--text-color);
    font-size: 10px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    stroke-width: 3px;
    paint-order: stroke fill;
  }

  .d3-multi-charts .grid line {
    stroke: var(--grid-color);
  }

  /* Lines */
  .d3-multi-charts path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-multi-charts path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-multi-charts.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-multi-charts.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  .d3-multi-charts.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  /* Tooltip */
  .d3-multi-charts .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-multi-charts .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 200px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-multi-charts .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-multi-charts'))) {
        const cs = Array.from(document.querySelectorAll('.d3-multi-charts')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration
      const CONFIG = {
        dataUrl: embedConfig.dataUrl || './assets/data/attention_evals.csv',
        charts: embedConfig.charts || [],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        gridColumns: embedConfig.gridColumns || 3,
        chartHeight: 240,
        margin: { top: 20, right: 20, bottom: 40, left: 50 },
        zoomExtent: [1.0, 8],
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Value',
        xColumn: embedConfig.xColumn || 'tokens',
        runColumn: embedConfig.runColumn || 'run_name'
      };

      if (!CONFIG.charts.length) {
        container.innerHTML = '<p style="color: var(--danger); font-size: 12px;">Error: No charts configured</p>';
        return;
      }

      // Create legend header
      const header = document.createElement('div');
      header.className = 'd3-multi-charts__header';
      header.innerHTML = `
      <div class="legend-bottom">
        <div class="legend-title">Legend</div>
        <div class="items"></div>
      </div>
    `;
      container.appendChild(header);

      // Create grid
      const grid = document.createElement('div');
      grid.className = 'd3-multi-charts__grid';
      container.appendChild(grid);

      // Trackio footer removed

      // Create chart cells
      CONFIG.charts.forEach((chartConfig, idx) => {
        const cell = document.createElement('div');
        cell.className = 'chart-cell';
        cell.style.zIndex = CONFIG.charts.length - idx; // Stacking order
        cell.innerHTML = `
        <div class="chart-cell__title">${chartConfig.title}</div>
        <button class="reset-button">Reset</button>
        <div class="chart-cell__body"></div>
      `;
        grid.appendChild(cell);
      });

      // Data
      let allData = [];
      let runList = [];
      let runColorMap = {};

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].value)) { sum += values[j].value; count++; } }
          const avg = count ? (sum / count) : values[i].value;
          out[i] = { step: values[i].step, value: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Init each chart
      function initChart(cellElement, chartConfig) {
        const bodyEl = cellElement.querySelector('.chart-cell__body');
        const resetBtn = cellElement.querySelector('.reset-button');

        const metric = chartConfig.metric;
        let smoothEnabled = CONFIG.smoothing;
        let hasMoved = false;

        // Tooltip
        let tip = cellElement.querySelector('.d3-tooltip');
        let tipInner;
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'd3-tooltip';
          Object.assign(tip.style, {
            position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
            padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
            background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease', zIndex: '20'
          });
          tipInner = document.createElement('div');
          tipInner.className = 'd3-tooltip__inner';
          tip.appendChild(tipInner);
          cellElement.appendChild(tip);
        } else {
          tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
        }

        // Create SVG
        const svg = d3.select(bodyEl).append('svg').attr('width', '100%').style('display', 'block');

        // Clip path
        const clipId = 'clip-' + Math.random().toString(36).slice(2);
        const clipPath = svg.append('defs').append('clipPath').attr('id', clipId);
        const clipRect = clipPath.append('rect');

        // Groups
        const g = svg.append('g');
        const gGrid = g.append('g').attr('class', 'grid');
        const gAxes = g.append('g').attr('class', 'axes');
        const gPlot = g.append('g').attr('class', 'plot').attr('clip-path', `url(#${clipId})`);
        const gHover = g.append('g').attr('class', 'hover-layer');
        const overlay = g.append('rect').attr('class', 'overlay').attr('fill', 'none').attr('pointer-events', 'all').style('cursor', 'grab')
          .on('mousedown', function () {
            d3.select(this).style('cursor', 'grabbing');
            tip.style.opacity = '0';
            if (hoverLine) hoverLine.style('display', 'none');
          })
          .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

        // Scales
        const xScale = d3.scaleLinear();
        const yScale = d3.scaleLinear();

        // Hover state
        let hoverLine = null;
        let steps = [];
        let hideTipTimer = null;

        // Formatters (will be set in render())
        let formatStep = (v) => v;
        let formatValue = (v) => v;

        // Zoom
        const zoom = d3.zoom().scaleExtent(CONFIG.zoomExtent).on('zoom', zoomed);
        overlay.call(zoom);

        function zoomed(event) {
          const transform = event.transform;
          hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
          updateResetButton();

          const newXScale = transform.rescaleX(xScale);
          const newYScale = transform.rescaleY(yScale);

          const innerWidth = xScale.range()[1];

          // Update grid
          const gridTicks = newYScale.ticks(5);
          gGrid.selectAll('line').data(gridTicks).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => newYScale(d)).attr('y2', d => newYScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Update lines
          const line = d3.line()
            .x(d => newXScale(d.step))
            .y(d => newYScale(d.value))
            .curve(getCurve(smoothEnabled));

          gPlot.selectAll('path.ghost-line')
            .attr('d', d => {
              const rawLine = d3.line().x(d => newXScale(d.step)).y(d => newYScale(d.value)).curve(d3.curveLinear);
              return rawLine(d.values);
            });

          gPlot.selectAll('path.main-line')
            .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

          // Update axes
          gAxes.select('.x-axis').call(d3.axisBottom(newXScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.select('.y-axis').call(d3.axisLeft(newYScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
        }

        function updateResetButton() {
          if (hasMoved) {
            resetBtn.style.display = 'block';
            requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
          } else {
            resetBtn.style.opacity = '0';
            setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
          }
        }

        function render() {
          const rect = bodyEl.getBoundingClientRect();
          const width = Math.max(1, Math.round(rect.width || 400));
          const height = CONFIG.chartHeight;
          svg.attr('width', width).attr('height', height);

          const margin = CONFIG.margin;
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;

          g.attr('transform', `translate(${margin.left},${margin.top})`);

          // Filter data for this metric
          const metricData = allData.filter(d => d[metric] != null && !isNaN(d[metric]));

          if (!metricData.length) {
            return;
          }

          // Auto-compute domains from data
          const stepExtent = d3.extent(metricData, d => d.step);
          const valueExtent = d3.extent(metricData, d => d[metric]);

          xScale.domain(stepExtent).range([0, innerWidth]);
          yScale.domain(valueExtent).range([innerHeight, 0]);

          // Create smart formatters based on actual data
          const stepValues = metricData.map(d => d.step);
          const metricValues = metricData.map(d => d[metric]);
          formatStep = createSmartFormatter(stepValues);
          formatValue = createSmartFormatter(metricValues);

          // Update clip
          clipRect.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update overlay
          overlay.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update zoom extent
          zoom.extent([[0, 0], [innerWidth, innerHeight]])
            .translateExtent([[0, 0], [innerWidth, innerHeight]]);

          // Grid
          gGrid.selectAll('line').data(yScale.ticks(5)).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Axes
          gAxes.selectAll('*').remove();
          gAxes.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.append('g').attr('class', 'y-axis')
            .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
          gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');
          gAxes.selectAll('text').attr('fill', 'var(--tick-color)');

          // Axis labels
          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight + 32)
            .attr('text-anchor', 'middle')
            .text(CONFIG.xAxisLabel);

          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -38)
            .attr('text-anchor', 'middle')
            .text(CONFIG.yAxisLabel);

          // Group data by run
          const dataByRun = {};
          runList.forEach(run => { dataByRun[run] = []; });
          metricData.forEach(d => {
            if (dataByRun[d.run]) dataByRun[d.run].push({ step: d.step, value: d[metric] });
          });
          runList.forEach(run => { dataByRun[run].sort((a, b) => a.step - b.step); });

          const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] })).filter(s => s.values.length > 0);

          // Ghost lines
          const ghostLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(d3.curveLinear);
          gPlot.selectAll('path.ghost-line').data(series, d => d.run).join('path')
            .attr('class', 'ghost-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 1.5)
            .attr('opacity', smoothEnabled ? 0.15 : 0)
            .attr('pointer-events', 'none')
            .attr('d', d => ghostLine(d.values));

          // Main lines
          const mainLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(getCurve(smoothEnabled));
          gPlot.selectAll('path.main-line').data(series, d => d.run).join('path')
            .attr('class', 'main-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('opacity', 0.85)
            .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

          // Hover
          setupHover(series, innerWidth, innerHeight);
        }

        function setupHover(series, innerWidth, innerHeight) {
          gHover.selectAll('*').remove();

          hoverLine = gHover.append('line')
            .style('stroke', 'var(--text-color)')
            .attr('stroke-opacity', 0.25)
            .attr('stroke-width', 1)
            .attr('y1', 0)
            .attr('y2', innerHeight)
            .style('display', 'none')
            .attr('pointer-events', 'none');

          const stepSet = new Set();
          series.forEach(s => s.values.forEach(v => stepSet.add(v.step)));
          steps = Array.from(stepSet).sort((a, b) => a - b);

          overlay.on('mousemove', function (ev) {
            if (ev.buttons === 0) onHoverMove(ev, series);
          }).on('mouseleave', onHoverLeave);
        }

        function onHoverMove(ev, series) {
          if (hideTipTimer) { clearTimeout(hideTipTimer); hideTipTimer = null; }

          const [mx, my] = d3.pointer(ev, overlay.node());
          const targetStep = xScale.invert(mx);
          const nearest = steps.reduce((best, t) => Math.abs(t - targetStep) < Math.abs(best - targetStep) ? t : best, steps[0]);

          const xpx = xScale(nearest);
          hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

          let html = `<div><strong>${chartConfig.title}</strong></div>`;
          html += `<div>${formatStep(nearest)}</div>`;

          const entries = series.map(s => {
            const values = s.values;
            let before = null, after = null;
            for (let i = 0; i < values.length; i++) {
              if (values[i].step <= nearest) before = values[i];
              if (values[i].step >= nearest && !after) { after = values[i]; break; }
            }

            let interpolatedValue = null;
            if (before && after && before.step !== after.step) {
              const t = (nearest - before.step) / (after.step - before.step);
              interpolatedValue = before.value + t * (after.value - before.value);
            } else if (before && before.step === nearest) {
              interpolatedValue = before.value;
            } else if (after && after.step === nearest) {
              interpolatedValue = after.value;
            } else if (before) {
              interpolatedValue = before.value;
            } else if (after) {
              interpolatedValue = after.value;
            }

            return { run: s.run, color: s.color, value: interpolatedValue };
          }).filter(e => e.value != null);

          entries.sort((a, b) => b.value - a.value);

          entries.forEach(e => {
            html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.value.toFixed(4)}</span></div>`;
          });

          tipInner.innerHTML = html;
          const offsetX = 12, offsetY = 12;
          tip.style.opacity = '1';
          tip.style.transform = `translate(${Math.round(mx + offsetX + CONFIG.margin.left)}px, ${Math.round(my + offsetY + CONFIG.margin.top)}px)`;
        }

        function onHoverLeave() {
          hideTipTimer = setTimeout(() => {
            tip.style.opacity = '0';
            tip.style.transform = 'translate(-9999px, -9999px)';
            if (hoverLine) hoverLine.style('display', 'none');
          }, 100);
        }

        // Reset button
        resetBtn.addEventListener('click', () => {
          overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        });

        return { render };
      }

      // Load data
      async function load() {
        try {
          const response = await fetch(CONFIG.dataUrl, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);

          const csvText = await response.text();

          // Parse CSV (long format: run_name, metric, tokens, value)
          const rawRows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            metric: (d.metric || '').trim(),
            tokens: +d[CONFIG.xColumn],
            value: +d.value
          }));

          // Pivot data: group by run + tokens, create columns for each metric
          const pivotMap = new Map();
          rawRows.forEach(row => {
            if (isNaN(row.tokens) || isNaN(row.value)) return;

            const key = `${row.run}|${row.tokens}`;
            if (!pivotMap.has(key)) {
              pivotMap.set(key, { run: row.run, step: row.tokens });
            }
            const pivotRow = pivotMap.get(key);
            pivotRow[row.metric] = row.value;
          });

          allData = Array.from(pivotMap.values());

          runList = Array.from(new Set(allData.map(d => d.run))).sort();

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => { runColorMap[run] = colors[i % colors.length]; });

          // Build legend
          const legendItemsHost = header.querySelector('.legend-bottom .items');
          if (legendItemsHost) {
            legendItemsHost.innerHTML = runList.map(run => {
              const color = runColorMap[run];
              return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
            }).join('');

            // Add hover interactions
            legendItemsHost.querySelectorAll('.item').forEach(el => {
              el.addEventListener('mouseenter', () => {
                const run = el.getAttribute('data-run');
                container.classList.add('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                grid.querySelectorAll('path.ghost-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                legendItemsHost.querySelectorAll('.item').forEach(it => {
                  it.classList.toggle('ghost', it.getAttribute('data-run') !== run);
                });
              });

              el.addEventListener('mouseleave', () => {
                container.classList.remove('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => path.classList.remove('ghost'));
                grid.querySelectorAll('path.ghost-line').forEach(path => path.classList.remove('ghost'));
                legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
              });
            });
          }

          // Init all charts
          const cells = Array.from(grid.querySelectorAll('.chart-cell'));
          const chartInstances = cells.map((cell, idx) => initChart(cell, CONFIG.charts[idx]));

          // Render all
          chartInstances.forEach(chart => chart.render());

          // Responsive - observe container for resize
          let resizeTimer;
          const handleResize = () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              chartInstances.forEach(chart => chart.render());
            }, 100);
          };

          const ro = window.ResizeObserver ? new ResizeObserver(handleResize) : null;
          if (ro) {
            ro.observe(container);
          }

          // Also observe window resize as fallback
          window.addEventListener('resize', handleResize);

          // Force a re-render after a short delay to ensure proper sizing
          setTimeout(() => {
            chartInstances.forEach(chart => chart.render());
          }, 100);

        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure> </div>
<p>LR 5e-2 diverges almost immediately, the loss spikes early and never recovers, making the model unusable. LR 1e-4 is too conservative, while it trains stably, it converges much more slowly than the other learning rates. The middle ground of 5e-4 and 5e-3 show better convergence and comparable performance. But running sweeps for every model size gets expensive quickly, and more importantly, it doesn’t account for the planned number of training tokens as we previously stated. This is where scaling laws become invaluable.</p>
<p>For SmolLM3, we trained 3B models on 100B tokens with AdamW using the WSD schedule, comparing several learning rates. We found that 2e-4 converged much faster than 1e-4 in both loss and downstream performance, while 3e-4 was only slightly better than 2e-4. The marginal gains from 3e-4 came with increased risk of instability during long training runs, so we chose 2e-4 as our sweet spot.</p>
<p>These sweeps help us rule out learning rates that are clearly too high (divergence) or too low (slow convergence), but running sweeps for every model size gets expensive quickly, and more importantly, it doesn’t account for the planned number of training tokens as we previously stated. This is where scaling laws become invaluable.</p>
<p>But before we dive into scaling laws for  hyperparameters, let’s discuss the other critical hyperparameter that interacts with learning rate: batch size.</p>
<h4 id="batch-size"><a href="#batch-size">Batch size</a></h4>
<p>The batch size is the number of samples processed before updating model weights. It directly impacts both training efficiency and final model performance. Increasing the batch size improves throughput if your hardware and training stack scale well across devices. But beyond a certain point, larger batches start to hurt data efficiency: the model needs more total tokens to reach the same loss. The breakpoint where this happens is known as the  <strong>critical batch size</strong> <span class="" id="citation--mccandlish2018empiricalmodellargebatchtraining--100">(<a href="https://arxiv.org/abs/1812.06162" id="refctx-bib-mccandlish2018empiricalmodellargebatchtraining-1" data-ref-id="bib-mccandlish2018empiricalmodellargebatchtraining" target="_blank" rel="noopener noreferrer">McCandlish et al., 2018</a>)</span>.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Throughput is the number of tokens processed per second during training.</p> </aside> </div>  
<ul>
<li><strong>Increasing the batch size while staying below critical:</strong>  after increasing the batch size and retuning the learning rate, you reach the same loss with the same number of tokens as the smaller batch size run, no data is wasted.</li>
<li><strong>Increasing the batch size while staying above critical:</strong> larger batches start to sacrifice data efficiency; reaching the same loss now requires more total tokens (and thus more money), even if wall-clock time drops because more chips are busy.</li>
</ul>
<p>Let’s try to give some intuition about why we need to retune the learning rate, and how to compute an estimation of what the critical batch size should be.</p>
<p>When batch size grows, each mini-batch gradient is a better estimate of the true gradient, so you can safely take a larger step (i.e., increase the learning rate) and reach a target loss in fewer updates. The question is how to scale it.</p>
<p>Averaging over B samples</p>
<ul>
<li>Batch gradient:  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>g</mi><mo>~</mo></mover><mi>B</mi></msub><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mfrac><mn>1</mn><mi>B</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>B</mi></msubsup><msup><mover accent="true"><mi>g</mi><mo>~</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\tilde{g}_{B} \;=\; \frac{1}{B}\sum_{i=1}^{B} \tilde{g}^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:0.03588em">g</span></span><span style="top:-3.35em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-0.2222em"><span class="mord">~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em">B</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9812em"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:0.03588em">g</span></span><span style="top:-3.35em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-0.2222em"><span class="mord">~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>Mean stays the same:  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">E</mi><mtext> ⁣</mtext><mrow><mo fence="true">[</mo><msub><mover accent="true"><mi>g</mi><mo>~</mo></mover><mi>B</mi></msub><mo fence="true">]</mo></mrow><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mi>g</mi></mrow><annotation encoding="application/x-tex">\mathbb{E}\!\left[\tilde{g}_{B}\right] \;=\; g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathbb">E</span><span class="mspace" style="margin-right:-0.1667em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="minner"><span class="mopen delimcenter" style="top:0em">[</span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:0.03588em">g</span></span><span style="top:-3.35em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-0.2222em"><span class="mord">~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em">]</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">g</span></span></span></span></li>
<li>But covariance shrinks:  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">v</mi></mrow><mtext> ⁣</mtext><mrow><mo fence="true">(</mo><msub><mover accent="true"><mi>g</mi><mo>~</mo></mover><mi>B</mi></msub><mo fence="true">)</mo></mrow><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mfrac><mi mathvariant="normal">Σ</mi><mi>B</mi></mfrac></mrow><annotation encoding="application/x-tex">\mathrm{Cov}\!\left(\tilde{g}_{B}\right) \;=\; \frac{\Sigma}{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em">Cov</span></span><span class="mspace" style="margin-right:-0.1667em"></span><span class="mspace" style="margin-right:0.1667em"></span><span class="minner"><span class="mopen delimcenter" style="top:0em">(</span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:0.03588em">g</span></span><span style="top:-3.35em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-0.2222em"><span class="mord">~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em">)</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em">B</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Σ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
<p>The SGD parameter update is:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>w</mi><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mo>−</mo><mtext> </mtext><mi>η</mi><mtext> </mtext><msub><mover accent="true"><mi>g</mi><mo>~</mo></mover><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">\Delta w \;=\; -\,\eta \,\tilde{g}_{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">η</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6679em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:0.03588em">g</span></span><span style="top:-3.35em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-0.2222em"><span class="mord">~</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>The variance of this update is proportional to:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">V</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Δ</mi><mi>w</mi><mo stretchy="false">)</mo><mtext>  </mtext><mo>∝</mo><mtext>  </mtext><msup><mi>η</mi><mn>2</mn></msup><mtext> </mtext><mfrac><mi mathvariant="normal">Σ</mi><mi>B</mi></mfrac></mrow><annotation encoding="application/x-tex">\mathrm{Var}(\Delta w) \;\propto\; \eta^{2}\,\frac{\Sigma}{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord"><span class="mord mathrm">Var</span></span><span class="mopen">(</span><span class="mord">Δ</span><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∝</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">η</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em">B</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Σ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
<p>so to keep the update variance roughly constant, if you scale the batch size by k, you want to scale the learning rate by  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>k</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1078em"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal" style="margin-right:0.03148em;padding-left:0.833em">k</span></span><span style="top:-2.8922em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1078em"><span></span></span></span></span></span></span></span></span> . So let’s say you have you have computed your optimal batch size and learning rate and you’ve find that increasing to the critical batch size is possible and increasing the throughput, you’ll need to adapt the optimal learning rate as well.</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>B</mi><mtext>critical</mtext></msub><mtext>  </mtext><mo>→</mo><mtext>  </mtext><mi>k</mi><msub><mi>B</mi><mtext>optimal</mtext></msub><mspace width="1em"></mspace><mo>⇒</mo><mspace width="1em"></mspace><msub><mi>η</mi><mtext>critical</mtext></msub><mtext>  </mtext><mo>→</mo><mtext>  </mtext><msqrt><mi>k</mi></msqrt><msub><mi>η</mi><mtext>optimal</mtext></msub></mrow><annotation encoding="application/x-tex">B_{\text{critical}} \;\rightarrow\; kB_{\text{optimal}} \quad\Rightarrow\quad \eta_{\text{critical}} \;\rightarrow\; \sqrt{k}\eta_{\text{optimal}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">critical</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">optimal</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">η</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">critical</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.2672em;vertical-align:-0.2861em"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9811em"><span class="svg-align" style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord" style="padding-left:0.833em"><span class="mord mathnormal" style="margin-right:0.03148em">k</span></span></span><span style="top:-2.9411em"><span class="pstrut" style="height:3em"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.0589em"><span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">η</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">optimal</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span></span>
<div class="sidenote-container"> <aside class="sidenote"> <p>See the (amazing) Jianlin Su’s series for more math on this: <a href="https://kexue.fm/archives/11260">https://kexue.fm/archives/11260</a></p> </aside> </div>  
<p>A useful rule of thumb for optimizers like AdamW or Muon is  <em><strong>square-root</strong></em>   <em><strong>LR scaling</strong></em>  as batch size grows, but this also depends on the optimizer. For instance using AdamW there are interactions with  <code>beta1</code> / <code>beta2</code>  that can introduce very different behavior. A pragmatic alternative is to branch training for a brief window: keep one run at the original batch, start a second with the larger batch and a rescaled LR, and only adopt the larger batch if the two loss curves align after the rescale  <span class="" id="citation--merrill2025criticalbatchsizerevisited--101">(<a href="https://arxiv.org/abs/2505.23971" id="refctx-bib-merrill2025criticalbatchsizerevisited-1" data-ref-id="bib-merrill2025criticalbatchsizerevisited" target="_blank" rel="noopener noreferrer">Merrill et al., 2025</a>)</span>. In the paper, they re-warm up the learning rate and reset the optimizer state when switching the batch size. They also set a tolerance and a time window to decide whether the losses “match”, both knobs are chosen empirically. They found that the  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>s</mi><mi>i</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">B_{simple}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">im</span><span class="mord mathnormal mtight" style="margin-right:0.01968em">pl</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>  estimate - which is also noisy - is underestimating the “actual” critical batch size. This gives you a quick, low-risk check that the new batch/LR pair preserves training dynamics.</p>
<p>The critical batch size isn’t fixed, it grows as training progresses. Early in training, the model is making big gradient step, so  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">∥</mo><mi>g</mi><msup><mo stretchy="false">∥</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\lVert g\rVert^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mopen">∥</span><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="mclose"><span class="mclose">∥</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>  is big which means  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mtext>simple</mtext></msub></mrow><annotation encoding="application/x-tex">B_\text{simple}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">simple</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span></span></span></span>  is small, hence the model have a smaller critical batch size. Later, as the model updates stabilizes and larger batches become more effective. This is why some large-scale trainings don’t keep the batch size constant and use what we can batch size warmup. For example, DeepSeek-V3 begins with a 12.6 M batch for the first ~469 B tokens, then increases to 62.9M for the remainder of training. A batch-size warmup schedule like this serves the same purpose as a learning-rate warmup: it keeps the model on the efficient frontier as the gradient noise scale grows, maintaining stable and efficient optimization throughout.</p>
<p>Another interesting approach is treating the loss as a proxy for the critical batch size. Minimax01 used this and in the last stage they trained with a 128M batch size! This is a bit different because they don’t increase the learning rate, so their batch-size schedule acts like a learning-rate decay schedule.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty>  <div class="note__title" data-astro-cid-qg6lmfty>Tuning batch size and learning rate</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>In practice, here’s how you can choose the batch size and learning rate:</p><ul>
<li>You first pick the batch size and learning rate you consider optimal, either from scaling laws (see later!) or</li>
</ul><p>from literature.</p><ul>
<li>Then, you can tune the batch size to see if you can improve the training throughput.</li>
</ul><p>The key insight is that there’s often a range between your starting batch size
and the critical batch size where you can increase it to improve hardware
utilization without sacrificing data efficiency, but you must retune the learning
rate accordingly.
If the throughput gain isn’t significant, or if testing a larger batch size
(with rescaled learning rate) shows worse data efficiency, stick with the initial values.</p> </div> </div> </div> 
<p>As mentioned in the note above, one way to pick your starting points for the batch size and learning rate is through scaling laws. Let’s see how these scaling laws work and how they predict both hyperparameters as a function of your compute budget.</p>
<h4 id="scaling-laws-for-hyperparameters"><a href="#scaling-laws-for-hyperparameters"><strong>Scaling laws for hyperparameters</strong></a></h4>
<p>The optimal learning rate and batch size aren’t just about model architecture and size, they also depends on our compute budget, which combines both the number of model parameters and the number of training tokens. In practice, both of these factors interact to determine how aggressive or conservative our updates should be. This is where scaling laws come in.</p>
<p>Scaling laws establish empirical relationships describing how model performance evolves as we increase training scale, whether that’s through larger models or more training data (see the “Scaling laws” section at the end of this chapter for the full history). But scaling laws can also help us predict how to adjust key hyperparameters like the learning rate and batch size as we scale up training, as it was done in recent work by <a href="https://arxiv.org/abs/2401.02954">DeepSeek</a> and <a href="https://arxiv.org/abs/2412.15115">Qwen2.5</a>. This gives us principled defaults rather than relying entirely on hyperparameter sweeps.</p>
<p>To apply scaling laws in this context, we need a way to quantify training scale. The standard metric is the compute budget, denoted C and measured in FLOPs, which can be approximated as:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>≈</mo><mn>6</mn><mo>×</mo><mi>N</mi><mo>×</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">C\approx 6×N×D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span></span></span></span></p>
<p>N is the number of model parameters (e.g., 1B = 1e9), D is the number of training tokens. This is often measured in FLOPs (floating-point operations), a hardware-agnostic way of quantifying how much actual computation is being done. But if FLOPs feel too abstract, just think of it this way: training a 1B parameter model on 100B tokens consumes about 2× fewer FLOPs than training a 2B model on 100B tokens, or a 1B model on 200B tokens.</p>
<p>The constant 6 comes from empirical estimates of how many floating-point operations are required to train a Transformer, roughly 6 FLOPs per parameter per token.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>If you want a more precise measure taking into account MoE layers and Hybrid layers you can checkout the <a href="https://github.com/NVIDIA/Megatron-LM/blob/f34fa11af6f5dc65f5342f2a785c3227446cebfd/megatron/training/training.py#L158"> <code>num_floating_point_operations</code> </a> function in Megatron-LM.</p> </aside> </div>  
<p>Now, how does this relate to learning rate? We can derive scaling laws that predict optimal learning rates and batch sizes as functions of total compute budget (C). They help answer questions like:</p>
<ul>
<li>How should the learning rate change as I scale from 1B to 7B parameters?</li>
<li>If I double my training data, should I adjust the learning rate?</li>
</ul>
<p>Let’s see how this works be walking through the approach DeepSeek used: First, we choose our learning rate schedule, ideally WSD for its flexibility. Then, we train models across a range of compute budgets (e.g., 1e17, 5e17, 1e18, 5e18, 1e19, 2e19 FLOPs) with different combinations of batch sizes and learning rates. In simpler terms: we train different model sizes for different numbers of tokens, testing different hyperparameter settings. This is where the WSD schedule shines, we can extend the same training run to different token counts without restarting.</p>
<p>For each setup, we perform sweeps over learning rate and batch size and identify the configurations that result in near-optimal performance, typically defined as being within a small margin (e.g., 0.25%) of the best validation loss (computed on an independent validation set, with a similar distribution to the training set). Each near-optimal configuration gives us a data point — a tuple of (compute budget C, optimal learning rate η) or (C, optimal batch size B). When plotted on a log-log scale, these relationships typically follow power-law behavior, appearing as approximately straight lines (as shown in the figure above). By fitting these data points, we can extract scaling laws that describe how optimal hyperparameters evolve with compute.</p>
<p>An important finding from this process is that for a fixed model size and compute budget, performance remains stable across a wide range of hyperparameters. This means there’s a broad sweet spot rather than a narrow optimum. We don’t need to find the perfect value, just a value that’s close enough, which makes the whole process much more practical.</p>
<p>Here you can see the results of the scaling laws DeepSeek derived, where each dot represents a near optimal setting:</p>
<div class="ri-root" data-ri-root="ri_3ynwqd792hm" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/image_2471384e-bcac-8059-84a4-d4ce5ae3847c.2mT4C1Dr_1a8Vp7.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/image_2471384e-bcac-8059-84a4-d4ce5ae3847c.2mT4C1Dr.png" data-astro-cid-6kov3kig width="1800" height="814" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script> 
<p>The core intuition behind these results is that as training becomes larger and longer, we want  <strong>more stable updates</strong>  (hence, smaller learning rates) and  <strong>more efficient gradient estimation</strong>  (hence, larger batch sizes).</p>
<p>These scaling laws give us starting points for the learning rate and batch size. But the objective is not “optimal samples per gradient” but “lower loss reachable within our time and number of GPUd constraint” while still extracting the full signal from every token.</p>
<p>In practice, you may be able to increase the batch size beyond the predicted optimal batch size to significantly improve throughput without meaningfully hurting data efficiency, up to the critical batch size we discussed earlier.</p>
<h4 id="smollm3-1"><a href="#smollm3-1">SmolLM3</a></h4>
<p>So what did we end up using for SmolLM3? At the time of ablations before launching SmolLM3, we compared AdamW, AdEMAMix, and Muon on a 1B model trained on 100B tokens. Muon could outperform AdamW when properly tuned but was sensitive to learning rate and prone to divergence. AdeMaMix was less sensitive and achieved similar loss to Muon. AdamW was the most stable but reached a higher final loss than the tuned alternatives.</p>
<p>However, when we scaled up to 3B, we encountered more frequent divergence with Muon and AdeMaMix. This may have been due to a parallelism bug we discovered after finishing the ablations (see The Training Marathon chapter), though we haven’t confirmed this. We decided to use AdamW (beta1: 0.9, beta2: 0.95) with weight decay 0.1 and gradient clipping 1. After all a very vanilla setting.</p>
<p>For the learning rate schedule, we chose WSD. We had used it successfully in SmolLM2, and it proved to be one of our best decisions for ease of use and flexibility regarding total training duration plus the ability to run mid-training decay experiments. We ran learning rate sweeps and settled on 2e-4. For the global batch size, we tested values from 2M to 4M tokens but found minimal impact on the loss or downstream performance, so we chose 2.36M tokens - the size that gave us the best throughput.</p>
<h4 id="rules-of-engagement-2"><a href="#rules-of-engagement-2">Rules of engagement</a></h4>
<blockquote class="quote" data-astro-cid-arj5dyob> <div class="quote__text" data-astro-cid-arj5dyob> <p><b>TL;DR:</b> Balance exploration and execution, done is better than perfect.</p> </div>  </blockquote> 
<p>We’ve talked a lot about the “what” (optimizer, learning rate, batch size) but just as important is the  <strong>how</strong> . How do we decide what’s worth experimenting with? How do we structure our time? When do we stop exploring and just train?</p>
<p><strong>Allocate your time wisely between exploration and execution.</strong>  Spending weeks perfecting a minor improvement from a new method is less valuable than investing that same compute in better data curation or more thorough architecture ablations. From our experience, and though it might disappoint architecture enthusiasts, the biggest performance gains usually come from data curation.</p>
<p><strong>When in doubt, choose flexibility and stability over peak performance.</strong>  If two methods perform equally well, pick the one that offers more flexibility or that has better implementation maturity and stability. A learning rate schedule like WSD that lets us extend training or run mid-training experiments is more valuable than a rigid schedule that might converge slightly better.</p>
<p><strong>Know when to stop optimizing and start training.</strong>  There’s always one more hyperparameter to tune or one more optimizer to try. Set a deadline for exploration and stick to it - the model we actually finish training will always beat the perfect model we never start.</p>
<div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <div class="ri-root" data-ri-root="ri_i9vsr7iqur" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/Capture_decran_2025-10-27_a_22_10_05_2991384e-bcac-802a-a6e6-dab0f9f410ec.CKOEFjcT_b6hhb.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/Capture_decran_2025-10-27_a_22_10_05_2991384e-bcac-802a-a6e6-dab0f9f410ec.CKOEFjcT.png" data-astro-cid-6kov3kig width="623" height="933" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script>  </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>One more ablation won't hurt (Spoiler: It did). Credits to <a href='[https://x.com/sea_snell/status/1905163154596012238](https://x.com/sea_snell/status/1905163154596012238)'>

sea_snell</a></figcaption> </figure> </div> 
<p>Perfect is the enemy of good, especially when we’re working with finite compute budgets and deadlines.</p>
<h3 id="scaling-laws-how-many-parameters-how-much-data"><a href="#scaling-laws-how-many-parameters-how-much-data">Scaling laws: how many parameters, how much data?</a></h3>
<p>In the early days of deep learning, before language models (and the clusters they were trained on) were “large”, training runs were often not heavily constrained by compute. When training a model, you’d just pick the largest model and batch size that fit on your hardware and then train until the model started overfitting or you ran out of data. However, even in these early days there was a sense that scale was helpful — for example, <a href="https://arxiv.org/abs/1712.00409">Hestness et al.</a> provided a comprehensive set of results in 2017 showing that training larger models for longer produced predictable gains.</p>
<p>In the era of large language models, we are  <em>always</em>  compute-constrained. Why? These early notions of scalability were formalized by <a href="https://arxiv.org/abs/2001.08361">Kaplan et al.’s work on Scaling Laws for Neural Language Models</a>, where it was shown that language model performance is remarkably predictable across many orders of magnitude of scale. This set off an explosion in the size and training duration of language models, because it provided a way to  <em>accurately predict</em> how much performance would improve from increasing scale. Consequently, the race to build better language models became a race to train larger models on larger amounts of data with ever-growing compute budgets, and the development of language models quickly became compute-constrained.</p>
<p>When faced with compute constraints, the most important question is whether to train a larger model or to train on more data. Surprisingly, Kaplan et al.’s scaling laws suggested that it was advantageous to allocate much more compute towards model scale than previous best practices — motivating, for example, training the gargantuan (175B parameters) GPT-3 model on a relatively modest token budget (300B tokens). On reexamination, <a href="https://arxiv.org/abs/2203.15556">Hoffman et al.</a> found a methodological issue with Kaplan et al.’s approach, ultimately re-deriving scaling laws that suggested allocating much more compute to training duration which indicated, for example, that compute-optimal training of the 175B-parameter GPT-3 should have consumed 3.7T tokens!</p>
<p>This shifted the field from “make models bigger” to “train them longer and better.” However, most modern trainings still don’t strictly follow the Chinchilla laws, because they have an shortcoming: They aim to predict the model size and  <em>training</em>  duration that achieves the best performance given a certain compute budget, but they fail to account for the fact that larger models are more expensive  <em>after</em>  training. Put another way, we might actually prefer to use a given compute budget train a smaller model for longer — even if this isn’t “compute-optimal” — because this will make inference costs cheaper (<a href="https://arxiv.org/abs/2401.00448">Sardana et al.</a>, <a href="https://www.harmdevries.com/post/model-size-vs-compute-overhead/">de Vries</a>). This could be the case if we expect that a model will be see a lot of inference usage (for example, because it’s being released openly 🤗). Recently, this practice of “overtraining” models beyond the training duration suggested by scaling laws has become standard practice, and is the approach we took when developing SmolLM3.</p>
<p>While scaling laws provide a suggestion for the model size and training duration given a particular compute budget, choosing to overtrain means you have to decide these factors yourself. For SmolLM3, we started by picking a target model size of 3 billion parameters. Based on recent models of a similar scale like Qwen3 4B, Gemma 3 4B, and Llama 3.2 3B, we considered 3B to be large enough to have meaningful capabilities (such as reasoning and tool calling), but small enough to enable super fast inference and efficient local usage. To pick a training duration, we first noted that recent models have been  <em>extremely</em>  overtrained — for example, the aforementioned Qwen3 series is claimed to have been trained for 36T tokens! As a result, training duration is often dictated by the amount of compute available. We secured 384 H100s roughly a month, which provided a budget for training on 11 trillion tokens (assuming an MFU of ~30%).</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty>  <div class="note__title" data-astro-cid-qg6lmfty>Scaling laws</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Despite these deviations, scaling laws remain practically valuable.
They provide baselines for experimental design,
people often use Chinchilla-optimal setups to get signal on ablations,
and they help predict whether a model size can reach a target performance.
As de Vries notes in this <a href="[https://www.harmdevries.com/post/model-size-vs-compute-overhead/](https://www.harmdevries.com/post/model-size-vs-compute-overhead/)" target="_blank">blog</a>,
by scaling down model size you can hit a critical model size: the minimal capacity required to reach a given loss,
below which you start getting diminishing return.</p> </div> </div> </div> 
<p>Now that we’re settled on our model architecture, training setup, model size, and training duration, we need to prepare two critical components: the data mixture that will teach our model, and the infrastructure that will train it reliably. With SmolLM3’s architecture set at 3B parameters, we needed to curate a data mixture that would deliver strong multilingual, math and code performance, and set up infrastructure robust enough for 11 trillion tokens of training. Getting these fundamentals right is essential, even the best architectural choices won’t save us from poor data curation or unstable training systems.</p>
<h2 id="the-art-of-data-curation"><a href="#the-art-of-data-curation">The art of data curation</a></h2>
<p>Picture this: you’ve spent weeks perfecting your architecture, tuning hyperparameters, and setting up the most robust training infrastructure. Your model converges beautifully, and then… it can’t write coherent code, struggles with basic math, and maybe even switches languages mid-sentence. What went wrong?
The answer usually lies in the data. While we obsess over fancy architectural innovations and hyperparameter sweeps, data curation often determines whether our model becomes genuinely useful or just another expensive experiment. It’s the difference between training on random web crawls versus carefully curated, high-quality datasets that actually teach the skills we want our model to learn.</p>
<p>If model architecture defines  <em>how</em>  your model learns, then data defines  <em>what</em>  it learns, and no amount of compute or optimizer tuning can compensate for training on the wrong content. Moreover, getting the training data right isn’t just about having good datasets. It’s about assembling the right  <strong>mixture</strong> : balancing conflicting objectives (like strong English vs. robust multilinguality) and tuning data proportions to align with our performance goals. This process is less about finding a universal best mix and more about asking the right questions and devising concrete plans to answer them:</p>
<ul>
<li>What do we want our model to be good at?</li>
<li>Which datasets are best for each domain and how do we mix them?</li>
<li>Do we have enough high-quality data for our target training scale?</li>
</ul>
<p>This section is about navigating these questions using a mix of principled methods, ablation experiments, and a little bit of alchemy, to turn a pile of great datasets into a great training mixture.</p>
<h3 id="whats-a-good-data-mixture-and-why-it-matters-most"><a href="#whats-a-good-data-mixture-and-why-it-matters-most">What’s a good data mixture and why it matters most</a></h3>
<p>We expect a lot from our language models, they should be able to help us write code, give us advice, answer questions about pretty much anything, complete tasks using tools, and more. Plentiful pre-training data sources like the web don’t cover the full range of knowledge and capabilities needed for these tasks. As a result, recent models additionally rely on more specialized pre-training datasets that target specific domains like math and coding. We have done a lot of past work on curating datasets, but for SmolLM3 we primarily made use of preexisting datasets. To learn more about dataset curation, check out our reports on building <a href="https://huggingface.co/spaces/HuggingFaceFW/blogpost-fineweb-v1">FineWeb and FineWeb-Edu</a>, <a href="https://arxiv.org/abs/2506.20920">FineWeb2</a>, <a href="https://arxiv.org/abs/2502.02737">Stack-Edu, and FineMath</a>.</p>
<h4 id="the-unintuitive-nature-of-data-mixtures"><a href="#the-unintuitive-nature-of-data-mixtures"><strong>The unintuitive nature of data mixtures</strong></a></h4>
<p>If you’re new to training language models, finding a good data mixture might seem straightforward: identify your target capabilities, gather high-quality datasets for each domain, and combine them. The reality is more complex, since some domains might compete with each other for your training budget. When focusing on some particular capability like coding, it can be tempting to upweight task-relevant data like source code. However, upweighting one source implicitly downweights all of the other sources, which can harm the language model’s capabilities in other settings. Training on a collection of different sources therefore involves striking some kind of balance between downstream capabilities.</p>
<p>Additionally, across all of these sources and domains, there’s often a subset of “high-quality” data that is especially helpful at improving the language model’s capabilities. Why not just throw out all the lower quality data and train on the highest quality data only? For SmolLM3’s large training budget of 11T tokens, doing such extreme filtering would result in repeating data many times. Prior work has shown that this kind of repetition can be harmful <span class="" id="citation--muennighoff2025scalingdataconstrainedlanguagemodels--102">(<a href="https://arxiv.org/abs/2305.16264" id="refctx-bib-muennighoff2025scalingdataconstrainedlanguagemodels-1" data-ref-id="bib-muennighoff2025scalingdataconstrainedlanguagemodels" target="_blank" rel="noopener noreferrer">Muennighoff et al., 2025</a>)</span>, so we should ideally be able to make use of higher and lower quality while still maximizing model performance.</p>
<p>To balance data across sources and make use of high-quality data, we need to carefully design the  <em>mixture</em> : the relative proportion of training documents from each source. Since a language model’s performance on some particular task or domain depends heavily on the amount of data it saw that is relevant to that task, tuning the mixing weights provides a direct way of balancing the model’s capabilities across domains. Because these trade-offs are model-dependent and difficult to predict, ablations are essential.</p>
<p>But the mixture doesn’t have to stay fixed throughout training. By adjusting the mixture as training progresses, what we call  <strong>multi-stage training</strong> <span class="" id="citation--smollm2--103">(<a href="https://arxiv.org/abs/2502.02737" id="refctx-bib-smollm2-2" data-ref-id="bib-smollm2" target="_blank" rel="noopener noreferrer">Allal et al., 2025</a>)</span> or curriculum, we can make better use of both high-quality and lower-quality data.</p>
<h4 id="the-evolution-of-training-curricula"><a href="#the-evolution-of-training-curricula"><strong>The evolution of training curricula</strong></a></h4>
<p>In the early days of large language model training, the standard approach was to fix a single data mixture for the entire training run. Models like GPT3 and early versions of Llama trained on a static mixture from start to finish. More recently, the field has shifted toward  <strong>multi-stage training</strong>  where the data mixture changes over the course of training. The main motivation is that a language model’s final behavior is strongly influenced by data seen toward the end of training <span class="" id="citation--chen2025scalinglawspredictingdownstream--104">(<a href="https://arxiv.org/abs/2410.08527" id="refctx-bib-chen2025scalinglawspredictingdownstream-1" data-ref-id="bib-chen2025scalinglawspredictingdownstream" target="_blank" rel="noopener noreferrer">Y. Chen et al., 2025b</a>)</span>. This insight enables a practical strategy: upweighting more plentiful sources early in training and mixing in smaller, higher quality sources towards the end.</p>
<p>A common question is: how do you decide when to change the mixture? While there’s no universal rule, but we typically follow these principles:</p>
<ol>
<li><strong>Performance-driven interventions</strong> : Monitor evaluation metrics on key benchmarks and adapt dataset mixtures to address specific capability bottlenecks. For example, if math performance plateaus while other capabilities continue improving, that’s a signal to introduce higher-quality math data.</li>
<li><strong>Reserve high-quality data for late stages</strong> : small high quality math and code datasets are most impactful when introduced during the annealing phase (final stage with learning rate decay).</li>
</ol>
<p>Now that we’ve established why mixtures matter and how curricula work, let’s discuss how to tune both.</p>
<h3 id="ablation-setup-how-to-systematically-test-data-recipes"><a href="#ablation-setup-how-to-systematically-test-data-recipes">Ablation setup: how to systematically test data recipes</a></h3>
<p>When testing data mixtures, our approach is similar to how we run architecture ablations, with one difference: we try to run them at the target model scale. Small and large models have different capacities, for example a very small model might struggle to handle many languages, while a larger one can absorb them without sacrificing performance elsewhere. Therefore running data ablations at too small a scale risks drawing the wrong conclusions about the optimal mix.</p>
<p>For SmolLM3, we ran our main data ablations directly on the 3B model, using shorter training runs of 50B and 100B tokens. We also used another type of ablation setup: <em><strong>annealing experiments</strong></em> . Instead of training from scratch with different mixtures, we took an intermediate checkpoint from the main run (for example at 7T tokens) and continued training with modified data compositions. This approach, allows us to test data mixture changes for doing multi-stage training (i.e changing the training mixture mid-training), and was used in recent work such as SmolLM2, Llama3 and Olmo2. For evaluation, we expanded our benchmark suite to include multilingual tasks alongside our standard English evaluations, ensuring we could properly assess the trade-offs between different language ratios.</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-3750k5f5nkj"><div class="ablation-study-charts"></div>
<style>
    .ablation-study-charts {
        position: relative;
    }

    .ablation-study-charts .axis-label {
        fill: var(--text-color);
        font-size: 12px;
        font-weight: 700;
    }

    .ablation-study-charts .axes path,
    .ablation-study-charts .axes line {
        stroke: var(--axis-color);
    }

    .ablation-study-charts .axes text {
        fill: var(--tick-color);
    }

    .ablation-study-charts .grid line {
        stroke: var(--grid-color);
    }

    .ablation-study-charts .chart-card {
        background: var(--page-bg);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 16px;
    }

    .ablation-study-charts .chart-title {
        font-size: 18px;
        font-weight: 600;
        color: #9b87d8;
        margin-bottom: 24px;
        letter-spacing: -0.01em;
        text-align: center;
    }

    .ablation-study-charts .lines path {
        stroke-width: 4;
        stroke-linecap: round;
        stroke-linejoin: round;
    }

    .ablation-study-charts .d3-tooltip {
        z-index: var(--z-elevated);
        backdrop-filter: saturate(1.12) blur(8px);
    }

    .ablation-study-charts .d3-tooltip__inner {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 220px;
    }

    .ablation-study-charts .d3-tooltip__inner>div:first-child {
        font-weight: 800;
        letter-spacing: 0.1px;
        margin-bottom: 0;
    }

    .ablation-study-charts .d3-tooltip__inner>div:nth-child(2) {
        font-size: 11px;
        color: var(--muted-color);
        display: block;
        margin-top: -4px;
        margin-bottom: 2px;
        letter-spacing: 0.1px;
    }

    .ablation-study-charts .d3-tooltip__color-dot {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 3px;
        border: 1px solid var(--border-color);
    }
</style>
<script>
    (() => {
        // Prevent multiple executions
        if (window.ablationStudyInitialized) return;
        window.ablationStudyInitialized = true;

        const ensureD3 = (cb) => {
            if (window.d3 && typeof window.d3.select === 'function') return cb();
            let s = document.getElementById('d3-cdn-script');
            if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
            const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
            s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
        };

        const bootstrapAblationStudy = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;
            if (!(container && container.classList && container.classList.contains('ablation-study-charts'))) {
                const cs = Array.from(document.querySelectorAll('.ablation-study-charts')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
                container = cs[cs.length - 1] || null;
            }
            if (!container) return;
            if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

            // Tooltip
            container.style.position = container.style.position || 'relative';
            let tip = container.querySelector('.d3-tooltip'); let tipInner;
            if (!tip) {
                tip = document.createElement('div'); tip.className = 'd3-tooltip';
                Object.assign(tip.style, {
                    position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
                    padding: '8px 10px', borderRadius: '8px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
                    background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 4px 24px rgba(0,0,0,.18)', opacity: '0', transition: 'opacity .12s ease'
                });
                tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
            } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

            // Create two chart containers
            const leftChart = document.createElement('div');
            leftChart.className = 'chart-container';
            leftChart.innerHTML = `
        <div class="chart-title">From scratch ablation</div>
        <div class="chart-card">
          <div class="chart-svg"></div>
        </div>
      `;

            const rightChart = document.createElement('div');
            rightChart.className = 'chart-container';
            rightChart.innerHTML = `
        <div class="chart-title">Annealing ablation (vs Main pretraining)</div>
        <div class="chart-card">
          <div class="chart-svg"></div>
        </div>
      `;

            // Style the containers
            const style = document.createElement('style');
            style.textContent = `
        .ablation-study-charts { 
          display: flex; 
          gap: 20px; 
          padding: 20px; 
          width: 100%; 
          box-sizing: border-box;
        }
        .ablation-study-charts .chart-container { 
          text-align: center; 
          display: flex;
          flex-direction: column;
          flex: 1;
        }
        .ablation-study-charts .chart-container:first-child { 
          flex: 0 0 40%; 
        }
        .ablation-study-charts .chart-container:last-child { 
          flex: 0 0 60%; 
        }
        .ablation-study-charts .chart-svg { 
          width: 100%; 
          height: 200px; 
        }
        .ablation-study-charts .chart-title {
          color: var(--text-color) !important;
        }
        .ablation-study-charts .chart-subtitle {
          font-size: 14px;
          color: var(--muted-color);
          margin-bottom: 16px;
          font-weight: 400;
        }
        @media (max-width: 768px) {
          .ablation-study-charts { 
            flex-direction: column; 
            gap: 40px; 
          }
          .ablation-study-charts .chart-container:first-child,
          .ablation-study-charts .chart-container:last-child { 
            flex: 1 1 100%; 
          }
        }
      `;
            document.head.appendChild(style);

            container.appendChild(leftChart);
            container.appendChild(rightChart);

            const d3 = window.d3;

            // Colors - use categorical palette
            let currentColors = [];

            function refreshPalette() {
                try {
                    if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
                        const colors = window.ColorPalettes.getColors('categorical', 3);
                        if (colors && colors.length >= 3) {
                            // Force the second color (Main pretraining) to be gray, keep first vibrant
                            colors[1] = '#888888';
                            currentColors = colors;
                            return;
                        }
                    }
                } catch (_) { }
                // Fallback colors - vibrant for ablations, gray for main pretraining
                currentColors = ['#e74c3c', '#888888', '#f39c12'];
            }

            function getColors() {
                return currentColors;
            }

            // Initialize palette
            refreshPalette();
            document.addEventListener('palettes:updated', refreshPalette);

            // Create chart function
            function createChart(chartContainer, dataUrl, title, width, height) {
                const svgContainer = chartContainer.querySelector('.chart-svg');
                const titleEl = chartContainer.querySelector('.chart-title');
                titleEl.textContent = title;

                // Create SVG
                const svg = d3.select(svgContainer).append('svg').attr('width', '100%').attr('height', height).style('display', 'block');
                const gRoot = svg.append('g');
                const gGrid = gRoot.append('g').attr('class', 'grid');
                const gAxes = gRoot.append('g').attr('class', 'axes');
                const gLines = gRoot.append('g').attr('class', 'lines');

                // State/data
                const margin = { top: 20, right: 40, bottom: 50, left: 60 };
                const xScale = d3.scaleLinear();
                const yScale = d3.scaleLinear();
                const lineGen = d3.line().x(d => xScale(d.tokens)).y(d => yScale(d.learning_rate)).curve(d3.curveLinear);

                // Simple data points
                let data = [];
                if (title.includes('From scratch')) {
                    // From scratch: 0 -> plateau -> 0 at 100B
                    data = [
                        { run: 'From scratch', tokens: 0, learning_rate: 0 },
                        { run: 'From scratch', tokens: 5e9, learning_rate: 0.0002 },
                        { run: 'From scratch', tokens: 85e9, learning_rate: 0.0002 },
                        { run: 'From scratch', tokens: 100e9, learning_rate: 0 }
                    ];
                } else {
                    // Annealing: Main pretraining + Ablation decay
                    data = [
                        // Main pretraining (goes to 11T)
                        { run: 'Main pretraining', tokens: 0, learning_rate: 0 },
                        { run: 'Main pretraining', tokens: 0.12e12, learning_rate: 0.0002 },
                        { run: 'Main pretraining', tokens: 8e12, learning_rate: 0.0002 },
                        { run: 'Main pretraining', tokens: 11e12, learning_rate: 0 },

                        // Ablation decay (starts at plateau, then decays at 7.1T)
                        { run: 'Ablation decay', tokens: 6.4e12, learning_rate: 0.0002 },
                        { run: 'Ablation decay', tokens: 7.1e12, learning_rate: 0 }
                    ];
                }

                function updateLayout() {
                    const containerWidth = svgContainer.clientWidth || width;
                    const containerHeight = height;
                    svg.attr('width', containerWidth).attr('height', containerHeight);
                    gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
                    const innerWidth = containerWidth - margin.left - margin.right;
                    const innerHeight = containerHeight - margin.top - margin.bottom;
                    return { innerWidth, innerHeight };
                }

                function render() {
                    const { innerWidth, innerHeight } = updateLayout();

                    // Group by run
                    const dataByRun = {};
                    const runList = Array.from(new Set(data.map(d => d.run))).sort();
                    runList.forEach(run => { dataByRun[run] = []; });
                    data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
                    runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

                    // Prepare series data
                    const series = runList.map(run => ({
                        name: run,
                        values: dataByRun[run]
                    }));

                    // domains
                    const minTokens = d3.min(data, d => d.tokens);
                    const maxTokens = d3.max(data, d => d.tokens);
                    const minLR = 0;
                    const maxLR = d3.max(data, d => d.learning_rate);

                    xScale.domain([minTokens, maxTokens]).range([0, innerWidth]);
                    yScale.domain([minLR, maxLR * 1.1]).range([innerHeight, 0]);

                    // grid
                    gGrid.selectAll('*').remove();
                    gGrid.selectAll('line').data(yScale.ticks(5)).join('line')
                        .attr('x1', 0).attr('x2', innerWidth).attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
                        .attr('stroke', 'var(--grid-color)').attr('stroke-width', 1).attr('shape-rendering', 'crispEdges');

                    // axes
                    gAxes.selectAll('*').remove();

                    // Custom ticks based on chart type
                    let xTicks;
                    let tickFormat;
                    if (title.includes('From scratch')) {
                        // From scratch: 0, 100B (where data reaches 0)
                        xTicks = [0, 100e9];
                        tickFormat = d => d === 0 ? '0' : '100B';
                    } else {
                        // Annealing: 0, 7.1T, 11T (where data reaches 0)
                        xTicks = [0, 7.1e12, 11e12];
                        tickFormat = d => {
                            if (d === 0) return '0';
                            if (d === 7.1e12) return '7.1T';
                            if (d === 11e12) return '11T';
                            return '';
                        };
                    }

                    gAxes.append('g').attr('transform', `translate(0,${innerHeight})`)
                        .call(d3.axisBottom(xScale).tickValues(xTicks).tickFormat(tickFormat).tickSizeOuter(0))
                        .call(g => {
                            g.selectAll('path, line').attr('stroke', 'var(--axis-color)');
                            g.selectAll('text').attr('fill', 'var(--tick-color)').style('font-size', '12px');
                        });

                    // Y-axis: no ticks, just arrows
                    gAxes.append('g').call(d3.axisLeft(yScale).tickValues([]).tickSizeOuter(0))
                        .call(g => { g.selectAll('path, line').attr('stroke', 'var(--axis-color)'); });

                    gAxes.append('text').attr('class', 'axis-label').attr('text-anchor', 'middle').attr('x', innerWidth / 2).attr('y', innerHeight + 40).text('Tokens');
                    gAxes.append('text').attr('class', 'axis-label').attr('text-anchor', 'middle').attr('transform', `translate(${-50}, ${innerHeight / 2}) rotate(-90)`).text('Learning rate');

                    // lines
                    gLines.selectAll('*').remove();
                    const colors = getColors();
                    series.forEach((s, i) => {
                        gLines.append('path')
                            .attr('class', `line line-${i}`)
                            .attr('data-series', s.name)
                            .attr('fill', 'none')
                            .attr('stroke', colors[i % colors.length])
                            .attr('stroke-width', 4)
                            .attr('stroke-linecap', 'round')
                            .attr('stroke-linejoin', 'round')
                            .attr('d', lineGen(s.values));
                    });

                    // No hover functionality
                }

                // Initial render
                render();

                const rerender = () => render();
                if (window.ResizeObserver) {
                    const ro = new ResizeObserver(() => rerender());
                    ro.observe(svgContainer);
                } else {
                    window.addEventListener('resize', rerender);
                }
            }

            // Create both charts
            createChart(leftChart, '', 'From scratch ablation', 500, 200);
            createChart(rightChart, '', 'Annealing ablation (vs Main pretraining)', 900, 200);
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrapAblationStudy), { once: true });
        } else {
            ensureD3(bootstrapAblationStudy);
        }
    })();
</script></div></div></figure> </div>
<p>Recent work has proposed automated approaches for finding optimal data proportions, including:</p>
<ul>
<li><strong>DoReMi</strong>  <span class="" id="citation--xie2023doremioptimizingdatamixtures--105">(<a href="https://arxiv.org/abs/2305.10429" id="refctx-bib-xie2023doremioptimizingdatamixtures-1" data-ref-id="bib-xie2023doremioptimizingdatamixtures" target="_blank" rel="noopener noreferrer">Xie et al., 2023</a>)</span>: Uses a small proxy model to learn domain weights that minimize validation loss</li>
<li><strong>Rho Loss</strong>  <span class="" id="citation--mindermann2022prioritizedtrainingpointslearnable--106">(<a href="https://arxiv.org/abs/2206.07137" id="refctx-bib-mindermann2022prioritizedtrainingpointslearnable-1" data-ref-id="bib-mindermann2022prioritizedtrainingpointslearnable" target="_blank" rel="noopener noreferrer">Mindermann et al., 2022</a>)</span>: Selects individual training points based on a holdout loss, prioritizing samples that are learnable, task-relevant, and not yet learned by the model</li>
<li><strong>RegMix</strong>  <span class="" id="citation--liu2025regmixdatamixtureregression--107">(<a href="https://arxiv.org/abs/2407.01492" id="refctx-bib-liu2025regmixdatamixtureregression-1" data-ref-id="bib-liu2025regmixdatamixtureregression" target="_blank" rel="noopener noreferrer">Q. Liu et al., 2025</a>)</span>: Determines optimal data mixture proportions through regularized regression that balances performance across multiple evaluation objectives and data domains</li>
</ul>
<p>We experimented with DoReMi and Rho Loss in past projects, but found they tend to converge toward distributions that roughly mirror the natural distribution of dataset sizes, essentially suggesting to use more of what we have more of. While theoretically appealing, they didn’t outperform careful manual ablations in our setting. Recent SOTA models still rely on manual mixture tuning through systematic ablations and annealing experiments, which is the approach we adopted for SmolLM3.</p>
<h3 id="smollm3-curating-the-data-mixture-web-multilingual-math-code"><a href="#smollm3-curating-the-data-mixture-web-multilingual-math-code">SmolLM3: Curating the data mixture (web, multilingual, math, code)</a></h3>
<p>For SmolLM3, we wanted a model that can handle English and multiple other languages, and excel in math and code. These domains — web text, multilingual content, code and math — are common in most LLMs, but the process we’ll describe here applies equally if you’re training for a low-resource language or a specific domain such as finance or healthcare. The method is the same: identify good candidate datasets, run ablations, and design a mixture that balances all the target domains.</p>
<p>We won’t cover how to build high-quality datasets here, since we’ve already detailed that extensively in earlier work (FineWeb, FineWeb2, FineMath and Stack-Edu). Instead, this section focuses on how we  <em>combine</em>  those datasets into an effective pretraining mixture.</p>
<h4 id="building-on-proven-foundations"><a href="#building-on-proven-foundations"><strong>Building on Proven Foundations</strong></a></h4>
<p>When it comes to pretraining data, the good news is that we rarely have to start from scratch. The open-source community has already built strong datasets for most common domains. Sometimes we will need to create something new — as we did with the Fine series (FineWeb, FineMath, etc.) — but more often, the challenge is in selecting and combining existing sources rather than reinventing them.</p>
<p>That was our situation with SmolLM3. SmolLM2 had already established a strong recipe at 1.7B parameters for English web data, and identified the best math and code datasets we had access to. Our goal was to scale that success to 3B while adding the certain capabilities: robust multilinguality, stronger math reasoning, and better code generation.</p>
<h4 id="english-web-data-the-foundation-layer"><a href="#english-web-data-the-foundation-layer"><strong>English Web Data: The Foundation Layer</strong></a></h4>
<p>Web text forms the backbone of any general-purpose LLM, but quality matters as much as quantity.</p>
<p>From SmolLM3, we knew that FineWeb-Edu and DCLM were the strongest open English web datasets at the time of training. Together, they gave us 5.1T tokens of high-quality English web data. The question was: what’s the optimal mixing ratio? FineWeb-Edu helps on educational and  STEM benchmarks, while DCLM improves commonsense reasoning.</p>
<p>Following the SmolLM2 methodology, we ran a sweep on our 3B model over 100B tokens, testing ratios of 20/80, 40/60, 50/50, 60/40, and 80/20 (FineWeb-Edu/DCLM).  Mixing them (around 60/40 or 50/50) gave the best trade-offs. We rerun the same ablations as the <a href="https://arxiv.org/abs/2502.02737v1">SmolLM2 paper</a> on our 3B model trained on 100B tokens and found the same conclusion.</p>
<p>Using 60/40 or 50/50  provided the best balance across benchmarks, matching our SmolLM2 findings. We used 50/50 ratio ratio for Stage 1.</p>
<p>We also added other datasets like <a href="https://huggingface.co/datasets/allenai/dolmino-mix-1124/tree/main/data/pes2o">Pes2o</a>, <a href="https://huggingface.co/datasets/allenai/dolmino-mix-1124/tree/main/data/wiki">Wikipedia &amp; Wikibooks</a> and <a href="https://huggingface.co/datasets/HuggingFaceTB/stackexchange_2025_md">StackExchange</a>, these datasets didn’t have any impact on the performance but we included them to improve diversity.</p>
<h4 id="multilingual-web-data"><a href="#multilingual-web-data"><strong>Multilingual Web Data</strong></a></h4>
<p>For multilingual capability, we targeted 5 other languages: French, Spanish, German, Italian, and Portuguese. We selected them from FineWeb2-HQ, which gave us 628B tokens total. We also included 10 other languages at smaller ratios, such as Chinese, Arabic, and Russian, not to target state of the art performance for them, but to allow people to easily do continual pretraining of SmolLM3 on them. We used FineWeb2 for the languages not supported in FineWeb2-HQ.</p>
<p>The key question was: how much of our web data should be non-English? We know that more data a model sees in a language or domain, the better it gets at that language or domain. The trade-off comes from our fixed compute budget: increasing data for one language means reducing data for the other languages including English.</p>
<p>Through ablations on the 3B model, we found that 12% multilingual content in the web mix struck the right balance, improving multilingual performance without degrading English benchmarks. This fit SmolLM3’s expected usage, where English would remain the primary language. It’s also worth noting that with only 628B tokens of non-English data versus 5.1T English tokens, going much higher would require doing more repetition of the multilingual data.</p>
<h4 id="code-data"><a href="#code-data"><strong>Code Data</strong></a></h4>
<p>Our code sources for Stage 1 are extracted from<a href="https://arxiv.org/abs/2402.19173"> The Stack v2 and StarCoder2 </a>training corpus:</p>
<ul>
<li><a href="https://huggingface.co/datasets/bigcode/the-stack-v2">The Stack v2</a> (16 languages) as our basis, filtered as StarCoder2Data.</li>
<li>StarCoder2 GitHub pull requests for real-world code review reasoning.</li>
<li>Jupyter and <a href="https://huggingface.co/datasets/HuggingFaceTB/issues-kaggle-notebooks">Kaggle notebooks</a> for executable, step-by-step workflows.</li>
<li><a href="https://huggingface.co/datasets/HuggingFaceTB/issues-kaggle-notebooks">GitHub issues</a> and <a href="https://huggingface.co/datasets/HuggingFaceTB/stackexchange_2025_md">StackExchange</a> threads for contextual discussions around code.</li>
</ul>
<p><span class="" id="citation--aryabumi2024codecodeexploringimpact--108"><a href="https://arxiv.org/abs/2408.10914" id="refctx-bib-aryabumi2024codecodeexploringimpact-1" data-ref-id="bib-aryabumi2024codecodeexploringimpact" target="_blank" rel="noopener noreferrer">Aryabumi et al. (2024)</a></span> highlight that code improves language models’ performance beyond coding, for example on natural language reasoning and world knowledge and recommend using 25% code in the training mixture. Motivated by this, we started our ablations with 25% code in the mixture.  However, we observed significant degradation on English benchmarks (HellaSwag, ARC-C, MMLU). Reducing to 10% code, we didn’t see improvements on our English benchmark suite compared to 0% code, but we included it anyway since code was a very important capability to have in the model.</p>
<p>We delayed adding Stack-Edu — our educationally filtered subset of StarCoder2Data — until later stages, following the principle of staging high-quality data for maximum late-training impact.</p>
<h4 id="math-data"><a href="#math-data"><strong>Math Data</strong></a></h4>
<p>Math followed a similar philosophy to code. Early on, we used the larger, more general sets FineMath3+ and InfiWebMath3+ and later we upsampled FineMath4+ and InfiWebMath4+, and introduced new high quality datasets:</p>
<ul>
<li>MegaMath <span class="" id="citation--zhou2025megamathpushinglimitsopen--109">(<a href="https://arxiv.org/abs/2504.02807" id="refctx-bib-zhou2025megamathpushinglimitsopen-1" data-ref-id="bib-zhou2025megamathpushinglimitsopen" target="_blank" rel="noopener noreferrer">Zhou et al., 2025</a>)</span></li>
<li>Instruction and reasoning datasets like OpenMathInstruct <span class="" id="citation--toshniwal2024openmathinstruct118millionmath--110">(<a href="https://arxiv.org/abs/2402.10176" id="refctx-bib-toshniwal2024openmathinstruct118millionmath-1" data-ref-id="bib-toshniwal2024openmathinstruct118millionmath" target="_blank" rel="noopener noreferrer">Toshniwal et al., 2024</a>)</span> and OpenMathReasoning <span class="" id="citation--moshkov2025aimo2winningsolutionbuilding--111">(<a href="https://arxiv.org/abs/2504.16891" id="refctx-bib-moshkov2025aimo2winningsolutionbuilding-1" data-ref-id="bib-moshkov2025aimo2winningsolutionbuilding" target="_blank" rel="noopener noreferrer">Moshkov et al., 2025</a>)</span></li>
</ul>
<p>We use 3% of math in Stage 1 equally split between FineMath3+ and InfiWebMath3+. With only 54B tokens available and an estimated 8T to 9T token Stage 1, using more than 3% math would require more than 5 epochs on the dataset.</p>
<h4 id="finding-the-right-mixture-for-new-stages"><a href="#finding-the-right-mixture-for-new-stages"><strong>Finding the right mixture for new stages</strong></a></h4>
<p>While we ran ablations from scratch to determine the stage 1 mixture, to test new datasets for new stages (in our case two new stages) we used annealing ablations: we took a checkpoint at around 7T tokens (late in stage 1) and ran a 50B token annealing experiments with the following setup:</p>
<ul>
<li><strong>40% baseline mixture</strong> : The exact stage 1 mixture we’d been training on</li>
<li><strong>60% new dataset</strong> : The candidate dataset we wanted to evaluate</li>
</ul>
<p>For example, to test whether MegaMath would improve our math performance, we ran 40% Stage 1 mixture (maintaining the 75/12/10/3 domain split) and 60% MegaMath.</p>
<p>The can find the composition of the 3 stages in the following section.</p>
<p>With our data carefully curated and our mixture validated through ablations, we’re ready to embark on the actual training journey. The chapter that follows is the story of SmolLM3’s month-long training run: the preparation, the unexpected challenges, and the lessons learned along the way.</p>
<h2 id="the-training-marathon"><a href="#the-training-marathon">The training marathon</a></h2>
<p>You’ve made it this far, congrats! The real fun is about to begin.</p>
<p>At this point, we have everything in place: a validated architecture, a finalized data mixture, and tuned hyperparameters. The only thing left is setting up the infrastructure and hitting “train”.</p>
<p>For SmolLM3, we trained on 384 H100 GPUs (48 nodes) for nearly a month, processing 11 trillion tokens. This section walks you through what actually happens during a long training run: the pre-flight checks, the inevitable surprises, and how we kept things stable. You’ll see firsthand why both solid ablation practices and reliable infrastructure matter. We cover the technical infrastructure details of GPU hardware, storage systems, and optimizing throughputs in the next chapter.</p>
<p>It’s a bit like setting off on a long road trip. We might have a perfect itinerary, but before we pull out of the driveway, we still check the car’s engine, tires, and fuel. LLM training is the same, even with all the prep work, there’s still a final round of sanity checks that can save us from unpleasant surprises mid-run.</p>
<p>Our team has been through this many times: from StarCoder and StarCoder2, to SmolLM, SmolLM2, and now SmolLM3. Every single run is different. Even if you’ve trained a dozen models, each new run finds a fresh way to surprise you. This section is about stacking the odds in your favor so you’re ready for those surprises.</p>
<h3 id="pre-flight-checklist-what-to-verify-before-hitting-train"><a href="#pre-flight-checklist-what-to-verify-before-hitting-train">Pre-flight checklist: What to verify before hitting “train”</a></h3>
<p>Before hitting “train”, we go through a checklist to ensure everything works end-to-end:</p>
<p><strong>Infrastructure readiness:</strong></p>
<ul>
<li>If your cluster supports reservations, use them. For SmolLM3, we had a fixed 48-node reservation for the entire run. That meant no queueing delays, consistent throughput, and the ability to track node health over time.</li>
<li>Stress-test GPUs before launch (we use <a href="https://github.com/huggingface/gpu-fryer">GPU Fryer</a> and <a href="https://docs.nvidia.com/datacenter/dcgm/latest/user-guide/dcgm-diagnostics.html">DCGM Diagnostics</a>) to catch throttling or performance degradation. For SmolLM3, we found two GPUs throttling and replaced them before starting the run.</li>
<li>Avoid storage bloat: our system uploads each checkpoint to S3, then deletes the local copy right after saving the next one, so we never store more than one on the fast local GPU SSDs.</li>
</ul>
<p><strong>Evaluation setup:</strong> Evaluations are deceptively time-consuming. Even with everything implemented, running them manually, logging results, and making plots can eat up hours each time. So try to automate them completely, and ensure they are running and logging correctly before the run starts. For SmolLM3, every saved checkpoint automatically triggered an evaluation job on the cluster that got logged to wandb/trackio.</p>
<p><strong>Checkpoint &amp; auto-resume system:</strong>  Verify that checkpoints are saved correctly and that the training job can resume from the latest one without manual intervention. On Slurm, we use  <code>--requeue</code>  option so a failed job gets automatically relaunched, resuming from the most recent checkpoint.</p>
<p><strong>Metrics logging:</strong>  Confirm that you’re logging all the metrics you care about: evaluation scores, throughput (tokens/sec), training loss, gradient norm, node health (GPU utilization, temperature, memory usage), and any custom debug metrics specific to your run.</p>
<p><strong>Training configuration sanity check:</strong> Double-check your training config, launch scripts, and Slurm submission commands.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty>  <div class="note__title" data-astro-cid-qg6lmfty>Infrastructure deep-dive</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>For detailed guidance on GPU testing, storage benchmarking, monitoring setup, and building resilient training systems, see the <a href="#infrastructure---the-unsung-hero">Infrastructure chapter</a>.</p> </div> </div> </div> 
<h3 id="scaling-surprises"><a href="#scaling-surprises">Scaling surprises</a></h3>
<p>After running extensive ablations for SmolLM3, we were ready for the full-scale run. Our 3B ablations on 100B tokens looked promising. The architectural changes compared to SmolLM2 (GQA, NoPE, document masking, tokenizer) either improved or maintained performance, and we found a good data mixture that balances English, multilingual, code, and math performance. We optimized our configuration for around 30% MFU on 384 GPUS (48 nodes).</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>We ran some ablations on 48 nodes to validate the throughput before launching the run. You can find more details about them in the Infrastructure chapter.</p> </aside> </div>  
<p>We were ready for the big one: 11T tokens. That’s when reality started throwing curveballs.</p>
<h4 id="mystery-1--the-vanishing-throughput"><a href="#mystery-1--the-vanishing-throughput"><strong>Mystery #1 – The vanishing throughput</strong></a></h4>
<p>Within hours of launch, throughput plummeted. It was a big jump with repeated sharp drops.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>Why throughput matters</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Throughput measures how many tokens per second our system processes during training. It directly impacts our training time, a 50% drop in throughput means our month-long run becomes a two-month run. In the Infrastructure chapter, we’ll show how we optimized throughput for SmolLM3 before starting the run.</p> </div> </div> </div> 
<figure class="html-embed"><div class="html-embed__card"><div id="frag-03nvrigwidky" data-config="{&#34;dataUrl&#34;:&#34;./data/throughput_weka_drops.csv&#34;,&#34;xColumn&#34;:&#34;step&#34;,&#34;yColumn&#34;:&#34;throughput&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;smoothing&#34;:false,&#34;xAxisLabel&#34;:&#34;Training Step&#34;,&#34;yAxisLabel&#34;:&#34;Tokens/sec/GPU&#34;,&#34;title&#34;:&#34;Throughput Weka Drops&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<p>This didn’t happen in any ablation run, so what changed? Three things:</p>
<ol>
<li>Hardware can develop issues, GPUs that worked fine in ablations might fail and network connections might degrade under sustained load.</li>
<li>We were now training on the full dataset instead of subsets: ~24 TB spanning dozens of web, code, math, and multilingual sources.</li>
<li>We set the real step count for 11T tokens instead of the short 100B-token ablation horizon.</li>
</ol>
<p>Intuitively, neither dataset size nor step count should cause throughput drops, so we naturally suspected hardware issues first. We checked our node monitoring metrics, which showed that the big throughput jump correlated with spikes in disk read latency. That pointed us straight at our data storage.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>Storage options in our cluster</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Our cluster has three storage tiers for training data:</p><ul>
<li><strong>FSx</strong> : Network-attached storage which uses <a href="https://www.weka.io/">Weka</a> a “keep-hot” caching model that stores frequently accessed files locally and evicts inactive “cold” files to S3 as capacity fills up.</li>
<li><strong>Scratch (Local NVMe RAID)</strong> : Fast local storage on each node (8×3.5TB NVMe drives in RAID), which is faster than FSx but limited to local node access.</li>
<li><strong>S3</strong> : Remote object storage for cold data and backups.</li>
</ul><p>You can find more details in the Infrastructure chapter.</p> </div> </div> </div> 
<p>For SmolLM3’s 24TB dataset, we initially stored the data in FSx (Weka). With 24TB of training data, on top of storage already used by several other teams, we were pushing Weka’s storage to the limit. So it started evicting dataset shards mid-training, which meant we had to fetch them back, creating stalls, which explained the big throughput jump. Worse: there was no way to pin our dataset folders as hot for the full training.</p>
<p><strong>Fix #1 – Changing data storage</strong></p>
<p>We didn’t find a way to pin our dataset folders as hot for the full training in Weka, so we tried to change the storage method. Streaming directly from S3 was slow, so we decided to store the data in each node in its local storage  <code>/scratch</code> .</p>
<p>This came with a catch: If a node died and was replaced, the new replacement GPUs had no data. Downloading 24TB from S3 with  <code>s5cmd</code>  took 3h. We cut that to 1h30 by copying from another healthy node using  <code>fpsync</code>  instead of going through S3. This was faster given all the nodes were in the same datacenter.</p>
<p>Still, 1h30 of downtime per node failure, and the need for manually copying the data to the new node immediately, was painful. The hack that finally made it bearable: reserve a spare node in our Slurm reservation with the dataset preloaded. If a node died, we swapped it instantly with the spare node, so zero recovery delay. While idle, the spare ran evals or dev jobs, so it wasn’t wasted.</p>
<p>This fixed Mystery #1… or so we thought.</p>
<h4 id="mystery-2--the-persisting-throughput-drops"><a href="#mystery-2--the-persisting-throughput-drops"><strong>Mystery #2 – The persisting throughput drops</strong></a></h4>
<p>Even after moving to scratch, the individual throughput drops kept happening although we didn’t find any anomaly in the hardware monitoring metrics. The chart below compares the throughput we got, after fixing the storage issue in orange, to the throughput we were getting during the ablations in blue. As you can see, the drops became much sharper.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-tbbdy1vhnc" data-config="{&#34;dataUrl&#34;:&#34;./data/throughput_drops_comparison.csv&#34;,&#34;xColumn&#34;:&#34;step&#34;,&#34;yColumn&#34;:&#34;throughput&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;smoothing&#34;:false,&#34;xAxisLabel&#34;:&#34;Training Step&#34;,&#34;yAxisLabel&#34;:&#34;Tokens/sec/GPU&#34;,&#34;title&#34;:&#34;Throughput Drops Comparison&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<p>Still suspecting hardware, we decided to test on fewer nodes. With 384 GPUs, there’s a high chance something could be failing. Surprisingly, we could reproduce the exact same throughput drops on a single node, no matter which specific node we tested. This ruled out hardware issues.</p>
<p>Remember the three things that changed from our ablations? We had already addressed the data storage issue by moving to local node storage. Hardware was now eliminated. That left only one variable: the step count. We tested this by rolling back to smaller step counts (from 3M to 32k) and the thoughput drops became smaller! Larger step counts produced sharper, more frequent drops.</p>
<p>Remember the three things that changed from our ablations? We had already addressed the data storage issue by moving to local node storage. Hardware was now eliminated. That left only one variable: the step count.</p>
<p>To test this, we ran identical configurations with only the training steps changed from 32k to 3.2M. You can see the <a href="https://huggingface.co/datasets/HuggingFaceTB/ablations-training-configs/tree/main/throughput_debugging">exact configs we used</a>:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="diff"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Short run (32k steps)</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7"><span style="user-select:none">-</span> &quot;lr_decay_starting_step&quot;: 2560000</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7"><span style="user-select:none">-</span> &quot;lr_decay_steps&quot;: 640000</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7"><span style="user-select:none">-</span> &quot;train_steps&quot;: 3200000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Long run (3.2M steps)</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D"><span style="user-select:none">+</span> &quot;lr_decay_starting_step&quot;: 26000</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D"><span style="user-select:none">+</span> &quot;lr_decay_steps&quot;: 6000</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D"><span style="user-select:none">+</span> &quot;train_steps&quot;: 32000</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div>
<p>The results shown in the figure below were clear: shorter runs had small throughput drops, while longer step counts produced sharper, more frequent drops. So the issue was not the hardware, but a software bottleneck, likely in the dataloader! Given that most other training components process each batch identically regardless of step count.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-43lrx353aeg" data-config="{&#34;dataUrl&#34;:&#34;./data/throughput_debug_1node_full.csv&#34;,&#34;xColumn&#34;:&#34;step&#34;,&#34;yColumn&#34;:&#34;throughput&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;smoothing&#34;:false,&#34;xAxisLabel&#34;:&#34;Training Step&#34;,&#34;yAxisLabel&#34;:&#34;Tokens/sec/GPU&#34;,&#34;title&#34;:&#34;Throughput Debug 1 Node&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<p>That’s when we realized we’d never actually done large-scale pretraining with nanotron’s dataloader. SmolLM2 had been trained with steady throughput using a Megatron-LM derived dataloader (<a href="https://github.com/huggingface/nanotron/blob/7bc9923285a03069ebffe994379a311aceaea546/src/nanotron/data/tokenized_bytes.py#L80">TokenizedBytes</a>) through an internal wrapper around nanotron. For SmolLM3, we switched to nanotron’s built-in dataloader ( <code>nanosets</code> ).</p>
<p>After deep diving into its implementation, we found that it was naively building one giant index that grew with each training step. For very large steps, this caused a higher shared memory which triggered throughput drops.</p>
<p><strong>Fix #2 – Bring in TokenizedBytes dataloader</strong></p>
<p>To confirm that the dataloader was indeed the culprit, we launched the same configuration with our internal SmolLM2 framework using  <code>TokenizedBytes</code>  dataloader. No drops. Even on 48 nodes using the same datasets.</p>
<p>Fastest path forward: copy this dataloader into nanotron. The drops were gone and the throughput back to target.</p>
<p>We were ready to relaunch… until the next curveball.</p>
<h4 id="mystery-3--the-noisy-loss"><a href="#mystery-3--the-noisy-loss"><strong>Mystery #3 – The noisy loss</strong></a></h4>
<p>With the new dataloader, we didn’t have throughput drops but the loss curve looked more noisy.</p>
<p><code>nanosets</code>  had been producing smoother loss, and the difference rang a bell from an old debugging war: a few years ago, we’d found a shuffling bug in our pretraining code where documents were shuffled, but sequences inside a batch were not, leading to small spikes.</p>
<p>Checking our new dataloader confirmed it: it was reading sequences sequentially from each document. That’s fine for short files, but with domains like code, a single long low-quality file can fill an entire batch and cause loss spikes.</p>
<p><strong>Fix #3 – Shuffle at the sequence level</strong></p>
<p>We had two options:</p>
<ol>
<li>Change the dataloader to do random access (risk: higher memory usage).</li>
<li>Pre-shuffle tokenized sequences offline.</li>
</ol>
<p>With the time pressure to start the run and our cluster reservation running, we went with option #2 as the safer, faster fix. Tokenized data was already on each node, so reshuffling locally was cheap (~1 h). We also generated shuffled sequences for each epoch with different seeds to avoid repeating shuffling patterns across epochs.</p>
<h4 id="launch-take-two"><a href="#launch-take-two"><strong>Launch, Take Two</strong></a></h4>
<p>By now we had:</p>
<ul>
<li><strong>Stable throughput</strong>  (scratch storage + spare node strategy)</li>
<li><strong>No step-count-induced drops</strong>  ( <code>TokenizedBytes</code>  dataloader)</li>
<li><strong>Clean, sequence-level shuffling</strong>  (offline pre-shuffle per epoch)</li>
</ul>
<p>We relaunched. This time, everything held. The loss curve was smooth, throughput was consistent, and we could finally focus on training instead of firefighting.</p>
<p><strong>Mystery #4 – Unsatisfactory performance</strong></p>
<p>After fixing the throughput and dataloader issues, we launched the run again and trained smoothly for the first two days. Throughput was stable, loss curves looked as expected, and nothing in the logs suggested any problems. At around the 1T token mark, however, the evaluations revealed something unexpected.</p>
<p>As part of our monitoring, we evaluate intermediate checkpoints and compare them to historical runs. For instance, we had the intermediate checkpoints from SmolLM2 (1.7B) trained on a similar recipe, so we could track how both models progressed at the same stages of training. The results were puzzling: despite having more parameters and a better data mixture, the 3B model was performing worse than the 1.7B at the same training point. Loss was still decreasing, and benchmark scores were improving, but the improvement rate was clearly below expectations.</p>
<p>Given that we had thoroughly tested every architecture and data change introduced in SmolLM3 compared to SmolLM2, we validated the training framework and there were only a few remaining untested differences between the two training setups. The most obvious was tensor parallelism. SmolLM2 could fit on a single GPU and was trained without TP, while SmolLM3 required TP=2 to fit in memory. We didn’t suspect it or think of testing it before, since TP was used in the 3B ablations and their results made sense.</p>
<p><strong>Fix #4 - The final fix</strong></p>
<p>To test the TP bug hypothesis, we trained a 1.7B model with the exact same setup as SmolLM3 — same architecture changes (document masking, NoPE), same data mixture, same hyperparameters — both with and without TP. The difference was immediate: the TP version consistently had a higher loss and lower downstream performance than the non-TP version. That confirmed we were looking at a TP-related bug.</p>
<p>We then examined the TP implementation in detail, comparing weights from TP and non-TP runs. The problem turned out to be subtle but significant: we were using identical random seeds across all TP ranks, when each rank should have been initialized with a different seed. This caused correlated weight initialization across shards, which affected convergence. The effect was not catastrophic — the model still trained and improved — but it introduced enough inefficiency to explain the gap we observed at scale.
Below is the bug fix:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="diff"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">diff --git a/src/nanotron/trainer.py b/src/nanotron/trainer.py</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">index 1234567..abcdefg 100644</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7"><span style="user-select:none">-</span>-- a/src/nanotron/trainer.py</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D"><span style="user-select:none">+</span>++ b/src/nanotron/trainer.py</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">@@ -185,7 +185,10 @@ class DistributedTrainer:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">     ):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">         # Set random states</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7"><span style="user-select:none">-</span>        set_random_seed(self.config.general.seed)</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D"><span style="user-select:none">+</span>        # Set different random seed for each TP rank to ensure diversity</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D"><span style="user-select:none">+</span>        tp_rank = dist.get_rank(self.parallel_context.tp_pg)</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D"><span style="user-select:none">+</span>        set_random_seed(self.config.general.seed + tp_rank)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D"><span style="user-select:none">+</span></span></span>
<span class="line"></span></code></pre></div>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-rxdhldqvdyg" data-config="{&#34;dataUrl&#34;:&#34;./data/tp_debug_fix_loss.csv&#34;,&#34;xDomain&#34;:[0,9000000000],&#34;yDomain&#34;:[2.7,3.7],&#34;smoothing&#34;:true,&#34;title&#34;:&#34;TP Debug Fix Loss&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<p>Once we fixed the seeds so that each TP rank used a different seed, we repeated the ablations experiments and confirmed that TP and non-TP runs now matched in both loss curves and downstream performance. To make sure there were no other hidden issues, we ran additional sanity checks: a SmolLM2-style (architecture and data wise) run at 3B parameters, and a separate SmolLM3 run at 3B parameters, comparing both to SmolLM2’s checkpoints. The results now aligned with expectations: the 1.7B SmolLM2 performed worse than the 3B SmolLM2 variant, which in turn was below SmolLM3’s 3B performance.</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-x1dz26nc5h" data-config="{&#34;dataUrl&#34;:&#34;./data/evals_tp_bug_fix_200B.csv&#34;,&#34;charts&#34;:[{&#34;title&#34;:&#34;HellaSwag&#34;,&#34;metric&#34;:&#34;hellaswag&#34;},{&#34;title&#34;:&#34;MMLU&#34;,&#34;metric&#34;:&#34;mmlu&#34;},{&#34;title&#34;:&#34;ARC&#34;,&#34;metric&#34;:&#34;arc&#34;},{&#34;title&#34;:&#34;PIQA&#34;,&#34;metric&#34;:&#34;piqa&#34;},{&#34;title&#34;:&#34;OpenBookQA&#34;,&#34;metric&#34;:&#34;openbookqa&#34;},{&#34;title&#34;:&#34;WinoGrande&#34;,&#34;metric&#34;:&#34;winogrande&#34;}],&#34;smoothing&#34;:true,&#34;smoothingWindow&#34;:15}"><!-- 
  Multi-Line Charts Grid
  
  A configurable grid of line charts with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute:
  {
    "dataUrl": "./assets/data/your_data.csv",
    "charts": [
      { "title": "Chart 1", "metric": "metric1" },
      { "title": "Chart 2", "metric": "metric2" },
      ...
    ],
    "smoothingWindow": 15,
    "smoothingCurve": "monotoneX",
    "gridColumns": 3  // Optional: number of columns (default: 3)
  }
  
  CSV format: run_name, step, metric1, metric2, ...
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/d3-six-line-charts.html" 
    config={{ 
      dataUrl: "./assets/data/attention_evals.csv",
      charts: [
        { title: "HellaSwag", metric: "hellaswag" },
        { title: "MMLU", metric: "mmlu" },
        { title: "ARC", metric: "arc" },
        { title: "PIQA", metric: "piqa" },
        { title: "OpenBookQA", metric: "openbookqa" },
        { title: "WinoGrande", metric: "winogrande" }
      ],
      smoothingWindow: 15
    }} 
  />
-->
<div class="d3-multi-charts"></div>
<style>
  .d3-multi-charts {
    position: relative;
    container-type: inline-size;
  }

  /* Legend header */
  .d3-multi-charts__header {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
  }

  .d3-multi-charts__header .legend-bottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
    max-width: 80%;
  }

  .d3-multi-charts__header .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-multi-charts__header .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
    justify-content: center;
  }

  .d3-multi-charts__header .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-multi-charts__header .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  /* Grid */
  .d3-multi-charts__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }

  /* Container queries - basées sur la largeur du container parent, pas de la viewport */
  @container (max-width: 900px) {
    .d3-multi-charts__grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @container (max-width: 600px) {
    .d3-multi-charts__grid {
      grid-template-columns: 1fr;
    }
  }

  .chart-cell {
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
    box-shadow: inset 0 0 0 1px var(--border-color);
    border-radius: 8px;
  }

  .chart-cell__title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
    margin-bottom: 8px;
    padding-bottom: 8px;
  }

  .chart-cell__body {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .chart-cell__body svg {
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* Reset button */
  .chart-cell .reset-button {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 10;
    display: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-size: 11px;
    padding: 3px 6px;
    border-radius: 4px;
    background: var(--surface-bg);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    cursor: pointer;
  }

  /* Axes */
  .d3-multi-charts .axes path {
    display: none;
  }

  .d3-multi-charts .axes line {
    stroke: var(--axis-color);
  }

  .d3-multi-charts .axes text {
    fill: var(--tick-color);
    font-size: 10px;
  }

  .d3-multi-charts .axis-label {
    fill: var(--text-color);
    font-size: 10px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    stroke-width: 3px;
    paint-order: stroke fill;
  }

  .d3-multi-charts .grid line {
    stroke: var(--grid-color);
  }

  /* Lines */
  .d3-multi-charts path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-multi-charts path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-multi-charts.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-multi-charts.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  .d3-multi-charts.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  /* Tooltip */
  .d3-multi-charts .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-multi-charts .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 200px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-multi-charts .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-multi-charts .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-multi-charts'))) {
        const cs = Array.from(document.querySelectorAll('.d3-multi-charts')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration
      const CONFIG = {
        dataUrl: embedConfig.dataUrl || './assets/data/attention_evals.csv',
        charts: embedConfig.charts || [],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        gridColumns: embedConfig.gridColumns || 3,
        chartHeight: 240,
        margin: { top: 20, right: 20, bottom: 40, left: 50 },
        zoomExtent: [1.0, 8],
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Value',
        xColumn: embedConfig.xColumn || 'tokens',
        runColumn: embedConfig.runColumn || 'run_name'
      };

      if (!CONFIG.charts.length) {
        container.innerHTML = '<p style="color: var(--danger); font-size: 12px;">Error: No charts configured</p>';
        return;
      }

      // Create legend header
      const header = document.createElement('div');
      header.className = 'd3-multi-charts__header';
      header.innerHTML = `
      <div class="legend-bottom">
        <div class="legend-title">Legend</div>
        <div class="items"></div>
      </div>
    `;
      container.appendChild(header);

      // Create grid
      const grid = document.createElement('div');
      grid.className = 'd3-multi-charts__grid';
      container.appendChild(grid);

      // Trackio footer removed

      // Create chart cells
      CONFIG.charts.forEach((chartConfig, idx) => {
        const cell = document.createElement('div');
        cell.className = 'chart-cell';
        cell.style.zIndex = CONFIG.charts.length - idx; // Stacking order
        cell.innerHTML = `
        <div class="chart-cell__title">${chartConfig.title}</div>
        <button class="reset-button">Reset</button>
        <div class="chart-cell__body"></div>
      `;
        grid.appendChild(cell);
      });

      // Data
      let allData = [];
      let runList = [];
      let runColorMap = {};

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].value)) { sum += values[j].value; count++; } }
          const avg = count ? (sum / count) : values[i].value;
          out[i] = { step: values[i].step, value: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Init each chart
      function initChart(cellElement, chartConfig) {
        const bodyEl = cellElement.querySelector('.chart-cell__body');
        const resetBtn = cellElement.querySelector('.reset-button');

        const metric = chartConfig.metric;
        let smoothEnabled = CONFIG.smoothing;
        let hasMoved = false;

        // Tooltip
        let tip = cellElement.querySelector('.d3-tooltip');
        let tipInner;
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'd3-tooltip';
          Object.assign(tip.style, {
            position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
            padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
            background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease', zIndex: '20'
          });
          tipInner = document.createElement('div');
          tipInner.className = 'd3-tooltip__inner';
          tip.appendChild(tipInner);
          cellElement.appendChild(tip);
        } else {
          tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
        }

        // Create SVG
        const svg = d3.select(bodyEl).append('svg').attr('width', '100%').style('display', 'block');

        // Clip path
        const clipId = 'clip-' + Math.random().toString(36).slice(2);
        const clipPath = svg.append('defs').append('clipPath').attr('id', clipId);
        const clipRect = clipPath.append('rect');

        // Groups
        const g = svg.append('g');
        const gGrid = g.append('g').attr('class', 'grid');
        const gAxes = g.append('g').attr('class', 'axes');
        const gPlot = g.append('g').attr('class', 'plot').attr('clip-path', `url(#${clipId})`);
        const gHover = g.append('g').attr('class', 'hover-layer');
        const overlay = g.append('rect').attr('class', 'overlay').attr('fill', 'none').attr('pointer-events', 'all').style('cursor', 'grab')
          .on('mousedown', function () {
            d3.select(this).style('cursor', 'grabbing');
            tip.style.opacity = '0';
            if (hoverLine) hoverLine.style('display', 'none');
          })
          .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

        // Scales
        const xScale = d3.scaleLinear();
        const yScale = d3.scaleLinear();

        // Hover state
        let hoverLine = null;
        let steps = [];
        let hideTipTimer = null;

        // Formatters (will be set in render())
        let formatStep = (v) => v;
        let formatValue = (v) => v;

        // Zoom
        const zoom = d3.zoom().scaleExtent(CONFIG.zoomExtent).on('zoom', zoomed);
        overlay.call(zoom);

        function zoomed(event) {
          const transform = event.transform;
          hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
          updateResetButton();

          const newXScale = transform.rescaleX(xScale);
          const newYScale = transform.rescaleY(yScale);

          const innerWidth = xScale.range()[1];

          // Update grid
          const gridTicks = newYScale.ticks(5);
          gGrid.selectAll('line').data(gridTicks).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => newYScale(d)).attr('y2', d => newYScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Update lines
          const line = d3.line()
            .x(d => newXScale(d.step))
            .y(d => newYScale(d.value))
            .curve(getCurve(smoothEnabled));

          gPlot.selectAll('path.ghost-line')
            .attr('d', d => {
              const rawLine = d3.line().x(d => newXScale(d.step)).y(d => newYScale(d.value)).curve(d3.curveLinear);
              return rawLine(d.values);
            });

          gPlot.selectAll('path.main-line')
            .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

          // Update axes
          gAxes.select('.x-axis').call(d3.axisBottom(newXScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.select('.y-axis').call(d3.axisLeft(newYScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
        }

        function updateResetButton() {
          if (hasMoved) {
            resetBtn.style.display = 'block';
            requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
          } else {
            resetBtn.style.opacity = '0';
            setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
          }
        }

        function render() {
          const rect = bodyEl.getBoundingClientRect();
          const width = Math.max(1, Math.round(rect.width || 400));
          const height = CONFIG.chartHeight;
          svg.attr('width', width).attr('height', height);

          const margin = CONFIG.margin;
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;

          g.attr('transform', `translate(${margin.left},${margin.top})`);

          // Filter data for this metric
          const metricData = allData.filter(d => d[metric] != null && !isNaN(d[metric]));

          if (!metricData.length) {
            return;
          }

          // Auto-compute domains from data
          const stepExtent = d3.extent(metricData, d => d.step);
          const valueExtent = d3.extent(metricData, d => d[metric]);

          xScale.domain(stepExtent).range([0, innerWidth]);
          yScale.domain(valueExtent).range([innerHeight, 0]);

          // Create smart formatters based on actual data
          const stepValues = metricData.map(d => d.step);
          const metricValues = metricData.map(d => d[metric]);
          formatStep = createSmartFormatter(stepValues);
          formatValue = createSmartFormatter(metricValues);

          // Update clip
          clipRect.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update overlay
          overlay.attr('x', 0).attr('y', 0).attr('width', innerWidth).attr('height', innerHeight);

          // Update zoom extent
          zoom.extent([[0, 0], [innerWidth, innerHeight]])
            .translateExtent([[0, 0], [innerWidth, innerHeight]]);

          // Grid
          gGrid.selectAll('line').data(yScale.ticks(5)).join('line')
            .attr('x1', 0).attr('x2', innerWidth)
            .attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
            .attr('stroke', 'var(--grid-color)');

          // Axes
          gAxes.selectAll('*').remove();
          gAxes.append('g').attr('class', 'x-axis').attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0).tickFormat(formatStep));
          gAxes.append('g').attr('class', 'y-axis')
            .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0).tickFormat(formatValue));
          gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');
          gAxes.selectAll('text').attr('fill', 'var(--tick-color)');

          // Axis labels
          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight + 32)
            .attr('text-anchor', 'middle')
            .text(CONFIG.xAxisLabel);

          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -38)
            .attr('text-anchor', 'middle')
            .text(CONFIG.yAxisLabel);

          // Group data by run
          const dataByRun = {};
          runList.forEach(run => { dataByRun[run] = []; });
          metricData.forEach(d => {
            if (dataByRun[d.run]) dataByRun[d.run].push({ step: d.step, value: d[metric] });
          });
          runList.forEach(run => { dataByRun[run].sort((a, b) => a.step - b.step); });

          const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] })).filter(s => s.values.length > 0);

          // Ghost lines
          const ghostLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(d3.curveLinear);
          gPlot.selectAll('path.ghost-line').data(series, d => d.run).join('path')
            .attr('class', 'ghost-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 1.5)
            .attr('opacity', smoothEnabled ? 0.15 : 0)
            .attr('pointer-events', 'none')
            .attr('d', d => ghostLine(d.values));

          // Main lines
          const mainLine = d3.line().x(d => xScale(d.step)).y(d => yScale(d.value)).curve(getCurve(smoothEnabled));
          gPlot.selectAll('path.main-line').data(series, d => d.run).join('path')
            .attr('class', 'main-line')
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('opacity', 0.85)
            .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

          // Hover
          setupHover(series, innerWidth, innerHeight);
        }

        function setupHover(series, innerWidth, innerHeight) {
          gHover.selectAll('*').remove();

          hoverLine = gHover.append('line')
            .style('stroke', 'var(--text-color)')
            .attr('stroke-opacity', 0.25)
            .attr('stroke-width', 1)
            .attr('y1', 0)
            .attr('y2', innerHeight)
            .style('display', 'none')
            .attr('pointer-events', 'none');

          const stepSet = new Set();
          series.forEach(s => s.values.forEach(v => stepSet.add(v.step)));
          steps = Array.from(stepSet).sort((a, b) => a - b);

          overlay.on('mousemove', function (ev) {
            if (ev.buttons === 0) onHoverMove(ev, series);
          }).on('mouseleave', onHoverLeave);
        }

        function onHoverMove(ev, series) {
          if (hideTipTimer) { clearTimeout(hideTipTimer); hideTipTimer = null; }

          const [mx, my] = d3.pointer(ev, overlay.node());
          const targetStep = xScale.invert(mx);
          const nearest = steps.reduce((best, t) => Math.abs(t - targetStep) < Math.abs(best - targetStep) ? t : best, steps[0]);

          const xpx = xScale(nearest);
          hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

          let html = `<div><strong>${chartConfig.title}</strong></div>`;
          html += `<div>${formatStep(nearest)}</div>`;

          const entries = series.map(s => {
            const values = s.values;
            let before = null, after = null;
            for (let i = 0; i < values.length; i++) {
              if (values[i].step <= nearest) before = values[i];
              if (values[i].step >= nearest && !after) { after = values[i]; break; }
            }

            let interpolatedValue = null;
            if (before && after && before.step !== after.step) {
              const t = (nearest - before.step) / (after.step - before.step);
              interpolatedValue = before.value + t * (after.value - before.value);
            } else if (before && before.step === nearest) {
              interpolatedValue = before.value;
            } else if (after && after.step === nearest) {
              interpolatedValue = after.value;
            } else if (before) {
              interpolatedValue = before.value;
            } else if (after) {
              interpolatedValue = after.value;
            }

            return { run: s.run, color: s.color, value: interpolatedValue };
          }).filter(e => e.value != null);

          entries.sort((a, b) => b.value - a.value);

          entries.forEach(e => {
            html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.value.toFixed(4)}</span></div>`;
          });

          tipInner.innerHTML = html;
          const offsetX = 12, offsetY = 12;
          tip.style.opacity = '1';
          tip.style.transform = `translate(${Math.round(mx + offsetX + CONFIG.margin.left)}px, ${Math.round(my + offsetY + CONFIG.margin.top)}px)`;
        }

        function onHoverLeave() {
          hideTipTimer = setTimeout(() => {
            tip.style.opacity = '0';
            tip.style.transform = 'translate(-9999px, -9999px)';
            if (hoverLine) hoverLine.style('display', 'none');
          }, 100);
        }

        // Reset button
        resetBtn.addEventListener('click', () => {
          overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        });

        return { render };
      }

      // Load data
      async function load() {
        try {
          const response = await fetch(CONFIG.dataUrl, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);

          const csvText = await response.text();

          // Parse CSV (long format: run_name, metric, tokens, value)
          const rawRows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            metric: (d.metric || '').trim(),
            tokens: +d[CONFIG.xColumn],
            value: +d.value
          }));

          // Pivot data: group by run + tokens, create columns for each metric
          const pivotMap = new Map();
          rawRows.forEach(row => {
            if (isNaN(row.tokens) || isNaN(row.value)) return;

            const key = `${row.run}|${row.tokens}`;
            if (!pivotMap.has(key)) {
              pivotMap.set(key, { run: row.run, step: row.tokens });
            }
            const pivotRow = pivotMap.get(key);
            pivotRow[row.metric] = row.value;
          });

          allData = Array.from(pivotMap.values());

          runList = Array.from(new Set(allData.map(d => d.run))).sort();

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => { runColorMap[run] = colors[i % colors.length]; });

          // Build legend
          const legendItemsHost = header.querySelector('.legend-bottom .items');
          if (legendItemsHost) {
            legendItemsHost.innerHTML = runList.map(run => {
              const color = runColorMap[run];
              return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
            }).join('');

            // Add hover interactions
            legendItemsHost.querySelectorAll('.item').forEach(el => {
              el.addEventListener('mouseenter', () => {
                const run = el.getAttribute('data-run');
                container.classList.add('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                grid.querySelectorAll('path.ghost-line').forEach(path => {
                  const pathRun = d3.select(path).datum()?.run;
                  path.classList.toggle('ghost', pathRun !== run);
                });
                legendItemsHost.querySelectorAll('.item').forEach(it => {
                  it.classList.toggle('ghost', it.getAttribute('data-run') !== run);
                });
              });

              el.addEventListener('mouseleave', () => {
                container.classList.remove('hovering');
                grid.querySelectorAll('path.main-line').forEach(path => path.classList.remove('ghost'));
                grid.querySelectorAll('path.ghost-line').forEach(path => path.classList.remove('ghost'));
                legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
              });
            });
          }

          // Init all charts
          const cells = Array.from(grid.querySelectorAll('.chart-cell'));
          const chartInstances = cells.map((cell, idx) => initChart(cell, CONFIG.charts[idx]));

          // Render all
          chartInstances.forEach(chart => chart.render());

          // Responsive - observe container for resize
          let resizeTimer;
          const handleResize = () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              chartInstances.forEach(chart => chart.render());
            }, 100);
          };

          const ro = window.ResizeObserver ? new ResizeObserver(handleResize) : null;
          if (ro) {
            ro.observe(container);
          }

          // Also observe window resize as fallback
          window.addEventListener('resize', handleResize);

          // Force a re-render after a short delay to ensure proper sizing
          setTimeout(() => {
            chartInstances.forEach(chart => chart.render());
          }, 100);

        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure> </div>
<p>This debugging process reinforced one of the core principles we outlined earlier in this blog:</p>
<p>“The real value of a solid ablation setup goes beyond just building a good model. When things inevitably go wrong during our main training run (and they will, no matter how much we prepare), we want to be confident in every decision we made and quickly identify which components weren’t properly tested and could be causing the issues. This preparation saves debugging time and keeps our sanity intact. There’s nothing worse than staring at a mysterious training failure with no idea where the bug could be hiding.”</p>
<p>Because every other component in our training had been validated, we could pinpoint TP as the only plausible cause and fix the bug within a single day of detecting the performance gap.</p>
<p>With that, we had resolved the last in a series of unexpected issues that had surfaced since launch. Third time’s a charm, from that point on, the remaining month of training was relatively uneventful, just the steady work of turning trillions of tokens into a finished model, interrupted by occasional restarts due to node failures.</p>
<h3 id="staying-the-course"><a href="#staying-the-course">Staying the course</a></h3>
<p>As the previous section showed, scaling from ablations to full pretraining wasn’t just “plug and play.” unexpected challenges, it brought unexpected challenges, but we successfully identified and resolved each issue. This section covers the essential monitoring setup and considerations for large-scale training runs. We’ll address critical questions: When should you restart training after encountering problems? How do you handle issues that surface deep into a run? Which metrics truly matter? Should you maintain a fixed data mixture throughout training?</p>
<h4 id="training-monitoring-beyond-loss-curves"><a href="#training-monitoring-beyond-loss-curves">Training monitoring: Beyond loss curves</a></h4>
<p>The reason we caught the tensor-parallelism bug was not the loss curve, which looked fine, but the fact that downstream evaluations were lagging behind expectations. Additionally, having evaluations from SmolLM2’s intermediate checkpoints was critical: they gave us a sanity check that the 3B model wasn’t on the right track early. So if you’re training large models, start running downstream evaluations early, and if you’re comparing to an open-source model, ask whether the authors can provide intermediate checkpoints, those can be invaluable as reference points.</p>
<p>On the infrastructure side, the most important metric is throughput, measured in tokens per second. For SmolLM3, we expected stable throughput between 13,500–14,000 tokens/sec across the run, and any sustained deviation was a red flag. But throughput alone is not enough: you also need continuous hardware health monitoring to anticipate and detect hardware failures. Some of the key metrics we tracked included: GPU temperatures, memory usage and compute utilization. We log them into Grafana dashboards and set up real-time Slack alerts for hardware anomalies.</p>
<h4 id="fix-and-restart-vs-fix-on-the-fly"><a href="#fix-and-restart-vs-fix-on-the-fly">Fix and restart vs fix on the fly</a></h4>
<p>Given that we restarted our run after 1T tokens, an important question arises: do you always need to restart when something goes wrong? The answer depends on the severity and root cause of the issue.</p>
<p>In our case, the TP seeding bug meant we were starting on the wrong foot, half our weights weren’t properly initialized. The model was showing performance similar to SmolLM2 and plateauing at similar points, meaning we’d likely end up with a model that performed the same but cost almost twice as much to train. Restarting made sense. However, many issues can be course-corrected mid-run to avoid wasting compute. The most common issue involves loss spikes, those sudden jumps in training loss that can either signal minor hiccups or divergence.</p>
<p>As <a href="https://media.istockphoto.com/id/486869012/fr/photo/ch%C3%A8vre-est-%C3%A0-nous.jpg?s=612x612&w=0&k=20&c=F26PCPZiy1P3FLZS23GWhKcQ8Buqfx8StHYoX85hq-s%3D">Stas Bekman</a> nicely puts it in the <a href="https://github.com/stas00/ml-engineering/blob/master/training/instabilities/training-loss-patterns.md">Machine Learning Engineering Open Book </a>“Training loss plots are similar to heartbeat patterns—there’s the good, the bad, and the you-should-worry ones.”</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-u24wlmf1dk" data-config="{&#34;dataUrl&#34;:&#34;./data/spike_loss.csv&#34;,&#34;xColumn&#34;:&#34;tokens&#34;,&#34;yColumn&#34;:&#34;loss&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;xAxisLabel&#34;:&#34;Tokens&#34;,&#34;yAxisLabel&#34;:&#34;Loss&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<p>Loss spikes fall into two categories:</p>
<ul>
<li>Recoverable spikes: These can recover either fast (immediately after the spike) or slow (requiring several more training steps to return to the pre-spike trajectory). You can usually continue training through these. If recovery is very slow, you can try rewinding to a previous checkpoint to skip problematic batches.</li>
<li>Non-recoverable spikes: The model either diverges or plateaus at worse performance than before the spike. These require more significant intervention than simply rewinding to a previous checkpoint.</li>
</ul>
<p>While we don’t fully understand training instabilities, we know they become more frequent at scale. Common culprits, assuming a conservative architecture and optimizer, include:</p>
<ul>
<li>High learning rates: These cause instability early in training and can be fixed by reducing the learning rate.</li>
<li>Bad data: Usually the main cause of recoverable spikes, though recovery may be slow. This can happen deep into training when the model encounters low-quality data.</li>
<li>Data-parameter state interactions: PaLM observed that spikes often result from specific combinations of data batches and model parameter states, rather than “bad data” alone. Training on the same problematic batches from a different checkpoint didn’t reproduce the spikes.</li>
<li>Poor initialization: Recent work by OLMo2 showed that switching from scaled initialization to a simple normal distribution (mean=0, std=0.02) improved stability.</li>
<li>Precision issues: While no one trains with FP16 anymore, <a href="https://arxiv.org/abs/2211.05100">BLOOM</a> found it highly unstable compared to BF16.</li>
</ul>
<p><strong>Before spikes happen, build in stability:</strong></p>
<p>Small models with conservative learning rates and good data rarely spike, but larger models require proactive stability measures. As more teams have trained at scale, we’ve accumulated a toolkit of techniques that help prevent training instability:</p>
<p>Data filtering and shuffling: By this point in the blog, you’ve noticed how often we circle back to data. Making sure your data is clean and well-shuffled can prevent spikes. For instance, OLMo2 found that removing documents with repeated n-grams (32+ repetitions of 1-13 token spans) significantly reduced spike frequency.</p>
<p>Training modifications: Z-loss regularization keeps output logits from growing too large without affecting performance. And excluding embeddings from weight decay also helps.</p>
<p>Architectural changes: QKNorm (normalizing query and key projections before attention) has proven effective. OLMo2 and other teams found it helps with stability, and interestingly, <a href="https://wandb.ai/marin-community/marin/reports/Marin-32B-Work-In-Progress--VmlldzoxMzM1Mzk1NQ">Marin team</a> found that it can even be applied mid-run to fix divergence issues.</p>
<p><strong>When spikes happen anyway - damage control:</strong></p>
<p>Even with these precautions, spikes can still occur. Here are some options for fixing them:</p>
<ul>
<li><strong>Skip problematic batches</strong> : Rewind to before the spike and skip the problematic batches. This is the most common fix for spikes. The Falcon team <span class="" id="citation--almazrouei2023falconseriesopenlanguage--112">(<a href="https://arxiv.org/abs/2311.16867" id="refctx-bib-almazrouei2023falconseriesopenlanguage-1" data-ref-id="bib-almazrouei2023falconseriesopenlanguage" target="_blank" rel="noopener noreferrer">Almazrouei et al., 2023</a>)</span> skipped 1B tokens to resolve their spikes, while the PaLM team <span class="" id="citation--palm--113">(<a href="https://arxiv.org/abs/2204.02311" id="refctx-bib-palm-3" data-ref-id="bib-palm" target="_blank" rel="noopener noreferrer">Chowdhery et al., 2022</a>)</span> found that skipping 200-500 batches around the spike location prevented recurrence.</li>
<li><strong>Tighten gradient clipping</strong> : Reduce the gradient norm threshold temporarily</li>
<li><strong>Apply architectural fixes</strong>  such as QKnorm, as done in Marin.</li>
</ul>
<h3 id="mid-training"><a href="#mid-training">Mid-training</a></h3>
<p>Modern LLM pretraining typically involves multiple stages with different data mixtures, often followed by a final phase to extend context length. For example, Qwen3 uses a three-stage approach: a general stage on 30T tokens at 4k context, a reasoning stage with 5T higher-quality tokens emphasizing STEM and coding, and finally a long context stage on hundreds of billions of tokens at 32k context length. SmolLM3 follows a similar philosophy, with planned interventions to introduce higher-quality datasets and extend context, alongside reactive adjustments based on performance monitoring.
As we explained in the data curation section, some interventions are planned from the start: for SmolLM3, we knew we’d introduce higher-quality math (FineMath4+) and code (Stack-Edu) in Stage 2, then add curated Q&amp;A and reasoning math and code data during the final decay phase. Other interventions are reactive, driven by monitoring performance during training. For example, in SmolLM2, when we found math and code performance lagging behind our targets, we responded by curating entirely new datasets (FineMath and Stack-Edu) and introducing them mid-training.</p>
<p>As we explained in the data curation section, the data mixture doesn’t have to stay fixed throughout training. Multi-stage training allows us to strategically shift dataset proportions as training progresses. Some interventions are planned from the start: for SmolLM3, we knew we’d introduce higher-quality FineMath4+ and Stack-Edu in Stage 2, then add curated Q&amp;A and reasoning data during the final decay phase. Other interventions are reactive, driven by monitoring performance during training. For example, in SmolLM2, when we found math and code performance lagging behind our targets, we curated entirely new datasets (FineMath and Stack-Edu) and introduced them mid-training. This flexibility—whether following a planned curriculum or adapting to emerging gaps—is what allows us to maximize the value of our compute budget.</p>
<h4 id="stage-2-and-stage-3-mixtures"><a href="#stage-2-and-stage-3-mixtures">Stage 2 and stage 3 mixtures</a></h4>
<p>The chart below show our 3 training stages and the progression of our web/code/math ratios during training. The SmolLM3 training configs for each stage are available <a href="https://github.com/huggingface/smollm/tree/main/text/pretraining/smollm3">here</a> with exact data weights. For more details on the rationale and composition behind each stage, refer to the data curation section.</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-nwpesa50qem"><div class="d3-data-mixture-stages"></div>
<style>
  .d3-data-mixture-stages { position: relative; }
  .d3-data-mixture-stages .legend { display:flex; flex-direction:column; align-items:center; gap:6px; margin: 8px 0 0 0; font-size:12px; color: var(--text-color); }
  .d3-data-mixture-stages .legend .legend-title { font-size:12px; font-weight:700; color: var(--text-color); }
  .d3-data-mixture-stages .legend .items { display:flex; flex-wrap:wrap; gap:8px 14px; }
  .d3-data-mixture-stages .legend .item { display:inline-flex; align-items:center; gap:6px; white-space:nowrap; }
  .d3-data-mixture-stages .legend .swatch { width:14px; height:14px; border-radius:3px; border:1px solid var(--border-color); }
  .d3-data-mixture-stages .axis-label { fill: var(--text-color); font-size: 12px; font-weight: 700; }
  .d3-data-mixture-stages .axes path, .d3-data-mixture-stages .axes line { stroke: var(--axis-color); }
  .d3-data-mixture-stages .axes text { fill: var(--tick-color); }
  .d3-data-mixture-stages .grid line { stroke: var(--grid-color); }
  .d3-data-mixture-stages .stage-label { fill: var(--text-color); font-size: 11px; font-weight: 600; text-anchor: middle; }
  .d3-data-mixture-stages .stage-line { stroke: var(--muted-color); stroke-width: 1; stroke-dasharray: 3,3; opacity: 0.6; }
  .d3-data-mixture-stages .d3-tooltip { position:absolute; top:0; left:0; transform:translate(-9999px,-9999px); pointer-events:none; padding:8px 10px; border-radius:8px; font-size:12px; line-height:1.35; border:1px solid var(--border-color); background:var(--surface-bg); color:var(--text-color); box-shadow:0 4px 24px rgba(0,0,0,.18); opacity:0; transition:opacity .12s ease; z-index: var(--z-elevated); backdrop-filter: saturate(1.12) blur(8px); }
  .d3-data-mixture-stages .d3-tooltip__inner { display:flex; flex-direction:column; gap:6px; min-width: 220px; text-align: left; }
  .d3-data-mixture-stages .d3-tooltip__inner > div:first-child { font-weight: 800; letter-spacing: 0.1px; margin-bottom: 0; }
  .d3-data-mixture-stages .d3-tooltip__inner > div:nth-child(2) { font-size: 11px; color: var(--muted-color); display: block; margin-top: -4px; margin-bottom: 2px; letter-spacing: 0.1px; }
  .d3-data-mixture-stages .d3-tooltip__inner > div:nth-child(n+3) { padding-top: 6px; border-top: 1px solid var(--border-color); }
  .d3-data-mixture-stages .d3-tooltip .swatch { width:12px; height:12px; border-radius:3px; border:1px solid var(--border-color); display:inline-block; margin-right:6px; }
  .d3-data-mixture-stages .chart-card { background: var(--page-bg); border: 1px solid var(--border-color); border-radius: 10px; padding: 8px; }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id='d3-cdn-script'; s.src='https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once:true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-data-mixture-stages'))){
        const cs = Array.from(document.querySelectorAll('.d3-data-mixture-stages')).filter(el => !(el.dataset && el.dataset.mounted==='true'));
        container = cs[cs.length-1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted==='true') return; container.dataset.mounted='true'; }

      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) { tip = document.createElement('div'); tip.className = 'd3-tooltip'; tipInner = document.createElement('div'); tipInner.className='d3-tooltip__inner'; tip.appendChild(tipInner); container.appendChild(tip); } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      const card = document.createElement('div'); card.className = 'chart-card'; container.appendChild(card);
      const legend = document.createElement('div'); legend.className = 'legend'; legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>'; container.appendChild(legend);

      const svg = d3.select(card).append('svg').attr('width','100%').style('display','block');
      const gRoot = svg.append('g');

      // Data with smooth transitions between stages
      const S1_vals = { web: 85, code: 12, math: 3 };
      const S2_vals = { web: 75, code: 15, math: 10 };
      const S3_vals = { web: 63, code: 24, math: 13 };

      const T1 = 8; // Transition from Stage 1 to Stage 2 (8T tokens)
      const T2 = 10; // Transition from Stage 2 to Stage 3 (8T + 2T tokens)
      const eps = 0.1; // Small offset for smooth transitions

      const data = [
        // Stage 1: Base training
        { tokens: 0, ...S1_vals, stage: 'Base training', duration: '8T tokens' },
        { tokens: T1 - eps, ...S1_vals, stage: 'Base training', duration: '8T tokens' },
        
        // Transition 1 (Stage 1 to Stage 2)
        { tokens: T1 + eps, ...S2_vals, stage: 'High quality injection', duration: '2T tokens' },
        
        // Stage 2: High quality injection
        { tokens: T2 - eps, ...S2_vals, stage: 'High quality injection', duration: '2T tokens' },
        
        // Transition 2 (Stage 2 to Stage 3)
        { tokens: T2 + eps, ...S3_vals, stage: 'LR Decay', duration: '1.1T tokens' },
        
        // Stage 3: LR Decay
        { tokens: 11.1, ...S3_vals, stage: 'LR Decay', duration: '1.1T tokens' }
      ];

      const categories = ['web', 'code', 'math'];
      const categoryLabels = {
        'web': 'Web',
        'code': 'Code',
        'math': 'Math'
      };

      let width=800, height=260; const margin = { top: 40, right: 40, bottom: 60, left: 80 };
      function updateSize(){
        width = container.clientWidth || 800; height = Math.max(240, Math.round(width/3.2));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return { innerWidth: width - margin.left - margin.right, innerHeight: height - margin.top - margin.bottom };
      }

      function makeLegend(categories, colorOf){
        const items = legend.querySelector('.items'); items.innerHTML = '';
        categories.forEach(name => { 
          const el = document.createElement('span'); el.className='item'; el.dataset.category=name; 
          const sw=document.createElement('span'); sw.className='swatch'; sw.style.background=colorOf(name); 
          const txt=document.createElement('span'); txt.textContent=categoryLabels[name]; 
          el.appendChild(sw); el.appendChild(txt); items.appendChild(el); 
        });
      }

      function render(){
        const { innerWidth, innerHeight } = updateSize();
        
        // Get colors from ColorPalettes
        const getColors = (n) => { 
          try { 
            if (window.ColorPalettes && typeof window.ColorPalettes.getColors==='function') 
              return window.ColorPalettes.getColors('categorical', n); 
          } catch(_){} 
          return ['#4e79a7','#f28e2b','#e15759','#76b7b2'].slice(0,n); 
        };
        const palette = getColors(categories.length);
        const color = d3.scaleOrdinal().domain(categories).range(palette);
        const colorOf = (c) => color(c);

        makeLegend(categories, colorOf);

        // Scales
        const xScale = d3.scaleLinear()
          .domain(d3.extent(data, d => d.tokens))
          .range([0, innerWidth]);

        const yScale = d3.scaleLinear()
          .domain([0, 100])
          .range([innerHeight, 0]);

        // Stack generator
        const stack = d3.stack()
          .keys(categories)
          .order(d3.stackOrderNone)
          .offset(d3.stackOffsetNone);

        const stackedData = stack(data);

        // Area generator
        const area = d3.area()
          .x(d => xScale(d.data.tokens))
          .y0(d => yScale(d[0]))
          .y1(d => yScale(d[1]))
          .curve(d3.curveMonotoneX);

        // Draw areas
        const areas = gRoot.selectAll('path.area').data(stackedData, d => d.key);
        areas.enter().append('path').attr('class','area')
          .attr('fill', d => colorOf(d.key))
          .attr('stroke', 'var(--surface-bg)')
          .attr('stroke-width', 1)
          .attr('data-category', d => d.key)
          .on('mouseenter', (ev, d) => {
            const point = d3.pointer(ev, container);
            const x = xScale.invert(point[0] - margin.left);
            const closest = data.reduce((prev, curr) => 
              Math.abs(curr.tokens - x) < Math.abs(prev.tokens - x) ? curr : prev
            );
            
            // Sort categories by value (ascending order)
            const sortedCategories = categories.sort((a, b) => closest[a] - closest[b]);
            
            tipInner.innerHTML = `<div><strong>Training Progress: ${closest.tokens.toFixed(1)}T tokens</strong></div>` +
              `<div>Stage: ${closest.stage}</div>` +
              `<div>Duration: ${closest.duration}</div>` +
              sortedCategories.map(cat => {
                const value = closest[cat];
                const colorSw = colorOf(cat);
                return `<div style="display:flex;align-items:center;gap:6px;white-space:nowrap;"><span class="swatch" style="background:${colorSw}"></span><strong>${categoryLabels[cat]}</strong><span style="margin-left:auto;text-align:right;">${value}%</span></div>`;
              }).join('');
            tip.style.opacity='1';
          })
          .on('mousemove', (ev) => { 
            const [mx,my] = d3.pointer(ev, container); 
            tip.style.transform = `translate(${Math.round(mx+12)}px, ${Math.round(my+12)}px)`; 
          })
          .on('mouseleave', () => {
            tip.style.opacity='0'; 
            tip.style.transform='translate(-9999px, -9999px)';
          })
          .merge(areas)
          .attr('d', area);
        areas.exit().remove();

        // Add stage dividers and labels
        const stageTransitions = [
          { x: 0, label: 'Stage 1: Base training', stage: 'Base training' },
          { x: 8, label: 'Stage 2: High quality injection', stage: 'High quality injection' },
          { x: 10, label: 'Stage 3: LR Decay', stage: 'LR Decay' }
        ];

        const stageLines = gRoot.selectAll('line.stage-line').data(stageTransitions);
        stageLines.enter().append('line').attr('class','stage-line')
          .merge(stageLines)
          .attr('x1', d => xScale(d.x))
          .attr('x2', d => xScale(d.x))
          .attr('y1', 0)
          .attr('y2', innerHeight);

        const stageLabels = gRoot.selectAll('text.stage-label').data(stageTransitions);
        stageLabels.enter().append('text').attr('class','stage-label')
          .merge(stageLabels)
          .attr('x', d => xScale(d.x))
          .attr('y', -15)
          .text(d => d.label);

        // Axes
        const xAxis = d3.axisBottom(xScale)
          .tickFormat(d => `${d}T`)
          .ticks(8);

        const yAxis = d3.axisLeft(yScale)
          .tickFormat(d => `${d}%`)
          .ticks(5);

        gRoot.selectAll('.x-axis').data([0]).join('g').attr('class','x-axis axes')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(xAxis);

        gRoot.selectAll('.y-axis').data([0]).join('g').attr('class','y-axis axes')
          .call(yAxis);

        // Grid lines
        gRoot.selectAll('.grid-x').data([0]).join('g').attr('class','grid-x grid')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickSize(-innerHeight).tickFormat(''));

        gRoot.selectAll('.grid-y').data([0]).join('g').attr('class','grid-y grid')
          .call(d3.axisLeft(yScale).tickSize(-innerWidth).tickFormat(''));

        // Axis labels
        gRoot.selectAll('.x-label').data([0]).join('text').attr('class','x-label axis-label')
          .attr('transform', `translate(${innerWidth/2},${innerHeight + 40})`)
          .attr('text-anchor', 'middle')
          .text('Training Progress (Trillion Tokens)');

        gRoot.selectAll('.y-label').data([0]).join('text').attr('class','y-label axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('y', 0 - margin.left)
          .attr('x', 0 - (innerHeight / 2))
          .attr('text-anchor', 'middle')
          .text('Data Mixture (%)');
      }

      render();
      const rerender = () => render();
      if (window.ResizeObserver) { const ro = new ResizeObserver(() => rerender()); ro.observe(container); } else { window.addEventListener('resize', rerender); }
    };

    if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once:true }); } else { ensureD3(bootstrap); }
  })();
</script>
</div></div></figure> </div>
<p><strong>Stage 1: Base training (8T tokens, 4k context)</strong>
The foundation stage uses our core pretraining mixture: web data (FineWeb-Edu, DCLM, FineWeb2, FineWeb2-HQ), code from The Stack v2 and StarCoder2, and math from FineMath3+ and InfiWebMath3+. All training happens at 4k context length.</p>
<p><strong>Stage 2: High-quality injection (2T tokens, 4k context)</strong>
We introduce higher-quality filtered datasets: Stack-Edu for code, FineMath4+ and InfiWebMath4+ for math, and MegaMath for advanced mathematical reasoning (we add the Qwen Q&amp;A data, synthetic rewrites, and text-code interleaved blocks).</p>
<p><strong>Stage 3: LR decay with reasoning &amp; Q&amp;A data (1.1T tokens, 4k context)</strong>
During the learning rate decay phase, we further upsample high-quality code and math datasets while introducing instruction and reasoning data like OpenMathReasoning, OpenCodeReasoning and OpenMathInstruct. The Q&amp;A samples are simply concatenated and separated by new lines.</p>
<h4 id="long-context-extension-from-4k-to-128k-tokens"><a href="#long-context-extension-from-4k-to-128k-tokens">Long context extension: From 4k to 128k tokens</a></h4>
<p>Context length determines how much text your model can process, it’s crucial for tasks like analyzing long documents, maintaining coherent multi-turn conversations, or processing entire codebases. SmolLM3 started training at 4k tokens, but we needed to scale to 128k for real-world applications.</p>
<p><strong>Why extend context mid-training?</strong></p>
<p>Training on long contexts from the start is computationally expensive since attention mechanisms scale quadratically with sequence length. Moreover, research shows that extending context with a few dozen to a hundred billion tokens toward the end of training, or during continual pretraining, is enough to reach good long context performance <span class="" id="citation--prolong--114">(<a href="https://arxiv.org/abs/2410.02660" id="refctx-bib-prolong-2" data-ref-id="bib-prolong" target="_blank" rel="noopener noreferrer">Gao et al., 2025</a>)</span>.</p>
<p><strong>Sequential scaling: 4k→32k→64k</strong></p>
<p>We didn’t jump straight to 128k. Instead, we gradually extended context in stages, giving the model time to adapt at each length before pushing further. We ran two long context stages: first from 4k to 32k, then from 32k to 64k (the 128k capability comes from inference-time extrapolation, not training). We found that starting a fresh learning rate schedule for each stage over 50B tokens worked better than extending context during the last 100B tokens of the main decay phase. At each stage, we ran ablations to find a good long context data mix and RoPE theta value, and evaluated on the Ruler benchmark.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>💡</span> <div class="note__title" data-astro-cid-qg6lmfty>Long context evals on base model</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>During the long context ablations, we found <a href="https://arxiv.org/abs/2410.02694">HELMET</a> benchmark to be very noisy on base models
(the same training with different seeds gives variable results). <a href="https://arxiv.org/abs/2410.02660">Gao et al.</a>
recommend doing SFT on top to reduce variance on the benchmarks’ tasks.
Instead we go for Ruler, which we found to give more reliable signal at the base
model level.</p> </div> </div> </div> 
<p>During this phase, it’s common to upsample long context documents such as lengthy web pages and books to improve long context performance <span class="" id="citation--prolong--115">(<a href="https://arxiv.org/abs/2410.02660" id="refctx-bib-prolong-3" data-ref-id="bib-prolong" target="_blank" rel="noopener noreferrer">Gao et al., 2025</a>)</span>. We ran several ablations upsampling books, articles, and even synthetically generated documents for tasks like retrieval and fill-in-the-middle, following Qwen2.5-1M’s approach <span class="" id="citation--qwen1million--116">(<a href="https://arxiv.org/abs/2501.15383" id="refctx-bib-qwen1million-2" data-ref-id="bib-qwen1million" target="_blank" rel="noopener noreferrer">A. Yang et al., 2025</a>)</span> with FineWeb-Edu and Python-Edu. Surprisingly, we didn’t observe any improvement over just using the baseline mixture from Stage 3, which was already competitive with other state-of-the-art models like Llama 3.2 3B and Qwen2.5 3B on Ruler. We hypothesize this is because the baseline mixture naturally includes long documents from web data and code (estimated at 10% of tokens), and that using NoPE helped.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>For more insights into long context extension, we recommend reading the paper <a href="https://arxiv.org/abs/2410.02660">How to Train Long-Context Language Models (Effectively)</a></p> </aside> </div>  
<p><strong>RoPE ABF (RoPE with Adjusted Base Frequency):</strong>  When going from 4k to 32k, we increased RoPE theta (base frequency) to 2M, and to go from 32k to 64k, we increased it to 5M. We found that using larger values like 10M slightly improves Ruler score but hurts some short context task like GSM8k, so we kept 5M which didn’t impact short context.
During this context extension phase, we also used the opportunity to further upsampled math, code, and reasoning Q&amp;A data, and we added few hundred thousand samples in ChatML format.</p>
<p><strong>YARN extrapolation: Reaching 128k</strong>
Even after training on 64k contexts, we wanted SmolLM3 to handle 128k at inference. Rather than training on 128k sequences (prohibitively expensive), we used YARN (Yet Another RoPE extensioN method) <span class="" id="citation--yarn--117">(<a href="https://arxiv.org/abs/2309.00071" id="refctx-bib-yarn-2" data-ref-id="bib-yarn" target="_blank" rel="noopener noreferrer">B. Peng et al., 2023</a>)</span>, which allows the model to extrapolate beyond its training length. In theory, YARN allows a four-fold increase in sequence length. We found that using the 64k checkpoint gave better performance at 128k than using the 32k checkpoint, confirming the benefit of training closer to the target inference length. However, pushing to 256k (four-fold from 64k) showed degraded Ruler performance, so we recommend using the model up to 128k.</p>
<h3 id="wrapping-up-pretraining"><a href="#wrapping-up-pretraining">Wrapping up pretraining</a></h3>
<p>We’ve covered a lot of ground. From the Training Compass that helped us decide why and what to train, through strategic planning, systematic ablations that validated every architectural choice, to the actual training marathon where surprises emerged at scale (throughput mysteriously collapsing, dataloader bottlenecks, and a subtle tensor parallelism bug that forced a restart at 1T tokens).</p>
<p>The messy reality behind those polished technical reports is now visible:  <strong>training LLMs is as much about disciplined experimentation and rapid debugging as it is about architectural innovations.</strong>  Planning identifies what’s worth testing. Ablations validate each decision. Monitoring catches problems early. And when things inevitably break, systematic derisking tells you exactly where to look.</p>
<p>For SmolLM3 specifically, this process delivered what we set out to build: a 3B model trained on 11T tokens that’s competitive on math, code, multilingual understanding, and long-context tasks, in the Pareto frontier of Qwen3 models.</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-s6ingfrnlf"><div class="base-model-performance"></div>

<style>
    .base-model-performance {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        max-width: 900px;
        margin: 0 auto;
    }

    .base-model-performance .chart-container {
        position: relative;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1.5 / 1;
    }

    .base-model-performance svg {
        width: 100%;
        height: 100%;
        display: block;
    }

    .base-model-performance .axis-line {
        stroke: var(--border-color);
        stroke-width: 2;
    }

    .base-model-performance .axis-label {
        fill: var(--text-color);
        font-size: 16px;
        font-weight: 600;
    }

    .base-model-performance .axis-sublabel {
        fill: var(--muted-color);
        font-size: 13px;
    }

    .base-model-performance .tick-line {
        stroke: var(--border-color);
        stroke-width: 1;
        opacity: 0.3;
    }

    .base-model-performance .tick-label {
        fill: var(--muted-color);
        font-size: 12px;
    }

    .base-model-performance .pareto-zone {
        fill: var(--text-color);
        opacity: 0.08;
    }

    .base-model-performance .pareto-border {
        stroke: var(--border-color);
        stroke-width: 2;
        fill: none;
        stroke-dasharray: 5, 5;
    }


    .base-model-performance .model-circle {
        /* stroke is set dynamically in JavaScript */
    }

    .base-model-performance .model-icon {
        font-size: 32px;
    }

    .base-model-performance .model-label {
        fill: var(--text-color);
        font-size: 14px;
        font-weight: 600;
        text-anchor: middle;
        pointer-events: none;
    }

    .base-model-performance .model-sublabel {
        fill: var(--muted-color);
        font-size: 12px;
        text-anchor: middle;
        pointer-events: none;
    }

    .base-model-performance .arrow {
        stroke: var(--muted-color);
        stroke-width: 2.5;
        fill: none;
        marker-end: url(#arrowhead);
        opacity: 0.4;
    }

    .base-model-performance .arrow-label {
        fill: var(--text-color);
        font-size: 14px;
        font-weight: 600;
        letter-spacing: 0.3px;
    }


    .base-model-performance .legend {
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        justify-content: center;
    }

    .base-model-performance .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: var(--muted-color);
    }

    .base-model-performance .legend-icon {
        font-size: 20px;
    }

    @media (max-width: 768px) {
        .base-model-performance .chart-container {
            height: 500px;
        }

        .base-model-performance .axis-label {
            font-size: 14px;
        }

        .base-model-performance .model-label {
            font-size: 12px;
        }

        .base-model-performance .arrow-label {
            font-size: 14px;
        }
    }
</style>

<script>
    (() => {
        const bootstrap = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;
            if (!(container && container.classList && container.classList.contains('base-model-performance'))) {
                const candidates = Array.from(document.querySelectorAll('.base-model-performance'))
                    .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
                container = candidates[candidates.length - 1] || null;
            }
            if (!container) return;
            if (container.dataset) {
                if (container.dataset.mounted === 'true') return;
                container.dataset.mounted = 'true';
            }

            // Data for models
            const models = [
                { name: 'Qwen3 1.7B Base', size: 1.7, winRate: 2.1, logo: 'qwen', color: '#8B5CF6' },
                { name: 'Qwen2.5 3B', size: 3.1, winRate: 3.1, logo: 'qwen', color: '#8B5CF6' },
                { name: 'SmolLM3 3B Base', size: 3.0, winRate: 4.0, logo: 'hf', color: '#FFD43B' },
                { name: 'Llama3.2 3B', size: 3.2, winRate: 2.3, logo: 'meta', color: '#4299E1' },
                { name: 'Qwen3 4B Base', size: 4.0, winRate: 4.9, logo: 'qwen', color: '#8B5CF6' },
                { name: 'Gemma3 4B Base', size: 4.3, winRate: 4.5, logo: 'google', color: '#EA4335' }
            ];

            // Chart dimensions
            const padding = 20;
            const margin = { top: 20 + padding, right: 20 + padding, bottom: 80 + padding, left: 100 + padding };
            const width = 900 - margin.left - margin.right;
            const height = 600 - margin.top - margin.bottom;

            // Scales
            const xScale = (value) => margin.left + ((value - 1.5) / (4.5 - 1.5)) * width;
            const yScale = (value) => height + margin.top - ((value - 1.8) / (5.2 - 1.8)) * height;

            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

            // Define arrowhead marker
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '6');
            marker.setAttribute('markerHeight', '6');
            marker.setAttribute('refX', '5');
            marker.setAttribute('refY', '3');
            marker.setAttribute('orient', 'auto');
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 6 3, 0 6');
            polygon.setAttribute('fill', 'var(--muted-color)');
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svg.appendChild(defs);

            // Draw Pareto border - straight diagonal
            const paretoBorder = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const borderD = `M ${xScale(1.5)} ${yScale(1.8)} L ${xScale(4.5)} ${yScale(5.2)}`;
            paretoBorder.setAttribute('d', borderD);
            paretoBorder.setAttribute('class', 'pareto-border');
            svg.appendChild(paretoBorder);

            // Draw X-axis
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', margin.left);
            xAxis.setAttribute('y1', height + margin.top);
            xAxis.setAttribute('x2', width + margin.left);
            xAxis.setAttribute('y2', height + margin.top);
            xAxis.setAttribute('class', 'axis-line');
            svg.appendChild(xAxis);

            // Draw Y-axis
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', margin.left);
            yAxis.setAttribute('y1', margin.top);
            yAxis.setAttribute('x2', margin.left);
            yAxis.setAttribute('y2', height + margin.top);
            yAxis.setAttribute('class', 'axis-line');
            svg.appendChild(yAxis);

            // X-axis ticks and labels
            for (let i = 2.0; i <= 4.5; i += 0.5) {
                const x = xScale(i);
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', margin.top);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', height + margin.top);
                tick.setAttribute('class', 'tick-line');
                svg.appendChild(tick);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', height + margin.top + 25);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'tick-label');
                label.textContent = i.toFixed(1);
                svg.appendChild(label);
            }

            // Y-axis ticks and labels
            for (let i = 2.0; i <= 5.0; i += 0.5) {
                const y = yScale(i);
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', margin.left);
                tick.setAttribute('y1', y);
                tick.setAttribute('x2', width + margin.left);
                tick.setAttribute('y2', y);
                tick.setAttribute('class', 'tick-line');
                svg.appendChild(tick);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', margin.left - 15);
                label.setAttribute('y', y + 5);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('class', 'tick-label');
                label.textContent = i.toFixed(1);
                svg.appendChild(label);
            }

            // X-axis label
            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', margin.left + width / 2);
            xLabel.setAttribute('y', height + margin.top + 65);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('class', 'axis-label');
            xLabel.innerHTML = '<tspan font-weight="700">Model Size</tspan><tspan font-weight="400"> (Billion parameters)</tspan>';
            svg.appendChild(xLabel);

            // Y-axis label
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', -(height / 2 + margin.top));
            yLabel.setAttribute('y', 55);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('transform', 'rotate(-90)');
            yLabel.setAttribute('class', 'axis-label');
            yLabel.innerHTML = '<tspan font-weight="700">Win Rate (%)</tspan><tspan font-weight="400"> - 12 popular LLM Benchmarks</tspan>';
            svg.appendChild(yLabel);

            // Draw arrows
            // "faster/cheaper" arrow (shorter, aligned to left)
            const arrow1StartX = margin.left + 80;
            const arrow1Length = 170;
            const arrow1EndX = arrow1StartX + arrow1Length;
            const arrow1Y = yScale(4.8);

            const arrow1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            arrow1.setAttribute('d', `M ${arrow1EndX} ${arrow1Y} L ${arrow1StartX} ${arrow1Y}`);
            arrow1.setAttribute('class', 'arrow');
            svg.appendChild(arrow1);

            const arrow1Label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            arrow1Label.setAttribute('x', (arrow1StartX + arrow1EndX) / 2);
            arrow1Label.setAttribute('y', arrow1Y - 10);
            arrow1Label.setAttribute('text-anchor', 'middle');
            arrow1Label.setAttribute('class', 'arrow-label');
            arrow1Label.textContent = 'faster / cheaper';
            svg.appendChild(arrow1Label);

            // "better" arrow (pointing up)
            const arrow2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            arrow2.setAttribute('d', `M ${xScale(1.75)} ${yScale(3.5)} L ${xScale(1.75)} ${yScale(4.5)}`);
            arrow2.setAttribute('class', 'arrow');
            svg.appendChild(arrow2);

            const arrow2Label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            arrow2Label.setAttribute('x', xScale(1.75) - 50);
            arrow2Label.setAttribute('y', yScale(4.0) + 35);
            arrow2Label.setAttribute('text-anchor', 'middle');
            arrow2Label.setAttribute('dominant-baseline', 'middle');
            arrow2Label.setAttribute('transform', `rotate(-90 ${xScale(1.75) - 50} ${yScale(4.0)})`);
            arrow2Label.setAttribute('class', 'arrow-label');
            arrow2Label.textContent = 'better';
            svg.appendChild(arrow2Label);


            // Draw model points
            models.forEach(model => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'model-point');

                const x = xScale(model.size);
                const y = yScale(model.winRate);

                // Circle background
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                const isHighlight = model.name.includes('SmolLM3');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', isHighlight ? 35 : 28);
                circle.setAttribute('fill', 'rgba(255, 255, 255, 0.3)');
                circle.setAttribute('class', 'model-circle');
                if (isHighlight) {
                    circle.setAttribute('stroke', model.color);
                    circle.setAttribute('stroke-width', '2');
                } else {
                    circle.setAttribute('stroke', 'rgba(0, 0, 0, 0.25)');
                    circle.setAttribute('stroke-width', '1');
                }
                g.appendChild(circle);

                // Logo as foreignObject
                const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                const isSmolLM3 = isHighlight;
                const logoOffset = isSmolLM3 ? 26 : 22;
                foreignObject.setAttribute('x', x - logoOffset);
                foreignObject.setAttribute('y', isSmolLM3 ? y - 28 : y - 22);
                foreignObject.setAttribute('width', isSmolLM3 ? 54 : 44);
                foreignObject.setAttribute('height', isSmolLM3 ? 54 : 44);
                let logoSize;
                if (model.logo === 'qwen' || model.logo === 'hf') {
                    logoSize = isSmolLM3 ? 52 : 44;
                } else if (model.logo === 'meta') {
                    logoSize = 32;
                } else {
                    logoSize = 36;
                }
                foreignObject.innerHTML = `<div xmlns="http://www.w3.org/1999/xhtml" style="width: ${isSmolLM3 ? 54 : 44}px; height: ${isSmolLM3 ? 54 : 44}px; display: flex; align-items: center; justify-content: center;"><img src="./data/${model.logo}-logo.svg" style="width: ${logoSize}px; height: auto; max-height: ${logoSize}px;" /></div>`;
                g.appendChild(foreignObject);

                // Label below
                const nameParts = model.name.split(' ');
                const label1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label1.setAttribute('x', x);
                label1.setAttribute('y', isSmolLM3 ? y + 55 : y + 50);
                label1.setAttribute('class', 'model-label');
                if (isHighlight) {
                    label1.setAttribute('font-weight', '800');
                    label1.setAttribute('font-size', '16px');
                }
                label1.textContent = nameParts.slice(0, -1).join(' ');
                g.appendChild(label1);

                const label2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label2.setAttribute('x', x);
                label2.setAttribute('y', isSmolLM3 ? y + 73 : y + 66);
                label2.setAttribute('class', 'model-sublabel');
                if (isHighlight) {
                    label2.setAttribute('font-weight', '800');
                    label2.setAttribute('font-size', '14px');
                }
                label2.textContent = nameParts[nameParts.length - 1];
                g.appendChild(label2);


                svg.appendChild(g);
            });

            // Create chart container and add SVG
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.appendChild(svg);
            container.appendChild(chartContainer);
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
            bootstrap();
        }
    })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">The win rate of of base models evaluation on: HellaSwag, ARC, Winogrande, CommonsenseQA, MMLU-CF, MMLU Pro CF, PIQA, OpenBookQA, GSM8K, MATH, HumanEval+, MBPP+</figcaption></figure> </div>
<p>With our base model checkpoint saved, training complete, and GPUs finally cooling down, we might be tempted to call it done. After all, we have a model that predicts text well, achieves strong benchmark scores, and demonstrates the capabilities we targeted.</p>
<p>Not quite. Because what people want today are assistants and coding agents, not raw next-token predictors.</p>
<p>This is where post-training comes in. And just like pretraining, the reality is messier than the papers suggest.</p>
<h2 id="beyond-base-models--post-training-in-2025"><a href="#beyond-base-models--post-training-in-2025">Beyond base models — post-training in 2025</a></h2>
<blockquote class="quote" data-astro-cid-arj5dyob> <div class="quote__text" data-astro-cid-arj5dyob> <p>Once the pre-training finishes we should have an SFT baseline within a day</p> </div> <footer class="quote__footer" data-astro-cid-arj5dyob>   <span class="quote__source" data-astro-cid-arj5dyob>Lewis Tunstall, optimistic LLM expert.</span> </footer> </blockquote> 
<div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <pre class="mermaid">flowchart TD
    %% Main algorithms
    Base[&quot;Base model&quot;]
    SFT[&quot;SFT&quot;]
    ORPO[&quot;ORPO&quot;]
    DPOAPO[&quot;DPO and friends&quot;]
    RL[&quot;RL (here be dragons)&quot;]
    KTO[&quot;KTO&quot;]

    Base --&gt; SFT
    Base --&gt; ORPO
    Base --&gt; KTO
    Base --&gt; RL

    SFT --&gt; ORPO
    SFT --&gt; DPOAPO
    SFT --&gt; RL
    SFT --&gt; KTO

    classDef baseModel fill:#f9f9f9
    classDef sft fill:#ffd0c5
    classDef algorithm fill:#fef3c7
    classDef note fill:#f5f5f5
    
    class Base baseModel
    class SFT sft
    class ORPO,DPOAPO,RL,KTO algorithm</pre> </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Choose your own (post-training) adventure.</figcaption> </figure> </div> 
<p>Pre-training gave us SmolLM3’s raw ability, but before the GPUs are cooled down we enter the next frontier of model capabilities:  <em>post-training</em> . This includes supervised fine-tuning, reinforcement learning, model merging, and more — all designed to bridge the gap between “a model that predicts text” to “a model people can actually use”. If pre-training is about brute-forcing knowledge into weights, post-training is about sculpting that raw capability into something reliable and steerable. And just like pre-training, the polished post-training papers don’t capture the late-night surprises: GPU meltdowns, finicky data mixtures, or the way a seemingly minor chat template decision can ripple through downstream benchmarks. In this section, we’ll show how we navigated the messy world of post-training to turn SmolLM3 from a strong base model into a state-of-the-art hybrid reasoner.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>What is a hybrid reasoning model?</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>A hybrid reasoning model operates in two distinct modes: one for concise, direct responses and another for extended step-by-step reasoning. Typically, the operating mode is set by the user in the system message. Following Qwen3, we make this explicit with lightweight commands: “/think” invokes extended reasoning, while “/no_think” enforces concise answers. This way, the user controls whether the model prioritises depth or speed.</p> </div> </div> </div> 
<h3 id="post-training-compass-why--what--how"><a href="#post-training-compass-why--what--how">Post-training compass: why → what → how</a></h3>
<p>Just like pre-training, post-training benefits from a clear compass to avoid wasted research and engineering cycles. Here’s how to frame it:</p>
<ol>
<li>
<p><strong>Why post-train?</strong> The three motivations for training that we outlined in the <a href="#training-compass-why--what--how">pretraining compass</a>—research, production, and strategic open-source—apply equally to post-training. For example, you might be exploring whether RL can unlock new reasoning capabilities in an existing model (research), or you might need to distill a large model into a smaller one for latency reasons (production), or you may have identified a gap where no strong open model exists for a specific use case (strategic open-source). The distinction is that post-training builds on existing capabilities rather than creating them from scratch. However, before reaching for your GPUs, ask yourself:</p>
<ul>
<li>Do you really need to post-train? Many open-weight models now rival proprietary ones on a wide range of tasks. Some can even be run locally with quantisation and modest compute. If you want a generalist assistant, an off-the-shelf model from the <a href="https://huggingface.co/models">Hugging Face Hub</a> may already meet your needs.</li>
<li>Do you have access to high-quality, domain specific data? Post-training makes most sense when you are targeting a specific task or domain where a generalist model underperforms. With the right data, you can tune the model to produce more accurate outputs for the applications you care most about.</li>
<li>Can you measure success? Without clear evaluation criteria, you won’t know if post-training really helps.</li>
</ul>
</li>
<li>
<p><strong>What should post-training achieve?</strong>  This depends on your priorities:</p>
<ul>
<li>Do you want a crisp instruction-follower that rarely drifts off-topic?</li>
<li>A versatile assistant that can switch tones and roles on demand?</li>
<li>A reasoning engine that can tackle math, code, or agentic problems?</li>
<li>A model that can converse in multiple languages?</li>
</ul>
</li>
<li>
<p><strong>How will you get there?</strong>  That’s where recipes matter. We’ll cover:</p>
<ul>
<li><strong>Supervised fine-tuning (SFT)</strong>  to instil core capabilities.</li>
<li><strong>Preference optimisation (PO)</strong>  to directly learn from human or AI preferences.</li>
<li><strong>Reinforcement learning (RL)</strong>  to refine reliability and reasoning beyond supervised data.</li>
<li><strong>Data curation</strong>  to strike the right balance between diversity and quality.</li>
<li><strong>Evaluation</strong>  to track progress and catch regressions early.</li>
</ul>
</li>
</ol>
<p>This compass keeps the chaos of post-training grounded. The  <em>why</em>  gives direction, the  <em>what</em>  sets priorities, and the  <em>how</em> turns ambitions into a practical training loop.</p>
<p>Let’s walk through how we answered these questions for SmolLM3:</p>
<ul>
<li><strong>Why?</strong> For us, the “why” was straightforward as we had a base model that needed post-training before release. At the same time, hybrid reasoning models like Qwen3 were becoming increasingly popular, yet open recipes showing how to train them were scarce. SmolLM3 gave us an opportunity to address both: prepare a model for real-world use and contribute a fully open recipe to sit on the Pareto front alongside Qwen3’s 1.7B and 4B models.</li>
<li><strong>What?</strong>  We set out to train a hybrid reasoning model that was tailored to SmolLM3’s strengths, chiefly that reasoning quality should hold up across languages other than English. And since real-world use increasingly involves tool calling and long-context workflows, those became core requirements in our post-training recipe.</li>
<li><strong>How?</strong> that’s the rest of this chapter 😀.</li>
</ul>
<p>Just like with pre-training, we start with the fundamentals: evals and baselines, because every big model starts with a small ablation. But there’s a key difference in how we ablate. In pre-training, “small” usually means smaller models and datasets. In post-training, “small” means smaller datasets and  <em>simpler</em>   <em>algorithms</em> . We almost never use a different base model for ablations because behaviour is too model-dependent, and runs are short enough to iterate on the target model directly.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>The main exception to this rule is when you’re using an off-the-shelf base model from the Hugging Face Hub. In this case, ablating base models can make sense, since there’s a world of difference between one model trained on 1T tokens and another on 10T, even if they have the same size.</p> </aside> </div>  
<p>Let’s start with the topic many model trainers avoid until too late into a project: evals.</p>
<h3 id="first-things-first-evals-before-everything-else"><a href="#first-things-first-evals-before-everything-else">First things first: evals before everything else</a></h3>
<p>The very first step in post-training — just like in pre-training — is to decide on the right set of evals. Since most LLMs today are used as assistants, we’ve found that aiming for a model that “works well” is a better goal than chasing abstract benchmarks of “intelligence” like <a href="https://arcprize.org/arc-agi">ARC-AGI</a>. So what does a good assistant need to do? At minimum, it should be able to:</p>
<ul>
<li>Handle ambiguous instructions</li>
<li>Plan step-by-step</li>
<li>Write code</li>
<li>Call tools when appropriate</li>
</ul>
<p>These behaviours draw on a mix of reasoning, long-context handling, and skills with math, code, and tool use. Models as small as or even smaller than 3B parameters can work well as assistants, though performance usually falls off steeply below 1B.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>It remains an interesting, yet open question whether tiny models can use tool calling to offset their limited capacity and thus act as viable assistants. See the models from <a href="https://huggingface.co/LiquidAI/LFM2-1.2B-Tool">LiquidAI</a> for recent work in this direction.</p> </aside> </div>  
<p>At Hugging Face, we use a layered eval suite, echoing the pre-training principles (monotonicity, low noise, above-random signal, ranking consistency) that we detailed in the <a href="#every-big-model-starts-with-a-small-ablation">ablations section</a> for pretraining.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>The list of evals to consider is continuously evolving and the ones discussed below reflect our focus in mid 2025. See the <a href="https://github.com/huggingface/evaluation-guidebook/blob/main/yearly_dives/2025-evaluations-for-useful-models.md"><a href="https://github.com/huggingface/evaluation-guidebook/blob/main/yearly_dives/2025-evaluations-for-useful-models.md">Evaluation Guidebook</a></a> for a comprehensive overview of post-training evals.</p> </aside> </div>  
<p>Here are the many ways one can evaluate a post trained model:</p>
<ol>
<li><strong>Capability evals</strong></li>
</ol>
<p>This class of evals target fundamental skills, like reasoning and competitive math and coding.</p>
<ul>
<li><strong>Knowledge.</strong>  We currently use GPQA Diamond <span class="" id="citation--gpqa--118">(<a href="#bib-gpqa" id="refctx-bib-gpqa-1">Rein et al., 2024</a>)</span> as the main eval for scientific knowledge. This benchmark consists of graduate-level, multiple-choice questions.  For small models, it’s far from saturated and gives better signal than MMLU and friends, while being much faster to run. Another good test of factuality is SimpleQA <span class="" id="citation--simpleqa--119">(<a href="#bib-simpleqa" id="refctx-bib-simpleqa-1">Wei et al., 2024</a>)</span>, although small models tend to struggle significantly on this benchmark due to their limited knowledge.</li>
<li><strong>Math.</strong>  To measure mathematical ability, most models today are evaluated on the latest version of AIME (currently the 2025 version). MATH-500 <span class="" id="citation--openaiprm--120">(<a href="https://arxiv.org/abs/2305.20050" id="refctx-bib-openaiprm-1" data-ref-id="bib-openaiprm" target="_blank" rel="noopener noreferrer">Lightman et al., 2023</a>)</span> remains a useful sanity test for small models, but is largely saturated by reasoning models. For a more comprehensive set of math evals, we recommend those from <a href="https://matharena.ai/">MathArena</a>.</li>
<li><strong>Code.</strong>  We use the latest version of <a href="https://livecodebench.github.io/leaderboard.html">LiveCodeBench</a> to track coding competency. Although targeted towards competitive programming problems, we’ve found that improvements on LiveCodeBench do translate into better coding models, albeit limited to Python. <a href="https://openai.com/index/introducing-swe-bench-verified/">SWE-bench Verified</a> is a more sophisticated measure of coding skill, but tends to be too hard for small models and thus is not one we usually consider.</li>
<li><strong>Multilinguality.</strong> Unfortunately, there are not many options when it comes to testing the multilingual capabilities of models. We currently rely on Global MMLU <span class="" id="citation--globalmmlu--121">(<a href="https://arxiv.org/abs/2412.03304" id="refctx-bib-globalmmlu-1" data-ref-id="bib-globalmmlu" target="_blank" rel="noopener noreferrer">Singh et al., 2025</a>)</span> to target the main languages our models should perform well in, with MGSM <span class="" id="citation--mgsm--122">(<a href="https://arxiv.org/abs/2210.03057" id="refctx-bib-mgsm-1" data-ref-id="bib-mgsm" target="_blank" rel="noopener noreferrer">Shi et al., 2022</a>)</span> included as a test of multilingual mathematical ability.</li>
</ul>
<ol>
<li><strong>Integrated task evals</strong></li>
</ol>
<p>These evals test things that are close to what we’ll ship: multi-turn reasoning, long-context use, and tool calls in semi-realistic settings.</p>
<ul>
<li><strong>Long context.</strong>  The most commonly used test for long-context retrieval is the Needle in a Haystack (NIAH) <span class="" id="citation--niah--123">(<a href="https://github.com/gkamradt/LLMTest_NeedleInAHaystack" id="refctx-bib-niah-2" data-ref-id="bib-niah" target="_blank" rel="noopener noreferrer">Kamradt, 2023</a>)</span>, where a random fact (“needle”) is placed in somewhere within a long document (“haystack”) and the model has to retrieve it. However, this benchmark is too superficial to discriminate long-context understanding, so the community has developed more comprehensive evals like RULER <span class="" id="citation--ruler--124">(<a href="https://arxiv.org/abs/2404.06654" id="refctx-bib-ruler-2" data-ref-id="bib-ruler" target="_blank" rel="noopener noreferrer">Hsieh et al., 2024</a>)</span> and HELMET <span class="" id="citation--helmet--125">(<a href="https://arxiv.org/abs/2410.02694" id="refctx-bib-helmet-2" data-ref-id="bib-helmet" target="_blank" rel="noopener noreferrer">Yen et al., 2025</a>)</span>. More recently, OpenAI have released the <a href="https://huggingface.co/datasets/openai/mrcr">MRCR</a> and <a href="https://huggingface.co/datasets/openai/graphwalks">GraphWalks</a> benchmarks which extend the difficulty of long-context evals.</li>
</ul>
<div class="sidenote-container"> <aside class="sidenote"> <p>See also this <a href="https://nrehiew.github.io/blog/long_context/">excellent <a href="https://nrehiew.github.io/blog/long_context/">blog post</a></a> on the limitations of long-context evals and how to design realistic ones.</p> </aside> </div>  
<ul>
<li><strong>Instruction following.</strong>  IFEval <span class="" id="citation--ifeval--126">(<a href="https://arxiv.org/abs/2311.07911" id="refctx-bib-ifeval-1" data-ref-id="bib-ifeval" target="_blank" rel="noopener noreferrer">J. Zhou et al., 2023</a>)</span> is currently the most popular eval to measure instruction following, and uses automatic scoring against “verifiable instructions”. IFBench <span class="" id="citation--ifbench--127">(<a href="https://arxiv.org/abs/2507.02833" id="refctx-bib-ifbench-1" data-ref-id="bib-ifbench" target="_blank" rel="noopener noreferrer">Pyatkin et al., 2025</a>)</span> is a new extension from Ai2 which includes a more diverse set of constraints than IFEval and mitigates some benchmaxxing that has occurred in recent model releases. For multi-turn instruction following, we recommend Multi-IF <span class="" id="citation--multiif--128">(<a href="https://arxiv.org/abs/2410.15553" id="refctx-bib-multiif-1" data-ref-id="bib-multiif" target="_blank" rel="noopener noreferrer">He et al., 2024</a>)</span> or MultiChallenge <span class="" id="citation--multichallenge--129">(<a href="https://arxiv.org/abs/2501.17399" id="refctx-bib-multichallenge-1" data-ref-id="bib-multichallenge" target="_blank" rel="noopener noreferrer">Sirdeshmukh et al., 2025</a>)</span>.</li>
<li><strong>Alignment.</strong> Measuring how well models align to user intent is typically done through human annotators or by public leaderboards like <a href="https://lmarena.ai/">LMArena</a>. This is because qualities such as free-form generation, style, or overall helpfulness are difficult to measure quantitatively with automated metrics. However, in all cases it is very expensive to run these evaluations which is why the community has resorted to using LLMs as a proxy for human preferences. The most popular benchmarks of this flavour include AlpacaEval <span class="" id="citation--alpacaeval--130">(<a href="https://arxiv.org/abs/2404.04475" id="refctx-bib-alpacaeval-1" data-ref-id="bib-alpacaeval" target="_blank" rel="noopener noreferrer">Dubois et al., 2025</a>)</span>, ArenaHard <span class="" id="citation--arenahard--131">(<a href="https://arxiv.org/abs/2406.11939" id="refctx-bib-arenahard-1" data-ref-id="bib-arenahard" target="_blank" rel="noopener noreferrer">T. Li et al., 2024</a>)</span> and MixEval <span class="" id="citation--mixeval--132">(<a href="https://arxiv.org/abs/2406.06565" id="refctx-bib-mixeval-1" data-ref-id="bib-mixeval" target="_blank" rel="noopener noreferrer">Ni et al., 2024</a>)</span>, with the latter having the strongest correlation with human Elo ratings on LMArena.</li>
<li><strong>Tool calling.</strong>  <a href="https://gorilla.cs.berkeley.edu/leaderboard.html">BFCL</a> provides a comprehensive test of tool calling, albeit one that is often saturated quite quickly. TAU-Bench <span class="" id="citation--taubench--133">(<a href="https://arxiv.org/abs/2506.07982" id="refctx-bib-taubench-1" data-ref-id="bib-taubench" target="_blank" rel="noopener noreferrer">Barres et al., 2025</a>)</span> provides a test of a model’s ability to use tools and resolve user problems in simulated customer service settings and has also become a popular benchmark to report on.</li>
</ul>
<ol>
<li><strong>Overfitting-prevention evals</strong></li>
</ol>
<p>To test whether our models are overfitting to a specific skill, we include some robustness or adaptability evals in our set, like GSMPlus <span class="" id="citation--gsmplus--134">(<a href="https://arxiv.org/abs/2402.19255" id="refctx-bib-gsmplus-1" data-ref-id="bib-gsmplus" target="_blank" rel="noopener noreferrer">Q. Li et al., 2024</a>)</span>, which perturbs problems from GSM8k <span class="" id="citation--gsm8k--135">(<a href="https://arxiv.org/abs/2110.14168" id="refctx-bib-gsm8k-1" data-ref-id="bib-gsm8k" target="_blank" rel="noopener noreferrer">Cobbe et al., 2021</a>)</span> to test whether models can still solve problems of similar difficulty.</p>
<ol>
<li><strong>Internal evals</strong></li>
</ol>
<p>Although public benchmarks can provide some useful signal during model development, they are no substitute for implementing your own internal evals to target specific capabilities, or asking internal experts to interact with your model.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>This is especially true if you are building an AI product. See Hamel Husain’s wonderful <a href="https://hamel.dev/blog/posts/evals/"><a href="https://decodingml.substack.com/?utm_source=navbar&utm_medium=web">blog post</a></a> for specific advice on this topic.</p> </aside> </div>  
<p>For example, for SmolLM3 we needed a benchmark to evaluate whether the model was capable of  <em>multi-turn</em>   <em>reasoning</em> , so we implemented a variant of Multi-IF to measure this.</p>
<ol>
<li><strong>Vibe evaluations and arenas</strong></li>
</ol>
<p>Similarly, we have found that “vibe testing” intermediate checkpoints (aka interacting with your model) is essential for uncovering subtle quirks in model behaviour that are not captured by eval scores. As we discuss later, vibe testing uncovered a bug in our data processing code where all system messages were deleted from the corpus!
This is also something that can be done at scale to measure human preference, like on the popular <a href="https://lmarena.ai/">LMArena</a>. However, crowdsourced human evaluation tends to be brittle (favouring sycophancy and flowery speech over actual usefulness), so it’s important to see it as a low signal feedback.</p>
<div class="note note--danger" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>☝️</span> <div class="note__title" data-astro-cid-qg6lmfty>Decontaminate your training data</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>One risk with relying on public benchmarks is that the models can easily be overfit to them, especially when synthetic data is used to generate prompts and responses that are similar to the target benchmarks. For this reason, it is essential to decontaminate your training data against the evals you will use to guide model development. You can do this with N-gram matching using scripts like those in <a href="https://github.com/huggingface/open-r1/blob/main/scripts/decontaminate.py">Open-R1.</a></p> </div> </div> </div> 
<p>For SmolLM3 specifically, we wanted a hybrid reasoning model that could reliably follow instructions and reason well in popular domains like mathematics and code. We also wanted to ensure we preserved the base model’s capabilities of multilinguality and long-context retrieval.</p>
<p>This led us to the following set of evals:</p>

































































<div class="table-scroll"><table><thead><tr><th>Benchmark</th><th>Category</th><th>Number of prompts</th><th>Metric</th></tr></thead><tbody><tr><td>AIME25</td><td>Competitive mathematics</td><td>30</td><td>avg@64</td></tr><tr><td>LiveCodeBench (v4 for validation, v5 for final release)</td><td>Competitive programming</td><td>100 (268)</td><td>avg@16</td></tr><tr><td>GPQA Diamond</td><td>Graduate-level reasoning</td><td>198</td><td>avg@8</td></tr><tr><td>IFEval</td><td>Instruction following</td><td>541</td><td>accuracy</td></tr><tr><td>MixEval Hard</td><td>Alignment</td><td>1000</td><td>accuracy</td></tr><tr><td>BFCL v3</td><td>Tool use</td><td>4441</td><td>mixed</td></tr><tr><td>Global MMLU (lite for validation)</td><td>Multilingual Q&amp;A</td><td>590,000 (6,400)</td><td>accuracy</td></tr><tr><td>GSMPlus (mini for validation)</td><td>Robustness</td><td>10,000 (2,400)</td><td>accuracy</td></tr><tr><td>RULER</td><td>Long context</td><td>6,500</td><td>accuracy</td></tr></tbody></table></div>
<p>Let’s look at a few example questions from each to get a concrete sense of what these evaluations actually test:</p>
<iframe src="https://huggingface.co/datasets/HuggingFaceTB/post-training-benchmarks-viewer/embed/viewer/aime25/test" frameborder="0" width="100%" height="560px"></iframe>
<p>Browse through the examples above to see the types of questions in each benchmark. Notice how the diversity of domains ensures we’re testing different aspects of model capability throughout our ablations.</p>
<p>For the 3B model scale we were working with, we felt these evals would give us actionable signal, run faster than training itself, and give us confidence that improvements are real and not just noise from sampling. We also tracked our pre-training evals (see the <a href="#every-big-model-starts-with-a-small-ablation">ablation section</a> for a full list) to make sure we weren’t regressing too much on the base model performance.</p>
<div class="note note--danger" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>☝️</span> <div class="note__title" data-astro-cid-qg6lmfty>Prioritise your evals</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>The story above suggests that we got together as a team, converged on the set of evals, and had them ready to go before training any models. The reality was far messier: we had a tight deadline and rushed ahead with model training before many of the above evals were implemented (e.g. RULER was not available until a few days before the model release 🙈). In hindsight, this was a  <strong>mistake</strong>  and we should have discussed with the pre-training team which core evals should be preserved across post-training and also prioritised implementing them long before the base model was finished training. In other words, prioritise your evals before all else!</p> </div> </div> </div> 
<h4 id="rules-of-engagement-3"><a href="#rules-of-engagement-3">Rules of engagement</a></h4>
<p>Let’s summarise this section with a few hard-earned lessons we’ve acquired from evaluating thousands of models:</p>
<ul>
<li>Use  <strong>small subsets to accelerate evals</strong>  during model development. For example, LiveCodeBench v4 is highly correlated with v5, but runs in half the time. Alternatively, use methods like those from tinyBenchmarks <span class="" id="citation--tinybenchmarks--136">(<a href="https://arxiv.org/abs/2402.14992" id="refctx-bib-tinybenchmarks-1" data-ref-id="bib-tinybenchmarks" target="_blank" rel="noopener noreferrer">Polo et al., 2024</a>)</span> which seek to find the smallest subset of prompts that reliably match the full evaluation.</li>
<li>For  <strong>reasoning models</strong> , strip the chain-of-thought from the  <strong>scored</strong>  output. This eliminates false positives and also directly impacts benchmarks like IFEval which penalise responses that violate constraints like “write a poem in under 50 words”.</li>
<li>If an eval uses  <strong>LLM judges, pin the judge and version</strong>  for apples-to-apples comparisons over time. Even better, use an open weight model so that the eval is reproducible even if a provider deprecates the judge model.</li>
<li>Be wary of  <strong>contamination</strong>  in the base models. For example, most models released before AIME 2025 performed much worse than AIME 2024, suggesting some benchmaxxing was at play.</li>
<li>If possible, treat anything used during ablations as  <strong>validation</strong> , not  <strong>test.</strong> This means keeping a set of held-out benchmarks for the final model reports, similar to the Tulu3 evaluation framework <span class="" id="citation--tulu3--137">(<a href="https://arxiv.org/abs/2411.15124" id="refctx-bib-tulu3-1" data-ref-id="bib-tulu3" target="_blank" rel="noopener noreferrer">Lambert et al., 2025</a>)</span>.</li>
<li>Always include a small set of  <strong>“vibe evals”</strong>  on your own data and tasks to catch overfitting to public suites.</li>
<li>For evals with a small number of problems (typically less than ~2k), sample  <code>k</code>  times and report the  <code>avg@k</code>  accuracy. This is important to mitigate noise which can lead to incorrect decisions during development.</li>
<li>When implementing a new eval, make sure you  <strong>can replicate the published result of a few models</strong>  (within some error). Failing to do this will waste a lot of time later on if you need to fix the implementation and re-evaluate many checkpoints.</li>
<li>When in doubt, always go back to the evaluation data, and notably inspect what you are prompting your models with</li>
</ul>
<p>With the evals at hand, it’s time to train some models! Before doing that, we first need to pick a post-training framework.</p>
<h3 id="tools-of-the-trade"><a href="#tools-of-the-trade">Tools of the trade</a></h3>
<p>Behind every post-training recipe lies a toolbox of frameworks and libraries that enable large-scale experimentation. Each frameworks brings its own set of supported algorithms, fine-tuning methods, and scalability features. The table summarises the main areas of support, from supervised fine-tuning (SFT) to preference optimisation (PO) and reinforcement learning (RL):</p>









































































































<div class="table-scroll"><table><thead><tr><th>Framework</th><th>SFT</th><th>PO</th><th>RL</th><th>Multi-modal</th><th>FullFT</th><th>LoRA</th><th>Distributed</th></tr></thead><tbody><tr><td><a href="https://github.com/huggingface/trl"> <strong>TRL</strong> </a></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><a href="https://github.com/axolotl-ai-cloud/axolotl"> <strong>Axolotl</strong> </a></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><a href="https://github.com/allenai/open-instruct"> <strong>OpenInstruct</strong> </a></td><td>✅</td><td>✅</td><td>✅</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><a href="https://github.com/unslothai/unsloth"> <strong>Unsloth</strong> </a></td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><a href="https://github.com/volcengine/verl"> <strong>vERL</strong> </a></td><td>✅</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><a href="https://github.com/PrimeIntellect-ai/prime-rl"> <strong>Prime RL</strong> </a></td><td>✅</td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><a href="https://github.com/ServiceNow/PipelineRL"> <strong>PipelineRL</strong> </a></td><td>❌</td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><a href="https://github.com/OpenPipe/ART/tree/main"> <strong>ART</strong> </a></td><td>❌</td><td>❌</td><td>✅</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td><a href="https://github.com/meta-pytorch/torchforge"> <strong>TorchForge</strong> </a></td><td>✅</td><td>❌</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td><td>✅</td></tr></tbody></table></div>
<p>Here  <em>FullFT</em>  refers to  <strong>full fine-tuning</strong> , where all model parameters are updated during training.  <em>LoRA</em>  stands for  <strong>Low-Rank Adaptation</strong> , a parameter-efficient approach that updates only small low-rank matrices while keeping the base model frozen. Multi-modal refers to whether support for training on modalities beyond text (e.g. images) is supported and Distributed indicates whether training models on more than one GPU is possible.</p>
<p>At Hugging Face, we develop and maintain TRL, so it’s our framework of choice and the one we used to post-train SmolLM3.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>Fork your frameworks</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Given the fast-moving pace of the field, we’ve found it quite effective to run our experiments on an internal fork of TRL. This allows us to add new features very quickly, which are later upstreamed to the main library. If you’re comfortable working with your framework’s internals, adopting a similar workflow can be a powerful approach for rapid iteration.</p> </div> </div> </div> 
<h4 id="why-bother-with-frameworks-at-all"><a href="#why-bother-with-frameworks-at-all">Why bother with frameworks at all?</a></h4>
<p>There is a class of researchers that love to bemoan the use of training frameworks and instead argue that you should implement everything from scratch, all the time. The implicit claim here is that “real” understanding only comes from re-implementing every RL algorithm, manually coding every distributed training primitive, or hacking together a one-off eval harness.</p>
<p>But this position ignores the reality of modern research and production. Take RL for example. Algorithms like PPO and GRPO are notoriously tricky to implement correctly <span class="" id="citation--ndetailsrlhf--138">(<a href="https://arxiv.org/abs/2403.17031" id="refctx-bib-ndetailsrlhf-1" data-ref-id="bib-ndetailsrlhf" target="_blank" rel="noopener noreferrer">Huang et al., 2024</a>)</span>, and tiny mistakes in normalisation or KL penalties can lead to days of wasted compute and effort.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Even for SFT, it is <a href="https://github.com/karpathy/nanochat/pull/59">tricky to implement gradient accumulation correctly</a> in distributed settings.</p> </aside> </div>  
<p>Similarly, although it’s tempting to write a single-file implementation of some algorithm, can that same script scale from 1B to 100B+ parameters?</p>
<p>Frameworks exist precisely because the basics are already well-understood and endlessly reinventing them is a poor use of time. That’s not to say there’s no value in low-level tinkering. Implementing PPO from scratch once is an excellent learning exercise. Writing a toy transformer without a framework teaches you how attention really works. But in most cases, just pick a framework you like and hack it for your purposes.</p>
<p>With that rant out of the way, let’s take a look at where we often start our training runs.</p>
<h3 id="why-almost-every-post-training-pipeline-starts-with-sft"><a href="#why-almost-every-post-training-pipeline-starts-with-sft">Why (almost) every post-training pipeline starts with SFT</a></h3>
<p>If you spend any time on X these days, you’d think reinforcement learning (RL) is the only game in town. Every day brings new acronyms, <a href="https://x.com/agarwl_/status/1981518825007853891">algorithmic tweaks</a>, and heated debates <span class="" id="citation--chu2025--yue2025--139">(<a href="https://arxiv.org/abs/2501.17161" id="refctx-bib-chu2025-1" data-ref-id="bib-chu2025" target="_blank" rel="noopener noreferrer">Chu et al., 2025</a>; <a href="https://arxiv.org/abs/2504.13837" id="refctx-bib-yue2025-1" data-ref-id="bib-yue2025" target="_blank" rel="noopener noreferrer">Yue et al., 2025</a>)</span> about whether RL can elicit new capabilities or not.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>As we’ll see later in this blog post, RL really does work, but comes with practical tradeoffs we discuss below.</p> </aside> </div>  
<p>RL isn’t new of course. OpenAI and other labs relied heavily on RL from human feedback (RLHF) <span class="" id="citation--rlhf--140">(<a href="#bib-rlhf" id="refctx-bib-rlhf-1">Lambert et al., 2022</a>)</span> to align their early models, but it wasn’t until the release of DeepSeek-R1 <span class="" id="citation--deepseekr1--141">(<a href="https://arxiv.org/abs/2501.12948" id="refctx-bib-deepseekr1-1" data-ref-id="bib-deepseekr1" target="_blank" rel="noopener noreferrer">DeepSeek-AI, Guo, et al., 2025</a>)</span> that RL-based post-training really caught on in the open-source ecosystem.</p>
<p>But one thing hasn’t changed: almost every effective post-training pipeline still begins with supervised fine-tuning (SFT). The reasons are straightforward:</p>
<ul>
<li><strong>It’s cheap:</strong>  SFT requires modest compute compared to RL. You can usually get meaningful gains without needing to burn a bonfire of silicon, and in fraction of the time required for RL.</li>
<li><strong>It’s stable:</strong>  unlike RL, which is notoriously sensitive to reward design and hyperparameters, SFT “just works.”</li>
<li><strong>It’s the right baseline:</strong> a good SFT checkpoint usually gives most of the gains you’re after, and it makes later methods like DPO or RLHF far more effective.</li>
</ul>
<p>In practice, this means that SFT isn’t just the first step because it’s easy; it’s the step that consistently improves performance before anything more complex should be attempted. This is especially true when you are working with base models. With a few exceptions, base models are too unrefined to benefit from advanced post-training methods.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>What about DeepSeek R1-Zero?</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>At the frontier, the usual reasons for starting with SFT don’t always apply. There’s no stronger model to distill from and human annotations are too noisy for complex behaviors like long chain-of-thought. That’s why DeepSeek skipped SFT and went straight to RL with R1-Zero; to <em>discover</em> reasoning behaviors that couldn’t be taught with standard supervision.</p><p>If you’re in that regime, starting with RL can make sense. But if you’re operating there … you probably aren’t reading this blog post anyway 😀.</p> </div> </div> </div> 
<p>So, if SFT is where most pipelines begin, the next question is:  <em>what</em>  should you fine-tune? That starts with choosing the right base model.</p>
<h4 id="picking-a-base-model"><a href="#picking-a-base-model">Picking a base model</a></h4>
<p>When choosing a base model for post-training, a few practical dimensions matter most:</p>
<ul>
<li><strong>Model size:</strong>  although smol models have dramatically improved over time, it is still the case today that larger models generalise better, and often with fewer samples. Pick a model size that is representative of how you plan to use or deploy the model after training. On the <a href="https://huggingface.co/models?pipeline_tag=text-generation&num_parameters=min%3A0%2Cmax%3A32B&sort=trending">Hugging Face Hub</a>, you can filter models by modality and size to find suitable candidates:</li>
</ul>
<div class="ri-root" data-ri-root="ri_tu6wbyk8l7k" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/Screenshot_2025-10-24_at_09_37_24_2961384e-bcac-8055-9e8e-ffbd3a1aa368.C0macOQ5_Z1iRGEy.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/Screenshot_2025-10-24_at_09_37_24_2961384e-bcac-8055-9e8e-ffbd3a1aa368.C0macOQ5.png" data-astro-cid-6kov3kig width="864" height="900" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script> 
<ul>
<li><strong>Architecture (MoE vs dense):</strong>  MoE models activate a subset of parameters per token and offer higher capacity per unit of compute. They’re great for large-scale serving, but trickier to fine-tune in our experience. By contrast, dense models are simpler to train and often outperform MoEs at smaller scales.</li>
<li><strong>Post-training track record:</strong>  benchmarks are useful, but it’s even better if the base model has already spawned a collection of strong post-trained models that resonate with the community. This provides a proxy for whether the model trains well.</li>
</ul>
<div class="sidenote-container"> <aside class="sidenote"> <p>The <a href="https://www.reddit.com/r/LocalLLaMA/">LocalLLaMa subreddit</a> is a great place to understand the broad vibes of new models. <a href="https://artificialanalysis.ai/">Artificial Analysis</a> and <a href="https://lmarena.ai/">LMArena</a> also provide independent evaluation of new models, although these platforms are sometimes <a href="https://huggingface.co/papers/2504.20879">benchmaxxed by model providers.</a></p> </aside> </div>  
<p>In our experience, the base models from Qwen, Mistral, and DeepSeek are the most amenable to post-training, with Qwen being a clear favourite since each model series typically covers a large parameter range (e.g. Qwen3 models range in size from 0.6B to 235B!). This feature makes scaling far more straightforward.</p>
<p>Once you’ve chosen a base model that matches your deployment needs, the next step is to establish a simple, fast SFT baseline to probe its core skills.</p>
<h4 id="training-simple-baselines"><a href="#training-simple-baselines">Training simple baselines</a></h4>
<p>For SFT, a good baseline should be fast to train, focused on the model’s core skills, and simple to extend with more data when a particular capability isn’t up to scratch. Choosing which datasets to use for an initial baseline involves some taste and familiarity with those that are likely to be of high quality. In general, avoid over-indexing on public datasets which report high scores on academic benchmarks and instead focus on those which have been used to train great models like <a href="https://huggingface.co/datasets/teknium/OpenHermes-2.5">OpenHermes</a>. For example, in the development of SmolLM1, we initially ran SFT on <a href="https://huggingface.co/datasets/TIGER-Lab/WebInstructFull">WebInstruct</a>, which is a great dataset on paper. However, during our vibe tests, we discovered it was too science focused because the model would respond with equations to simple greetings like “How are you?”.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>The use of vibe testing to uncover quirks in the training data is a recurrent theme in this chapter — don’t underestimate the power of just chatting with your model!</p> </aside> </div>  
<p>This led us to create the <a href="./href="./2421384ebcac800cb22cdf0bb34c69f7">Everyday Conversations</a> dataset which turned out to be crucial for instilling basic chat capabilities in small models.</p>
<p>For SmolLM3, we set out to train a hybrid reasoning model and initially picked a small set of datasets to target reasoning, instruction following, and steerabilty. The table below shows the statistics of each dataset:<sup><a href="#user-content-fn-f1" id="user-content-fnref-f1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup></p>
<div class="wide"> <div class="reference-wrapper" id="sft-datasets" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> 




































































































<div class="table-scroll"><table><thead><tr><th>Dataset</th><th>Reasoning mode</th><th># examples</th><th>% of examples</th><th># tokens (M)</th><th>% of tokens</th><th>Avg. # tokens per example</th><th>Avg. # tokens in context</th><th>Avg. # tokens in response</th><th>Avg. # turns</th></tr></thead><tbody><tr><td>Everyday Conversations</td><td>/no_think</td><td>2,260</td><td>2.3</td><td>0.6</td><td>0.8</td><td>260.2</td><td>222.3</td><td>94.0</td><td>7.8</td></tr><tr><td>SystemChats 30k</td><td>/no_think</td><td>33,997</td><td>35.2</td><td>21.5</td><td>28.2</td><td>631.9</td><td>422.8</td><td>267.7</td><td>6.3</td></tr><tr><td>Tulu 3 SFT Personas IF</td><td>/no_think</td><td>29,970</td><td>31.0</td><td>13.3</td><td>17.5</td><td>444.5</td><td>119.8</td><td>380.7</td><td>2</td></tr><tr><td>Everyday Conversations (Qwen3-32B)</td><td>/think</td><td>2,057</td><td>2.1</td><td>3.1</td><td>4.1</td><td>1,522.4</td><td>376.8</td><td>1,385.6</td><td>4</td></tr><tr><td>SystemChats 30k (Qwen3-32B)</td><td>/think</td><td>27,436</td><td>28.4</td><td>29.4</td><td>38.6</td><td>1070.8</td><td>84.6</td><td>1,042.7</td><td>2</td></tr><tr><td>s1k-1.1</td><td>/think</td><td>835</td><td>0.9</td><td>8.2</td><td>10.8</td><td>8,859.3</td><td>370.9</td><td>9,728.5</td><td>2</td></tr><tr><td>Total</td><td>-</td><td>96,555</td><td>100.0</td><td>76.1</td><td>100.0</td><td>2,131.5</td><td>266.2</td><td>2,149.9</td><td>4.0</td></tr></tbody></table></div> </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Data mixture for hybrid reasoning baselines</figcaption> </figure> </div>  </div>
<p>As we learned throughout the development of SmolLM3, training hybrid reasoning models is trickier than standard SFT because you can’t just mix datasets together; you need to  <em>pair</em>  data across modes. Each example has to clearly indicate whether the model should engage in extended reasoning or give a concise answer, and ideally you want parallel examples that teach it when to switch modes. Another thing to note from the above table is that you should balance your data mixture in terms of  <em>tokens</em>  not  <em>examples</em> : for instance, the s1k-1.1 dataset is ~1% of the total examples but accounts for ~11% of the total tokens due to the long reasoning responses.</p>
<p>This gave us basic coverage across the skills we cared about most, but also introduced a new challenge: each dataset had to be formatted differently, depending on whether it should enable extended thinking or not. To unify these formats, we needed a consistent chat template.</p>
<h4 id="picking-a-good-chat-template"><a href="#picking-a-good-chat-template">Picking a good chat template</a></h4>
<p>When it comes to choosing or designing a chat template, there isn’t a one-size-fits-all answer. In practice, we’ve found there are a few questions worth asking up front:</p>
<ul>
<li><strong>Can users customise the system role?</strong>  If users should be able to define their own system prompts (e.g. “act like a pirate”), the template needs to handle that cleanly.</li>
<li><strong>Does the model need tools?</strong>  If your model needs to call APIs, the template needs to accommodate structured outputs for tool calls and responses.</li>
<li><strong>Is it a reasoning model?</strong> Reasoning models use templates like  <code>&lt;think&gt; ... &lt;/think&gt;</code>  to separate the model’s “thoughts” from its final answer. Some models discard the reasoning tokens across turns in a conversation, and the chat template needs to handle that logic.</li>
<li><strong>Will it work with inference engines?</strong>  Inference engines like vLLM and SGLang have dedicated parsers for reasoning and tools<sup><a href="#user-content-fn-f2" id="user-content-fnref-f2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>. Compatibility with these parsers saves a lot of pain later, especially in complex agent benchmarks where consistent tool calls are essential.<sup><a href="#user-content-fn-f3" id="user-content-fnref-f3" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup></li>
</ul>
<p>The table below shows a few popular chat templates and how they compare across the key considerations:</p>
<div class="wide"> 




































































<div class="table-scroll"><table><thead><tr><th><strong>Chat template</strong></th><th><strong>System role customisation</strong></th><th><strong>Tools</strong></th><th><strong>Reasoning</strong></th><th><strong>Inference  compatibility</strong></th><th><strong>Notes</strong></th></tr></thead><tbody><tr><td>ChatML</td><td>✅</td><td>✅</td><td>❌</td><td>✅</td><td>Simple and good for most use cases.</td></tr><tr><td>Qwen3</td><td>✅</td><td>✅</td><td><u>✅</u></td><td>✅</td><td>Hybrid reasoning template</td></tr><tr><td>DeepSeek-R1</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td><td>Prefills reasoning content with  <code>&lt;think&gt;</code> .</td></tr><tr><td>Llama 3</td><td>✅</td><td>✅</td><td>❌</td><td>✅</td><td>Has built-in tools like a Python code interpreter.</td></tr><tr><td>Gemma 3</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>System role customisation defined at the first user turn.</td></tr><tr><td>Command A Reasoning</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td><td>Multiple chat templates per model.</td></tr><tr><td>GPT-OSS</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>Based on the <a href="https://cookbook.openai.com/articles/openai-harmony">Harmony response format</a>. Complex, yet versatile.</td></tr></tbody></table></div> </div>
<p>In most cases, we’ve found that ChatML or Qwen’s chat templates are an excellent place to start. For SmolLM3, we needed a template for hybrid reasoning and found that Qwen3 was one of the few templates that struck a good balance across the dimensions we cared about. However, it had one quirk that we weren’t entirely happy with: the reasoning content is discarded for all but the final turn in a conversation. As shown in the figure below, this is similar to how <a href="https://platform.openai.com/docs/guides/reasoning/how-reasoning-works">OpenAI’s reasoning models work</a>:</p>
<div class="wide"> <pre class="mermaid">flowchart LR
    subgraph Turn1 [&quot;Turn 1&quot;]
        T1_Input[&quot;**INPUT**&quot;]
        T1_Output[&quot;**OUTPUT**&quot;]
    end

    subgraph Turn2 [&quot;Turn 2&quot;]
        T2_Input[&quot;**INPUT**&quot;]
        T2_Output[&quot;**OUTPUT**&quot;]
    end

    subgraph Turn3 [&quot;Turn 3&quot;]
        T3_Input[&quot;**INPUT**&quot;]
        T3_Output1[&quot;**OUTPUT**&quot;]
        Reasoning[&quot;**REASONING**&quot;]
        T3_Output2_Top[&quot;**OUTPUT**&quot;]
        TruncatedOutput[&quot;**TRUNCATED OUTPUT**&quot;]
    end

    T1_Input --&gt; T2_Input
    T1_Output --&gt; T2_Input

    T2_Input --&gt; T3_Input
    T2_Output --&gt; T3_Input

    T3_Input --&gt; T3_Output1
    T3_Output1 --&gt; Reasoning
    Reasoning --&gt; T3_Output2_Top

    T3_Output2_Top --&gt;|CONTEXT WINDOW ✂️| TruncatedOutput

    classDef input fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
    classDef output fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
    classDef reasoning fill:#f5f5f5,stroke:#999,stroke-width:1px
    classDef truncated fill:#ffebee,stroke:#f44336,stroke-width:3px
    classDef subgraphStyle fill:#f8f9fa,stroke:#dee2e6,stroke-width:1px
    classDef linkLabel fill:#f8f9fa,stroke:#dee2e6,stroke-width:1px

    class T1_Input,T2_Input,T3_Input input
    class T1_Output,T2_Output,T3_Output1,T3_Output2_Top output
    class Reasoning reasoning
    class TruncatedOutput truncated
    class Turn1,Turn2,Turn3 subgraphStyle
    linkStyle 4 stroke:#333,stroke-width:2px,fill:#f8f9fa
</pre> </div>
<p>Although this makes sense for  <em>inference</em>  (to avoid blowing up the context), we concluded that for  <em>training</em>  it is important to  <em>retain the reasoning tokens across all turns</em>  in order to condition the model appropriately.</p>
<p>Instead, we decided to craft our own chat template with the following features:</p>
<ul>
<li>A structured system prompt, like <a href="https://huggingface.co/spaces/huggingfacejs/chat-template-playground?modelId=meta-llama%2FLlama-3.1-8B-Instruct">Llama 3’s</a> and those <a href="https://github.com/elder-plinius/CL4R1T4S">jailbroken from proprietary models</a>. We also wanted to offer the flexibility to override the system prompt entirely.</li>
<li>Support for <a href="https://huggingface.co/learn/agents-course/en/unit2/smolagents/code_agents">code agents</a>, which execute arbitrary Python code instead of making JSON tool calls.</li>
<li>Explicit control of the reasoning mode via the system message.</li>
</ul>
<p>To iterate on the design of the chat template, we used the <a href="https://huggingface.co/spaces/huggingfacejs/chat-template-playground">Chat Template Playground</a>. This handy application was developed by our colleagues at Hugging Face and makes it easy to preview how messages are rendered and debug formatting issues. Here’s an embedded version of the playground so you can try it out directly:</p>
<div class="wide"> <iframe src="https://huggingfacejs-chat-template-playground.hf.space?modelId=HuggingFaceTB%2FSmolLM3-3B&example=hello-world" frameborder="0" width="100%" height="650"></iframe> </div>
<p>Select different examples from the drop-down to see how the chat template works for multi-turn dialogues, reasoning, or tool-use. You can even change the JSON input manually to enable different behaviour. For example, see what happens if you provide  <code>enable_thinking: false</code>  or append  <code>/no_think</code>  to the system message.</p>
<p>Once you’ve settled on some initial datasets and a chat template, it’s time to train some baselines!</p>
<h4 id="baby-baselines"><a href="#baby-baselines">Baby baselines</a></h4>
<p>Before we dive into optimisation and squeezing every point of performance, we need to establish some “baby baselines”. These baselines aren’t about reaching state-of-the-art (yet), but aim to validate that the chat template does what you want and that the initial set of hyperparameters produce stable training. Only after we have this foundation do we start heavily tuning hyperparameters and training mixtures.</p>
<p>When it comes to training SFT baselines, here’s the main things to consider:</p>
<ul>
<li>Will you use full fine-tuning (FullFT) or parameter efficient methods like LoRA or QLoRA?</li>
</ul>
<div class="sidenote-container"> <aside class="sidenote"> <p>See the wonderful <a href="https://thinkingmachines.ai/blog/lora/">blog post</a> by Thinking Machines on when these methods produce equivalent performance.</p> </aside> </div>  
<ul>
<li>What type of parallelism do you need? For small models or those trained with LoRA, you can usually get by with data parallel. For larger models you will need FSDP2 or DeepSpeed ZeRO-3 to shared the model weights and optimizer states. For models trained with long context, use methods like <a href="https://huggingface.co/docs/trl/v0.23.0/en/reducing_memory_usage#context-parallelism">context parallelism</a>.</li>
<li>Use kernels like FlashAttention and Liger if your hardware supports them. Many of these kernels are hosted on the <a href="https://huggingface.co/models?other=kernel">Hugging Face Hub</a> and can be set via a <a href="https://huggingface.co/docs/trl/kernels_hub">simple argument</a> in TRL to dramatically lower the VRAM usage.</li>
<li>Mask the loss to <a href="https://huggingface.co/docs/trl/sft_trainer#train-on-assistant-messages-only">train only on assistant tokens</a>.  As we discuss below, this can be achieved by wrapping the assistant turns of your chat template with a special  <code>{% generation %}</code>  keyword.</li>
<li>Tune the learning rate; aside from the data, this is the most important factor that determines whether your model is “meh” vs “great”.</li>
<li><a href="https://huggingface.co/docs/trl/v0.23.0/en/reducing_memory_usage#packing">Pack the training samples</a> and tune the sequence length to match the distribution of your data. This will dramatically speed up training.</li>
</ul>
<div class="sidenote-container"> <aside class="sidenote"> <p>TRL has a handy <a href="https://huggingface.co/docs/trl/v0.23.0/en/reducing_memory_usage#how-to-choose-the-maxlength-value">application</a> to do this for you.</p> </aside> </div>  
<p>Let’s look at how some of these choices panned out for SmolLM3. For our first baseline experiments, we wanted a simple sanity check: does the chat template actually elicit hybrid reasoning? To test this, we compared three data mixtures from our <a href="#sft-datasets">table</a>:</p>
<ul>
<li><strong>Instruct:</strong>  train on the non-reasoning examples.</li>
<li><strong>Thinking:</strong> train on the reasoning examples.</li>
<li><strong>Hybrid:</strong>  train on all examples.</li>
</ul>
<p>For each mixture, we ran SFT on <a href="https://huggingface.co/HuggingFaceTB/SmolLM3-3B-Base">SmolLM3-3B-Base</a> using FullFT with a learning rate of 1e-5, an effective batch size of 128, and trained for 1 epoch.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>We have found that for most models and datasets, this choice of hyperparameters works well as a baseline.</p> </aside> </div>  
<p>Since these are small datasets, we did not use packing, capping sequences at 8,192 tokens for the Instruct subset and 32,768 tokens for the rest. On one node of 8 x H100s, these experiments were quick to run, taking between 30-90 minutes depending on the subset. The figures below compare the performance of each subset for the corresponding reasoning mode:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-b4isiktisn"><div class="d3-sft-baby-baseline"></div>
<style>
  .d3-sft-baby-baseline {
    position: relative;
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  }

  .d3-sft-baby-baseline svg {
    display: block;
    width: 100%;
  }

  .d3-sft-baby-baseline .axes path,
  .d3-sft-baby-baseline .axes line {
    stroke: var(--axis-color);
  }

  .d3-sft-baby-baseline .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-baby-baseline .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2, 2;
  }

  .d3-sft-baby-baseline .bar {
    cursor: pointer;
    transition: opacity 0.15s ease;
  }

  .d3-sft-baby-baseline .bar:hover {
    opacity: 0.8;
  }

  .d3-sft-baby-baseline .legend-controls-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 24px;
    margin-top: 12px;
    flex-wrap: wrap;
  }

  .d3-sft-baby-baseline .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    flex: 1;
    min-width: 0;
  }

  .d3-sft-baby-baseline .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-baby-baseline .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-baby-baseline .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-sft-baby-baseline .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-baby-baseline .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    flex-shrink: 0;
  }

  .d3-sft-baby-baseline .controls .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-baby-baseline .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-baby-baseline .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
  }

  .d3-sft-baby-baseline .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }

  .d3-sft-baby-baseline .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 10px 12px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.5;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.18);
    opacity: 0;
    transition: opacity 0.12s ease;
    z-index: 1000;
  }

  .d3-sft-baby-baseline .d3-tooltip.visible {
    opacity: 1;
  }

  .d3-sft-baby-baseline .d3-tooltip__inner {
    text-align: left;
  }

  .d3-sft-baby-baseline .d3-tooltip__inner strong {
    color: var(--text-color);
    font-weight: 700;
  }

  .d3-sft-baby-baseline .axis-label {
    font-size: 12px;
    font-weight: 600;
    fill: var(--text-color);
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-baby-baseline'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-baby-baseline'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Data loading helpers
      const CSV_PATHS = [
        '/data/sft_baby-baseline.csv',
        './assets/data/sft_baby-baseline.csv',
        '../assets/data/sft_baby-baseline.csv',
        '../../assets/data/sft_baby-baseline.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found at any of the specified paths');
      };

      // Tooltip setup
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gBars = gRoot.append('g').attr('class', 'bars');
      const gAxes = gRoot.append('g').attr('class', 'axes');

      // State
      let data = [];
      let currentMode = '/no_think';
      let width = 800;
      let height = 400;
      const margin = { top: 20, right: 40, bottom: 80, left: 64 };

      // Color palette
      let uniqueSubsets = [];
      const subsetColors = {};

      const getColors = (n) => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          return window.ColorPalettes.getColors('categorical', n);
        }
        // Fallback to Tableau10-inspired colors
        return ['#4E79A7', '#F28E2B', '#E15759', '#76B7B2'];
      };

      function updateColors() {
        const colors = getColors(uniqueSubsets.length);
        uniqueSubsets.forEach((subset, i) => {
          subsetColors[subset] = colors[i];
        });
      }

      // Listen for palette changes
      if (window.ColorPalettes && window.ColorPalettes.onChange) {
        window.ColorPalettes.onChange(() => {
          updateColors();
          render();
        });
      }

      function updateSize() {
        width = container.clientWidth || 800;
        height = Math.max(320, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      }

      function makeLegendAndControls() {
        // Create wrapper if it doesn't exist
        let wrapper = container.querySelector('.legend-controls-wrapper');
        if (!wrapper) {
          wrapper = document.createElement('div');
          wrapper.className = 'legend-controls-wrapper';
          container.appendChild(wrapper);
        }

        // Create legend
        let legend = wrapper.querySelector('.legend');
        if (!legend) {
          legend = document.createElement('div');
          legend.className = 'legend';
          wrapper.appendChild(legend);
        }
        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.textContent = 'Legend';
          legend.appendChild(title);
        }
        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }
        items.innerHTML = '';

        uniqueSubsets.forEach((subset) => {
          const el = document.createElement('span');
          el.className = 'item';
          const sw = document.createElement('span');
          sw.className = 'swatch';
          sw.style.background = subsetColors[subset];
          const txt = document.createElement('span');
          txt.textContent = subset;
          el.appendChild(sw);
          el.appendChild(txt);
          items.appendChild(el);
        });

        // Create controls
        let controls = wrapper.querySelector('.controls');
        if (!controls) {
          controls = document.createElement('div');
          controls.className = 'controls';
          wrapper.appendChild(controls);
        }

        let group = controls.querySelector('.control-group');
        if (!group) {
          group = document.createElement('div');
          group.className = 'control-group';
          controls.appendChild(group);
        }

        let label = group.querySelector('label');
        if (!label) {
          label = document.createElement('label');
          label.setAttribute('for', 'reasoning-mode-select');
          label.textContent = 'Reasoning mode';
          group.appendChild(label);
        }

        let select = group.querySelector('select');
        if (!select) {
          select = document.createElement('select');
          select.id = 'reasoning-mode-select';
          select.innerHTML = `
            <option value="/no_think">/no_think</option>
            <option value="/think">/think</option>
          `;
          select.addEventListener('change', (e) => {
            currentMode = e.target.value;
            render();
          });
          group.appendChild(select);
        }
      }

      function render() {
        if (!data || data.length === 0) return;

        const { innerWidth, innerHeight } = updateSize();

        // Filter data by current mode
        const filteredData = data.filter(d => d['Reasoning mode'] === currentMode);

        // Get unique benchmarks
        const benchmarks = ['AIME25', 'GPQA-D', 'LiveCodeBench v4', 'IFEval', 'Global MMLU Lite'];

        // Transform data for grouped bars
        const groupedData = benchmarks.map(benchmark => {
          const values = filteredData.map(d => ({
            subset: d.Subset,
            value: +d[benchmark] || 0
          }));
          return { benchmark, values };
        });

        // Scales
        const x0 = d3.scaleBand()
          .domain(benchmarks)
          .range([0, innerWidth])
          .padding(0.2);

        const x1 = d3.scaleBand()
          .domain(filteredData.map(d => d.Subset))
          .range([0, x0.bandwidth()])
          .padding(0.05);

        const y = d3.scaleLinear()
          .domain([0, d3.max(filteredData, d => d3.max(benchmarks, b => +d[b] || 0)) || 100])
          .range([innerHeight, 0])
          .nice();

        // Grid
        gGrid
          .attr('transform', `translate(0,0)`)
          .call(d3.axisLeft(y).tickSize(-innerWidth).tickFormat(''))
          .call(g => g.select('.domain').remove());

        // Bars
        const groups = gBars.selectAll('g.benchmark-group')
          .data(groupedData, d => d.benchmark);

        const groupsEnter = groups.enter()
          .append('g')
          .attr('class', 'benchmark-group');

        groups.exit().remove();

        const groupsMerge = groupsEnter.merge(groups)
          .attr('transform', d => `translate(${x0(d.benchmark)},0)`);

        const bars = groupsMerge.selectAll('rect.bar')
          .data(d => d.values, d => d.subset);

        bars.enter()
          .append('rect')
          .attr('class', 'bar')
          .merge(bars)
          .attr('x', d => x1(d.subset))
          .attr('width', x1.bandwidth())
          .attr('fill', d => subsetColors[d.subset])
          .attr('stroke', 'none')
          .transition()
          .duration(200)
          .attr('y', d => y(d.value))
          .attr('height', d => Math.max(0, innerHeight - y(d.value)));

        bars.exit().remove();

        // Hover interactions
        groupsMerge.selectAll('rect.bar')
          .on('mouseenter', function (event, d) {
            const benchmark = d3.select(this.parentNode).datum().benchmark;
            tipInner.innerHTML = `<strong>${d.subset}</strong><br/>${benchmark}: <strong>${d.value.toFixed(2)}</strong>`;
            tip.classList.add('visible');
          })
          .on('mousemove', function (event) {
            const [mx, my] = d3.pointer(event, container);
            const offsetX = 10;
            const offsetY = -10;
            tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
          })
          .on('mouseleave', function () {
            tip.classList.remove('visible');
            tip.style.transform = 'translate(-9999px, -9999px)';
          });

        // Axes
        gAxes.selectAll('.x-axis').remove();
        gAxes.selectAll('.y-axis').remove();

        const xAxis = gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(x0).tickSizeOuter(0));

        xAxis.selectAll('text')
          .style('text-anchor', 'middle');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(y).ticks(6).tickSizeOuter(0));

        // Y-axis label
        gAxes.selectAll('.y-label').remove();
        gAxes.append('text')
          .attr('class', 'y-label axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -margin.left + 20)
          .style('text-anchor', 'middle')
          .text('Score (%)');
      }

      // Load data
      fetchFirstAvailable(CSV_PATHS)
        .then(csvText => {
          data = d3.csvParse(csvText);

          // Extract unique subsets from data
          uniqueSubsets = [...new Set(data.map(d => d.Subset))];
          updateColors();

          makeLegendAndControls();
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.color = 'red';
          pre.style.fontSize = '12px';
          pre.style.padding = '12px';
          pre.textContent = `Error loading data: ${err.message}`;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>These results quickly showed us that hybrid models exhibit a type of “split brain”, where the data mixture for one reasoning mode has little effect on the other. This is evident by most evals having similar scores between the Instruct, Thinking and Hybrid subsets, with LiveCodeBench v4 and IFEval being the exception where hybrid data boosts the overall performance.</p>
<h4 id="vibe-test-your-baselines"><a href="#vibe-test-your-baselines"><strong>Vibe-test your baselines</strong></a></h4>
<p>Although the evals looked OK, when we tried getting the hybrid model to act in different personas (e.g. like a pirate), it consistently ignored anything we placed in the system message. After a bit of digging, we found the reason was due to the way we had formatted the data:</p>
<div class="ri-root" data-ri-root="ri_wzmco1o6dpk" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/Screenshot_2025-09-26_at_22_36_40_27a1384e-bcac-8063-94e0-f1c689e7d9b9.vtcw08KN_wObJG.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/Screenshot_2025-09-26_at_22_36_40_27a1384e-bcac-8063-94e0-f1c689e7d9b9.vtcw08KN.png" data-astro-cid-6kov3kig width="1458" height="238" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script> 
<p>What happened is that in the design of our chat template, we exposed a  <code>custom_instructions</code>  argument to store the system prompts. For example, here’s how we set a persona in a dialogue:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> transformers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> AutoTokenizer</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">tok </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> AutoTokenizer.from_pretrained(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;HuggingFaceTB/SmolLM3-3B&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">messages </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        &quot;content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;I&#39;m trying to set up my iPhone, can you help?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        &quot;role&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        &quot;content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;Of course, even as a vampire, technology can be a bit of a challenge sometimes [TRUNCATED]&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        &quot;role&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;assistant&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">chat_template_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    &quot;custom_instructions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;You are a vampire technologist&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    &quot;enable_thinking&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">False</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">rendered_input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> tok.apply_chat_template(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    messages, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">tokenize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">False</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">chat_template_kwargs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(rendered_input)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## &lt;|im_start|&gt;system</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">### Metadata</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Knowledge Cutoff Date: June 2025</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Today Date: 28 October 2025</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Reasoning Mode: /no_think</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">### Custom Instructions</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## You are a vampire technologist</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## &lt;|im_start|&gt;user</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## I&#39;m trying to set up my iPhone, can you help?&lt;|im_end|&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## &lt;|im_start|&gt;assistant</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## &lt;think&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## &lt;/think&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Of course, even as a vampire, technology can be a bit of a challenge sometimes # [TRUNCATED]&lt;|im_end|&gt;</span></span>
<span class="line"></span></code></pre></div>
<p>The issue was that our data samples looked like this:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    &quot;messages&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">            &quot;content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;I&#39;m trying to set up my iPhone, can you help?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">            &quot;role&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;user&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">            &quot;content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;Of course, even as a vampire, technology can be a bit of a challenge sometimes [TRUNCATED]&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">            &quot;role&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;assistant&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    ],</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    &quot;chat_template_kwargs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        &quot;custom_instructions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        &quot;enable_thinking&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">False</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        &quot;python_tools&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">        &quot;xml_tools&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"></span></code></pre></div>
<p>A bug in our processing code had set  <code>custom_instructions</code>  to  <code>None</code> , which effectively removed the system message from  <em>every single training sample</em>  🙈! So instead of getting a nice persona for these training samples, we ended up with the SmolLM3 default system prompt:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">chat_template_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;custom_instructions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;enable_thinking&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">False</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">rendered_input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> tok.apply_chat_template(messages, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">tokenize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">False</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">chat_template_kwargs)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(rendered_input)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## &lt;|im_start|&gt;system</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">#### Metadata</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Knowledge Cutoff Date: June 2025</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Today Date: 28 October 2025</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Reasoning Mode: /no_think</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">#### Custom Instructions</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## You are a helpful AI assistant named SmolLM, trained by Hugging Face.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## &lt;|im_start|&gt;user</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## I&#39;m trying to set up my iPhone, can you help?&lt;|im_end|&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## &lt;|im_start|&gt;assistant</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## &lt;think&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## &lt;/think&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Of course, even as a vampire, technology can be a bit of a challenge sometimes [TRUNCATED]&lt;|im_end|&gt;</span></span>
<span class="line"></span></code></pre></div>
<p>This was especially problematic for the SystemChats subset, where all the personas are defined via  <code>custom_instructions</code>  and thus the model had a tendency to randomly switch character mid-conversation. This brings us to the following rule:</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>☝️</span> <div class="note__title" data-astro-cid-qg6lmfty>Rule</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Always vibe-test your models, even if the evals look fine. More often than not, you will uncover subtle bugs in your training data.</p> </div> </div> </div> 
<p>Fixing this bug had no impact on the evals, but finally we were confident the chat template and dataset formatting was working. Once your setup is stable and your data pipeline checks out, the next step is to focus on developing specific capabilities.</p>
<h4 id="targeting-specific-capabilities"><a href="#targeting-specific-capabilities">Targeting specific capabilities</a></h4>
<p>During the development of <a href="https://github.com/huggingface/open-r1">Open-R1</a>, we noticed that training a base model entirely on single-turn reasoning data would fail to generalise to multi-turn. This is not a surprise; absent such examples, the model is being tested outside its training distribution.</p>
<p>To measure this quantitatively for SmolLM3, we took inspiration from Qwen3, who developed an internal eval called  <em>ThinkFollow</em> , which randomly inserts  <code>/think</code>  or  <code>/no_think</code>  tags to test whether the model can consistently switch reasoning modes. In our implementation, we took the prompts from Multi-IF and then checked if the model generated empty or non-empty think blocks enclosed in the  <code>&lt;think&gt;</code>  and  <code>&lt;/think&gt;</code>  tags. As expected, the results from our hybrid baseline showed the model failing abysmally to enable the reasoning mode beyond the first turn:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-zd7vrutf41i"><div class="d3-sft-think-follow"></div>
<style>
  .d3-sft-think-follow {
    position: relative;
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  }

  .d3-sft-think-follow svg {
    display: block;
    width: 100%;
  }

  .d3-sft-think-follow .axes path,
  .d3-sft-think-follow .axes line {
    stroke: var(--axis-color);
  }

  .d3-sft-think-follow .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-think-follow .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2, 2;
  }

  .d3-sft-think-follow .bar {
    cursor: pointer;
    transition: opacity 0.15s ease;
  }

  .d3-sft-think-follow .bar:hover {
    opacity: 0.8;
  }

  .d3-sft-think-follow .legend-controls-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 24px;
    margin-top: 12px;
    flex-wrap: wrap;
  }

  .d3-sft-think-follow .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    flex: 1;
    min-width: 0;
  }

  .d3-sft-think-follow .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-think-follow .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-think-follow .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-sft-think-follow .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-think-follow .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    flex-shrink: 0;
  }

  .d3-sft-think-follow .controls .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-think-follow .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-think-follow .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
  }

  .d3-sft-think-follow .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }

  .d3-sft-think-follow .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 10px 12px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.5;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.18);
    opacity: 0;
    transition: opacity 0.12s ease;
    z-index: 1000;
  }

  .d3-sft-think-follow .d3-tooltip.visible {
    opacity: 1;
  }

  .d3-sft-think-follow .d3-tooltip__inner {
    text-align: left;
  }

  .d3-sft-think-follow .d3-tooltip__inner strong {
    color: var(--text-color);
    font-weight: 700;
  }

  .d3-sft-think-follow .axis-label {
    font-size: 12px;
    font-weight: 600;
    fill: var(--text-color);
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-think-follow'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-think-follow'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Data loading helpers
      const CSV_PATHS = [
        '/data/sft_think-follow-0.csv',
        './assets/data/sft_think-follow-0.csv',
        '../assets/data/sft_think-follow-0.csv',
        '../../assets/data/sft_think-follow-0.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found at any of the specified paths');
      };

      // Tooltip setup
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gBars = gRoot.append('g').attr('class', 'bars');
      const gAxes = gRoot.append('g').attr('class', 'axes');

      // State
      let data = [];
      let width = 800;
      let height = 400;
      const margin = { top: 20, right: 40, bottom: 60, left: 64 };

      // Color palette
      let uniqueModels = [];
      const modelColors = {};

      const getColors = (n) => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          return window.ColorPalettes.getColors('categorical', n);
        }
        // Fallback to Tableau10-inspired colors
        return ['#4E79A7', '#F28E2B', '#E15759', '#76B7B2'];
      };

      function updateColors() {
        const colors = getColors(uniqueModels.length);
        uniqueModels.forEach((model, i) => {
          modelColors[model] = colors[i];
        });
      }

      // Listen for palette changes
      if (window.ColorPalettes && window.ColorPalettes.onChange) {
        window.ColorPalettes.onChange(() => {
          updateColors();
          render();
        });
      }

      function updateSize() {
        width = container.clientWidth || 800;
        height = Math.max(320, Math.round(width / 2.5));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      }

      function makeLegend() {
        // Create wrapper if it doesn't exist
        let wrapper = container.querySelector('.legend-controls-wrapper');
        if (!wrapper) {
          wrapper = document.createElement('div');
          wrapper.className = 'legend-controls-wrapper';
          container.appendChild(wrapper);
        }

        // Create legend
        let legend = wrapper.querySelector('.legend');
        if (!legend) {
          legend = document.createElement('div');
          legend.className = 'legend';
          wrapper.appendChild(legend);
        }
        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.textContent = 'Legend';
          legend.appendChild(title);
        }
        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }
        items.innerHTML = '';

        uniqueModels.forEach((model) => {
          const el = document.createElement('span');
          el.className = 'item';
          const sw = document.createElement('span');
          sw.className = 'swatch';
          sw.style.background = modelColors[model];
          const txt = document.createElement('span');
          txt.textContent = model;
          el.appendChild(sw);
          el.appendChild(txt);
          items.appendChild(el);
        });
      }

      function render() {
        if (!data || data.length === 0) return;

        const { innerWidth, innerHeight } = updateSize();

        // Get all turns from data
        const turns = ['Turn 1', 'Turn 2', 'Turn 3'];

        // Transform data for grouped bars
        // Each turn should have bars for each model
        const groupedData = turns.map(turn => {
          const values = uniqueModels.map(model => {
            const row = data.find(d => d.Model === model);
            return {
              model: model,
              value: row ? (+row[turn] || 0) : 0
            };
          });
          return { turn, values };
        });

        // Scales
        const x0 = d3.scaleBand()
          .domain(turns)
          .range([0, innerWidth])
          .padding(0.2);

        const x1 = d3.scaleBand()
          .domain(uniqueModels)
          .range([0, x0.bandwidth()])
          .padding(0.05);

        const y = d3.scaleLinear()
          .domain([0, 100])
          .range([innerHeight, 0])
          .nice();

        // Grid
        gGrid
          .attr('transform', `translate(0,0)`)
          .call(d3.axisLeft(y).tickSize(-innerWidth).tickFormat(''))
          .call(g => g.select('.domain').remove());

        // Groups
        const groups = gBars.selectAll('g.turn-group')
          .data(groupedData, d => d.turn);

        const groupsEnter = groups.enter()
          .append('g')
          .attr('class', 'turn-group');

        groups.exit().remove();

        const groupsMerge = groupsEnter.merge(groups)
          .attr('transform', d => `translate(${x0(d.turn)},0)`);

        // Bars
        const bars = groupsMerge.selectAll('rect.bar')
          .data(d => d.values, d => d.model);

        bars.enter()
          .append('rect')
          .attr('class', 'bar')
          .attr('x', d => x1(d.model))
          .attr('width', x1.bandwidth())
          .attr('fill', d => modelColors[d.model])
          .attr('stroke', 'none')
          .attr('y', innerHeight)
          .attr('height', 0)
          .merge(bars)
          .transition()
          .duration(200)
          .attr('x', d => x1(d.model))
          .attr('width', x1.bandwidth())
          .attr('fill', d => modelColors[d.model])
          .attr('y', d => y(d.value))
          .attr('height', d => Math.max(0, innerHeight - y(d.value)));

        bars.exit()
          .transition()
          .duration(200)
          .attr('y', innerHeight)
          .attr('height', 0)
          .remove();

        // Hover interactions
        groupsMerge.selectAll('rect.bar')
          .on('mouseenter', function (event, d) {
            const turn = d3.select(this.parentNode).datum().turn;
            tipInner.innerHTML = `<strong>${d.model}</strong><br/>${turn}: <strong>${d.value.toFixed(2)}%</strong>`;
            tip.classList.add('visible');
          })
          .on('mousemove', function (event) {
            const [mx, my] = d3.pointer(event, container);
            const offsetX = 10;
            const offsetY = -10;
            tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
          })
          .on('mouseleave', function () {
            tip.classList.remove('visible');
            tip.style.transform = 'translate(-9999px, -9999px)';
          });

        // Axes
        gAxes.selectAll('.x-axis').remove();
        gAxes.selectAll('.y-axis').remove();

        const xAxis = gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(x0).tickSizeOuter(0));

        xAxis.selectAll('text')
          .style('text-anchor', 'middle')
          .attr('dy', '1em');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(y).ticks(6).tickSizeOuter(0));

        // Y-axis label
        gAxes.selectAll('.y-label').remove();
        gAxes.append('text')
          .attr('class', 'y-label axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -margin.left + 20)
          .style('text-anchor', 'middle')
          .text('Score (%)');
      }

      // Load data
      fetchFirstAvailable(CSV_PATHS)
        .then(csvText => {
          data = d3.csvParse(csvText);

          // Extract unique models from data
          uniqueModels = data.map(d => d.Model);
          updateColors();

          makeLegend();
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.color = 'red';
          pre.style.fontSize = '12px';
          pre.style.padding = '12px';
          pre.textContent = `Error loading data: ${err.message}`;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>To fix this capability, we constructed a new dataset called IFThink. Based on the Multi-IF pipeline, we used single-turn instructions from <a href="https://huggingface.co/datasets/allenai/tulu-3-sft-personas-instruction-following">Tulu 3’s instruction-following subset</a> and expanded them into multi-turn exchanges using Qwen3-32B to both generate both verifiable instructions and reasoning traces. The method is illustrated below:</p>
<pre class="mermaid">flowchart TD
    %% Inputs
    IFEval[&quot;Tülu3 IF Dataset&quot;]
    InstructionTypes[&quot;Set of instruction types&quot;]
    
    %% English Multi-Turn Generation
    SingleTurn[&quot;Single turn prompt&quot;]
    LLM1[&quot;Generate instructions with Qwen3-32B&quot;]
    
    subgraph Turns [&quot;Multi-turn prompts&quot;]
        Turn1[&quot;Prompt @ turn 1&quot;]
        Turn2[&quot;Prompt @ turn 2&quot;]
        Turn3[&quot;Prompt @ turn 3&quot;]
    end
    
    MultiTurn[&quot;Generate reasoning traces with Qwen3-32B&quot;]
    
    IFThink[&quot;IFThink&quot;]
    
    %% Connections
    IFEval --&gt; SingleTurn
    IFEval --&gt; InstructionTypes
    SingleTurn --&gt; Turn1
    InstructionTypes --&gt; LLM1
    LLM1 --&gt; Turn2
    LLM1 --&gt; Turn3
    
    Turn1 --&gt; MultiTurn
    Turn2 --&gt; MultiTurn
    Turn3 --&gt; MultiTurn
    
    MultiTurn --&gt; IFThink
    
    %% Styling
    classDef question fill:#ffd0c5
    classDef decision fill:#f9f9f9
    classDef success fill:#d1f2eb
    classDef danger fill:#fef3c7
    classDef category fill:#fef3c7
    
    class IFEval,InstructionTypes question
    class SingleTurn,LLM1,MultiTurn decision
    class Turn1,Turn2,Turn3 decision
    class IFThink success</pre>
<p>Including this data in our baseline mix produced a dramatic improvement:</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>We considered filtering out conflicting instructions, but the initial results were strong enough to skip this step.</p> </aside> </div>  
<figure class="html-embed"><div class="html-embed__card"><div id="frag-69fi5ztnls9"><div class="d3-sft-think-follow-1"></div>
<style>
  .d3-sft-think-follow-1 {
    position: relative;
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  }

  .d3-sft-think-follow-1 svg {
    display: block;
    width: 100%;
  }

  .d3-sft-think-follow-1 .axes path,
  .d3-sft-think-follow-1 .axes line {
    stroke: var(--axis-color);
  }

  .d3-sft-think-follow-1 .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-think-follow-1 .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2, 2;
  }

  .d3-sft-think-follow-1 .bar {
    cursor: pointer;
    transition: opacity 0.15s ease;
  }

  .d3-sft-think-follow-1 .bar:hover {
    opacity: 0.8;
  }

  .d3-sft-think-follow-1 .legend-controls-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 24px;
    margin-top: 12px;
    flex-wrap: wrap;
  }

  .d3-sft-think-follow-1 .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    flex: 1;
    min-width: 0;
  }

  .d3-sft-think-follow-1 .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-think-follow-1 .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-think-follow-1 .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-sft-think-follow-1 .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-think-follow-1 .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    flex-shrink: 0;
  }

  .d3-sft-think-follow-1 .controls .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-think-follow-1 .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-think-follow-1 .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
  }

  .d3-sft-think-follow-1 .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }

  .d3-sft-think-follow-1 .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 10px 12px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.5;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.18);
    opacity: 0;
    transition: opacity 0.12s ease;
    z-index: 1000;
  }

  .d3-sft-think-follow-1 .d3-tooltip.visible {
    opacity: 1;
  }

  .d3-sft-think-follow-1 .d3-tooltip__inner {
    text-align: left;
  }

  .d3-sft-think-follow-1 .d3-tooltip__inner strong {
    color: var(--text-color);
    font-weight: 700;
  }

  .d3-sft-think-follow-1 .axis-label {
    font-size: 12px;
    font-weight: 600;
    fill: var(--text-color);
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-think-follow-1'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-think-follow-1'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Data loading helpers
      const CSV_PATHS = [
        '/data/sft_think-follow-1.csv',
        './assets/data/sft_think-follow-1.csv',
        '../assets/data/sft_think-follow-1.csv',
        '../../assets/data/sft_think-follow-1.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found at any of the specified paths');
      };

      // Tooltip setup
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gBars = gRoot.append('g').attr('class', 'bars');
      const gAxes = gRoot.append('g').attr('class', 'axes');

      // State
      let data = [];
      let width = 800;
      let height = 400;
      const margin = { top: 20, right: 40, bottom: 60, left: 64 };

      // Color palette
      let uniqueModels = [];
      const modelColors = {};

      const getColors = (n) => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          return window.ColorPalettes.getColors('categorical', n);
        }
        // Fallback to Tableau10-inspired colors
        return ['#4E79A7', '#F28E2B', '#E15759', '#76B7B2'];
      };

      function updateColors() {
        const colors = getColors(uniqueModels.length);
        uniqueModels.forEach((model, i) => {
          modelColors[model] = colors[i];
        });
      }

      // Listen for palette changes
      if (window.ColorPalettes && window.ColorPalettes.onChange) {
        window.ColorPalettes.onChange(() => {
          updateColors();
          render();
        });
      }

      function updateSize() {
        width = container.clientWidth || 800;
        height = Math.max(320, Math.round(width / 2.5));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      }

      function makeLegend() {
        // Create wrapper if it doesn't exist
        let wrapper = container.querySelector('.legend-controls-wrapper');
        if (!wrapper) {
          wrapper = document.createElement('div');
          wrapper.className = 'legend-controls-wrapper';
          container.appendChild(wrapper);
        }

        // Create legend
        let legend = wrapper.querySelector('.legend');
        if (!legend) {
          legend = document.createElement('div');
          legend.className = 'legend';
          wrapper.appendChild(legend);
        }
        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.textContent = 'Legend';
          legend.appendChild(title);
        }
        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }
        items.innerHTML = '';

        uniqueModels.forEach((model) => {
          const el = document.createElement('span');
          el.className = 'item';
          const sw = document.createElement('span');
          sw.className = 'swatch';
          sw.style.background = modelColors[model];
          const txt = document.createElement('span');
          txt.textContent = model;
          el.appendChild(sw);
          el.appendChild(txt);
          items.appendChild(el);
        });
      }

      function render() {
        if (!data || data.length === 0) return;

        const { innerWidth, innerHeight } = updateSize();

        // Get all turns from data
        const turns = ['Turn 1', 'Turn 2', 'Turn 3'];

        // Transform data for grouped bars
        // Each turn should have bars for each model
        const groupedData = turns.map(turn => {
          const values = uniqueModels.map(model => {
            const row = data.find(d => d.Model === model);
            return {
              model: model,
              value: row ? (+row[turn] || 0) : 0
            };
          });
          return { turn, values };
        });

        // Scales
        const x0 = d3.scaleBand()
          .domain(turns)
          .range([0, innerWidth])
          .padding(0.2);

        const x1 = d3.scaleBand()
          .domain(uniqueModels)
          .range([0, x0.bandwidth()])
          .padding(0.05);

        const y = d3.scaleLinear()
          .domain([0, 100])
          .range([innerHeight, 0])
          .nice();

        // Grid
        gGrid
          .attr('transform', `translate(0,0)`)
          .call(d3.axisLeft(y).tickSize(-innerWidth).tickFormat(''))
          .call(g => g.select('.domain').remove());

        // Groups
        const groups = gBars.selectAll('g.turn-group')
          .data(groupedData, d => d.turn);

        const groupsEnter = groups.enter()
          .append('g')
          .attr('class', 'turn-group');

        groups.exit().remove();

        const groupsMerge = groupsEnter.merge(groups)
          .attr('transform', d => `translate(${x0(d.turn)},0)`);

        // Bars
        const bars = groupsMerge.selectAll('rect.bar')
          .data(d => d.values, d => d.model);

        bars.enter()
          .append('rect')
          .attr('class', 'bar')
          .attr('x', d => x1(d.model))
          .attr('width', x1.bandwidth())
          .attr('fill', d => modelColors[d.model])
          .attr('stroke', 'none')
          .attr('y', innerHeight)
          .attr('height', 0)
          .merge(bars)
          .transition()
          .duration(200)
          .attr('x', d => x1(d.model))
          .attr('width', x1.bandwidth())
          .attr('fill', d => modelColors[d.model])
          .attr('y', d => y(d.value))
          .attr('height', d => Math.max(0, innerHeight - y(d.value)));

        bars.exit()
          .transition()
          .duration(200)
          .attr('y', innerHeight)
          .attr('height', 0)
          .remove();

        // Hover interactions
        groupsMerge.selectAll('rect.bar')
          .on('mouseenter', function (event, d) {
            const turn = d3.select(this.parentNode).datum().turn;
            tipInner.innerHTML = `<strong>${d.model}</strong><br/>${turn}: <strong>${d.value.toFixed(2)}%</strong>`;
            tip.classList.add('visible');
          })
          .on('mousemove', function (event) {
            const [mx, my] = d3.pointer(event, container);
            const offsetX = 10;
            const offsetY = -10;
            tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
          })
          .on('mouseleave', function () {
            tip.classList.remove('visible');
            tip.style.transform = 'translate(-9999px, -9999px)';
          });

        // Axes
        gAxes.selectAll('.x-axis').remove();
        gAxes.selectAll('.y-axis').remove();

        const xAxis = gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(x0).tickSizeOuter(0));

        xAxis.selectAll('text')
          .style('text-anchor', 'middle')
          .attr('dy', '1em');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(y).ticks(6).tickSizeOuter(0));

        // Y-axis label
        gAxes.selectAll('.y-label').remove();
        gAxes.append('text')
          .attr('class', 'y-label axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -margin.left + 20)
          .style('text-anchor', 'middle')
          .text('Score (%)');
      }

      // Load data
      fetchFirstAvailable(CSV_PATHS)
        .then(csvText => {
          data = d3.csvParse(csvText);

          // Extract unique models from data
          uniqueModels = data.map(d => d.Model);
          updateColors();

          makeLegend();
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.color = 'red';
          pre.style.fontSize = '12px';
          pre.style.padding = '12px';
          pre.textContent = `Error loading data: ${err.message}`;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>After fixing the multi-turn reasoning issue with IFThink, our baseline finally behaved as intended; it could stay consistent across turns, follow instructions, and use the chat template correctly. With that foundation in place, we turned back to the basics: tuning the training setup itself.</p>
<h4 id="which-hyperparameters-actually-matter"><a href="#which-hyperparameters-actually-matter">Which hyperparameters actually matter?</a></h4>
<p>In SFT, there are only a few hyperparameters that actually matter. Learning rate, batch size, and packing determine almost everything about how efficiently your model trains and how well it generalises. In our baby baselines, we picked reasonable defaults just to validate the data and chat template. Now that the setup was stable, we revisited these choices to see how much impact they have on our baseline.</p>
<p><strong>Masking user turns</strong></p>
<p>One subtle design choice for the chat template is whether to mask the user turns during training. In most chat-style datasets, each training example consists of alternating user and assistant messages (possibly with interleaved tool calls). If we train the model to predict all tokens, it effectively learns to autocomplete user queries, rather than focusing on producing high-quality assistant responses.</p>
<p>As shown in the figure below, masking user turns prevents this by ensuring the model’s loss is only computed on assistant outputs, not user messages:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-8o7yrks0krk"><div class="d3-input-labels"></div>
<style>
    .d3-input-labels {
        margin: 0;
        padding: 10px 0;
    }

    .d3-input-labels .container {
        max-width: 1000px;
        margin: 0 auto;
        border-radius: 10px;
    }

    .d3-input-labels .sections-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
    }

    .d3-input-labels .section {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
    }

    .d3-input-labels .section:first-child {
        margin-bottom: 30px;
    }

    @media (max-width: 768px) {
        .d3-input-labels .sections-container {
            flex-direction: column;
            gap: 30px;
        }
    }

    .d3-input-labels .section {
        flex: 1;
        margin-bottom: 0;
    }

    .d3-input-labels .section-title {
        font-size: 16px;
        font-weight: bold;
        color: var(--text-color, #333);
        text-align: left;
        margin-bottom: 15px;
    }

    .d3-input-labels .tokens-row {
        display: flex;
        gap: 3px;
        justify-content: flex-start;
        flex-wrap: wrap;
        flex: 1;
    }

    .d3-input-labels .token {
        width: 30px;
        height: 30px;
        border: 1px solid;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: bold;
        color: white;
        position: relative;
    }

    .d3-input-labels .user-token {
        background-color: color-mix(in srgb, var(--color-0) 60%, transparent);
        border-color: var(--color-0);
    }

    .d3-input-labels .assistant-token {
        background-color: color-mix(in srgb, var(--color-1) 60%, transparent);
        border-color: var(--color-1);
    }

    .d3-input-labels .label-token {
        background-color: color-mix(in srgb, var(--color-2) 40%, transparent);
        border-color: var(--color-2);
        position: relative;
    }

    .d3-input-labels .label-masked {
        background-color: transparent;
        border-color: var(--color-2);
        position: relative;
        opacity: 0.5;
    }

    .d3-input-labels .label-masked::after {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 4px;
        background-image: repeating-linear-gradient(135deg,
                transparent,
                transparent 3px,
                var(--color-2) 3px,
                var(--color-2) 4px);
        opacity: 0.5;
    }

    .d3-input-labels .turn-label {
        position: absolute;
        top: -25px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 10px;
        font-weight: bold;
        color: var(--text-color, #333);
        background: var(--surface-bg, #fafafa);
        padding: 2px 4px;
        white-space: nowrap;
        border-radius: 2px;
    }

    .d3-input-labels .user-label {
        color: var(--color-0);
    }

    .d3-input-labels .assistant-label {
        color: var(--color-1);
    }
</style>
<script>
    (() => {
        const bootstrap = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;
            if (!(container && container.classList && container.classList.contains('d3-input-labels'))) {
                const candidates = Array.from(document.querySelectorAll('.d3-input-labels'))
                    .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
                container = candidates[candidates.length - 1] || null;
            }
            if (!container) return;
            if (container.dataset) {
                if (container.dataset.mounted === 'true') return;
                container.dataset.mounted = 'true';
            }

            // Apply categorical color palette
            const applyColorPalette = () => {
                try {
                    if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
                        const colors = window.ColorPalettes.getColors('categorical', 4);
                        colors.forEach((color, index) => {
                            document.documentElement.style.setProperty(`--color-${index}`, color);
                        });
                    } else {
                        // Fallback colors
                        const fallbackColors = [
                            '#E889AB', '#4EA5B7', '#E38A42', '#CEC0FA'
                        ];
                        fallbackColors.forEach((color, index) => {
                            document.documentElement.style.setProperty(`--color-${index}`, color);
                        });
                    }
                } catch (e) {
                    console.warn('ColorPalettes not available, using fallback colors');
                }
            };

            // Apply colors immediately and on theme changes
            applyColorPalette();
            if (window.ColorPalettes && typeof window.ColorPalettes.refresh === 'function') {
                window.ColorPalettes.refresh();
            }

            // Data structure for input_ids and labels
            const inputIds = [
                { type: 'user', count: 5, label: 'U' },
                { type: 'assistant', count: 4, label: 'A' },
                { type: 'user', count: 5, label: 'U' },
                { type: 'assistant', count: 4, label: 'A' }
            ];

            const labels = [
                { type: 'masked', count: 5, label: '-100' },
                { type: 'active', count: 4, label: 'A' },
                { type: 'masked', count: 5, label: '-100' },
                { type: 'active', count: 4, label: 'A' }
            ];

            // Helper function to create tokens
            const createTokens = (tokens, rowType) => {
                let tokenIndex = 1;
                return tokens.map((token, groupIndex) => {
                    const tokens = [];
                    for (let i = 0; i < token.count; i++) {
                        const isFirst = i === 0;
                        const tokenClass = token.type === 'user' ? 'user-token' :
                            token.type === 'assistant' ? 'assistant-token' :
                                token.type === 'active' ? 'label-token' : 'label-masked';

                        const labelClass = token.type === 'user' ? 'user-label' : 'assistant-label';
                        const labelText = token.type === 'user' ? 'user' : 'assistant';

                        tokens.push(`
                            <div class="token ${tokenClass}">
                                ${isFirst && rowType === 'input_ids' ? `<div class="turn-label ${labelClass}">${labelText}</div>` : ''}
                            </div>
                        `);
                        tokenIndex++;
                    }
                    return tokens.join('');
                }).join('');
            };

            // Create the HTML structure
            container.innerHTML = `
                <div class="container">
                    <div class="sections-container">
                        <div class="section">
                            <label class="section-title">input_ids</label>
                            <div class="tokens-row">
                                ${createTokens(inputIds, 'input_ids')}
                            </div>
                        </div>

                        <div class="section">
                            <label class="section-title">labels</label>
                            <div class="tokens-row">
                                ${createTokens(labels, 'labels')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
            bootstrap();
        }
    })();
</script></div></div></figure>
<p>In TRL, masking is applied for chat templates that can return the assistant tokens mask. In practice, this involves including a  <code>{% generation %}</code>  keyword in the template as follows:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="javascript"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> for message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> messages </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">-%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> message.role </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> &quot;user&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> -%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">    {{ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;&lt;|im_start|&gt;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> message.role </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> message.content </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> &quot;&lt;|im_end|&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> }}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> elif message.role </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> &quot;assistant&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> -%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> generation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{{ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;&lt;|im_start|&gt;assistant&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> message.content </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> &quot;&lt;|im_end|&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> }}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> endgeneration </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> endif </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> endfor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> add_generation_prompt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">  {{ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;&lt;|im_start|&gt;assistant</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> }}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> endif </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">}</span></span>
<span class="line"></span></code></pre></div>
<p>Then, when  <code>apply_chat_template()</code>  is used with  <code>return_assistant_tokens_mask=True</code>  the chat template will indicate which parts of the dialogue should be masked. Here’s a simple example, which shows how the assistant tokens are given ID 1, while the user tokens are masked with ID 0:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">chat_template </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> &#39;&#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">{%- for message in messages -%}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  {%- if message.role == &quot;user&quot; -%}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    {{ &quot;&lt;|im_start|&gt;&quot; + message.role + &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot; + message.content + &quot;&lt;|im_end|&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot; }}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  {%- elif message.role == &quot;assistant&quot; %}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    {% generation %}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    {{ &quot;&lt;|im_start|&gt;assistant&quot; + &quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot; + message.content + &quot;&lt;|im_end|&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot; }}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">    {% endgeneration %}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  {%- endif %}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">{%- endfor %}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">{%- if add_generation_prompt %}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">  {{ &quot;&lt;|im_start|&gt;assistant</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&quot; }}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">{%- endif %}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF">&#39;&#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">rendered_input </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> tok.apply_chat_template(messages, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">chat_template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">chat_template, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">return_assistant_tokens_mask</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70">return_dict</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">(rendered_input)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## {&#39;input_ids&#39;: [128011, 882, 198, 40, 2846, 4560, 311, 743, 709, 856, 12443, 11, 649, 499, 1520, 30, 128012, 198, 257, 128011, 78191, 198, 2173, 3388, 11, 1524, 439, 264, 51587, 11, 5557, 649, 387, 264, 2766, 315, 264, 8815, 7170, 510, 2434, 12921, 9182, 60, 128012, 271], &#39;attention_mask&#39;: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], &#39;assistant_masks&#39;: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}</span></span>
<span class="line"></span></code></pre></div>
<p>In practice, masking doesn’t have a huge impact on downstream evals and usually provides a few points improvement in most cases. With SmolLM3, we found it had the most impact on IFEval, likely because the model is less inclined to restate the prompt and follow the various constraints more closely. A comparison of how user masking affected each eval and reasoning mode is shown below:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-xgiev6gptii"><div class="d3-sft-mask-turns"></div>
<style>
  .d3-sft-mask-turns {
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    position: relative;
  }

  .d3-sft-mask-turns svg {
    display: block;
  }

  .d3-sft-mask-turns .axes path,
  .d3-sft-mask-turns .axes line {
    stroke: var(--axis-color);
  }

  .d3-sft-mask-turns .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-mask-turns .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2, 2;
  }

  .d3-sft-mask-turns .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .d3-sft-mask-turns .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-top: 12px;
    gap: 16px;
    flex-wrap: wrap;
  }

  .d3-sft-mask-turns .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-mask-turns .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-mask-turns .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-mask-turns .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
    cursor: pointer;
    user-select: none;
    opacity: 1;
    transition: opacity 0.15s ease;
  }

  .d3-sft-mask-turns .legend .item.dimmed {
    opacity: 0.3;
  }

  .d3-sft-mask-turns .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    flex-shrink: 0;
  }

  .d3-sft-mask-turns .controls {
    display: flex;
    gap: 16px;
    align-items: center;
    flex-wrap: wrap;
  }

  .d3-sft-mask-turns .controls .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-mask-turns .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-mask-turns .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    appearance: none;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12"><path fill="grey" d="M6 9L1 4h10z"/></svg>');
    background-repeat: no-repeat;
    background-position: right 8px center;
    transition: border-color 0.15s ease;
  }

  .d3-sft-mask-turns .controls select:hover {
    border-color: var(--primary-color);
  }

  .d3-sft-mask-turns .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }

  .d3-sft-mask-turns .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.35;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, .18);
    opacity: 0;
    transition: opacity .12s ease;
  }

  .d3-sft-mask-turns .d3-tooltip__inner {
    text-align: left;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-mask-turns'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-mask-turns'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Tooltip setup
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // Data loading
      const DEFAULT_CSV = '/data/sft_mask-turns.csv';
      const CSV_PATHS = [
        DEFAULT_CSV,
        './assets/data/sft_mask-turns.csv',
        '../assets/data/sft_mask-turns.csv',
        '../../assets/data/sft_mask-turns.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found at any path');
      };

      fetchFirstAvailable(CSV_PATHS).then((csvText) => {
        const rawData = d3.csvParse(csvText);

        // Parse data
        const data = rawData.map(d => ({
          mask: d.Mask === 'TRUE',
          reasoningMode: d['Reasoning mode'],
          aime25: +d.AIME25,
          gpqaD: +d['GPQA-D'],
          lcbV4: +d['LiveCodeBench v4'],
          ifeval: +d.IFEval,
          globalMMLULite: +d['Global MMLU Lite']
        }));

        const benchmarks = [
          { key: 'aime25', label: 'AIME25' },
          { key: 'gpqaD', label: 'GPQA-D' },
          { key: 'lcbV4', label: 'LiveCodeBench v4' },
          { key: 'ifeval', label: 'IFEval' },
          { key: 'globalMMLULite', label: 'Global MMLU Lite' }
        ];

        const reasoningModes = ['/think', '/no_think'];
        const maskValues = [true, false];
        const maskLabels = { true: 'Mask', false: 'No mask' };

        // State
        let selectedMode = '/no_think';
        let hiddenSeries = new Set();

        // Color palette
        const getColors = () => {
          if (window.ColorPalettes && window.ColorPalettes.getColors) {
            return window.ColorPalettes.getColors('categorical', 2);
          }
          return ['#4E79A7', '#F28E2B'];
        };

        let colors = getColors();
        const colorScale = d3.scaleOrdinal()
          .domain([true, false])
          .range(colors);

        // Listen for color palette changes
        if (window.ColorPalettes && window.ColorPalettes.addListener) {
          window.ColorPalettes.addListener(() => {
            colors = getColors();
            colorScale.range(colors);
            render();
          });
        }

        // SVG setup
        const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
        const gRoot = svg.append('g');
        const gBars = gRoot.append('g').attr('class', 'bars');
        const gAxes = gRoot.append('g').attr('class', 'axes');

        let width = 800;
        let height = 360;
        const margin = { top: 16, right: 28, bottom: 56, left: 64 };

        const x0 = d3.scaleBand().padding(0.2);
        const x1 = d3.scaleBand().padding(0.05);
        const y = d3.scaleLinear();

        function updateSize() {
          width = container.clientWidth || 800;
          height = Math.max(260, Math.round(width / 2.5));
          svg.attr('width', width).attr('height', height);
          gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
          return {
            innerWidth: width - margin.left - margin.right,
            innerHeight: height - margin.top - margin.bottom
          };
        }

        function render() {
          const { innerWidth, innerHeight } = updateSize();

          // Filter data by selected mode
          const filteredData = data.filter(d => d.reasoningMode === selectedMode);

          // Prepare data for grouped bars
          const chartData = benchmarks.map(b => {
            const obj = { benchmark: b.label };
            maskValues.forEach(mask => {
              const entry = filteredData.find(d => d.mask === mask);
              obj[mask] = entry ? entry[b.key] : 0;
            });
            return obj;
          });

          // Update scales
          x0.domain(benchmarks.map(b => b.label)).range([0, innerWidth]);
          x1.domain(maskValues).range([0, x0.bandwidth()]);

          const maxVal = d3.max(chartData, d => d3.max(maskValues, mask => d[mask])) || 100;
          y.domain([0, maxVal]).range([innerHeight, 0]).nice();

          // Draw bars
          const groups = gBars.selectAll('g.group').data(chartData, d => d.benchmark);

          groups.exit().remove();

          const groupsEnter = groups.enter().append('g').attr('class', 'group');
          const groupsMerge = groupsEnter.merge(groups);

          groupsMerge.attr('transform', d => `translate(${x0(d.benchmark)},0)`);

          // Bars within groups
          const bars = groupsMerge.selectAll('rect.bar').data(d => {
            return maskValues.map(mask => ({
              benchmark: d.benchmark,
              mask: mask,
              value: d[mask]
            }));
          }, d => `${d.benchmark}-${d.mask}`);

          bars.exit().remove();

          const barsEnter = bars.enter().append('rect').attr('class', 'bar');
          const barsMerge = barsEnter.merge(bars);

          barsMerge
            .attr('x', d => x1(d.mask))
            .attr('width', x1.bandwidth())
            .attr('y', d => y(d.value))
            .attr('height', d => Math.max(0, innerHeight - y(d.value)))
            .attr('fill', d => colorScale(d.mask))
            .attr('opacity', d => hiddenSeries.has(d.mask) ? 0.1 : 1)
            .style('cursor', 'pointer')
            .on('mouseenter', function (event, d) {
              if (hiddenSeries.has(d.mask)) return;
              d3.select(this).attr('opacity', 0.8);
              tipInner.innerHTML = `<strong>${d.benchmark}</strong><br/>${maskLabels[d.mask]}<br/>Score: ${d.value.toFixed(2)}%`;
              tip.style.opacity = '1';
              const [mx, my] = d3.pointer(event, container);
              tip.style.transform = `translate(${mx + 12}px, ${my - 12}px)`;
            })
            .on('mouseleave', function (event, d) {
              d3.select(this).attr('opacity', hiddenSeries.has(d.mask) ? 0.1 : 1);
              tip.style.opacity = '0';
              tip.style.transform = 'translate(-9999px, -9999px)';
            });

          // Axes
          const xAxisG = gAxes.selectAll('.x-axis').data([0]);
          xAxisG.enter().append('g').attr('class', 'x-axis').merge(xAxisG)
            .attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(x0).tickSizeOuter(0));

          const yAxisG = gAxes.selectAll('.y-axis').data([0]);
          yAxisG.enter().append('g').attr('class', 'y-axis').merge(yAxisG)
            .call(d3.axisLeft(y).ticks(5).tickSizeOuter(0));

          // Y-axis label
          const yLabelG = gAxes.selectAll('.y-axis-label').data([0]);
          yLabelG.enter().append('text').attr('class', 'y-axis-label axis-label').merge(yLabelG)
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -margin.left + 16)
            .attr('text-anchor', 'middle')
            .text('Score (%)');

          // Grid
          const gridG = gAxes.selectAll('.grid').data([0]);
          gridG.enter().append('g').attr('class', 'grid').merge(gridG)
            .call(d3.axisLeft(y).ticks(5).tickSize(-innerWidth).tickFormat(''))
            .call(g => g.select('.domain').remove());
        }

        function makeLegend() {
          let legend = container.querySelector('.legend');
          if (!legend) {
            legend = document.createElement('div');
            legend.className = 'legend';
            container.appendChild(legend);
          }

          let title = legend.querySelector('.legend-title');
          if (!title) {
            title = document.createElement('div');
            title.className = 'legend-title';
            title.textContent = 'Legend';
            legend.appendChild(title);
          }

          let items = legend.querySelector('.items');
          if (!items) {
            items = document.createElement('div');
            items.className = 'items';
            legend.appendChild(items);
          }

          items.innerHTML = '';
          maskValues.forEach(mask => {
            const el = document.createElement('span');
            el.className = 'item';
            if (hiddenSeries.has(mask)) el.classList.add('dimmed');

            const sw = document.createElement('span');
            sw.className = 'swatch';
            sw.style.background = colorScale(mask);

            const txt = document.createElement('span');
            txt.textContent = maskLabels[mask];

            el.appendChild(sw);
            el.appendChild(txt);
            items.appendChild(el);

            el.addEventListener('click', () => {
              if (hiddenSeries.has(mask)) {
                hiddenSeries.delete(mask);
              } else {
                hiddenSeries.add(mask);
              }
              makeLegend();
              render();
            });
          });

          return legend;
        }

        function makeControls() {
          let controls = container.querySelector('.controls');
          if (!controls) {
            controls = document.createElement('div');
            controls.className = 'controls';
            container.appendChild(controls);
          }

          controls.innerHTML = '';

          const group = document.createElement('div');
          group.className = 'control-group';

          const label = document.createElement('label');
          label.textContent = 'Reasoning mode';
          label.setAttribute('for', 'mode-select-mask-turns');

          const select = document.createElement('select');
          select.id = 'mode-select-mask-turns';

          reasoningModes.forEach(mode => {
            const opt = document.createElement('option');
            opt.value = mode;
            opt.textContent = mode;
            if (mode === selectedMode) opt.selected = true;
            select.appendChild(opt);
          });

          select.addEventListener('change', (e) => {
            selectedMode = e.target.value;
            render();
          });

          group.appendChild(label);
          group.appendChild(select);
          controls.appendChild(group);

          return controls;
        }

        function makeHeader() {
          let header = container.querySelector('.header');
          if (!header) {
            header = document.createElement('div');
            header.className = 'header';
            container.appendChild(header);
          }
          header.innerHTML = '';
          header.appendChild(makeLegend());
          header.appendChild(makeControls());
        }

        // Initial render
        makeHeader();
        render();

        // Resize handling
        const rerender = () => render();
        if (window.ResizeObserver) {
          const ro = new ResizeObserver(() => rerender());
          ro.observe(container);
        } else {
          window.addEventListener('resize', rerender);
        }

      }).catch((err) => {
        const pre = document.createElement('pre');
        pre.style.color = 'red';
        pre.style.fontSize = '12px';
        pre.style.padding = '12px';
        pre.textContent = 'Error loading data: ' + err.message;
        container.appendChild(pre);
      });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p><strong>To pack or not to pack?</strong></p>
<p>As we Sequence packing is one of the training details that makes a huge difference to training efficiency. In SFT, most datasets contain samples of variable length, which means each batch contains a large number of padding tokens that waste compute and slow convergence.</p>
<p>Packing solves this by concatenating multiple sequences together until a desired maximum token length is achieved. There are various ways to perform the concatenation, with TRL adopting a “best-fit decreasing” strategy <span class="" id="citation--bfd--142">(<a href="https://arxiv.org/abs/2404.10830" id="refctx-bib-bfd-1" data-ref-id="bib-bfd" target="_blank" rel="noopener noreferrer">Ding et al., 2024</a>)</span>, where the ordering of sequences to pack is determined by their length. As shown below, this strategy minimises truncation of documents across batch boundaries, while also reducing the amount of padding tokens:</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-v271g3d32aq"><div class="d3-data-packing"></div>
<style>
    .d3-data-packing {
        font-family: 'Arial', sans-serif;
        margin: 0;
    }

    .d3-data-packing .container {
        max-width: 1000px;
        margin: 0 auto;
        border-radius: 10px;
    }

    .d3-data-packing .sections-container {
        display: flex;
        gap: 20px;
    }

    @media (max-width: 768px) {
        .d3-data-packing .sections-container {
            flex-direction: column;
            gap: 30px;
        }
    }

    .d3-data-packing .section {
        flex: 1;
        margin-bottom: 0;
    }

    .d3-data-packing .section-title {
        font-size: 16px;
        font-weight: bold;
        color: var(--text-color, #333);
        margin: 0 auto 20px auto;
        text-align: center;
        width: 100%;
        display: block;
    }

    .d3-data-packing .dataset {
        display: flex;
        flex-direction: column;
        gap: 3px;
    }

    .d3-data-packing .dataset-row {
        display: flex;
        gap: 3px;
        justify-content: center;
        flex-wrap: wrap;
    }

    .d3-data-packing .grid {
        display: grid;
        gap: 3px;
        margin: 0 auto;
        width: fit-content;
    }

    .d3-data-packing .block {
        width: 30px;
        height: 30px;
        border: 1px solid;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: bold;
        color: white;
        position: relative;
    }

    .d3-data-packing .red {
        background-color: color-mix(in srgb, var(--color-0) 60%, transparent);
        border-color: var(--color-0);
    }

    .d3-data-packing .orange {
        background-color: color-mix(in srgb, var(--color-1) 60%, transparent);
        border-color: var(--color-1);
    }

    .d3-data-packing .yellow {
        background-color: color-mix(in srgb, var(--color-2) 60%, transparent);
        border-color: var(--color-2);
    }

    .d3-data-packing .green {
        background-color: color-mix(in srgb, var(--color-3) 60%, transparent);
        border-color: var(--color-3);
    }

    .d3-data-packing .lightgreen {
        background-color: color-mix(in srgb, var(--color-4) 60%, transparent);
        border-color: var(--color-4);
    }

    .d3-data-packing .lightblue {
        background-color: color-mix(in srgb, var(--color-5) 60%, transparent);
        border-color: var(--color-5);
    }

    .d3-data-packing .blue {
        background-color: color-mix(in srgb, var(--color-6) 60%, transparent);
        border-color: var(--color-6);
    }

    .d3-data-packing .purple {
        background-color: color-mix(in srgb, var(--color-7) 60%, transparent);
        border-color: var(--color-7);
    }

    .d3-data-packing .pink {
        background-color: color-mix(in srgb, var(--color-8) 60%, transparent);
        border-color: var(--color-8);
    }

    .d3-data-packing .gray {
        background-color: var(--surface-bg);
        border-color: color-mix(in srgb, var(--text-color) 30%, transparent);
    }

    .d3-data-packing .packing-false {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 3px;
        max-width: calc(7 * 30px + 6 * 3px);
    }

    .d3-data-packing .packing-true {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 3px;
        max-width: calc(7 * 30px + 6 * 3px);
    }
</style>
<script>
    (() => {
        const bootstrap = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;
            if (!(container && container.classList && container.classList.contains('d3-data-packing'))) {
                const candidates = Array.from(document.querySelectorAll('.d3-data-packing'))
                    .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
                container = candidates[candidates.length - 1] || null;
            }
            if (!container) return;
            if (container.dataset) {
                if (container.dataset.mounted === 'true') return;
                container.dataset.mounted = 'true';
            }

            // Apply categorical color palette
            const applyColorPalette = () => {
                try {
                    if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
                        const colors = window.ColorPalettes.getColors('categorical', 9);
                        colors.forEach((color, index) => {
                            document.documentElement.style.setProperty(`--color-${index}`, color);
                        });
                    } else {
                        // Fallback to CSS variables or default colors
                        const fallbackColors = [
                            'var(--primary-color, #E889AB)',
                            '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6',
                            '#16A085', '#1f77b4', '#ff7f0e', '#2ca02c'
                        ];
                        fallbackColors.forEach((color, index) => {
                            document.documentElement.style.setProperty(`--color-${index}`, color);
                        });
                    }
                } catch (e) {
                    console.warn('ColorPalettes not available, using fallback colors');
                }
            };

            // Apply colors immediately and on theme changes
            applyColorPalette();
            if (window.ColorPalettes && typeof window.ColorPalettes.refresh === 'function') {
                window.ColorPalettes.refresh();
            }

            // Data structure - only colored blocks, no gray blocks
            const dataset = [
                { color: 'red', count: 7, label: 'R' },
                { color: 'orange', count: 3, label: 'O' },
                { color: 'yellow', count: 4, label: 'Y' },
                { color: 'lightgreen', count: 6, label: 'G' },
                { color: 'lightblue', count: 12, label: 'L' },
                { color: 'purple', count: 6, label: 'P' },
                { color: 'pink', count: 4, label: 'K' }
            ];

            const packingFalse = [
                { color: 'red', count: 7, label: 'R' },
                { color: 'orange', count: 3, label: 'O' },
                { color: 'gray', count: 4, label: '-' },
                { color: 'yellow', count: 4, label: 'Y' },
                { color: 'gray', count: 3, label: '-' },
                { color: 'lightgreen', count: 6, label: 'G' },
                { color: 'gray', count: 1, label: '-' },
                { color: 'lightblue', count: 7, label: 'L' },
                { color: 'lightblue', count: 3, label: 'L' },
                { color: 'gray', count: 4, label: '-' },
                { color: 'purple', count: 6, label: 'P' },
                { color: 'gray', count: 1, label: '-' },
                { color: 'pink', count: 4, label: 'K' },
                { color: 'gray', count: 3, label: '-' }
            ];

            const packingTrue = [
                // Ligne 1: 7 R
                { color: 'red', count: 7, label: 'R' },
                // Ligne 2: 3 O + 4 Y (combinaison optimisée)
                { color: 'orange', count: 3, label: 'O' },
                { color: 'yellow', count: 4, label: 'Y' },
                // Ligne 3: 6 G + 1 gris
                { color: 'lightgreen', count: 6, label: 'G' },
                { color: 'gray', count: 1, label: '-' },
                // Ligne 4: 7 L (rangée complète)
                { color: 'lightblue', count: 7, label: 'L' },
                // Ligne 5: 3 L + 4 K (combinaison optimisée)
                { color: 'lightblue', count: 3, label: 'L' },
                { color: 'pink', count: 4, label: 'K' },
                // Ligne 6: 6 P + 1 gris
                { color: 'purple', count: 6, label: 'P' },
                { color: 'gray', count: 1, label: '-' }
            ];

            // Helper function to create blocks
            const createBlocks = (blocks) => {
                return blocks.map(block =>
                    block.count > 0 ? `<div class="block ${block.color}"></div>`.repeat(block.count) : ''
                ).join('');
            };

            // Helper function to create dataset rows
            const createDatasetRows = (dataset) => {
                return dataset.map(item =>
                    `<div class="dataset-row">${createBlocks([item])}</div>`
                ).join('');
            };

            // Create the HTML structure
            container.innerHTML = `
        <div class="container">
          <div class="sections-container">
            <div class="section">
              <label class="section-title">Dataset</label>
              <div class="dataset">
                ${createDatasetRows(dataset)}
              </div>
            </div>

            <div class="section">
              <label class="section-title">Packing = False</label>
              <div class="grid packing-false">
                ${createBlocks(packingFalse)}
              </div>
            </div>

            <div class="section">
              <label class="section-title">Packing = True</label>
              <div class="grid packing-true">
                ${createBlocks(packingTrue)}
              </div>
            </div>
          </div>
        </div>
      `;
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
            bootstrap();
        }
    })();
</script></div></div></figure> </div>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty>  <div class="note__title" data-astro-cid-qg6lmfty>Packing in post-training vs pre-training</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>In pre-training, this isn’t really a question. When training on trillions of tokens, packing is essential to avoid wasting significant amounts of compute on padding. Pretraining frameworks like Megatron-LM and Nanotron implement packing by default. Post-training is different. Because the runs are shorter, the trade-offs change.</p> </div> </div> </div> 
<p>To get a sense of how efficient packing is for training, below we compare the runtimes between packing and no-packing over one epoch of our baseline dataset:</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>The reason the runtime flattens out after an effective batch size of 32 is because this is the largest size possible without invoking gradient accumulation.</p> </aside> </div>  
<figure class="html-embed"><div class="html-embed__card"><div id="frag-tf43c5n2pjs"><div class="d3-sft-packing-runtime"></div>
<style>
  .d3-sft-packing-runtime {
    position: relative;
    width: 100%;
    min-height: 320px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .d3-sft-packing-runtime svg {
    display: block;
    width: 100%;
  }

  .d3-sft-packing-runtime .axes path,
  .d3-sft-packing-runtime .axes line {
    stroke: var(--axis-color);
  }

  .d3-sft-packing-runtime .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-packing-runtime .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2, 2;
  }

  .d3-sft-packing-runtime .bar {
    cursor: pointer;
    transition: opacity 0.15s ease;
  }

  .d3-sft-packing-runtime .bar:hover {
    opacity: 0.85;
  }

  .d3-sft-packing-runtime .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .d3-sft-packing-runtime .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    margin-top: 12px;
  }

  .d3-sft-packing-runtime .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-packing-runtime .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-packing-runtime .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
    cursor: pointer;
    transition: opacity 0.15s ease;
  }

  .d3-sft-packing-runtime .legend .item:hover {
    opacity: 0.7;
  }

  .d3-sft-packing-runtime .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-packing-runtime .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.35;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, .18);
    opacity: 0;
    transition: opacity .12s ease;
  }

  .d3-sft-packing-runtime .d3-tooltip__inner {
    text-align: left;
  }

  .d3-sft-packing-runtime .d3-tooltip .label {
    font-weight: 700;
    margin-bottom: 2px;
  }

  .d3-sft-packing-runtime .d3-tooltip .value {
    color: var(--muted-color);
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-packing-runtime'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-packing-runtime'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // Data loading
      let mountEl = container;
      while (mountEl && !mountEl.getAttribute?.('data-datafiles')) {
        mountEl = mountEl.parentElement;
      }
      let providedData = null;
      try {
        const attr = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-datafiles') : null;
        if (attr && attr.trim()) {
          providedData = attr.trim().startsWith('[') ? JSON.parse(attr) : attr.trim();
        }
      } catch (_) { }

      const DEFAULT_CSV = '/data/sft-packing-vs-no-packing-runtime.csv';
      const ensureDataPrefix = (p) => {
        if (typeof p !== 'string' || !p) return p;
        // If path doesn't start with / or ./, add /data/ prefix
        if (!p.startsWith('/') && !p.startsWith('./') && !p.startsWith('../')) {
          return `/data/${p}`;
        }
        return p;
      };
      const normalizeInput = (inp) => Array.isArray(inp)
        ? inp.map(ensureDataPrefix)
        : (typeof inp === 'string' ? [ensureDataPrefix(inp)] : null);

      const CSV_PATHS = Array.isArray(providedData)
        ? normalizeInput(providedData)
        : (typeof providedData === 'string' ? normalizeInput(providedData) || [DEFAULT_CSV] : [
          DEFAULT_CSV,
          './assets/data/tech_report/sft-packing-vs-no-packing-runtime.csv',
          '../assets/data/tech_report/sft-packing-vs-no-packing-runtime.csv',
          '../../assets/data/tech_report/sft-packing-vs-no-packing-runtime.csv'
        ]);

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found at any of: ' + paths.join(', '));
      };

      fetchFirstAvailable(CSV_PATHS)
        .then((text) => {
          const parsed = d3.csvParse(text);
          if (!parsed || parsed.length === 0) throw new Error('Empty CSV');

          // Process data
          const data = parsed.map(d => ({
            packing: d.Packing === 'TRUE' ? 'Packing' : 'No Packing',
            batchSize: +d['Batch size'],
            runtime: +d['Runtime (min)']
          })).filter(d => !isNaN(d.batchSize) && !isNaN(d.runtime));

          render(data);
        })
        .catch((err) => {
          const pre = document.createElement('pre');
          pre.style.cssText = 'color:#c00; font-size:11px; padding:12px; white-space:pre-wrap;';
          pre.textContent = 'Error loading data:\n' + err.message;
          container.appendChild(pre);
        });

      function render(data) {
        // SVG setup
        const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
        const gRoot = svg.append('g');
        const gGrid = gRoot.append('g').attr('class', 'grid');
        const gBars = gRoot.append('g').attr('class', 'bars');
        const gAxes = gRoot.append('g').attr('class', 'axes');

        let width = 800;
        let height = 360;
        const margin = { top: 16, right: 28, bottom: 56, left: 64 };

        // Get color palette
        const getColors = () => {
          if (window.ColorPalettes && window.ColorPalettes.getColors) {
            return window.ColorPalettes.getColors('categorical', 2);
          }
          // Fallback colors
          return ['#4e79a7', '#f28e2c'];
        };

        let colors = getColors();
        const colorScale = d3.scaleOrdinal()
          .domain(['No Packing', 'Packing'])
          .range(colors);

        // Listen for color palette changes
        if (window.ColorPalettes && window.ColorPalettes.addListener) {
          window.ColorPalettes.addListener(() => {
            colors = getColors();
            colorScale.range(colors);
            updateChart();
          });
        }

        // Sort data: No Packing first, then Packing in ascending batch size order
        const sortedData = [
          ...data.filter(d => d.packing === 'No Packing').sort((a, b) => a.batchSize - b.batchSize),
          ...data.filter(d => d.packing === 'Packing').sort((a, b) => a.batchSize - b.batchSize)
        ];

        // Create labels for x-axis
        const xLabels = sortedData.map(d => `${d.packing}\nBS ${d.batchSize}`);

        // Scales
        const x = d3.scaleBand().padding(0.2);
        const y = d3.scaleLinear();

        function updateSize() {
          width = container.clientWidth || 800;
          height = Math.max(280, Math.round(width / 2.8));
          svg.attr('width', width).attr('height', height);
          gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
          return {
            innerWidth: width - margin.left - margin.right,
            innerHeight: height - margin.top - margin.bottom
          };
        }

        function updateChart() {
          const { innerWidth, innerHeight } = updateSize();

          x.domain(sortedData.map((d, i) => i)).range([0, innerWidth]);
          y.domain([0, d3.max(sortedData, d => d.runtime) * 1.1]).range([innerHeight, 0]).nice();

          // Grid
          gGrid.selectAll('line').remove();
          gGrid.selectAll('line')
            .data(y.ticks(5))
            .join('line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', d => y(d))
            .attr('y2', d => y(d));

          // Bars
          const bars = gBars.selectAll('.bar')
            .data(sortedData, (d, i) => i);

          bars.exit().remove();

          const barsEnter = bars.enter()
            .append('rect')
            .attr('class', 'bar')
            .on('mouseenter', function (event, d) {
              const [mx, my] = d3.pointer(event, container);
              tipInner.innerHTML = `
                <div class="label">${d.packing} - Batch Size ${d.batchSize}</div>
                <div class="value">Runtime: ${d.runtime.toFixed(1)} min</div>
              `;
              tip.style.opacity = '1';
              tip.style.transform = `translate(${mx + 12}px, ${my - 12}px)`;
            })
            .on('mouseleave', function () {
              tip.style.opacity = '0';
              tip.style.transform = 'translate(-9999px, -9999px)';
            });

          barsEnter.merge(bars)
            .attr('x', (d, i) => x(i))
            .attr('y', d => y(d.runtime))
            .attr('width', x.bandwidth())
            .attr('height', d => Math.max(0, innerHeight - y(d.runtime)))
            .attr('fill', d => colorScale(d.packing));

          // Axes
          const xAxis = d3.axisBottom(x)
            .tickFormat((d, i) => {
              const item = sortedData[i];
              return `${item.batchSize}`;
            })
            .tickSizeOuter(0);
          const yAxis = d3.axisLeft(y).ticks(5).tickSizeOuter(0);

          gAxes.selectAll('.x-axis').remove();
          gAxes.selectAll('.y-axis').remove();

          gAxes.append('g')
            .attr('class', 'x-axis')
            .attr('transform', `translate(0,${innerHeight})`)
            .call(xAxis);

          gAxes.append('g')
            .attr('class', 'y-axis')
            .call(yAxis);

          // Axis labels
          gAxes.selectAll('.x-label').remove();
          gAxes.selectAll('.y-label').remove();

          gAxes.append('text')
            .attr('class', 'axis-label x-label')
            .attr('text-anchor', 'middle')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight + 50)
            .text('Effective batch size');

          gAxes.append('text')
            .attr('class', 'axis-label y-label')
            .attr('text-anchor', 'middle')
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -48)
            .text('Runtime (min)');
        }

        // Legend
        function makeLegend() {
          let legend = container.querySelector('.legend');
          if (!legend) {
            legend = document.createElement('div');
            legend.className = 'legend';
            container.appendChild(legend);
          }
          let title = legend.querySelector('.legend-title');
          if (!title) {
            title = document.createElement('div');
            title.className = 'legend-title';
            title.textContent = 'Legend';
            legend.appendChild(title);
          }
          let items = legend.querySelector('.items');
          if (!items) {
            items = document.createElement('div');
            items.className = 'items';
            legend.appendChild(items);
          }
          items.innerHTML = '';
          ['No Packing', 'Packing'].forEach(name => {
            const el = document.createElement('span');
            el.className = 'item';
            const sw = document.createElement('span');
            sw.className = 'swatch';
            sw.style.background = colorScale(name);
            const txt = document.createElement('span');
            txt.textContent = name;
            el.appendChild(sw);
            el.appendChild(txt);
            items.appendChild(el);
          });
        }

        // Initial render
        updateChart();
        makeLegend();

        // Resize handling
        if (window.ResizeObserver) {
          const ro = new ResizeObserver(() => updateChart());
          ro.observe(container);
        } else {
          window.addEventListener('resize', updateChart);
        }
      }
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>Depending on the batch size, we see that packing improves throughput by a factor of 3-5x! So, should you  <em>always</em>  use packing? To some extent, the answer depends on how large your dataset is, because packing reduces the number of optimisation steps per epoch by fitting more tokens into each step. You can see this in the following figure, where we plot the average number of non-padding tokens per batch:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-hsxrbtyu1z"><div class="d3-sft-packing-tokens"></div>
<style>
  .d3-sft-packing-tokens {
    position: relative;
    width: 100%;
    min-height: 320px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .d3-sft-packing-tokens svg {
    display: block;
    width: 100%;
  }

  .d3-sft-packing-tokens .axes path,
  .d3-sft-packing-tokens .axes line {
    stroke: var(--axis-color);
  }

  .d3-sft-packing-tokens .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-packing-tokens .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2, 2;
  }

  .d3-sft-packing-tokens .bar {
    cursor: pointer;
    transition: opacity 0.15s ease;
  }

  .d3-sft-packing-tokens .bar:hover {
    opacity: 0.85;
  }

  .d3-sft-packing-tokens .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .d3-sft-packing-tokens .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    margin-top: 12px;
  }

  .d3-sft-packing-tokens .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-packing-tokens .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-packing-tokens .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
    cursor: pointer;
    transition: opacity 0.15s ease;
  }

  .d3-sft-packing-tokens .legend .item:hover {
    opacity: 0.7;
  }

  .d3-sft-packing-tokens .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-packing-tokens .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.35;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, .18);
    opacity: 0;
    transition: opacity .12s ease;
  }

  .d3-sft-packing-tokens .d3-tooltip__inner {
    text-align: left;
  }

  .d3-sft-packing-tokens .d3-tooltip .label {
    font-weight: 700;
    margin-bottom: 2px;
  }

  .d3-sft-packing-tokens .d3-tooltip .value {
    color: var(--muted-color);
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-packing-tokens'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-packing-tokens'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // Data loading
      let mountEl = container;
      while (mountEl && !mountEl.getAttribute?.('data-datafiles')) {
        mountEl = mountEl.parentElement;
      }
      let providedData = null;
      try {
        const attr = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-datafiles') : null;
        if (attr && attr.trim()) {
          providedData = attr.trim().startsWith('[') ? JSON.parse(attr) : attr.trim();
        }
      } catch (_) { }

      const DEFAULT_CSV = '/data/sft-packing-vs-no-packing-tokens.csv';
      const ensureDataPrefix = (p) => {
        if (typeof p !== 'string' || !p) return p;
        // If path doesn't start with / or ./, add /data/ prefix
        if (!p.startsWith('/') && !p.startsWith('./') && !p.startsWith('../')) {
          return `/data/${p}`;
        }
        return p;
      };
      const normalizeInput = (inp) => Array.isArray(inp)
        ? inp.map(ensureDataPrefix)
        : (typeof inp === 'string' ? [ensureDataPrefix(inp)] : null);

      const CSV_PATHS = Array.isArray(providedData)
        ? normalizeInput(providedData)
        : (typeof providedData === 'string' ? normalizeInput(providedData) || [DEFAULT_CSV] : [
          DEFAULT_CSV,
          './assets/data/tech_report/sft-packing-vs-no-packing-tokens.csv',
          '../assets/data/tech_report/sft-packing-vs-no-packing-tokens.csv',
          '../../assets/data/tech_report/sft-packing-vs-no-packing-tokens.csv'
        ]);

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found at any of: ' + paths.join(', '));
      };

      fetchFirstAvailable(CSV_PATHS)
        .then((text) => {
          const parsed = d3.csvParse(text);
          if (!parsed || parsed.length === 0) throw new Error('Empty CSV');

          // Process data - convert to millions
          const data = parsed.map(d => ({
            packing: d.Packing === 'TRUE' ? 'Packing' : 'No Packing',
            batchSize: +d['Batch size'],
            tokens: +d['Avg. # tokens per batch'] / 1000000, // Convert to millions
            tokensRaw: +d['Avg. # tokens per batch'] // Keep raw for tooltip
          }));

          render(data);
        })
        .catch((err) => {
          const pre = document.createElement('pre');
          pre.style.cssText = 'color:#c00; font-size:11px; padding:12px; white-space:pre-wrap;';
          pre.textContent = 'Error loading data:\n' + err.message;
          container.appendChild(pre);
        });

      function render(data) {
        // SVG setup
        const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
        const gRoot = svg.append('g');
        const gGrid = gRoot.append('g').attr('class', 'grid');
        const gBars = gRoot.append('g').attr('class', 'bars');
        const gAxes = gRoot.append('g').attr('class', 'axes');

        let width = 800;
        let height = 360;
        const margin = { top: 16, right: 28, bottom: 56, left: 80 };

        // Get color palette
        const getColors = () => {
          if (window.ColorPalettes && window.ColorPalettes.getColors) {
            return window.ColorPalettes.getColors('categorical', 2);
          }
          // Fallback colors
          return ['#4e79a7', '#f28e2c'];
        };

        let colors = getColors();
        const colorScale = d3.scaleOrdinal()
          .domain(['No Packing', 'Packing'])
          .range(colors);

        // Listen for color palette changes
        if (window.ColorPalettes && window.ColorPalettes.addListener) {
          window.ColorPalettes.addListener(() => {
            colors = getColors();
            colorScale.range(colors);
            updateChart();
          });
        }

        // Sort data: No Packing first (128), then Packing (8, 16, 128)
        const sortedData = data.sort((a, b) => {
          if (a.packing !== b.packing) {
            return a.packing === 'No Packing' ? -1 : 1;
          }
          return a.batchSize - b.batchSize;
        });

        // Scales
        const x = d3.scaleBand().padding(0.2);
        const y = d3.scaleLinear();

        function updateSize() {
          width = container.clientWidth || 800;
          height = Math.max(280, Math.round(width / 2.8));
          svg.attr('width', width).attr('height', height);
          gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
          return {
            innerWidth: width - margin.left - margin.right,
            innerHeight: height - margin.top - margin.bottom
          };
        }

        function updateChart() {
          const { innerWidth, innerHeight } = updateSize();

          x.domain(sortedData.map((d, i) => i)).range([0, innerWidth]);
          y.domain([0, d3.max(sortedData, d => d.tokens) * 1.1]).range([innerHeight, 0]).nice();

          // Grid
          gGrid.selectAll('line').remove();
          gGrid.selectAll('line')
            .data(y.ticks(5))
            .join('line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', d => y(d))
            .attr('y2', d => y(d));

          // Bars
          const bars = gBars.selectAll('.bar')
            .data(sortedData, (d, i) => i);

          bars.exit().remove();

          const barsEnter = bars.enter()
            .append('rect')
            .attr('class', 'bar')
            .on('mouseenter', function (event, d) {
              const [mx, my] = d3.pointer(event, container);
              tipInner.innerHTML = `
                <div class="label">${d.packing} - Batch Size ${d.batchSize}</div>
                <div class="value">Avg. tokens: ${d.tokensRaw.toLocaleString()}</div>
                <div class="value">(${d.tokens.toFixed(2)}M)</div>
              `;
              tip.style.opacity = '1';
              tip.style.transform = `translate(${mx + 12}px, ${my - 12}px)`;
            })
            .on('mouseleave', function () {
              tip.style.opacity = '0';
              tip.style.transform = 'translate(-9999px, -9999px)';
            });

          barsEnter.merge(bars)
            .attr('x', (d, i) => x(i))
            .attr('y', d => y(d.tokens))
            .attr('width', x.bandwidth())
            .attr('height', d => Math.max(0, innerHeight - y(d.tokens)))
            .attr('fill', d => colorScale(d.packing));

          // Axes
          const xAxis = d3.axisBottom(x)
            .tickFormat((d, i) => {
              const item = sortedData[i];
              return `${item.batchSize}`;
            })
            .tickSizeOuter(0);
          const yAxis = d3.axisLeft(y).ticks(5).tickSizeOuter(0);

          gAxes.selectAll('.x-axis').remove();
          gAxes.selectAll('.y-axis').remove();

          gAxes.append('g')
            .attr('class', 'x-axis')
            .attr('transform', `translate(0,${innerHeight})`)
            .call(xAxis);

          gAxes.append('g')
            .attr('class', 'y-axis')
            .call(yAxis);

          // Axis labels
          gAxes.selectAll('.x-label').remove();
          gAxes.selectAll('.y-label').remove();

          gAxes.append('text')
            .attr('class', 'axis-label x-label')
            .attr('text-anchor', 'middle')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight + 50)
            .text('Effective batch size');

          gAxes.append('text')
            .attr('class', 'axis-label y-label')
            .attr('text-anchor', 'middle')
            .attr('transform', 'rotate(-90)')
            .attr('x', -innerHeight / 2)
            .attr('y', -64)
            .text('Avg. # tokens per batch (millions)');
        }

        // Legend
        function makeLegend() {
          let legend = container.querySelector('.legend');
          if (!legend) {
            legend = document.createElement('div');
            legend.className = 'legend';
            container.appendChild(legend);
          }
          let title = legend.querySelector('.legend-title');
          if (!title) {
            title = document.createElement('div');
            title.className = 'legend-title';
            title.textContent = 'Legend';
            legend.appendChild(title);
          }
          let items = legend.querySelector('.items');
          if (!items) {
            items = document.createElement('div');
            items.className = 'items';
            legend.appendChild(items);
          }
          items.innerHTML = '';
          ['No Packing', 'Packing'].forEach(name => {
            const el = document.createElement('span');
            el.className = 'item';
            const sw = document.createElement('span');
            sw.className = 'swatch';
            sw.style.background = colorScale(name);
            const txt = document.createElement('span');
            txt.textContent = name;
            el.appendChild(sw);
            el.appendChild(txt);
            items.appendChild(el);
          });
        }

        // Initial render
        updateChart();
        makeLegend();

        // Resize handling
        if (window.ResizeObserver) {
          const ro = new ResizeObserver(() => updateChart());
          ro.observe(container);
        } else {
          window.addEventListener('resize', updateChart);
        }
      }
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>With packing, the number of tokens per batch scales linearly with the batch size and compared to training without packing, can include up to 33x more tokens per optimisation step! However, packing can slightly alter the training dynamics: while you process more data overall, you take fewer gradient updates which can influence final performance, especially on small datasets where each sample matters more. For example, if we compare packing versus no-packing at the same effective batch size of 128, we see that some evals like IFEval take a significant performance hit of nearly 10 percentage points:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-aayif5vn5wj"><div class="d3-sft-packing-vs-no-packing"></div>
<style>
  .d3-sft-packing-vs-no-packing {
    width: 100%;
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .d3-sft-packing-vs-no-packing svg {
    display: block;
    overflow: visible;
  }

  .d3-sft-packing-vs-no-packing .bar {
    cursor: pointer;
    transition: opacity 0.15s ease;
  }

  .d3-sft-packing-vs-no-packing .bar:hover {
    opacity: 0.8;
  }

  .d3-sft-packing-vs-no-packing .axes path,
  .d3-sft-packing-vs-no-packing .axes line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }

  .d3-sft-packing-vs-no-packing .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-packing-vs-no-packing .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 500;
  }

  .d3-sft-packing-vs-no-packing .grid line {
    stroke: var(--grid-color);
    shape-rendering: crispEdges;
  }

  .d3-sft-packing-vs-no-packing .header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 16px;
    margin-top: 16px;
    flex-wrap: wrap;
  }

  .d3-sft-packing-vs-no-packing .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-packing-vs-no-packing .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-no-packing .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-packing-vs-no-packing .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-no-packing .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-packing-vs-no-packing .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: flex-end;
    flex-wrap: wrap;
  }

  .d3-sft-packing-vs-no-packing .controls .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-packing-vs-no-packing .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-no-packing .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 6px center;
    background-size: 16px;
  }

  .d3-sft-packing-vs-no-packing .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }

  .d3-sft-packing-vs-no-packing .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.35;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, .18);
    opacity: 0;
    transition: opacity .12s ease;
  }

  .d3-sft-packing-vs-no-packing .d3-tooltip__inner {
    text-align: left;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-packing-vs-no-packing'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-packing-vs-no-packing'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Tooltip setup
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // Data loading
      const CSV_PATHS = [
        '/data/sft_packing-vs-no-packing.csv',
        './assets/data/sft_packing-vs-no-packing.csv',
        '../assets/data/sft_packing-vs-no-packing.csv',
        '../../assets/data/sft_packing-vs-no-packing.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found in any of the expected locations');
      };

      fetchFirstAvailable(CSV_PATHS)
        .then((csvText) => {
          const rawData = d3.csvParse(csvText);

          // Process data
          const benchmarks = Object.keys(rawData[0]).filter(k => k !== 'Packing' && k !== 'Reasoning mode');
          const reasoningModes = [...new Set(rawData.map(d => d['Reasoning mode']))];

          let currentMode = reasoningModes[1];

          // Get colors from ColorPalettes
          let colors;
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            colors = window.ColorPalettes.getColors('categorical', 2);
          } else {
            // Fallback to simple colors
            colors = ['#4e79a7', '#f28e2c'];
          }

          const colorMap = {
            'TRUE': colors[0],
            'FALSE': colors[1]
          };

          // SVG setup
          const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
          const gRoot = svg.append('g');
          const gBars = gRoot.append('g').attr('class', 'bars');
          const gAxes = gRoot.append('g').attr('class', 'axes');
          const gGrid = gRoot.append('g').attr('class', 'grid');

          let width = 800;
          let height = 400;
          const margin = { top: 16, right: 28, bottom: 56, left: 64 };

          const xBenchmark = d3.scaleBand().padding(0.2);
          const xPacking = d3.scaleBand().padding(0.05);
          const yScale = d3.scaleLinear();

          function updateSize() {
            width = container.clientWidth || 800;
            height = Math.max(320, Math.round(width / 2.2));
            svg.attr('width', width).attr('height', height);
            gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
            return {
              innerWidth: width - margin.left - margin.right,
              innerHeight: height - margin.top - margin.bottom
            };
          }

          function render() {
            const { innerWidth, innerHeight } = updateSize();

            // Filter data for current reasoning mode
            const filteredData = rawData.filter(d => d['Reasoning mode'] === currentMode);

            // Prepare data structure for grouped bars
            const chartData = benchmarks.map(benchmark => {
              return {
                benchmark,
                values: filteredData.map(d => ({
                  packing: d.Packing,
                  value: +d[benchmark]
                }))
              };
            });

            // Update scales
            xBenchmark.domain(benchmarks).range([0, innerWidth]);
            xPacking.domain(['TRUE', 'FALSE']).range([0, xBenchmark.bandwidth()]);

            const maxValue = d3.max(chartData, d => d3.max(d.values, v => v.value)) || 100;
            yScale.domain([0, maxValue]).range([innerHeight, 0]).nice();

            // Grid
            gGrid.selectAll('.grid-line').data(yScale.ticks(5))
              .join('line')
              .attr('class', 'grid-line')
              .attr('x1', 0)
              .attr('x2', innerWidth)
              .attr('y1', d => yScale(d))
              .attr('y2', d => yScale(d))
              .attr('stroke', 'var(--grid-color)');

            // Draw bars
            const groups = gBars.selectAll('.benchmark-group')
              .data(chartData, d => d.benchmark);

            const groupsEnter = groups.enter()
              .append('g')
              .attr('class', 'benchmark-group');

            groups.exit().remove();

            const groupsMerged = groupsEnter.merge(groups)
              .attr('transform', d => `translate(${xBenchmark(d.benchmark)},0)`);

            // Bars within each group
            groupsMerged.each(function (groupData) {
              const bars = d3.select(this)
                .selectAll('.bar')
                .data(groupData.values, d => d.packing);

              bars.join('rect')
                .attr('class', 'bar')
                .attr('x', d => xPacking(d.packing))
                .attr('width', xPacking.bandwidth())
                .attr('fill', d => colorMap[d.packing])
                .on('mouseenter', function (event, d) {
                  const packingLabel = d.packing === 'TRUE' ? 'Packing' : 'No Packing';
                  tipInner.innerHTML = `<strong>${groupData.benchmark}</strong><br/>${packingLabel}: ${d.value.toFixed(2)}`;
                  tip.style.opacity = '1';
                  const [mx, my] = d3.pointer(event, container);
                  tip.style.transform = `translate(${mx + 12}px, ${my - 12}px)`;
                })
                .on('mouseleave', function () {
                  tip.style.opacity = '0';
                  tip.style.transform = 'translate(-9999px, -9999px)';
                })
                .transition()
                .duration(150)
                .attr('y', d => yScale(d.value))
                .attr('height', d => Math.max(0, innerHeight - yScale(d.value)));
            });

            // Axes
            const xAxis = d3.axisBottom(xBenchmark);
            const yAxis = d3.axisLeft(yScale).ticks(5);

            gAxes.selectAll('.x-axis').data([0])
              .join('g')
              .attr('class', 'x-axis')
              .attr('transform', `translate(0,${innerHeight})`)
              .call(xAxis)
              .selectAll('text')
              .style('text-anchor', 'middle');

            gAxes.selectAll('.y-axis').data([0])
              .join('g')
              .attr('class', 'y-axis')
              .call(yAxis);

            // Axis labels
            gAxes.selectAll('.y-label').data([0])
              .join('text')
              .attr('class', 'y-label axis-label')
              .attr('transform', 'rotate(-90)')
              .attr('x', -innerHeight / 2)
              .attr('y', -48)
              .attr('text-anchor', 'middle')
              .text('Score (%)');
          }

          // Create header with legend and controls
          function makeHeader() {
            let header = container.querySelector('.header');
            if (!header) {
              header = document.createElement('div');
              header.className = 'header';
              container.appendChild(header);
            }

            // Create legend
            let legend = header.querySelector('.legend');
            if (!legend) {
              legend = document.createElement('div');
              legend.className = 'legend';
              header.appendChild(legend);
            }

            let title = legend.querySelector('.legend-title');
            if (!title) {
              title = document.createElement('div');
              title.className = 'legend-title';
              title.textContent = 'Legend';
              legend.appendChild(title);
            }

            let items = legend.querySelector('.items');
            if (!items) {
              items = document.createElement('div');
              items.className = 'items';
              legend.appendChild(items);
            }

            items.innerHTML = '';
            const legendData = [
              { label: 'Packing', packing: 'TRUE' },
              { label: 'No Packing', packing: 'FALSE' }
            ];

            legendData.forEach(({ label, packing }) => {
              const el = document.createElement('span');
              el.className = 'item';
              const sw = document.createElement('span');
              sw.className = 'swatch';
              sw.style.background = colorMap[packing];
              const txt = document.createElement('span');
              txt.textContent = label;
              el.appendChild(sw);
              el.appendChild(txt);
              items.appendChild(el);
            });

            // Create controls
            let controls = header.querySelector('.controls');
            if (!controls) {
              controls = document.createElement('div');
              controls.className = 'controls';
              header.appendChild(controls);
            }

            let controlGroup = controls.querySelector('.control-group');
            if (!controlGroup) {
              controlGroup = document.createElement('div');
              controlGroup.className = 'control-group';
              controls.appendChild(controlGroup);
            }

            let label = controlGroup.querySelector('label');
            if (!label) {
              label = document.createElement('label');
              label.setAttribute('for', 'reasoning-mode-select');
              label.textContent = 'Reasoning mode';
              controlGroup.appendChild(label);
            }

            let select = controlGroup.querySelector('select');
            if (!select) {
              select = document.createElement('select');
              select.id = 'reasoning-mode-select';
              controlGroup.appendChild(select);
            }

            select.innerHTML = '';
            reasoningModes.forEach(mode => {
              const option = document.createElement('option');
              option.value = mode;
              option.textContent = mode;
              option.selected = mode === currentMode;
              select.appendChild(option);
            });

            select.addEventListener('change', (e) => {
              currentMode = e.target.value;
              render();
            });
          }

          // Initial setup
          makeHeader();
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch((err) => {
          const pre = document.createElement('pre');
          pre.style.color = 'red';
          pre.style.fontSize = '12px';
          pre.style.padding = '12px';
          pre.textContent = `Error loading data: ${err.message}`;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>More generally, we see that once the effective batch size is large than 32, there is an average drop in performance for this particular model and dataset:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-iqlkmc20dlf"><div class="d3-sft-packing-vs-bs"></div>
<style>
  .d3-sft-packing-vs-bs {
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    position: relative;
  }

  .d3-sft-packing-vs-bs svg {
    display: block;
    overflow: visible;
  }

  .d3-sft-packing-vs-bs .axes path,
  .d3-sft-packing-vs-bs .axes line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }

  .d3-sft-packing-vs-bs .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-packing-vs-bs .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2, 2;
    shape-rendering: crispEdges;
  }

  .d3-sft-packing-vs-bs .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .d3-sft-packing-vs-bs .line-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .d3-sft-packing-vs-bs .line-no-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .d3-sft-packing-vs-bs .line-no-packing {
    fill: none;
    stroke-width: 2;
    stroke-dasharray: 4, 4;
  }

  .d3-sft-packing-vs-bs .dot {
    stroke: var(--surface-bg);
    stroke-width: 2;
  }

  .d3-sft-packing-vs-bs .header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 16px;
    margin-top: 16px;
    flex-wrap: wrap;
  }

  .d3-sft-packing-vs-bs .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-packing-vs-bs .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-bs .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-packing-vs-bs .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-bs .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-packing-vs-bs .legend .swatch-line {
    width: 20px;
    height: 2px;
    border: none;
  }

  .d3-sft-packing-vs-bs .legend .swatch-dashed {
    width: 20px;
    height: 2px;
    border: none;
    background: repeating-linear-gradient(to right,
        var(--text-color) 0,
        var(--text-color) 4px,
        transparent 4px,
        transparent 8px);
  }

  .d3-sft-packing-vs-bs .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: flex-end;
    flex-wrap: wrap;
  }

  .d3-sft-packing-vs-bs .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-packing-vs-bs .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-packing-vs-bs .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
  }

  .d3-sft-packing-vs-bs .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-packing-vs-bs'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-packing-vs-bs'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      const CSV_PATHS = [
        '/data/sft_packing-vs-bs.csv',
        './assets/data/sft_packing-vs-bs.csv',
        '../assets/data/sft_packing-vs-bs.csv',
        '../../assets/data/sft_packing-vs-bs.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found in any of the expected locations');
      };

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        const [mx, my] = d3.pointer(event, container);
        const offsetX = 12, offsetY = 12;
        tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
        tip.style.opacity = '1';
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gAxes = gRoot.append('g').attr('class', 'axes');
      const gLines = gRoot.append('g').attr('class', 'lines');
      const gDots = gRoot.append('g').attr('class', 'dots');

      let width = 800, height = 360;
      const margin = { top: 16, right: 28, bottom: 56, left: 64 };

      // State
      let data = [];
      let benchmarks = [];
      let currentMetric = 'Average';
      let currentMode = '/no_think';

      const updateSize = () => {
        width = container.clientWidth || 800;
        height = Math.max(260, Math.round(width / 2.5));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      };

      // Get colors
      const getColors = () => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          const colors = window.ColorPalettes.getColors('categorical', 2);
          return {
            think: colors[0],
            noThink: colors[1]
          };
        }
        return {
          think: 'var(--primary-color)',
          noThink: '#7F7F7F'
        };
      };

      const render = () => {
        if (data.length === 0) return;

        const { innerWidth, innerHeight } = updateSize();
        const colors = getColors();

        // Filter data by mode
        const modeData = data.filter(d => d.mode === currentMode);

        // Separate packing data and no-packing data
        const packingData = modeData.filter(d => d.batchSize !== 'N/A');
        const noPackingData = modeData.filter(d => d.batchSize === 'N/A');

        // Get metric values
        const getMetricValue = (d) => {
          if (currentMetric === 'Average') {
            return d.average;
          }
          return d[currentMetric];
        };

        // Scales
        const batchSizes = [8, 16, 32, 64, 128];
        const xScale = d3.scalePoint()
          .domain(batchSizes)
          .range([0, innerWidth])
          .padding(0.5);

        const allValues = modeData.map(getMetricValue).filter(v => v != null);
        const yScale = d3.scaleLinear()
          .domain([0, d3.max(allValues) * 1.1 || 100])
          .range([innerHeight, 0])
          .nice();

        // Grid
        gGrid.selectAll('.grid-line').data(yScale.ticks(5))
          .join('line')
          .attr('class', 'grid-line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d));

        // Axes
        const xAxis = d3.axisBottom(xScale).tickFormat(d => d);
        const yAxis = d3.axisLeft(yScale).ticks(5);

        gAxes.selectAll('.x-axis').data([0])
          .join('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(xAxis);

        gAxes.selectAll('.y-axis').data([0])
          .join('g')
          .attr('class', 'y-axis')
          .call(yAxis);

        // Axis labels
        gAxes.selectAll('.x-label').data([0])
          .join('text')
          .attr('class', 'x-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 40)
          .text('Effective batch Size');

        gAxes.selectAll('.y-label').data([0])
          .join('text')
          .attr('class', 'y-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -48)
          .text('Score (%)');

        // Line for packing data
        const line = d3.line()
          .x(d => xScale(d.batchSize))
          .y(d => yScale(getMetricValue(d)))
          .curve(d3.curveMonotoneX);

        gLines.selectAll('.line-packing')
          .data([packingData])
          .join('path')
          .attr('class', 'line-packing')
          .attr('d', line)
          .attr('stroke', colors.think)
          .attr('stroke-width', 2.5)
          .attr('fill', 'none')
          .attr('stroke-linecap', 'round')
          .attr('stroke-linejoin', 'round');

        // Horizontal line for no-packing
        if (noPackingData.length > 0) {
          const noPackingValue = getMetricValue(noPackingData[0]);
          gLines.selectAll('.line-no-packing')
            .data([noPackingValue])
            .join('line')
            .attr('class', 'line-no-packing')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', d => yScale(d))
            .attr('y2', d => yScale(d))
            .attr('stroke', colors.noThink)
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '4,4');
        } else {
          gLines.selectAll('.line-no-packing').remove();
        }

        // Dots for packing data
        gDots.selectAll('.dot')
          .data(packingData)
          .join('circle')
          .attr('class', 'dot')
          .attr('cx', d => xScale(d.batchSize))
          .attr('cy', d => yScale(getMetricValue(d)))
          .attr('r', 4)
          .attr('fill', colors.think)
          .on('mouseenter', (event, d) => {
            const value = getMetricValue(d);
            const html = `<strong>Batch Size: ${d.batchSize}</strong><br/>Score: ${value.toFixed(2)}%`;
            showTooltip(html, event);
          })
          .on('mouseleave', hideTooltip);

        // Update legend
        updateLegend(colors);
      };

      const ensureHeader = () => {
        let header = container.querySelector('.header');
        if (!header) {
          header = document.createElement('div');
          header.className = 'header';
          container.appendChild(header);

          // Create legend container first
          const legend = document.createElement('div');
          legend.className = 'legend';
          header.appendChild(legend);

          // Create controls container second
          const controls = document.createElement('div');
          controls.className = 'controls';
          header.appendChild(controls);
        }
        return header;
      };

      const updateLegend = (colors) => {
        const header = ensureHeader();
        let legend = header.querySelector('.legend');

        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.textContent = 'Legend';
          legend.appendChild(title);
        }

        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }

        items.innerHTML = '';

        // Packing line
        const packingItem = document.createElement('span');
        packingItem.className = 'item';
        const packingSwatch = document.createElement('span');
        packingSwatch.className = 'swatch-line';
        packingSwatch.style.background = colors.think;
        const packingText = document.createElement('span');
        packingText.textContent = 'Packing';
        packingItem.appendChild(packingSwatch);
        packingItem.appendChild(packingText);
        items.appendChild(packingItem);

        // No packing line
        const noPackingItem = document.createElement('span');
        noPackingItem.className = 'item';
        const noPackingSwatch = document.createElement('span');
        noPackingSwatch.className = 'swatch-dashed';
        noPackingSwatch.style.background = `repeating-linear-gradient(to right, ${colors.noThink} 0, ${colors.noThink} 4px, transparent 4px, transparent 8px)`;
        const noPackingText = document.createElement('span');
        noPackingText.textContent = 'No packing';
        noPackingItem.appendChild(noPackingSwatch);
        noPackingItem.appendChild(noPackingText);
        items.appendChild(noPackingItem);
      };

      const buildControls = () => {
        const header = ensureHeader();
        let controls = header.querySelector('.controls');

        // Metric select
        const metricGroup = document.createElement('div');
        metricGroup.className = 'control-group';
        const metricLabel = document.createElement('label');
        metricLabel.setAttribute('for', 'metric-select-packing-bs');
        metricLabel.textContent = 'Metric';
        const metricSelect = document.createElement('select');
        metricSelect.id = 'metric-select-packing-bs';

        const metrics = ['Average', ...benchmarks];
        metrics.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m;
          opt.textContent = m;
          if (m === currentMetric) opt.selected = true;
          metricSelect.appendChild(opt);
        });

        metricSelect.addEventListener('change', (e) => {
          currentMetric = e.target.value;
          render();
        });

        metricGroup.appendChild(metricLabel);
        metricGroup.appendChild(metricSelect);
        controls.appendChild(metricGroup);

        // Reasoning mode select
        const modeGroup = document.createElement('div');
        modeGroup.className = 'control-group';
        const modeLabel = document.createElement('label');
        modeLabel.setAttribute('for', 'mode-select-packing-bs');
        modeLabel.textContent = 'Reasoning mode';
        const modeSelect = document.createElement('select');
        modeSelect.id = 'mode-select-packing-bs';

        const modes = ['/think', '/no_think'];
        modes.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m;
          opt.textContent = m;
          if (m === currentMode) opt.selected = true;
          modeSelect.appendChild(opt);
        });

        modeSelect.addEventListener('change', (e) => {
          currentMode = e.target.value;
          render();
        });

        modeGroup.appendChild(modeLabel);
        modeGroup.appendChild(modeSelect);
        controls.appendChild(modeGroup);
      };

      // Load data
      fetchFirstAvailable(CSV_PATHS)
        .then(csvText => {
          const rows = d3.csvParse(csvText);

          // Get benchmark columns (all except Batch size and Reasoning mode)
          benchmarks = rows.columns.filter(c => c !== 'Batch size' && c !== 'Reasoning mode');

          // Parse data
          data = rows.map(row => {
            const batchSize = row['Batch size'];
            const mode = row['Reasoning mode'];
            const entry = {
              batchSize: batchSize === 'N/A' ? 'N/A' : +batchSize,
              mode: mode
            };

            // Add all benchmark values
            let sum = 0;
            let count = 0;
            benchmarks.forEach(b => {
              const val = +row[b];
              entry[b] = val;
              sum += val;
              count++;
            });

            // Calculate average
            entry.average = sum / count;

            return entry;
          });

          buildControls();
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.cssText = 'color:red;font-size:12px;padding:12px;';
          pre.textContent = 'Error loading data: ' + err.message;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>In practice, for large-scale SFT where the dataset is massive, packing is almost always beneficial since the compute savings far outweigh any minor differences in gradient frequency. However, for smaller or more diverse datasets—like domain-specific fine-tuning or instruction-tuning on limited human-curated data—it might be worth disabling packing to preserve sample granularity and ensure every example contributes cleanly to optimisation.</p>
<p>Ultimately, the best strategy is empirical: start with packing enabled, monitor both throughput and downstream evals, and adjust based on whether the speed gains translate into equivalent or improved model quality.</p>
<p><strong>Tuning the learning rate</strong></p>
<p>We now come to the last, but still important hyperparameter: the learning rate. Set it too high and training may diverge; too low and convergence is painfully slow.</p>
<p>In SFT, the optimal learning rate is typically an order of magnitude (or more) smaller than the one used during pretraining. This is because we’re initialising from a model with rich representations, and aggressive updates can lead to catastrophic forgetting.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty>  <div class="note__title" data-astro-cid-qg6lmfty>Tuning the learning rate in post-training vs pretraining</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Unlike pre-training, where hyperparameter sweeps on the full run are prohibitively expensive, post-training runs are short enough that we can actually do full learning rate sweeps.</p> </div> </div> </div> 
<p>In our experiments, we’ve found that the “best” learning rate varies with both model family, size and the use of packing. Since a high learning rate can lead to exploding gradients, we find it’s often safer to slightly decrease the learning rate when packing is enabled. You can see this below, where using a small learning rate of 3e-6 or 1e-5 gives better overall performance than large values:</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>When picking a range of learning rate values to scan over, we find is useful to pick an initial range like [1e-6, 3e-6, 1e-5, 3e-5, 1e-4]. This covers two orders of magnitude and allows us to hone in on a region where some additional tuning can be applied</p> </aside> </div>  
<figure class="html-embed"><div class="html-embed__card"><div id="frag-hwwu85q7lw"><div class="d3-sft-lr-scan"></div>
<style>
  .d3-sft-lr-scan {
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    position: relative;
  }

  .d3-sft-lr-scan svg {
    display: block;
    overflow: visible;
  }

  .d3-sft-lr-scan .axes path,
  .d3-sft-lr-scan .axes line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }

  .d3-sft-lr-scan .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-lr-scan .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2, 2;
    shape-rendering: crispEdges;
  }

  .d3-sft-lr-scan .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .d3-sft-lr-scan .line-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .d3-sft-lr-scan .line-no-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  .d3-sft-lr-scan .dot {
    stroke: var(--surface-bg);
    stroke-width: 2;
  }

  .d3-sft-lr-scan .header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 16px;
    margin-top: 16px;
    flex-wrap: wrap;
  }

  .d3-sft-lr-scan .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-lr-scan .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-lr-scan .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-lr-scan .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-sft-lr-scan .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-lr-scan .legend .swatch-line {
    width: 20px;
    height: 2px;
    border: none;
  }

  .d3-sft-lr-scan .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: flex-end;
    flex-wrap: wrap;
  }

  .d3-sft-lr-scan .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-lr-scan .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-lr-scan .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
  }

  .d3-sft-lr-scan .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-lr-scan'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-lr-scan'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      const CSV_PATHS = [
        '/data/sft-lr-scan.csv',
        './assets/data/sft-lr-scan.csv',
        '../assets/data/sft-lr-scan.csv',
        '../../assets/data/sft-lr-scan.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found in any of the expected locations');
      };

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        const [mx, my] = d3.pointer(event, container);
        const offsetX = 12, offsetY = 12;
        tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
        tip.style.opacity = '1';
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gAxes = gRoot.append('g').attr('class', 'axes');
      const gLines = gRoot.append('g').attr('class', 'lines');
      const gDots = gRoot.append('g').attr('class', 'dots');

      let width = 800, height = 360;
      const margin = { top: 16, right: 28, bottom: 56, left: 64 };

      // State
      let data = [];
      let benchmarks = [];
      let currentMetric = 'Average';

      const updateSize = () => {
        width = container.clientWidth || 800;
        height = Math.max(260, Math.round(width / 2.5));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      };

      // Get colors
      const getColors = () => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          const colors = window.ColorPalettes.getColors('categorical', 2);
          return {
            think: colors[0],
            noThink: colors[1]
          };
        }
        return {
          think: 'var(--primary-color)',
          noThink: '#7F7F7F'
        };
      };

      const render = () => {
        if (data.length === 0) return;

        const { innerWidth, innerHeight } = updateSize();
        const colors = getColors();

        // Separate data by mode
        const thinkData = data.filter(d => d.mode === '/think');
        const noThinkData = data.filter(d => d.mode === '/no_think');

        // Get metric values
        const getMetricValue = (d) => {
          if (currentMetric === 'Average') {
            return d.average;
          }
          return d[currentMetric];
        };

        // Scales - use log scale for learning rate
        const learningRates = [1e-6, 3e-6, 1e-5, 3e-5, 1e-4];
        const xScale = d3.scaleLog()
          .domain([1e-6, 1e-4])
          .range([0, innerWidth])
          .nice();

        const allValues = data.map(getMetricValue).filter(v => v != null);
        const yScale = d3.scaleLinear()
          .domain([0, d3.max(allValues) * 1.1 || 100])
          .range([innerHeight, 0])
          .nice();

        // Grid
        gGrid.selectAll('.grid-line').data(yScale.ticks(5))
          .join('line')
          .attr('class', 'grid-line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d));

        // Axes
        const xAxis = d3.axisBottom(xScale)
          .tickValues(learningRates)
          .tickFormat(d3.format('.0e'));
        const yAxis = d3.axisLeft(yScale).ticks(5);

        gAxes.selectAll('.x-axis').data([0])
          .join('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(xAxis);

        gAxes.selectAll('.y-axis').data([0])
          .join('g')
          .attr('class', 'y-axis')
          .call(yAxis);

        // Axis labels
        gAxes.selectAll('.x-label').data([0])
          .join('text')
          .attr('class', 'x-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 40)
          .text('Learning rate');

        gAxes.selectAll('.y-label').data([0])
          .join('text')
          .attr('class', 'y-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -48)
          .text('Score (%)');

        // Line generator
        const line = d3.line()
          .x(d => xScale(d.learningRate))
          .y(d => yScale(getMetricValue(d)))
          .curve(d3.curveMonotoneX);

        // Think line
        gLines.selectAll('.line-think')
          .data([thinkData])
          .join('path')
          .attr('class', 'line-think')
          .attr('d', line)
          .attr('stroke', colors.think)
          .attr('stroke-width', 2.5)
          .attr('fill', 'none')
          .attr('stroke-linecap', 'round')
          .attr('stroke-linejoin', 'round');

        // No-think line
        gLines.selectAll('.line-no-think')
          .data([noThinkData])
          .join('path')
          .attr('class', 'line-no-think')
          .attr('d', line)
          .attr('stroke', colors.noThink)
          .attr('stroke-width', 2.5)
          .attr('fill', 'none')
          .attr('stroke-linecap', 'round')
          .attr('stroke-linejoin', 'round');

        // Dots for think mode
        gDots.selectAll('.dot-think')
          .data(thinkData)
          .join('circle')
          .attr('class', 'dot dot-think')
          .attr('cx', d => xScale(d.learningRate))
          .attr('cy', d => yScale(getMetricValue(d)))
          .attr('r', 4)
          .attr('fill', colors.think)
          .on('mouseenter', (event, d) => {
            const value = getMetricValue(d);
            const html = `<strong>Learning Rate: ${d3.format('.0e')(d.learningRate)}</strong><br/>Mode: /think<br/>Score: ${value.toFixed(2)}%`;
            showTooltip(html, event);
          })
          .on('mouseleave', hideTooltip);

        // Dots for no-think mode
        gDots.selectAll('.dot-no-think')
          .data(noThinkData)
          .join('circle')
          .attr('class', 'dot dot-no-think')
          .attr('cx', d => xScale(d.learningRate))
          .attr('cy', d => yScale(getMetricValue(d)))
          .attr('r', 4)
          .attr('fill', colors.noThink)
          .on('mouseenter', (event, d) => {
            const value = getMetricValue(d);
            const html = `<strong>Learning Rate: ${d3.format('.0e')(d.learningRate)}</strong><br/>Mode: /no_think<br/>Score: ${value.toFixed(2)}%`;
            showTooltip(html, event);
          })
          .on('mouseleave', hideTooltip);

        // Update legend
        updateLegend(colors);
      };

      const ensureHeader = () => {
        let header = container.querySelector('.header');
        if (!header) {
          header = document.createElement('div');
          header.className = 'header';
          container.appendChild(header);

          // Create legend container first
          const legend = document.createElement('div');
          legend.className = 'legend';
          header.appendChild(legend);

          // Create controls container second
          const controls = document.createElement('div');
          controls.className = 'controls';
          header.appendChild(controls);
        }
        return header;
      };

      const updateLegend = (colors) => {
        const header = ensureHeader();
        let legend = header.querySelector('.legend');

        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.textContent = 'Legend';
          legend.appendChild(title);
        }

        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }

        items.innerHTML = '';

        // Think line
        const thinkItem = document.createElement('span');
        thinkItem.className = 'item';
        const thinkSwatch = document.createElement('span');
        thinkSwatch.className = 'swatch-line';
        thinkSwatch.style.background = colors.think;
        const thinkText = document.createElement('span');
        thinkText.textContent = '/think';
        thinkItem.appendChild(thinkSwatch);
        thinkItem.appendChild(thinkText);
        items.appendChild(thinkItem);

        // No-think line
        const noThinkItem = document.createElement('span');
        noThinkItem.className = 'item';
        const noThinkSwatch = document.createElement('span');
        noThinkSwatch.className = 'swatch-line';
        noThinkSwatch.style.background = colors.noThink;
        const noThinkText = document.createElement('span');
        noThinkText.textContent = '/no_think';
        noThinkItem.appendChild(noThinkSwatch);
        noThinkItem.appendChild(noThinkText);
        items.appendChild(noThinkItem);
      };

      const buildControls = () => {
        const header = ensureHeader();
        let controls = header.querySelector('.controls');

        // Metric select
        const metricGroup = document.createElement('div');
        metricGroup.className = 'control-group';
        const metricLabel = document.createElement('label');
        metricLabel.setAttribute('for', 'metric-select-lr-scan');
        metricLabel.textContent = 'Metric';
        const metricSelect = document.createElement('select');
        metricSelect.id = 'metric-select-lr-scan';

        const metrics = ['Average', ...benchmarks];
        metrics.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m;
          opt.textContent = m;
          if (m === currentMetric) opt.selected = true;
          metricSelect.appendChild(opt);
        });

        metricSelect.addEventListener('change', (e) => {
          currentMetric = e.target.value;
          render();
        });

        metricGroup.appendChild(metricLabel);
        metricGroup.appendChild(metricSelect);
        controls.appendChild(metricGroup);
      };

      // Load data
      fetchFirstAvailable(CSV_PATHS)
        .then(csvText => {
          const rows = d3.csvParse(csvText);

          // Get benchmark columns (all except Learning rate and Reasoning mode)
          benchmarks = rows.columns.filter(c => c !== 'Learning rate' && c !== 'Reasoning mode');

          // Parse data
          data = rows.map(row => {
            const learningRate = +row['Learning rate'];
            const mode = row['Reasoning mode'];
            const entry = {
              learningRate: learningRate,
              mode: mode
            };

            // Add all benchmark values
            let sum = 0;
            let count = 0;
            benchmarks.forEach(b => {
              const val = +row[b];
              entry[b] = val;
              sum += val;
              count++;
            });

            // Calculate average
            entry.average = sum / count;

            return entry;
          });

          buildControls();
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.cssText = 'color:red;font-size:12px;padding:12px;';
          pre.textContent = 'Error loading data: ' + err.message;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>Although a few points on average may not seem like much, if you look at individual benchmarks like AIME25, you’ll see the performance drop dramatically when the learning rate is larger than 1e-5.</p>
<p><strong>Scaling the number of epochs</strong></p>
<p>In our ablations, we usually train for a single epoch to iterate quickly. Once you’ve identified a good data mixture and tuned key parameters like the learning rate, the next step is to increase the number of epochs for final training.</p>
<p>For example, if we take our baseline data mixture and train for five epochs, we see it is possible to squeeze a few more percentage points of performance on average:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-h8eq64gdgd"><div class="d3-sft-epoch-scan"></div>
<style>
  .d3-sft-epoch-scan {
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    position: relative;
  }
  .d3-sft-epoch-scan svg {
    display: block;
    overflow: visible;
  }
  .d3-sft-epoch-scan .axes path,
  .d3-sft-epoch-scan .axes line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }
  .d3-sft-epoch-scan .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }
  .d3-sft-epoch-scan .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2,2;
    shape-rendering: crispEdges;
  }
  .d3-sft-epoch-scan .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }
  .d3-sft-epoch-scan .line-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .d3-sft-epoch-scan .line-no-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .d3-sft-epoch-scan .dot {
    stroke: var(--surface-bg);
    stroke-width: 2;
  }
  .d3-sft-epoch-scan .header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 16px;
    margin-top: 16px;
    flex-wrap: wrap;
  }
  .d3-sft-epoch-scan .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }
  .d3-sft-epoch-scan .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }
  .d3-sft-epoch-scan .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }
  .d3-sft-epoch-scan .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }
  .d3-sft-epoch-scan .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }
  .d3-sft-epoch-scan .legend .swatch-line {
    width: 20px;
    height: 2px;
    border: none;
  }
  .d3-sft-epoch-scan .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: flex-end;
    flex-wrap: wrap;
  }
  .d3-sft-epoch-scan .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }
  .d3-sft-epoch-scan .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }
  .d3-sft-epoch-scan .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
  }
  .d3-sft-epoch-scan .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-epoch-scan'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-epoch-scan'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      const CSV_PATHS = [
        '/data/sft-epoch-scan.csv',
        './assets/data/sft-epoch-scan.csv',
        '../assets/data/sft-epoch-scan.csv',
        '../../assets/data/sft-epoch-scan.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch(_){}
        }
        throw new Error('CSV not found in any of the expected locations');
      };

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        const [mx, my] = d3.pointer(event, container);
        const offsetX = 12, offsetY = 12;
        tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
        tip.style.opacity = '1';
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gAxes = gRoot.append('g').attr('class', 'axes');
      const gLines = gRoot.append('g').attr('class', 'lines');
      const gDots = gRoot.append('g').attr('class', 'dots');

      let width = 800, height = 360;
      const margin = { top: 16, right: 28, bottom: 56, left: 64 };

      // State
      let data = [];
      let benchmarks = [];
      let currentMetric = 'Average';

      const updateSize = () => {
        width = container.clientWidth || 800;
        height = Math.max(260, Math.round(width / 2.5));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      };

      // Get colors
      const getColors = () => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          const colors = window.ColorPalettes.getColors('categorical', 2);
          return {
            think: colors[0],
            noThink: colors[1]
          };
        }
        return {
          think: 'var(--primary-color)',
          noThink: '#7F7F7F'
        };
      };

      const render = () => {
        if (data.length === 0) return;

        const { innerWidth, innerHeight } = updateSize();
        const colors = getColors();

        // Separate data by mode
        const thinkData = data.filter(d => d.mode === '/think');
        const noThinkData = data.filter(d => d.mode === '/no_think');

        // Get metric values
        const getMetricValue = (d) => {
          if (currentMetric === 'Average') {
            return d.average;
          }
          return d[currentMetric];
        };

        // Scales - use linear scale for epochs
        const epochs = [...new Set(data.map(d => d.epoch))].sort((a, b) => a - b);
        const xScale = d3.scaleLinear()
          .domain([d3.min(epochs), d3.max(epochs)])
          .range([0, innerWidth])
          .nice();

        const allValues = data.map(getMetricValue).filter(v => v != null);
        const yScale = d3.scaleLinear()
          .domain([0, d3.max(allValues) * 1.1 || 100])
          .range([innerHeight, 0])
          .nice();

        // Grid
        gGrid.selectAll('.grid-line').data(yScale.ticks(5))
          .join('line')
          .attr('class', 'grid-line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d));

        // Axes
        const xAxis = d3.axisBottom(xScale)
          .tickValues(epochs)
          .tickFormat(d3.format('d'));
        const yAxis = d3.axisLeft(yScale).ticks(5);

        gAxes.selectAll('.x-axis').data([0])
          .join('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(xAxis);

        gAxes.selectAll('.y-axis').data([0])
          .join('g')
          .attr('class', 'y-axis')
          .call(yAxis);

        // Axis labels
        gAxes.selectAll('.x-label').data([0])
          .join('text')
          .attr('class', 'x-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 40)
          .text('Epoch');

        gAxes.selectAll('.y-label').data([0])
          .join('text')
          .attr('class', 'y-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -48)
          .text('Score (%)');

        // Line generator
        const line = d3.line()
          .x(d => xScale(d.epoch))
          .y(d => yScale(getMetricValue(d)))
          .curve(d3.curveMonotoneX);

        // Think line
        gLines.selectAll('.line-think')
          .data([thinkData])
          .join('path')
          .attr('class', 'line-think')
          .attr('d', line)
          .attr('stroke', colors.think)
          .attr('stroke-width', 2.5)
          .attr('fill', 'none')
          .attr('stroke-linecap', 'round')
          .attr('stroke-linejoin', 'round');

        // No-think line
        gLines.selectAll('.line-no-think')
          .data([noThinkData])
          .join('path')
          .attr('class', 'line-no-think')
          .attr('d', line)
          .attr('stroke', colors.noThink)
          .attr('stroke-width', 2.5)
          .attr('fill', 'none')
          .attr('stroke-linecap', 'round')
          .attr('stroke-linejoin', 'round');

        // Dots for think mode
        gDots.selectAll('.dot-think')
          .data(thinkData)
          .join('circle')
          .attr('class', 'dot dot-think')
          .attr('cx', d => xScale(d.epoch))
          .attr('cy', d => yScale(getMetricValue(d)))
          .attr('r', 4)
          .attr('fill', colors.think)
          .on('mouseenter', (event, d) => {
            const value = getMetricValue(d);
            const html = `<strong>Epoch: ${d.epoch}</strong><br/>Mode: /think<br/>Score: ${value.toFixed(2)}%`;
            showTooltip(html, event);
          })
          .on('mouseleave', hideTooltip);

        // Dots for no-think mode
        gDots.selectAll('.dot-no-think')
          .data(noThinkData)
          .join('circle')
          .attr('class', 'dot dot-no-think')
          .attr('cx', d => xScale(d.epoch))
          .attr('cy', d => yScale(getMetricValue(d)))
          .attr('r', 4)
          .attr('fill', colors.noThink)
          .on('mouseenter', (event, d) => {
            const value = getMetricValue(d);
            const html = `<strong>Epoch: ${d.epoch}</strong><br/>Mode: /no_think<br/>Score: ${value.toFixed(2)}%`;
            showTooltip(html, event);
          })
          .on('mouseleave', hideTooltip);

        // Update legend
        updateLegend(colors);
      };

      const ensureHeader = () => {
        let header = container.querySelector('.header');
        if (!header) {
          header = document.createElement('div');
          header.className = 'header';
          container.appendChild(header);

          // Create legend container first
          const legend = document.createElement('div');
          legend.className = 'legend';
          header.appendChild(legend);

          // Create controls container second
          const controls = document.createElement('div');
          controls.className = 'controls';
          header.appendChild(controls);
        }
        return header;
      };

      const updateLegend = (colors) => {
        const header = ensureHeader();
        let legend = header.querySelector('.legend');

        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.textContent = 'Legend';
          legend.appendChild(title);
        }

        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }

        items.innerHTML = '';

        // Think line
        const thinkItem = document.createElement('span');
        thinkItem.className = 'item';
        const thinkSwatch = document.createElement('span');
        thinkSwatch.className = 'swatch-line';
        thinkSwatch.style.background = colors.think;
        const thinkText = document.createElement('span');
        thinkText.textContent = '/think';
        thinkItem.appendChild(thinkSwatch);
        thinkItem.appendChild(thinkText);
        items.appendChild(thinkItem);

        // No-think line
        const noThinkItem = document.createElement('span');
        noThinkItem.className = 'item';
        const noThinkSwatch = document.createElement('span');
        noThinkSwatch.className = 'swatch-line';
        noThinkSwatch.style.background = colors.noThink;
        const noThinkText = document.createElement('span');
        noThinkText.textContent = '/no_think';
        noThinkItem.appendChild(noThinkSwatch);
        noThinkItem.appendChild(noThinkText);
        items.appendChild(noThinkItem);
      };

      const buildControls = () => {
        const header = ensureHeader();
        let controls = header.querySelector('.controls');

        // Metric select
        const metricGroup = document.createElement('div');
        metricGroup.className = 'control-group';
        const metricLabel = document.createElement('label');
        metricLabel.setAttribute('for', 'metric-select-epoch-scan');
        metricLabel.textContent = 'Metric';
        const metricSelect = document.createElement('select');
        metricSelect.id = 'metric-select-epoch-scan';

        const metrics = ['Average', ...benchmarks];
        metrics.forEach(m => {
          const opt = document.createElement('option');
          opt.value = m;
          opt.textContent = m;
          if (m === currentMetric) opt.selected = true;
          metricSelect.appendChild(opt);
        });

        metricSelect.addEventListener('change', (e) => {
          currentMetric = e.target.value;
          render();
        });

        metricGroup.appendChild(metricLabel);
        metricGroup.appendChild(metricSelect);
        controls.appendChild(metricGroup);
      };

      // Load data
      fetchFirstAvailable(CSV_PATHS)
        .then(csvText => {
          const rows = d3.csvParse(csvText);

          // Get benchmark columns (all except Epoch and Reasoning mode)
          benchmarks = rows.columns.filter(c => c !== 'Epoch' && c !== 'Reasoning mode');

          // Parse data
          data = rows.map(row => {
            const epoch = +row['Epoch'];
            const mode = row['Reasoning mode'];
            const entry = {
              epoch: epoch,
              mode: mode
            };

            // Add all benchmark values
            let sum = 0;
            let count = 0;
            benchmarks.forEach(b => {
              const val = +row[b];
              entry[b] = val;
              sum += val;
              count++;
            });

            // Calculate average
            entry.average = sum / count;

            return entry;
          });

          buildControls();
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.cssText = 'color:red;font-size:12px;padding:12px;';
          pre.textContent = 'Error loading data: ' + err.message;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div></figure>
<p>As we saw with the learning rate scan, the average performance obscures the impact that scaling the number of epochs has on individual evals: in the case of LiveCodeBench v4 with extended thinking, we nearly double the performance over one epoch!</p>
<p>Once you’ve iterated on your SFT data mixture and the model has reached a reasonable level of performance, the next step is often to explore more advanced methods like [preference optimisation](#from-sft-to-preference-optimisation:-teaching-models-what- <em>better-</em> means) or <a href="#going-online-and-beyond-supervised-labels">reinforcement learning</a>. However, before diving into those, it’s worth considering whether the additional compute would be better spent on strengthening the base model through  <em>continued pretraining.</em></p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>Optimisers in post-training</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Another important component we mentioned in the pre-training section is the optimiser. Similarly, AdamW remains the default choice for post-training. An open question is whether models pre-trained with alternative optimisers like Muon should be post-trained with the  <em>same</em>  optimiser. The Kimi team found that using the same optimise for pre- and post-training yielded best performance for their <a href="https://arxiv.org/abs/2502.16982">Moonlight</a> model.</p> </div> </div> </div> 
<h4 id="boosting-reasoning-through-continued-pretraining"><a href="#boosting-reasoning-through-continued-pretraining">Boosting reasoning through continued pretraining</a></h4>
<p>Continued pretraining—or mid-training if you want to sound fancy—means taking a base model and training it further on large amounts of domain-specific tokens before doing SFT. Mid-training is useful when your target capabilities for SFT share a common core skill, such as coding or reasoning. In practice, this shifts the model toward a distribution that better supports reasoning, a specific language, or any other capability you care about. Starting SFT from a model that has already integrated that core skill allows your model to better focus on the specific topics in your SFT data rather than using compute to learn the core skill from scratch.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>You might wonder why we’re discussing continued pretraining  <em>after</em>  we did some SFT runs. Chronologically, mid-training happens before SFT on the base model. But the decision to do mid-training only becomes clear after you’ve run initial SFT experiments and identified performance gaps. In practice, you’ll often iterate: run SFT to identify weak areas, then do targeted mid-training, then run SFT again. Think of this section as <b>“what to do when SFT alone isn’t enough.”</b></p> </aside> </div>  
<p>The mid-training approach traces back to ULMFit <span class="" id="citation--ulmfit--143">(<a href="https://arxiv.org/abs/1801.06146" id="refctx-bib-ulmfit-1" data-ref-id="bib-ulmfit" target="_blank" rel="noopener noreferrer">Howard &amp; Ruder, 2018</a>)</span>, which pioneered the three-stage pipeline of general pretraining → mid-training → post-training that is now common in modern LLMs like FAIR’s Code World Model <span class="" id="citation--cwm--144">(<a href="https://arxiv.org/abs/2510.02387" id="refctx-bib-cwm-1" data-ref-id="bib-cwm" target="_blank" rel="noopener noreferrer">team et al., 2025</a>)</span>:</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-nwva3sl073"><div class="training-pipeline"></div>
<style>
    .training-pipeline {
        font-family: 'Arial', sans-serif;
        margin: 20px 0;
        padding: 0;
    }

    .training-pipeline .container {
        display: flex;
        gap: 30px;
        align-items: center;
        justify-content: center;
        flex-wrap: nowrap;
    }

    .training-pipeline .phase {
        flex: 0 1 auto;
        border: 1px dashed color-mix(in srgb, var(--text-color, #333) 40%, transparent);
        border-radius: 8px;
        padding: 15px;
    }

    .training-pipeline .phase-header {
        font-size: 14px;
        font-weight: bold;
        color: var(--text-color, #333);
        margin-bottom: 20px;
        text-align: left;
        letter-spacing: 1px;
        text-transform: uppercase;
        opacity: 0.6;
    }

    .training-pipeline .steps-row {
        display: flex;
        gap: 15px;
        align-items: flex-start;
        justify-content: center;
        flex-wrap: nowrap;
    }

    .training-pipeline .step-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 0 1 auto;
        min-width: 150px;
        max-width: 240px;
    }

    .training-pipeline .step {
        width: 100%;
        padding: 16px;
        border-radius: 8px;
        border: 1px solid;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .training-pipeline .step-title {
        font-size: 13px;
        font-weight: 600;
        line-height: 1.4;
        margin-bottom: 5px;
    }

    .training-pipeline .step-info {
        font-size: 11px;
        opacity: 0.9;
    }

    .training-pipeline .arrow-right {
        font-size: 24px;
        color: #999;
        display: flex;
        align-items: center;
        flex-shrink: 0;
        margin-top: 40px;
    }

    .training-pipeline .arrow-between {
        font-size: 32px;
        color: #999;
        display: flex;
        align-items: center;
        flex-shrink: 0;
    }

    .training-pipeline .model-badge {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        padding: 8px 16px;
        background: linear-gradient(135deg, #FFB6B6, #FF9999);
        border-radius: 20px;
        font-weight: 600;
        font-size: 11px;
        color: #333;
        box-shadow: 0 2px 6px rgba(255, 182, 182, 0.3);
        position: relative;
        margin-top: 15px;
        white-space: nowrap;
    }

    .training-pipeline .model-badge::before {
        content: '';
        position: absolute;
        top: -15px;
        left: 50%;
        transform: translateX(-50%);
        width: 2px;
        height: 15px;
        border-left: 2px dashed #FFB6B6;
    }

    .training-pipeline .model-icon {
        font-size: 16px;
        font-weight: bold;
    }

    .training-pipeline .pre-training {
        background: color-mix(in srgb, #87CEEB 60%, transparent);
        border-color: #87CEEB;
        color: var(--text-color, #000);
    }

    .training-pipeline .sft {
        background: color-mix(in srgb, #F4C28F 60%, transparent);
        border-color: #F4C28F;
        color: var(--text-color, #000);
    }

    .training-pipeline .rl {
        background: color-mix(in srgb, #E6B8E6 60%, transparent);
        border-color: #E6B8E6;
        color: var(--text-color, #000);
    }

    @media (max-width: 1100px) {
        .training-pipeline .container {
            flex-direction: column;
            align-items: stretch;
        }

        .training-pipeline .phase {
            width: 100%;
            max-width: 100%;
        }

        .training-pipeline .arrow-between {
            transform: rotate(90deg);
            margin: 10px 0;
            align-self: center;
        }
    }

    @media (max-width: 768px) {
        .training-pipeline .steps-row {
            flex-direction: column;
            align-items: center;
        }

        .training-pipeline .arrow-right {
            transform: rotate(90deg);
            margin: 10px 0;
        }

        .training-pipeline .step-wrapper {
            max-width: 100%;
            width: 100%;
        }
    }
</style>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        const container = document.querySelector('.training-pipeline');

        container.innerHTML = `
            <div class="container">
                <!-- PRE-TRAINING -->
                <div class="phase">
                    <div class="phase-header">Pre-Training</div>
                    <div class="steps-row">
                        <div class="step-wrapper">
                            <div class="step pre-training">
                                <div class="step-title">General<br/>Pre-training</div>
                                <div class="step-info">8T tokens<br/>8k context</div>
                            </div>
                        </div>
                        
                        <div class="arrow-right">→</div>
                        
                        <div class="step-wrapper">
                            <div class="step pre-training">
                                <div class="step-title">Code World Modeling<br/>Mid-training</div>
                                <div class="step-info">5T tokens<br/>131k context</div>
                            </div>
                            <div class="model-badge">
                                <span class="model-icon">📦</span>
                                <span>CWM pretrained</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ARROW BETWEEN PHASES -->
                <div class="arrow-between">→</div>

                <!-- POST-TRAINING -->
                <div class="phase">
                    <div class="phase-header">Post-Training</div>
                    <div class="steps-row">
                        <div class="step-wrapper">
                            <div class="step sft">
                                <div class="step-title">Supervised Fine-tuning<br/>Instruction and Reasoning</div>
                                <div class="step-info">100B tokens<br/>32k context</div>
                            </div>
                            <div class="model-badge">
                                <span class="model-icon">📦</span>
                                <span>CWM sft</span>
                            </div>
                        </div>
                        
                        <div class="arrow-right">→</div>
                        
                        <div class="step-wrapper">
                            <div class="step rl">
                                <div class="step-title">Joint Reinforcement Learning<br/>Agentic and Reasoning</div>
                                <div class="step-info">172B tokens<br/>131k context</div>
                            </div>
                            <div class="model-badge">
                                <span class="model-icon">📦</span>
                                <span>CWM</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    });
</script></div></div></figure> </div>
<p>This approach was also used in the training of Phi-4-Mini-Reasoning <span class="" id="citation--phi4reasoning--145">(<a href="https://arxiv.org/abs/2504.21233" id="refctx-bib-phi4reasoning-1" data-ref-id="bib-phi4reasoning" target="_blank" rel="noopener noreferrer">Xu et al., 2025</a>)</span>, but with a twist: instead of doing continued pretraining on web data, the authors used distilled reasoning tokens from DeepSeek-R1 for the mid-training corpus. The results were compelling, showing consistent and large gains through multi-stage training:</p>









































<div class="table-scroll"><table><thead><tr><th>Model</th><th>AIME24</th><th>MATH-500</th><th>GPQA Diamond</th></tr></thead><tbody><tr><td><strong>Phi-4-Mini</strong></td><td>10.0</td><td>71.8</td><td>36.9</td></tr><tr><td>+ Distill Mid-training</td><td>30.0</td><td>82.9</td><td>42.6</td></tr><tr><td>+ Distill Fine-tuning</td><td>43.3</td><td>89.3</td><td>48.3</td></tr><tr><td>+ Roll-Out DPO</td><td>50.0</td><td>93.6</td><td>49.0</td></tr><tr><td>+ RL (Phi-4-Mini-Reasoning)</td><td><strong>57.5</strong></td><td><strong>94.6</strong></td><td><strong>52.0</strong></td></tr></tbody></table></div>
<p>These results prompted us to try a similar approach. From our prior experience with creating and evaluating reasoning datasets in Open-R1, we had three main candidates to work with:</p>
<ul>
<li><a href="https://huggingface.co/datasets/open-r1/Mixture-of-Thoughts"> <strong>Mixture of Thoughts</strong> </a> <strong>:</strong> 350k reasoning samples distilled from DeepSeek-R1 across math, code, and science.</li>
<li><a href="https://huggingface.co/datasets/nvidia/Llama-Nemotron-Post-Training-Dataset"> <strong>Llama-Nemotron-Post-Training-Dataset:</strong> </a> NVIDIA’s large-scale dataset of distilled from a wide variety of models such as Llama3 and DeepSeek-R1. We filtered the dataset for the DeepSeek-R1 outputs, which resulted in about 3.64M samples or 18.7B tokens.</li>
<li><a href="https://huggingface.co/datasets/open-thoughts/OpenThoughts3-1.2M"> <strong>OpenThoughts3-1.2M:</strong> </a> one of the highest-quality reasoning datasets, with 1.2M samples distilled from QwQ-32B, comprising 16.5B tokens.</li>
</ul>
<p>Since we planned to include reasoning data in the final SFT mix, we decided to keep Mixture of Thoughts for that stage the others for mid-training. We used ChatML as the chat template to avoid “burning in” the SmolLM3 one too early on. We also trained for 5 epochs with a learning rate of 2e-5, using 8 nodes to accelerate training with an effective batch size of 128.</p>
<p><strong>The mystery of the melting GPUs</strong></p>
<p>Running these experiments turned out to be a surprising challenge on our cluster: the aging GPUs would get throttled at various points which would lead to hardware failures and forced restarts of each run. To give you a taste of what it was like, here’s the logs from one of the runs, where each colour represents a restart:</p>
<div class="ri-root" data-ri-root="ri_ygjvxst1kzc" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/GtU8DnoWsAAruEG_28e1384e-bcac-8051-8122-ed6cacf8f632.AUNwy38i_Z1Unntg.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/GtU8DnoWsAAruEG_28e1384e-bcac-8051-8122-ed6cacf8f632.AUNwy38i.png" data-astro-cid-6kov3kig width="680" height="291" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script> 
<p>We initially thought DeepSpeed might be the culprit, since the accelerator is highly optimised for throughput. To test this, we switched to DP, which helped somewhat, but then the loss was dramatically different!</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Finding bugs in your code at midnight is more common than you might think. In hindsight, for long runs at this scale, it would have made more sense to use nanotron since it was battle-tested and had faster throughput.</p> </aside> </div>  
<div class="ri-root" data-ri-root="ri_4dxsryp8yh5" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/Screenshot_2025-10-01_at_11_31_19_28e1384e-bcac-8005-8c5e-f0af3bf70372.BuE895O6_Z1ti3sF.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/Screenshot_2025-10-01_at_11_31_19_28e1384e-bcac-8005-8c5e-f0af3bf70372.BuE895O6.png" data-astro-cid-6kov3kig width="664" height="575" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script> 
<p>As we later discovered, a bug with DP in Accelerate meant that the weights and gradients were stored in the model’s native precision (BF16 in this case), which led to numerical instability and loss of gradient accuracy during accumulation and optimisation.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>To prevent this, most accelerators use FP32 for the “master weights” and optimiser states, and only cast back to BF16 for the forward and backward passes.</p> </aside> </div>  
<p>So we switched back to DeepSpeed and added aggressive checkpointing to minimise the time lost from GPUs overheating and “falling off the bus”. This strategy proved successful and is something we recommend more generally:</p>
<div class="note note--danger" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>☝️</span> <div class="note__title" data-astro-cid-qg6lmfty>Rule</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>As we emphasized in pre-training, save model checkpoints frequently during a training run, and ideally push them to the Hugging Face Hub to avoid accidental overwrites. Also, make your training framework robust to failures and capable of automatic restarts. Both of these strategies will save you time, especially for long-running jobs like mid-training ones.</p> </div> </div> </div> 
<p>After babysitting the runs for a week or so, we finally had our results:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-fowwlvd9agc"><div class="d3-sft-mid-train"></div>
<style>
  .d3-sft-mid-train {
    position: relative;
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  }

  .d3-sft-mid-train svg {
    display: block;
    width: 100%;
  }

  .d3-sft-mid-train .axes path,
  .d3-sft-mid-train .axes line {
    stroke: var(--axis-color);
  }

  .d3-sft-mid-train .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-mid-train .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2, 2;
  }

  .d3-sft-mid-train .bar {
    cursor: pointer;
    transition: opacity 0.15s ease;
  }

  .d3-sft-mid-train .bar:hover {
    opacity: 0.8;
  }

  .d3-sft-mid-train .legend-controls-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 24px;
    margin-top: 12px;
    flex-wrap: wrap;
  }

  .d3-sft-mid-train .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    flex: 1;
    min-width: 0;
  }

  .d3-sft-mid-train .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-mid-train .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-mid-train .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-sft-mid-train .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-mid-train .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 10px 12px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.5;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.18);
    opacity: 0;
    transition: opacity 0.12s ease;
    z-index: 1000;
  }

  .d3-sft-mid-train .d3-tooltip.visible {
    opacity: 1;
  }

  .d3-sft-mid-train .d3-tooltip__inner {
    text-align: left;
  }

  .d3-sft-mid-train .d3-tooltip__inner strong {
    color: var(--text-color);
    font-weight: 700;
  }

  .d3-sft-mid-train .axis-label {
    font-size: 12px;
    font-weight: 600;
    fill: var(--text-color);
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-mid-train'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-mid-train'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Data loading helpers
      const CSV_PATHS = [
        '/data/sft-midtrain.csv',
        './assets/data/sft-midtrain.csv',
        '../assets/data/sft-midtrain.csv',
        '../../assets/data/sft-midtrain.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found at any of the specified paths');
      };

      // Tooltip setup
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gBars = gRoot.append('g').attr('class', 'bars');
      const gAxes = gRoot.append('g').attr('class', 'axes');

      // State
      let data = [];
      let width = 800;
      let height = 400;
      const margin = { top: 20, right: 40, bottom: 80, left: 64 };

      // Color palette
      let uniqueSubsets = [];
      const subsetColors = {};

      const getColors = (n) => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          return window.ColorPalettes.getColors('categorical', n);
        }
        // Fallback to Tableau10-inspired colors
        return ['#4E79A7', '#F28E2B', '#E15759', '#76B7B2'];
      };

      function updateColors() {
        const colors = getColors(uniqueSubsets.length);
        uniqueSubsets.forEach((subset, i) => {
          subsetColors[subset] = colors[i];
        });
      }

      // Listen for palette changes
      if (window.ColorPalettes && window.ColorPalettes.onChange) {
        window.ColorPalettes.onChange(() => {
          updateColors();
          render();
        });
      }

      function updateSize() {
        width = container.clientWidth || 800;
        height = Math.max(320, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      }

      function makeLegend() {
        // Create wrapper if it doesn't exist
        let wrapper = container.querySelector('.legend-controls-wrapper');
        if (!wrapper) {
          wrapper = document.createElement('div');
          wrapper.className = 'legend-controls-wrapper';
          container.appendChild(wrapper);
        }

        // Create legend
        let legend = wrapper.querySelector('.legend');
        if (!legend) {
          legend = document.createElement('div');
          legend.className = 'legend';
          wrapper.appendChild(legend);
        }
        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.textContent = 'Legend';
          legend.appendChild(title);
        }
        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }
        items.innerHTML = '';

        uniqueSubsets.forEach((subset) => {
          const el = document.createElement('span');
          el.className = 'item';
          const sw = document.createElement('span');
          sw.className = 'swatch';
          sw.style.background = subsetColors[subset];
          const txt = document.createElement('span');
          txt.textContent = subset;
          el.appendChild(sw);
          el.appendChild(txt);
          items.appendChild(el);
        });
      }

      function render() {
        if (!data || data.length === 0) return;

        const { innerWidth, innerHeight } = updateSize();

        // Get unique benchmarks (excluding 'Subset' column)
        const benchmarks = ['AIME25', 'GPQA-D', 'LiveCodeBench v4', 'IFEval'];

        // Transform data for grouped bars
        const groupedData = benchmarks.map(benchmark => {
          const values = data.map(d => ({
            subset: d.Subset,
            value: +d[benchmark] || 0
          }));
          return { benchmark, values };
        });

        // Scales
        const x0 = d3.scaleBand()
          .domain(benchmarks)
          .range([0, innerWidth])
          .padding(0.2);

        const x1 = d3.scaleBand()
          .domain(data.map(d => d.Subset))
          .range([0, x0.bandwidth()])
          .padding(0.05);

        const y = d3.scaleLinear()
          .domain([0, d3.max(data, d => d3.max(benchmarks, b => +d[b] || 0)) || 100])
          .range([innerHeight, 0])
          .nice();

        // Grid
        gGrid
          .attr('transform', `translate(0,0)`)
          .call(d3.axisLeft(y).tickSize(-innerWidth).tickFormat(''))
          .call(g => g.select('.domain').remove());

        // Bars
        const groups = gBars.selectAll('g.benchmark-group')
          .data(groupedData, d => d.benchmark);

        const groupsEnter = groups.enter()
          .append('g')
          .attr('class', 'benchmark-group');

        groups.exit().remove();

        const groupsMerge = groupsEnter.merge(groups)
          .attr('transform', d => `translate(${x0(d.benchmark)},0)`);

        const bars = groupsMerge.selectAll('rect.bar')
          .data(d => d.values, d => d.subset);

        bars.enter()
          .append('rect')
          .attr('class', 'bar')
          .merge(bars)
          .attr('x', d => x1(d.subset))
          .attr('width', x1.bandwidth())
          .attr('fill', d => subsetColors[d.subset])
          .attr('stroke', 'none')
          .transition()
          .duration(200)
          .attr('y', d => y(d.value))
          .attr('height', d => Math.max(0, innerHeight - y(d.value)));

        bars.exit().remove();

        // Hover interactions
        groupsMerge.selectAll('rect.bar')
          .on('mouseenter', function (event, d) {
            const benchmark = d3.select(this.parentNode).datum().benchmark;
            tipInner.innerHTML = `<strong>${d.subset}</strong><br/>${benchmark}: <strong>${d.value.toFixed(1)}</strong>`;
            tip.classList.add('visible');
          })
          .on('mousemove', function (event) {
            const [mx, my] = d3.pointer(event, container);
            const offsetX = 10;
            const offsetY = -10;
            tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
          })
          .on('mouseleave', function () {
            tip.classList.remove('visible');
            tip.style.transform = 'translate(-9999px, -9999px)';
          });

        // Axes
        gAxes.selectAll('.x-axis').remove();
        gAxes.selectAll('.y-axis').remove();

        const xAxis = gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(x0).tickSizeOuter(0));

        xAxis.selectAll('text')
          .style('text-anchor', 'middle');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(y).ticks(6).tickSizeOuter(0));

        // Y-axis label
        gAxes.selectAll('.y-label').remove();
        gAxes.append('text')
          .attr('class', 'y-label axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -margin.left + 20)
          .style('text-anchor', 'middle')
          .text('Score (%)');
      }

      // Load data
      fetchFirstAvailable(CSV_PATHS)
        .then(csvText => {
          data = d3.csvParse(csvText);

          // Extract unique subsets from data
          uniqueSubsets = [...new Set(data.map(d => d.Subset))];
          updateColors();

          makeLegend();
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.color = 'red';
          pre.style.fontSize = '12px';
          pre.style.padding = '12px';
          pre.textContent = `Error loading data: ${err.message}`;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>Overall, we found that NVIDIA’s post-training dataset gave better performance than OpenThoughts, but the combination was best overall.</p>
<p>Now let’s take a look at the effect of taking one of these checkpoints and applying our same baseline data mixture:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-2u7dhp1hrgg"><div class="d3-sft-base-vs-mid"></div>
<style>
  .d3-sft-base-vs-mid {
    position: relative;
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  }

  .d3-sft-base-vs-mid svg {
    display: block;
    width: 100%;
  }

  .d3-sft-base-vs-mid .axes path,
  .d3-sft-base-vs-mid .axes line {
    stroke: var(--axis-color);
  }

  .d3-sft-base-vs-mid .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-sft-base-vs-mid .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2, 2;
  }

  .d3-sft-base-vs-mid .bar {
    cursor: pointer;
    transition: opacity 0.15s ease;
  }

  .d3-sft-base-vs-mid .bar:hover {
    opacity: 0.8;
  }

  .d3-sft-base-vs-mid .legend-controls-wrapper {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 24px;
    margin-top: 12px;
    flex-wrap: wrap;
  }

  .d3-sft-base-vs-mid .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    flex: 1;
    min-width: 0;
  }

  .d3-sft-base-vs-mid .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-base-vs-mid .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-sft-base-vs-mid .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-sft-base-vs-mid .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-sft-base-vs-mid .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    flex-shrink: 0;
  }

  .d3-sft-base-vs-mid .controls .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-sft-base-vs-mid .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-sft-base-vs-mid .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
  }

  .d3-sft-base-vs-mid .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }

  .d3-sft-base-vs-mid .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 10px 12px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.5;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.18);
    opacity: 0;
    transition: opacity 0.12s ease;
    z-index: 1000;
  }

  .d3-sft-base-vs-mid .d3-tooltip.visible {
    opacity: 1;
  }

  .d3-sft-base-vs-mid .d3-tooltip__inner {
    text-align: left;
  }

  .d3-sft-base-vs-mid .d3-tooltip__inner strong {
    color: var(--text-color);
    font-weight: 700;
  }

  .d3-sft-base-vs-mid .axis-label {
    font-size: 12px;
    font-weight: 600;
    fill: var(--text-color);
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-sft-base-vs-mid'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-sft-base-vs-mid'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Data loading helpers
      const CSV_PATHS = [
        '/data/sft-base-vs-mid.csv',
        './assets/data/sft-base-vs-mid.csv',
        '../assets/data/sft-base-vs-mid.csv',
        '../../assets/data/sft-base-vs-mid.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (_) { }
        }
        throw new Error('CSV not found at any of the specified paths');
      };

      // Tooltip setup
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gBars = gRoot.append('g').attr('class', 'bars');
      const gAxes = gRoot.append('g').attr('class', 'axes');

      // State
      let data = [];
      let currentMode = '/no_think';
      let width = 800;
      let height = 400;
      const margin = { top: 20, right: 40, bottom: 80, left: 64 };

      // Color palette
      let uniqueBaseModels = [];
      const baseModelColors = {};

      const getColors = (n) => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          return window.ColorPalettes.getColors('categorical', n);
        }
        // Fallback to Tableau10-inspired colors
        return ['#4E79A7', '#F28E2B', '#E15759', '#76B7B2'];
      };

      function updateColors() {
        const colors = getColors(uniqueBaseModels.length);
        uniqueBaseModels.forEach((baseModel, i) => {
          baseModelColors[baseModel] = colors[i];
        });
      }

      // Listen for palette changes
      if (window.ColorPalettes && window.ColorPalettes.onChange) {
        window.ColorPalettes.onChange(() => {
          updateColors();
          render();
        });
      }

      function updateSize() {
        width = container.clientWidth || 800;
        height = Math.max(320, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      }

      function makeLegendAndControls() {
        // Create wrapper if it doesn't exist
        let wrapper = container.querySelector('.legend-controls-wrapper');
        if (!wrapper) {
          wrapper = document.createElement('div');
          wrapper.className = 'legend-controls-wrapper';
          container.appendChild(wrapper);
        }

        // Create legend
        let legend = wrapper.querySelector('.legend');
        if (!legend) {
          legend = document.createElement('div');
          legend.className = 'legend';
          wrapper.appendChild(legend);
        }
        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.textContent = 'Legend';
          legend.appendChild(title);
        }
        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }
        items.innerHTML = '';

        uniqueBaseModels.forEach((baseModel) => {
          const el = document.createElement('span');
          el.className = 'item';
          const sw = document.createElement('span');
          sw.className = 'swatch';
          sw.style.background = baseModelColors[baseModel];
          const txt = document.createElement('span');
          txt.textContent = baseModel;
          el.appendChild(sw);
          el.appendChild(txt);
          items.appendChild(el);
        });

        // Create controls
        let controls = wrapper.querySelector('.controls');
        if (!controls) {
          controls = document.createElement('div');
          controls.className = 'controls';
          wrapper.appendChild(controls);
        }

        let group = controls.querySelector('.control-group');
        if (!group) {
          group = document.createElement('div');
          group.className = 'control-group';
          controls.appendChild(group);
        }

        let label = group.querySelector('label');
        if (!label) {
          label = document.createElement('label');
          label.setAttribute('for', 'reasoning-mode-select');
          label.textContent = 'Reasoning mode';
          group.appendChild(label);
        }

        let select = group.querySelector('select');
        if (!select) {
          select = document.createElement('select');
          select.id = 'reasoning-mode-select';
          select.innerHTML = `
            <option value="/no_think">/no_think</option>
            <option value="/think">/think</option>
          `;
          select.addEventListener('change', (e) => {
            currentMode = e.target.value;
            render();
          });
          group.appendChild(select);
        }
      }

      function render() {
        if (!data || data.length === 0) return;

        const { innerWidth, innerHeight } = updateSize();

        // Filter data by current mode
        const filteredData = data.filter(d => d['Reasoning mode'] === currentMode);

        // Get unique benchmarks
        const benchmarks = ['AIME25', 'GPQA-D', 'LiveCodeBench v4', 'IFEval', 'Global MMLU Lite'];

        // Transform data for grouped bars
        const groupedData = benchmarks.map(benchmark => {
          const values = filteredData.map(d => ({
            baseModel: d['Base model'],
            value: +d[benchmark] || 0
          }));
          return { benchmark, values };
        });

        // Scales
        const x0 = d3.scaleBand()
          .domain(benchmarks)
          .range([0, innerWidth])
          .padding(0.2);

        const x1 = d3.scaleBand()
          .domain(filteredData.map(d => d['Base model']))
          .range([0, x0.bandwidth()])
          .padding(0.05);

        const y = d3.scaleLinear()
          .domain([0, d3.max(filteredData, d => d3.max(benchmarks, b => +d[b] || 0)) || 100])
          .range([innerHeight, 0])
          .nice();

        // Grid
        gGrid
          .attr('transform', `translate(0,0)`)
          .call(d3.axisLeft(y).tickSize(-innerWidth).tickFormat(''))
          .call(g => g.select('.domain').remove());

        // Bars
        const groups = gBars.selectAll('g.benchmark-group')
          .data(groupedData, d => d.benchmark);

        const groupsEnter = groups.enter()
          .append('g')
          .attr('class', 'benchmark-group');

        groups.exit().remove();

        const groupsMerge = groupsEnter.merge(groups)
          .attr('transform', d => `translate(${x0(d.benchmark)},0)`);

        const bars = groupsMerge.selectAll('rect.bar')
          .data(d => d.values, d => d.baseModel);

        bars.enter()
          .append('rect')
          .attr('class', 'bar')
          .merge(bars)
          .attr('x', d => x1(d.baseModel))
          .attr('width', x1.bandwidth())
          .attr('fill', d => baseModelColors[d.baseModel])
          .attr('stroke', 'none')
          .transition()
          .duration(200)
          .attr('y', d => y(d.value))
          .attr('height', d => Math.max(0, innerHeight - y(d.value)));

        bars.exit().remove();

        // Hover interactions
        groupsMerge.selectAll('rect.bar')
          .on('mouseenter', function (event, d) {
            const benchmark = d3.select(this.parentNode).datum().benchmark;
            tipInner.innerHTML = `<strong>${d.baseModel}</strong><br/>${benchmark}: <strong>${d.value.toFixed(2)}</strong>`;
            tip.classList.add('visible');
          })
          .on('mousemove', function (event) {
            const [mx, my] = d3.pointer(event, container);
            const offsetX = 10;
            const offsetY = -10;
            tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
          })
          .on('mouseleave', function () {
            tip.classList.remove('visible');
            tip.style.transform = 'translate(-9999px, -9999px)';
          });

        // Axes
        gAxes.selectAll('.x-axis').remove();
        gAxes.selectAll('.y-axis').remove();

        const xAxis = gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(x0).tickSizeOuter(0));

        xAxis.selectAll('text')
          .style('text-anchor', 'middle');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(y).ticks(6).tickSizeOuter(0));

        // Y-axis label
        gAxes.selectAll('.y-label').remove();
        gAxes.append('text')
          .attr('class', 'y-label axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -margin.left + 20)
          .style('text-anchor', 'middle')
          .text('Score (%)');
      }

      // Load data
      fetchFirstAvailable(CSV_PATHS)
        .then(csvText => {
          data = d3.csvParse(csvText);

          // Extract unique base models from data
          uniqueBaseModels = [...new Set(data.map(d => d['Base model']))];
          updateColors();

          makeLegendAndControls();
          render();

          // Resize handling
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.color = 'red';
          pre.style.fontSize = '12px';
          pre.style.padding = '12px';
          pre.textContent = `Error loading data: ${err.message}`;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>The effect of using a mid-trained reasoning model instead of the pre-trained one are dramatic: with extended thinking, we nearly triple the performance on AIME25 and LiveCodeBench v4, while GPQA-D receives a full 10 point gain. Somewhat surprisingly, the reasoning core also translated partially to the  <code>/no_think</code>  reasoning mode, with about 4-6 point improvements on the reasoning benchmarks. These results gave us clear evidence that for reasoning models, it almost always makes sense to perform some amount of mid-training if your base model hasn’t already seen a lot of reasoning data during pre-training.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>When not to mid-train</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Mid-training shines when your model must learn a new, core skill. It’s less useful when the base model already has the skill or if you’re trying to elicit shallow capabilities like style or conversational chit-chat. In these cases, we recommend skipping mid-training and allocating your compute to other methods like preference optimisation or reinforcement learning.</p> </div> </div> </div> 
<p>Once you’re confident in your SFT data mixture and the model’s broad capabilities, the focus naturally shifts from learning skills to refining them. In most cases, the most effective way forward is  <em>preference optimisation.</em></p>
<h3 id="from-sft-to-preference-optimisation-teaching-models-what-better-means"><a href="#from-sft-to-preference-optimisation-teaching-models-what-better-means">From SFT to preference optimisation: teaching models what  <em>better</em>  means</a></h3>
<p>Although you can keep scaling SFT with more data, at some point you’ll observe diminishing gains or failure modes like your model being unable to fix its own buggy code. Why?  Because SFT is a form of  <em>imitation learning</em> , and so the model only learns to reproduce patterns in the data it was trained on. If the data doesn’t already contain good fixes, or if the desired behaviour is hard to elicit with distillation, the model has no clear signal for what counts as “better”.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>The problem persists even if your dataset contains an even mix of traces (i.e. some that reach the correct solution immediately, and others where the model first makes a mistake and corrects it). In this case, the model may simply learn that making an initial error is part of the desired pattern: half the time it should start wrong and then correct itself. What we actually want, of course, is a model that aims to produce the correct solution from the start.</p> </aside> </div>  
<p>This is where preference optimisation comes in. Instead of just copying demonstrations, we give the model comparative feedback like “response A is better than response B”. These preferences provide a more direct training signal for quality and enable to model performance to scale beyond the limits of SFT alone.</p>
<p>Another benefit of preference optimisation is that you typically need far less data than SFT, since the starting point is already a pretty good model that can follow instructions and has knowledge from previous training stages.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>As we’ll see below, there are some algorithms like <a href="https://arxiv.org/abs/2403.07691">ORPO</a> which can be applied directly to base models.</p> </aside> </div>  
<p>Let’s take a look at how these datasets are created.</p>
<h4 id="creating-preference-datasets"><a href="#creating-preference-datasets">Creating preference datasets</a></h4>
<p>Historically, preference datasets were created by providing human annotators with pairs of model responses and asking them to grade which one is better (possibly on a scale). This approach is still used by LLM providers to collect  <em>human preference</em>  labels, but it is extremely expensive and scales poorly. Recently, LLMs have become capable of producing high-quality responses, and often in a cost-effective way. These advances make it practical for LLMs to  <em>generate</em>  preferences for many applications. In practice, there are two common approaches:</p>
<p><strong>Strong vs. weak</strong></p>
<ol>
<li>Take a fixed set of prompts (often curated for coverage and difficulty).</li>
<li>Generate one response from a weaker or baseline model, and another from a stronger or more advanced model.</li>
<li>Label the stronger model’s output as the preferred response.</li>
</ol>
<p>This produces a dataset of “stronger vs. weaker” comparisons, which is simple to construct because we assume the stronger model’s output is reliably better.</p>
<p>Below is a popular example from Intel, which took an SFT dataset with responses from gpt-3.5 and gpt-4 and converted it into a preference dataset by selecting the gpt-4 responses as “chosen” and the gpt-3.5 ones as “rejected”:</p>
<iframe src="https://huggingface.co/datasets/Intel/orca_dpo_pairs/embed/viewer/default/train" frameborder="0" width="100%" height="560px"></iframe>
<p><strong>On-policy with evaluation</strong></p>
<ol>
<li>Use the  <em>same model</em>  you are training to generate multiple candidate responses to the same prompt. This creates data that is “on-policy” because it reflects the distribution of outputs the model would naturally produce.</li>
<li>Instead of relying on a stronger model as the reference, introduce an  <em>external evaluator:</em>  either a verifier or a reward model that scores responses along one or more quality axes (e.g., helpfulness or factual accuracy).</li>
<li>The evaluator then assigns preference labels among the candidate responses, producing a more nuanced and flexible preference dataset.</li>
</ol>
<p>This method allows ongoing bootstrapping of preference data as the model improves, but its quality depends heavily on the evaluator’s reliability and calibration.</p>
<p>A nice example of such a dataset is from SnorkelAI, which took the prompts from a popular preference dataset called UltraFeedback, partitioned them into 3 sets, and then applied the above recipe iteratively to improve their model:</p>
<iframe src="https://huggingface.co/datasets/snorkelai/Snorkel-Mistral-PairRM-DPO-Dataset/embed/viewer/default/train_iteration_1" frameborder="0" width="100%" height="560px"></iframe>
<p>At the time of SmolLM3’s development, there did not exist any preference data with reasoning traces, so we decided to generate some of our own using the “strong vs weak” approach. We used the prompts from Ai2’s Tulu 3 preference mixture to generate responses from Qwen3-0.6B and Qwen3-32B in the  <code>/think</code>  mode. The result was a large-scale dataset of 250k+ LLM-generated preferences, ready to simultaneously improve our SFT checkpoint across multiple axes using preference optimisation algorithms.</p>
<h4 id="which-algorithm-do-i-pick"><a href="#which-algorithm-do-i-pick">Which algorithm do I pick?</a></h4>
<p>Direct Preference Optimization (DPO) <span class="" id="citation--dpo--146">(<a href="https://arxiv.org/abs/2305.18290" id="refctx-bib-dpo-1" data-ref-id="bib-dpo" target="_blank" rel="noopener noreferrer">Rafailov et al., 2024</a>)</span> was the first preference optimisation algorithm to gain widespread adoption in open source.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>When the DPO paper came out in mid-2023, there was widespread debate online about whether it could match RL methods, and there were no recipes showing it’s effectiveness in non-academic settings. To address that, we released <a href="https://huggingface.co/HuggingFaceH4/zephyr-7b-beta">Zephyr 7B</a> a few months later, training the entire model on synthetic data and showing significant performance gains from DPO.</p> </aside> </div>  
<p>Its appeal came from being simple to implement, stable in practice, and effective even with modest amounts of preference data. As a result, DPO has become the default method to improve SFT models before reaching for more complex techniques like RL.</p>
<p>But researchers quickly discovered there are many ways to improve upon DPO, and nowadays there is a wide variety of alternatives to explore. Below we list a few of the ones we’ve found most effective:</p>
<ul>
<li><strong>Kahneman-Tversky Optimisation (KTO) [</strong> <span class="" id="citation--kto--147"><a href="https://arxiv.org/abs/2402.01306" id="refctx-bib-kto-1" data-ref-id="bib-kto" target="_blank" rel="noopener noreferrer">Ethayarajh et al. (2024)</a></span> <strong>]:</strong> Instead of relying on preference pairs, KTO models where an individual response is “desirable or not”, using ideas from human decision making. This is a good choice if you don’t have access to paired preference data (e.g. raw responses collected from end-users).</li>
<li><strong>Odds Ratio Preference Optimisation (ORPO) [</strong> <span class="" id="citation--orpo--148"><a href="https://arxiv.org/abs/2403.07691" id="refctx-bib-orpo-1" data-ref-id="bib-orpo" target="_blank" rel="noopener noreferrer">Hong et al. (2024)</a></span> <strong>]:</strong> integrates preference optimisation directly into SFT by adding an odds ratio to the cross-entropy loss. As a result there is no need for a reference model or SFT stage, which makes this method more computationally efficient.</li>
<li><strong>Anchored Preference Optimisation (APO) [</strong> <span class="" id="citation--apo--149"><a href="https://arxiv.org/abs/2408.06266" id="refctx-bib-apo-1" data-ref-id="bib-apo" target="_blank" rel="noopener noreferrer">D’Oosterlinck et al. (2024)</a></span> <strong>]:</strong> this is a more controllable objective the explicitly regularises how much the model’s likelihoods for chosen vs rejected outputs should shift, rather than just optimising their difference. There are two variants (APO-zero and APO-down) who’s choice depends on the relationship between your model and the preference data (i.e. whether the chosen outputs are better than the model or worse).</li>
</ul>
<p>Luckily, many of these choices are just a one-line change in TRL’s  <code>DPOTrainer</code> , so for our initial baseline we did the following:</p>
<ul>
<li>Use the prompts and completions from Ai2’s <a href="https://huggingface.co/datasets/allenai/tulu-3-pref-personas-instruction-following">Tülu3 Preference Personas IF dataset</a> to measure the improvements for instruction-following on IFEval with the  <code>/no_think</code>  reasoning mode.</li>
<li>Re-use the prompts from the above, but now generate “strong vs. weak” preference pairs with Qwen3-32B and Qwen3-0.6B. This gave us preference data for the  <code>/think</code>  reasoning mode.</li>
<li>Train for 1 epoch and measure the in-domain improvements on IFEval, along with the out-of-domain impact on other evals like AIME25 which are directly correlated with instruction-following.</li>
</ul>
<p>As shown in the figure below, the in-domain improvements for both reasoning modes were significant: on IFEval, APO-zero improved over the SFT checkpoint by 15-20 percentage points!</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-6srw94w5erk"><div class="d3-dpo-ablations"></div>
<style>
  .d3-dpo-ablations {
    width: 100%;
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  }

  .d3-dpo-ablations svg {
    display: block;
    width: 100%;
  }

  .d3-dpo-ablations .bar {
    stroke: none;
  }

  .d3-dpo-ablations .axes path,
  .d3-dpo-ablations .axes line {
    stroke: var(--axis-color, var(--text-color));
  }

  .d3-dpo-ablations .axes text {
    fill: var(--tick-color, var(--muted-color));
    font-size: 11px;
  }

  .d3-dpo-ablations .grid line {
    stroke: var(--grid-color, rgba(0, 0, 0, .08));
  }

  .d3-dpo-ablations .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.35;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, .18);
    opacity: 0;
    transition: opacity .12s ease;
  }

  .d3-dpo-ablations .d3-tooltip__inner {
    text-align: left;
  }

  .d3-dpo-ablations .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    margin-top: 16px;
  }

  .d3-dpo-ablations .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-dpo-ablations .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-dpo-ablations .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-dpo-ablations .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-dpo-ablations .controls {
    display: flex;
    gap: 16px;
    align-items: center;
    justify-content: flex-end;
    flex-wrap: wrap;
    margin-top: 8px;
  }

  .d3-dpo-ablations .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-dpo-ablations .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-dpo-ablations .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
  }

  .d3-dpo-ablations .checkbox-group {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .d3-dpo-ablations .checkbox-group input[type="checkbox"] {
    width: 16px;
    height: 16px;
    cursor: pointer;
  }

  .d3-dpo-ablations .checkbox-group label {
    font-size: 12px;
    color: var(--text-color);
    cursor: pointer;
    font-weight: 400;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-dpo-ablations'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-dpo-ablations'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        tip.style.opacity = '1';
        const [mx, my] = d3.pointer(event, container);
        tip.style.transform = `translate(${mx + 12}px, ${my - 12}px)`;
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // SVG scaffolding
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');

      let width = 800, height = 400;
      const margin = { top: 16, right: 16, bottom: 80, left: 60 };

      // Data loading
      const CSV_PATHS = [
        '/data/smollm3_dpo_ablations.csv',
        './assets/data/smollm3_dpo_ablations.csv',
        '../assets/data/smollm3_dpo_ablations.csv',
        '../../assets/data/smollm3_dpo_ablations.csv'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
          } catch (e) { }
        }
        throw new Error('CSV not found');
      };

      fetchFirstAvailable(CSV_PATHS)
        .then((csvText) => {
          const data = d3.csvParse(csvText);

          // Get unique methods and benchmarks
          const methods = ['SFT', 'DPO', 'IPO', 'APO-zero', 'APO-down', 'DiscoPOP'];
          const benchmarks = ['aime25', 'gpqa_d', 'ifeval', 'lcb_v4'];
          const benchmarkNames = {
            'aime25': 'AIME 2025',
            'gpqa_d': 'GPQA Diamond',
            'ifeval': 'IFEval',
            'lcb_v4': 'LiveCodeBench v4'
          };

          let selectedMode = 'no_think';
          let selectedBenchmark = 'ifeval';
          let showDelta = false;

          // Get colors
          const colors = window.ColorPalettes
            ? window.ColorPalettes.getColors('categorical', methods.length)
            : ['#4e79a7', '#f28e2c', '#e15759', '#76b7b2', '#59a14f', '#edc949'];

          // Create controls
          const controls = document.createElement('div');
          controls.className = 'controls';

          // Reasoning mode select
          const modeGroup = document.createElement('div');
          modeGroup.className = 'control-group';

          const modeLabel = document.createElement('label');
          modeLabel.textContent = 'Reasoning mode';
          modeLabel.setAttribute('for', 'mode-select-' + Date.now());

          const modeSelect = document.createElement('select');
          modeSelect.id = modeLabel.getAttribute('for');

          const thinkOption = document.createElement('option');
          thinkOption.value = 'think';
          thinkOption.textContent = '/think';

          const noThinkOption = document.createElement('option');
          noThinkOption.value = 'no_think';
          noThinkOption.textContent = '/no_think';
          noThinkOption.selected = true;

          modeSelect.appendChild(thinkOption);
          modeSelect.appendChild(noThinkOption);

          modeSelect.addEventListener('change', (e) => {
            selectedMode = e.target.value;
            render();
          });

          modeGroup.appendChild(modeLabel);
          modeGroup.appendChild(modeSelect);

          // Benchmark select
          const benchmarkGroup = document.createElement('div');
          benchmarkGroup.className = 'control-group';

          const benchmarkLabel = document.createElement('label');
          benchmarkLabel.textContent = 'Benchmark';
          benchmarkLabel.setAttribute('for', 'benchmark-select-' + Date.now());

          const benchmarkSelect = document.createElement('select');
          benchmarkSelect.id = benchmarkLabel.getAttribute('for');

          benchmarks.forEach(bench => {
            const option = document.createElement('option');
            option.value = bench;
            option.textContent = benchmarkNames[bench];
            if (bench === 'ifeval') option.selected = true;
            benchmarkSelect.appendChild(option);
          });

          benchmarkSelect.addEventListener('change', (e) => {
            selectedBenchmark = e.target.value;
            render();
          });

          benchmarkGroup.appendChild(benchmarkLabel);
          benchmarkGroup.appendChild(benchmarkSelect);

          // Delta checkbox
          const deltaGroup = document.createElement('div');
          deltaGroup.className = 'control-group';

          const deltaCheckboxGroup = document.createElement('div');
          deltaCheckboxGroup.className = 'checkbox-group';

          const deltaCheckbox = document.createElement('input');
          deltaCheckbox.type = 'checkbox';
          deltaCheckbox.id = 'delta-checkbox-' + Date.now();

          const deltaLabel = document.createElement('label');
          deltaLabel.textContent = 'Show Δ vs SFT';
          deltaLabel.setAttribute('for', deltaCheckbox.id);

          deltaCheckbox.addEventListener('change', (e) => {
            showDelta = e.target.checked;
            render();
          });

          deltaCheckboxGroup.appendChild(deltaCheckbox);
          deltaCheckboxGroup.appendChild(deltaLabel);
          deltaGroup.appendChild(deltaCheckboxGroup);

          controls.appendChild(modeGroup);
          controls.appendChild(benchmarkGroup);
          controls.appendChild(deltaGroup);
          container.appendChild(controls);

          // Create legend
          const legend = document.createElement('div');
          legend.className = 'legend';

          const legendTitle = document.createElement('div');
          legendTitle.className = 'legend-title';
          legendTitle.textContent = 'Legend';

          const legendItems = document.createElement('div');
          legendItems.className = 'items';

          methods.forEach((method, idx) => {
            const item = document.createElement('span');
            item.className = 'item';

            const swatch = document.createElement('span');
            swatch.className = 'swatch';
            swatch.style.background = colors[idx];

            const text = document.createElement('span');
            text.textContent = method;

            item.appendChild(swatch);
            item.appendChild(text);
            legendItems.appendChild(item);
          });

          legend.appendChild(legendTitle);
          legend.appendChild(legendItems);
          container.appendChild(legend);

          function updateSize() {
            width = container.clientWidth || 800;
            height = Math.max(360, Math.round(width / 2.5));
            svg.attr('width', width).attr('height', height);
            gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
            return {
              innerWidth: width - margin.left - margin.right,
              innerHeight: height - margin.top - margin.bottom
            };
          }

          function render() {
            const { innerWidth, innerHeight } = updateSize();

            // Clear previous
            gRoot.selectAll('*').remove();

            // Filter data for selected mode
            const filteredData = data.filter(d => d['reasoning mode'] === selectedMode);

            // Create data for chart
            let chartData = methods.map(method => {
              const row = filteredData.find(d => d.Method === method);
              const absoluteValue = row ? parseFloat(row[selectedBenchmark]) : 0;
              return {
                method,
                absoluteValue,
                value: absoluteValue
              };
            });

            // Get SFT baseline value
            const sftValue = chartData.find(d => d.method === 'SFT').absoluteValue;

            // Calculate delta if checkbox is checked
            if (showDelta) {
              chartData = chartData.map(d => ({
                ...d,
                value: d.method === 'SFT' ? 0 : d.absoluteValue - sftValue
              }));
            }

            // Separate SFT and sort others by descending value
            const sftData = chartData.find(d => d.method === 'SFT');
            const otherData = chartData.filter(d => d.method !== 'SFT')
              .sort((a, b) => b.value - a.value);

            // Recombine with SFT first (unless showing delta)
            chartData = showDelta ? otherData : [sftData, ...otherData];

            // Get ordered methods for color mapping and x-axis
            const orderedMethods = chartData.map(d => d.method);

            // Scales
            const xScale = d3.scaleBand()
              .domain(orderedMethods)
              .range([0, innerWidth])
              .padding(0.3);

            // Set y-axis domain based on whether we're showing delta
            const yMin = showDelta ? Math.min(0, d3.min(chartData, d => d.value)) : 0;
            const yMax = showDelta
              ? Math.max(Math.abs(yMin), d3.max(chartData, d => d.value)) * 1.1
              : d3.max(chartData, d => d.value) * 1.1;

            const yScale = d3.scaleLinear()
              .domain(showDelta ? [yMin * 1.1, yMax] : [0, yMax])
              .range([innerHeight, 0])
              .nice();

            // Grid
            gRoot.append('g')
              .attr('class', 'grid')
              .call(
                d3.axisLeft(yScale)
                  .ticks(6)
                  .tickSize(-innerWidth)
                  .tickFormat('')
              )
              .call(g => g.select('.domain').remove());

            // Create color map based on original method order
            const colorMap = {};
            methods.forEach((method, idx) => {
              colorMap[method] = colors[idx];
            });

            // Add zero line if showing delta
            if (showDelta) {
              gRoot.append('line')
                .attr('x1', 0)
                .attr('x2', innerWidth)
                .attr('y1', yScale(0))
                .attr('y2', yScale(0))
                .attr('stroke', 'var(--text-color)')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '4,4')
                .attr('opacity', 0.5);
            }

            // Bars
            gRoot.selectAll('rect.bar')
              .data(chartData)
              .join('rect')
              .attr('class', 'bar')
              .attr('x', d => xScale(d.method))
              .attr('y', d => d.value >= 0 ? yScale(d.value) : yScale(0))
              .attr('width', xScale.bandwidth())
              .attr('height', d => Math.abs(yScale(d.value) - yScale(0)))
              .attr('fill', d => colorMap[d.method])
              .attr('opacity', 0.85)
              .on('mouseenter', (event, d) => {
                const deltaText = showDelta && d.method !== 'SFT'
                  ? `Δ: ${d.value >= 0 ? '+' : ''}${d.value.toFixed(2)}%`
                  : '';
                const absoluteText = `${benchmarkNames[selectedBenchmark]}: ${d.absoluteValue.toFixed(2)}%`;
                const html = `<strong>${d.method}</strong><br/>${absoluteText}${deltaText ? '<br/>' + deltaText : ''}`;
                showTooltip(html, event);
              })
              .on('mouseleave', hideTooltip);

            // X axis
            const xAxis = gRoot.append('g')
              .attr('class', 'axes')
              .attr('transform', `translate(0,${innerHeight})`)
              .call(d3.axisBottom(xScale));

            xAxis.select('.domain').remove();

            xAxis.selectAll('text')
              .style('text-anchor', 'middle');

            // Y axis
            const yAxis = gRoot.append('g')
              .attr('class', 'axes')
              .call(d3.axisLeft(yScale).ticks(6));

            yAxis.select('.domain').remove();

            // Y axis label
            gRoot.append('text')
              .attr('class', 'axes')
              .attr('transform', 'rotate(-90)')
              .attr('x', -innerHeight / 2)
              .attr('y', -45)
              .attr('text-anchor', 'middle')
              .style('font-size', '12px')
              .style('fill', 'var(--text-color)')
              .text(showDelta ? 'Δ Score vs SFT (%)' : 'Score (%)');
          }

          render();

          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch((err) => {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + err.message;
          pre.style.cssText = 'color:red;font-size:12px;padding:12px;margin:0;';
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>Since APO-zero also had the best overall out-of-domain performance, we settled on using it for the remainder of our ablations.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📍</span> <div class="note__title" data-astro-cid-qg6lmfty>Preference optimisation works for reasoning</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>As our results above show, preference optimisation doesn’t just make models more helpful or aligned, it teaches them to  <em>reason better</em> . If you need a quick way to improve your reasoning model, try generating strong-vs-weak preferences and ablate different loss functions: you may find significant gains over vanilla DPO!</p> </div> </div> </div> 
<h4 id="which-hyperparameters-matter-most-for-preference-optimisation"><a href="#which-hyperparameters-matter-most-for-preference-optimisation">Which hyperparameters matter most for preference optimisation?</a></h4>
<p>For preference optimisation, there are typically only three hyperparameters that impact the training dynamics:</p>
<ul>
<li>The learning rate, typically a factor of 10-100x smaller than the one used for SFT.</li>
<li>The β parameter, which typically controls the size of the margin between preference pairs.</li>
<li>The batch size.</li>
</ul>
<p>Let’s take a look at how these played out for SmolLM3, starting from the <a href="https://huggingface.co/HuggingFaceTB/SmolLM3-3B-checkpoints/tree/it-SFT"> <code>it-SFT</code> </a><a href="https://huggingface.co/HuggingFaceTB/SmolLM3-3B-checkpoints/tree/it-SFT"> checkpoint</a> we trained over the whole of  <code>smoltalk2</code> .</p>
<p><strong>Learning curves</strong></p>
<p>The first ablation we ran was to check the influence of the learning rate on model performance. We first ran experiments to determine the influence of learning rates between ~200x smaller (1e-7) and ~2x smaller (1e-5) than the SFT learning rate (2e-5). Previous projects like Zephyr 7B had taught us that the best learning rate for PO is around 10x smaller than the one used for SFT, and the ablations we ran for SmolLM3 confirmed this rule of thumb.</p>
<p>As shown in the figure below, learning rates ~10x smaller improve the performance of the SFT model in both reasoning modes, but all learning rates beyond that 10x limit result in worse performance for the extended thinking mode. The trend for the mode without extended thinking is more stable, with the best learning rate at 5e-6. This is mostly driven by a single benchmark (LiveCodeBench v4), so we opted for 1e-6 in our SmolLM3 runs.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-zeyk0ppiri"><div class="d3-apo-lr-ablation"></div>
<style>
  .d3-apo-lr-ablation {
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    position: relative;
    --axis-color: var(--text-color, #333);
    --tick-color: var(--muted-color, #666);
    --grid-color: rgba(0,0,0,.08);
  }
  [data-theme="dark"] .d3-apo-lr-ablation {
    --axis-color: var(--text-color, #ccc);
    --tick-color: var(--muted-color, #999);
    --grid-color: rgba(255,255,255,.10);
  }
  .d3-apo-lr-ablation svg {
    display: block;
    overflow: visible;
  }
  .d3-apo-lr-ablation .axes path,
  .d3-apo-lr-ablation .axes line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }
  .d3-apo-lr-ablation .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }
  .d3-apo-lr-ablation .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2,2;
    shape-rendering: crispEdges;
  }
  .d3-apo-lr-ablation .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }
  .d3-apo-lr-ablation .line-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .d3-apo-lr-ablation .line-no-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .d3-apo-lr-ablation .reference-line {
    fill: none;
    stroke-width: 1.5;
    stroke-dasharray: 5, 5;
    opacity: 0.4;
  }
  .d3-apo-lr-ablation .dot {
    stroke: var(--surface-bg);
    stroke-width: 2;
  }
  .d3-apo-lr-ablation .header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 16px;
    margin-top: 16px;
    flex-wrap: wrap;
  }
  .d3-apo-lr-ablation .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }
  .d3-apo-lr-ablation .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }
  .d3-apo-lr-ablation .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }
  .d3-apo-lr-ablation .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }
  .d3-apo-lr-ablation .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }
  .d3-apo-lr-ablation .legend .swatch-line {
    width: 20px;
    height: 2px;
    border: none;
  }
  .d3-apo-lr-ablation .legend .swatch-dashed {
    width: 20px;
    height: 2px;
    border: none;
    background: repeating-linear-gradient(
      to right,
      var(--text-color) 0,
      var(--text-color) 4px,
      transparent 4px,
      transparent 8px
    );
  }
  .d3-apo-lr-ablation .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: flex-end;
    flex-wrap: wrap;
  }
  .d3-apo-lr-ablation .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }
  .d3-apo-lr-ablation .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }
  .d3-apo-lr-ablation .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
  }
  .d3-apo-lr-ablation .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }
  .d3-apo-lr-ablation .d3-tooltip {
    position: absolute;
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    font-size: 12px;
    z-index: 1000;
  }
  .d3-apo-lr-ablation .tooltip-title {
    font-weight: 700;
    margin-bottom: 8px;
    color: var(--text-color);
  }
  .d3-apo-lr-ablation .tooltip-item {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 4px 0;
    color: var(--text-color);
  }
  .d3-apo-lr-ablation .tooltip-color {
    width: 12px;
    height: 12px;
    border-radius: 2px;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-apo-lr-ablation'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-apo-lr-ablation'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Data embedded inline
      const data = [{"Learning rate":0.00001,"system_prompt":"/think","Evaluation":"AIME25","Score":29.9},{"Learning rate":0.00001,"system_prompt":"/no_think","Evaluation":"AIME25","Score":4.9},{"Learning rate":0.000005,"system_prompt":"/think","Evaluation":"AIME25","Score":36.46},{"Learning rate":0.000001,"system_prompt":"/think","Evaluation":"AIME25","Score":45.47},{"Learning rate":0.000001,"system_prompt":"/no_think","Evaluation":"AIME25","Score":7.92},{"Learning rate":0.0000005,"system_prompt":"/think","Evaluation":"AIME25","Score":48.7},{"Learning rate":0.0000005,"system_prompt":"/no_think","Evaluation":"AIME25","Score":7.5},{"Learning rate":0.0000001,"system_prompt":"/think","Evaluation":"AIME25","Score":48.59},{"Learning rate":0.0000001,"system_prompt":"/no_think","Evaluation":"AIME25","Score":9.27},{"Learning rate":0.00001,"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":34.28},{"Learning rate":0.00001,"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":26.64},{"Learning rate":0.000005,"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":36.93},{"Learning rate":0.000005,"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":29.04},{"Learning rate":0.000001,"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":42.49},{"Learning rate":0.000001,"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":32.58},{"Learning rate":0.0000005,"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":44.7},{"Learning rate":0.0000005,"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":32.77},{"Learning rate":0.0000001,"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":44.44},{"Learning rate":0.0000001,"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":32.2},{"Learning rate":0.00001,"system_prompt":"/think","Evaluation":"IF-Eval","Score":69.72},{"Learning rate":0.00001,"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":70.86},{"Learning rate":0.000005,"system_prompt":"/think","Evaluation":"IF-Eval","Score":70.97},{"Learning rate":0.000005,"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":75.46},{"Learning rate":0.000001,"system_prompt":"/think","Evaluation":"IF-Eval","Score":69.88},{"Learning rate":0.000001,"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":74.46},{"Learning rate":0.0000005,"system_prompt":"/think","Evaluation":"IF-Eval","Score":72.61},{"Learning rate":0.0000005,"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":77.13},{"Learning rate":0.0000001,"system_prompt":"/think","Evaluation":"IF-Eval","Score":73.86},{"Learning rate":0.0000001,"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":77.0},{"Learning rate":0.00001,"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":13.86},{"Learning rate":0.00001,"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":11.88},{"Learning rate":0.000005,"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":21.78},{"Learning rate":0.000005,"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":16.83},{"Learning rate":0.000001,"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":23.76},{"Learning rate":0.000001,"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":13.86},{"Learning rate":0.0000005,"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":25.74},{"Learning rate":0.0000005,"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":12.87},{"Learning rate":0.0000001,"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":31.68},{"Learning rate":0.0000001,"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":11.88},{"Learning rate":0.00001,"system_prompt":"/think","Evaluation":"Average","Score":36.94},{"Learning rate":0.00001,"system_prompt":"/no_think","Evaluation":"Average","Score":28.57},{"Learning rate":0.000005,"system_prompt":"/think","Evaluation":"Average","Score":41.535},{"Learning rate":0.000005,"system_prompt":"/no_think","Evaluation":"Average","Score":40.4433333333},{"Learning rate":0.000001,"system_prompt":"/think","Evaluation":"Average","Score":45.4},{"Learning rate":0.000001,"system_prompt":"/no_think","Evaluation":"Average","Score":32.205},{"Learning rate":0.0000005,"system_prompt":"/think","Evaluation":"Average","Score":47.9375},{"Learning rate":0.0000005,"system_prompt":"/no_think","Evaluation":"Average","Score":32.5675},{"Learning rate":0.0000001,"system_prompt":"/think","Evaluation":"Average","Score":49.6425},{"Learning rate":0.0000001,"system_prompt":"/no_think","Evaluation":"Average","Score":32.5875}];
      const sftData = [{"system_prompt":"/think","Evaluation":"AIME25","Score":36.56},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":4.01},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":42.23},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":30.43},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":70.03},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":67.29},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":36.63},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":12.87},{"system_prompt":"/think","Evaluation":"Average","Score":46.3625},{"system_prompt":"/no_think","Evaluation":"Average","Score":28.65}];

      // Get colors from ColorPalettes or fallback
      const getColors = () => {
        if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
          const colors = window.ColorPalettes.getColors('categorical', 2);
          return { think: colors[0], noThink: colors[1] };
        }
        return { think: '#E377C2', noThink: '#7FC97F' };
      };

      let colors = getColors();

      // Set up dimensions
      const margin = { top: 16, right: 28, bottom: 56, left: 64 };

      // Create SVG
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const g = svg.append('g');

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease',
          zIndex: '1000'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        const [mx, my] = d3.pointer(event, container);
        const offsetX = 12, offsetY = 12;
        tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
        tip.style.opacity = '1';
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // Get unique evaluations
      const evaluations = [...new Set(data.map(d => d.Evaluation))];

      // Create header with legend and controls
      const header = d3.select(container).append('div').attr('class', 'header');

      const legend = header.append('div').attr('class', 'legend');
      legend.append('div').attr('class', 'legend-title').text('Legend');
      const legendItems = legend.append('div').attr('class', 'items');

      const controls = header.append('div').attr('class', 'controls');
      const controlGroup = controls.append('div').attr('class', 'control-group');
      controlGroup.append('label').attr('for', 'metric-select-lr').text('Metric');
      const select = controlGroup.append('select').attr('id', 'metric-select-lr');

      // Populate dropdown
      select.selectAll('option')
        .data(evaluations)
        .enter()
        .append('option')
        .text(d => d)
        .attr('value', d => d);

      // Build legend
      const buildLegend = () => {
        legendItems.html('');

        const thinkItem = legendItems.append('span').attr('class', 'item');
        thinkItem.append('span').attr('class', 'swatch-line').style('background', colors.think);
        thinkItem.append('span').text('/think');

        const noThinkItem = legendItems.append('span').attr('class', 'item');
        noThinkItem.append('span').attr('class', 'swatch-line').style('background', colors.noThink);
        noThinkItem.append('span').text('/no_think');

        const sftItem = legendItems.append('span').attr('class', 'item');
        sftItem.append('span').attr('class', 'swatch-dashed');
        sftItem.append('span').text('SFT checkpoint');
      };

      buildLegend();

      // Update chart function
      function updateChart(evaluation) {
        const filtered = data.filter(d => d.Evaluation === evaluation);
        const thinkData = filtered.filter(d => d.system_prompt === "/think").sort((a, b) => a["Learning rate"] - b["Learning rate"]);
        const noThinkData = filtered.filter(d => d.system_prompt === "/no_think").sort((a, b) => a["Learning rate"] - b["Learning rate"]);

        g.selectAll("*").remove();

        const sftThink = sftData.find(d => d.Evaluation === evaluation && d.system_prompt === "/think");
        const sftNoThink = sftData.find(d => d.Evaluation === evaluation && d.system_prompt === "/no_think");

        const width = container.clientWidth || 800;
        const height = Math.max(320, Math.round(width / 2.5));
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        svg.attr('width', width).attr('height', height);
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Scales
        const xScale = d3.scaleLog()
          .domain([d3.min(filtered, d => d["Learning rate"]), d3.max(filtered, d => d["Learning rate"])])
          .range([0, innerWidth]);

        const allScores = filtered.map(d => d.Score);
        if (sftThink) allScores.push(sftThink.Score);
        if (sftNoThink) allScores.push(sftNoThink.Score);
        const maxScore = d3.max(allScores);

        const yScale = d3.scaleLinear()
          .domain([0, maxScore * 1.1])
          .range([innerHeight, 0]);

        // Grid
        g.append("g")
          .attr("class", "grid")
          .attr("transform", `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickSize(-innerHeight).tickFormat("").tickSizeOuter(0));

        g.append("g")
          .attr("class", "grid")
          .call(d3.axisLeft(yScale).tickSize(-innerWidth).tickFormat("").tickSizeOuter(0));

        // Axes
        const tickValues = [1e-7, 5e-7, 1e-6, 5e-6, 1e-5];
        g.append("g")
          .attr("class", "axes")
          .attr("transform", `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(tickValues).tickFormat(d3.format(".0e")).tickSizeOuter(0))
          .call(gAxis => {
            gAxis.selectAll(".tick line").attr("stroke", "var(--axis-color)").style("opacity", 1);
            gAxis.selectAll(".tick text").attr("fill", "var(--tick-color)").style("opacity", 1);
            gAxis.select(".domain").attr("stroke", "var(--axis-color)");
          });

        g.append("g")
          .attr("class", "axes")
          .call(d3.axisLeft(yScale).ticks(6).tickSizeOuter(0))
          .call(gAxis => {
            gAxis.selectAll(".tick line").attr("stroke", "var(--axis-color)").style("opacity", 1);
            gAxis.selectAll(".tick text").attr("fill", "var(--tick-color)").style("opacity", 1);
            gAxis.select(".domain").attr("stroke", "var(--axis-color)");
          });

        // Axis labels
        g.append("text")
          .attr("class", "axis-label")
          .attr("text-anchor", "middle")
          .attr("x", innerWidth / 2)
          .attr("y", innerHeight + 40)
          .text("Learning rate");

        g.append("text")
          .attr("class", "axis-label")
          .attr("text-anchor", "middle")
          .attr("transform", "rotate(-90)")
          .attr("y", -45)
          .attr("x", -innerHeight / 2)
          .text("Score (%)");

        // Line generator
        const line = d3.line()
          .x(d => xScale(d["Learning rate"]))
          .y(d => yScale(d.Score));

        // Reference lines
        if (sftThink) {
          g.append("line")
            .attr("class", "reference-line")
            .style("stroke", colors.think)
            .attr("x1", 0)
            .attr("x2", innerWidth)
            .attr("y1", yScale(sftThink.Score))
            .attr("y2", yScale(sftThink.Score));
        }

        if (sftNoThink) {
          g.append("line")
            .attr("class", "reference-line")
            .style("stroke", colors.noThink)
            .attr("x1", 0)
            .attr("x2", innerWidth)
            .attr("y1", yScale(sftNoThink.Score))
            .attr("y2", yScale(sftNoThink.Score));
        }

        // Lines
        g.append("path")
          .datum(thinkData)
          .attr("class", "line-think")
          .style("stroke", colors.think)
          .attr("d", line);

        g.append("path")
          .datum(noThinkData)
          .attr("class", "line-no-think")
          .style("stroke", colors.noThink)
          .attr("d", line);

        // Dots for /think
        g.selectAll(".dot-think")
          .data(thinkData)
          .enter()
          .append("circle")
          .attr("class", "dot")
          .style("fill", colors.think)
          .attr("cx", d => xScale(d["Learning rate"]))
          .attr("cy", d => yScale(d.Score))
          .attr("r", 4)
          .on("mouseenter", function(event, d) {
            const noThinkValue = noThinkData.find(item => item["Learning rate"] === d["Learning rate"]);
            const html = `
              <div class="tooltip-title">LR ${d["Learning rate"].toExponential(0)}</div>
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.think};"></div>
                <span>/think: ${d.Score.toFixed(2)}%</span>
              </div>
              ${noThinkValue ? `
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.noThink};"></div>
                <span>/no_think: ${noThinkValue.Score.toFixed(2)}%</span>
              </div>` : ''}
            `;
            showTooltip(html, event);
          })
          .on("mouseleave", hideTooltip);

        // Dots for /no_think
        g.selectAll(".dot-no-think")
          .data(noThinkData)
          .enter()
          .append("circle")
          .attr("class", "dot")
          .style("fill", colors.noThink)
          .attr("cx", d => xScale(d["Learning rate"]))
          .attr("cy", d => yScale(d.Score))
          .attr("r", 4)
          .on("mouseenter", function(event, d) {
            const thinkValue = thinkData.find(item => item["Learning rate"] === d["Learning rate"]);
            const html = `
              <div class="tooltip-title">LR ${d["Learning rate"].toExponential(0)}</div>
              ${thinkValue ? `
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.think};"></div>
                <span>/think: ${thinkValue.Score.toFixed(2)}%</span>
              </div>` : ''}
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.noThink};"></div>
                <span>/no_think: ${d.Score.toFixed(2)}%</span>
              </div>
            `;
            showTooltip(html, event);
          })
          .on("mouseleave", hideTooltip);
      }

      // Set default value to "Average" if it exists
      const defaultEval = evaluations.includes("Average") ? "Average" : evaluations[0];
      select.property("value", defaultEval);

      // Initial chart
      updateChart(defaultEval);

      // Update on dropdown change
      select.on("change", function() {
        updateChart(this.value);
      });

      // Resize handling
      const rerender = () => updateChart(select.property("value"));
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => rerender());
        ro.observe(container);
      } else {
        window.addEventListener('resize', rerender);
      }

      // Listen for ColorPalettes changes
      if (window.ColorPalettes && typeof window.ColorPalettes.addListener === 'function') {
        window.ColorPalettes.addListener(() => {
          colors = getColors();
          buildLegend();
          updateChart(select.property("value"));
        });
      }
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div></figure>
<p>Our recommendation for your training runs is to run scans of your learning rate at a range of 5x to 20x smaller than your SFT learning rate. It is highly likely that you will find your optimal performance within that range!</p>
<p><strong>Tuning β</strong></p>
<p>The experiments we ran for the ß parameter ranged from 0.01 to 0.99 to explore values that encourage different degrees of alignment to the reference model. As a reminder, lower values of beta encourage staying close to the reference model while higher values allow the PO model to match the preference data more closely. The model performance for ß=0.1 is the highest for both reasoning modes and improves compared to the metrics from the SFT checkpoint. Using a low beta value hurts model performance and results in a worse model than the SFT checkpoint, while performance remains stable across multiple ß values without extended thinking.</p>
<p>These results suggest that values greater than 0.1 are preferable for preference optimisation, and that aligning the model with the preference data is more beneficial than staying close to the reference model. However, we suggest exploring ß values in the range 0.01 and 0.5. Higher values may erase capabilities from the SFT checkpoint that we might not be capturing in the evals shown on the plot.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-o7tlujslzg"><div class="d3-apo-beta-ablation"></div>
<style>
  .d3-apo-beta-ablation {
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    position: relative;
    --axis-color: var(--text-color, #333);
    --tick-color: var(--muted-color, #666);
    --grid-color: rgba(0,0,0,.08);
  }
  [data-theme="dark"] .d3-apo-beta-ablation {
    --axis-color: var(--text-color, #ccc);
    --tick-color: var(--muted-color, #999);
    --grid-color: rgba(255,255,255,.10);
  }
  .d3-apo-beta-ablation svg {
    display: block;
    overflow: visible;
  }
  .d3-apo-beta-ablation .axes path,
  .d3-apo-beta-ablation .axes line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }
  .d3-apo-beta-ablation .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }
  .d3-apo-beta-ablation .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2,2;
    shape-rendering: crispEdges;
  }
  .d3-apo-beta-ablation .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }
  .d3-apo-beta-ablation .line-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .d3-apo-beta-ablation .line-no-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .d3-apo-beta-ablation .reference-line {
    fill: none;
    stroke-width: 1.5;
    stroke-dasharray: 5, 5;
    opacity: 0.4;
  }
  .d3-apo-beta-ablation .dot {
    stroke: var(--surface-bg);
    stroke-width: 2;
  }
  .d3-apo-beta-ablation .header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 16px;
    margin-top: 16px;
    flex-wrap: wrap;
  }
  .d3-apo-beta-ablation .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }
  .d3-apo-beta-ablation .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }
  .d3-apo-beta-ablation .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }
  .d3-apo-beta-ablation .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }
  .d3-apo-beta-ablation .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }
  .d3-apo-beta-ablation .legend .swatch-line {
    width: 20px;
    height: 2px;
    border: none;
  }
  .d3-apo-beta-ablation .legend .swatch-dashed {
    width: 20px;
    height: 2px;
    border: none;
    background: repeating-linear-gradient(
      to right,
      var(--text-color) 0,
      var(--text-color) 4px,
      transparent 4px,
      transparent 8px
    );
  }
  .d3-apo-beta-ablation .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: flex-end;
    flex-wrap: wrap;
  }
  .d3-apo-beta-ablation .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }
  .d3-apo-beta-ablation .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }
  .d3-apo-beta-ablation .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
  }
  .d3-apo-beta-ablation .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }
  .d3-apo-beta-ablation .d3-tooltip {
    position: absolute;
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    font-size: 12px;
    z-index: 1000;
  }
  .d3-apo-beta-ablation .tooltip-title {
    font-weight: 700;
    margin-bottom: 8px;
    color: var(--text-color);
  }
  .d3-apo-beta-ablation .tooltip-item {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 4px 0;
    color: var(--text-color);
  }
  .d3-apo-beta-ablation .tooltip-color {
    width: 12px;
    height: 12px;
    border-radius: 2px;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-apo-beta-ablation'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-apo-beta-ablation'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Data embedded inline
      const data = [{"system_prompt":"/think","Evaluation":"AIME25","Score":45.47,"Beta":0.05},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":7.92,"Beta":0.05},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":42.49,"Beta":0.05},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":32.58,"Beta":0.05},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":69.88,"Beta":0.05},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":74.46,"Beta":0.05},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":23.76,"Beta":0.05},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":13.86,"Beta":0.05},{"system_prompt":"/think","Evaluation":"Average","Score":45.4,"Beta":0.05},{"system_prompt":"/no_think","Evaluation":"Average","Score":32.205,"Beta":0.05},{"system_prompt":"/think","Evaluation":"AIME25","Score":43.28,"Beta":0.01},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":6.77,"Beta":0.01},{"system_prompt":"/think","Evaluation":"AIME25","Score":46.82,"Beta":0.1},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":8.02,"Beta":0.1},{"system_prompt":"/think","Evaluation":"AIME25","Score":44.95,"Beta":0.2},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":7.6,"Beta":0.2},{"system_prompt":"/think","Evaluation":"AIME25","Score":47.45,"Beta":0.5},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":7.29,"Beta":0.5},{"system_prompt":"/think","Evaluation":"AIME25","Score":47.45,"Beta":0.75},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":7.29,"Beta":0.75},{"system_prompt":"/think","Evaluation":"AIME25","Score":45.36,"Beta":0.99},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":8.8,"Beta":0.99},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":39.77,"Beta":0.01},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":32.95,"Beta":0.01},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":44.38,"Beta":0.1},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":33.27,"Beta":0.1},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":42.05,"Beta":0.2},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":31.57,"Beta":0.2},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":41.54,"Beta":0.5},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":31.63,"Beta":0.5},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":41.54,"Beta":0.75},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":31.63,"Beta":0.75},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":42.36,"Beta":0.99},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":30.43,"Beta":0.99},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":69.04,"Beta":0.01},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":77.02,"Beta":0.01},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":71.47,"Beta":0.1},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":75.36,"Beta":0.1},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":71.55,"Beta":0.2},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":75.33,"Beta":0.2},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":73.58,"Beta":0.5},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":75.91,"Beta":0.5},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":73.58,"Beta":0.75},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":75.91,"Beta":0.75},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":69.13,"Beta":0.99},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":75.41,"Beta":0.99},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":12.87,"Beta":0.01},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":10.89,"Beta":0.01},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":29.7,"Beta":0.1},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":16.83,"Beta":0.1},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":26.73,"Beta":0.2},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":16.83,"Beta":0.2},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":28.71,"Beta":0.5},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":11.88,"Beta":0.5},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":28.71,"Beta":0.75},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":11.88,"Beta":0.75},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":34.65,"Beta":0.99},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":19.8,"Beta":0.99},{"system_prompt":"/think","Evaluation":"Average","Score":41.24,"Beta":0.01},{"system_prompt":"/no_think","Evaluation":"Average","Score":31.9075,"Beta":0.01},{"system_prompt":"/think","Evaluation":"Average","Score":48.0925,"Beta":0.1},{"system_prompt":"/no_think","Evaluation":"Average","Score":33.37,"Beta":0.1},{"system_prompt":"/think","Evaluation":"Average","Score":46.32,"Beta":0.2},{"system_prompt":"/no_think","Evaluation":"Average","Score":32.8325,"Beta":0.2},{"system_prompt":"/think","Evaluation":"Average","Score":47.82,"Beta":0.5},{"system_prompt":"/no_think","Evaluation":"Average","Score":31.6775,"Beta":0.5},{"system_prompt":"/think","Evaluation":"Average","Score":47.82,"Beta":0.75},{"system_prompt":"/no_think","Evaluation":"Average","Score":31.6775,"Beta":0.75},{"system_prompt":"/think","Evaluation":"Average","Score":47.875,"Beta":0.99},{"system_prompt":"/no_think","Evaluation":"Average","Score":33.61,"Beta":0.99}];
      const sftData = [{"system_prompt":"/think","Evaluation":"AIME25","Score":36.56},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":4.01},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":42.23},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":30.43},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":70.03},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":67.29},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":36.63},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":12.87},{"system_prompt":"/think","Evaluation":"Average","Score":46.3625},{"system_prompt":"/no_think","Evaluation":"Average","Score":28.65}];

      // Get colors from ColorPalettes or fallback
      const getColors = () => {
        if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
          const colors = window.ColorPalettes.getColors('categorical', 2);
          return { think: colors[0], noThink: colors[1] };
        }
        return { think: '#E377C2', noThink: '#7FC97F' };
      };

      let colors = getColors();

      // Set up dimensions
      const margin = { top: 16, right: 28, bottom: 56, left: 64 };

      // Create SVG
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const g = svg.append('g');

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease',
          zIndex: '1000'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        const [mx, my] = d3.pointer(event, container);
        const offsetX = 12, offsetY = 12;
        tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
        tip.style.opacity = '1';
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // Get unique evaluations
      const evaluations = [...new Set(data.map(d => d.Evaluation))];

      // Create header with legend and controls
      const header = d3.select(container).append('div').attr('class', 'header');

      const legend = header.append('div').attr('class', 'legend');
      legend.append('div').attr('class', 'legend-title').text('Legend');
      const legendItems = legend.append('div').attr('class', 'items');

      const controls = header.append('div').attr('class', 'controls');
      const controlGroup = controls.append('div').attr('class', 'control-group');
      controlGroup.append('label').attr('for', 'metric-select-beta').text('Metric');
      const select = controlGroup.append('select').attr('id', 'metric-select-beta');

      // Populate dropdown
      select.selectAll('option')
        .data(evaluations)
        .enter()
        .append('option')
        .text(d => d)
        .attr('value', d => d);

      // Build legend
      const buildLegend = () => {
        legendItems.html('');

        const thinkItem = legendItems.append('span').attr('class', 'item');
        thinkItem.append('span').attr('class', 'swatch-line').style('background', colors.think);
        thinkItem.append('span').text('/think');

        const noThinkItem = legendItems.append('span').attr('class', 'item');
        noThinkItem.append('span').attr('class', 'swatch-line').style('background', colors.noThink);
        noThinkItem.append('span').text('/no_think');

        const sftItem = legendItems.append('span').attr('class', 'item');
        sftItem.append('span').attr('class', 'swatch-dashed');
        sftItem.append('span').text('SFT checkpoint');
      };

      buildLegend();

      // Update chart function
      function updateChart(evaluation) {
        const filtered = data.filter(d => d.Evaluation === evaluation);
        const thinkData = filtered.filter(d => d.system_prompt === "/think").sort((a, b) => a.Beta - b.Beta);
        const noThinkData = filtered.filter(d => d.system_prompt === "/no_think").sort((a, b) => a.Beta - b.Beta);

        g.selectAll("*").remove();

        const sftThink = sftData.find(d => d.Evaluation === evaluation && d.system_prompt === "/think");
        const sftNoThink = sftData.find(d => d.Evaluation === evaluation && d.system_prompt === "/no_think");

        const width = container.clientWidth || 800;
        const height = Math.max(320, Math.round(width / 2.5));
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        svg.attr('width', width).attr('height', height);
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Scales
        const xScale = d3.scaleLog()
          .domain([d3.min(filtered, d => d.Beta), d3.max(filtered, d => d.Beta)])
          .range([0, innerWidth]);

        const allScores = filtered.map(d => d.Score);
        if (sftThink) allScores.push(sftThink.Score);
        if (sftNoThink) allScores.push(sftNoThink.Score);
        const maxScore = d3.max(allScores);

        const yScale = d3.scaleLinear()
          .domain([0, maxScore * 1.1])
          .range([innerHeight, 0]);

        // Grid
        g.append("g")
          .attr("class", "grid")
          .attr("transform", `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickSize(-innerHeight).tickFormat("").tickSizeOuter(0));

        g.append("g")
          .attr("class", "grid")
          .call(d3.axisLeft(yScale).tickSize(-innerWidth).tickFormat("").tickSizeOuter(0));

        // Axes
        const tickValues = [0.01, 0.05, 0.1, 0.5, 1.0];
        g.append("g")
          .attr("class", "axes")
          .attr("transform", `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(tickValues).tickFormat(d3.format(".2f")).tickSizeOuter(0))
          .call(gAxis => {
            gAxis.selectAll(".tick line").attr("stroke", "var(--axis-color)").style("opacity", 1);
            gAxis.selectAll(".tick text").attr("fill", "var(--tick-color)").style("opacity", 1);
            gAxis.select(".domain").attr("stroke", "var(--axis-color)");
          });

        g.append("g")
          .attr("class", "axes")
          .call(d3.axisLeft(yScale).ticks(6).tickSizeOuter(0))
          .call(gAxis => {
            gAxis.selectAll(".tick line").attr("stroke", "var(--axis-color)").style("opacity", 1);
            gAxis.selectAll(".tick text").attr("fill", "var(--tick-color)").style("opacity", 1);
            gAxis.select(".domain").attr("stroke", "var(--axis-color)");
          });

        // Axis labels
        g.append("text")
          .attr("class", "axis-label")
          .attr("text-anchor", "middle")
          .attr("x", innerWidth / 2)
          .attr("y", innerHeight + 40)
          .text("Beta");

        g.append("text")
          .attr("class", "axis-label")
          .attr("text-anchor", "middle")
          .attr("transform", "rotate(-90)")
          .attr("y", -45)
          .attr("x", -innerHeight / 2)
          .text("Score (%)");

        // Line generator
        const line = d3.line()
          .x(d => xScale(d.Beta))
          .y(d => yScale(d.Score));

        // Reference lines
        if (sftThink) {
          g.append("line")
            .attr("class", "reference-line")
            .style("stroke", colors.think)
            .attr("x1", 0)
            .attr("x2", innerWidth)
            .attr("y1", yScale(sftThink.Score))
            .attr("y2", yScale(sftThink.Score));
        }

        if (sftNoThink) {
          g.append("line")
            .attr("class", "reference-line")
            .style("stroke", colors.noThink)
            .attr("x1", 0)
            .attr("x2", innerWidth)
            .attr("y1", yScale(sftNoThink.Score))
            .attr("y2", yScale(sftNoThink.Score));
        }

        // Lines
        g.append("path")
          .datum(thinkData)
          .attr("class", "line-think")
          .style("stroke", colors.think)
          .attr("d", line);

        g.append("path")
          .datum(noThinkData)
          .attr("class", "line-no-think")
          .style("stroke", colors.noThink)
          .attr("d", line);

        // Dots for /think
        g.selectAll(".dot-think")
          .data(thinkData)
          .enter()
          .append("circle")
          .attr("class", "dot")
          .style("fill", colors.think)
          .attr("cx", d => xScale(d.Beta))
          .attr("cy", d => yScale(d.Score))
          .attr("r", 4)
          .on("mouseenter", function(event, d) {
            const noThinkValue = noThinkData.find(item => item.Beta === d.Beta);
            const html = `
              <div class="tooltip-title">Beta ${d.Beta.toFixed(2)}</div>
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.think};"></div>
                <span>/think: ${d.Score.toFixed(2)}%</span>
              </div>
              ${noThinkValue ? `
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.noThink};"></div>
                <span>/no_think: ${noThinkValue.Score.toFixed(2)}%</span>
              </div>` : ''}
            `;
            showTooltip(html, event);
          })
          .on("mouseleave", hideTooltip);

        // Dots for /no_think
        g.selectAll(".dot-no-think")
          .data(noThinkData)
          .enter()
          .append("circle")
          .attr("class", "dot")
          .style("fill", colors.noThink)
          .attr("cx", d => xScale(d.Beta))
          .attr("cy", d => yScale(d.Score))
          .attr("r", 4)
          .on("mouseenter", function(event, d) {
            const thinkValue = thinkData.find(item => item.Beta === d.Beta);
            const html = `
              <div class="tooltip-title">Beta ${d.Beta.toFixed(2)}</div>
              ${thinkValue ? `
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.think};"></div>
                <span>/think: ${thinkValue.Score.toFixed(2)}%</span>
              </div>` : ''}
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.noThink};"></div>
                <span>/no_think: ${d.Score.toFixed(2)}%</span>
              </div>
            `;
            showTooltip(html, event);
          })
          .on("mouseleave", hideTooltip);
      }

      // Set default value to "Average" if it exists
      const defaultEval = evaluations.includes("Average") ? "Average" : evaluations[0];
      select.property("value", defaultEval);

      // Initial chart
      updateChart(defaultEval);

      // Update on dropdown change
      select.on("change", function() {
        updateChart(this.value);
      });

      // Resize handling
      const rerender = () => updateChart(select.property("value"));
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => rerender());
        ro.observe(container);
      } else {
        window.addEventListener('resize', rerender);
      }

      // Listen for ColorPalettes changes
      if (window.ColorPalettes && typeof window.ColorPalettes.addListener === 'function') {
        window.ColorPalettes.addListener(() => {
          colors = getColors();
          buildLegend();
          updateChart(select.property("value"));
        });
      }
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div></figure>
<p><strong>Scaling the preference data</strong></p>
<p>We also ran experiments to determine how dataset size influences results, testing values from 2k to 340k preference pairs. Across this range, performance remained stable. Performance drops in the extended thinking mode occur for datasets beyond 100k preference pairs, but the drop is not as pronounced as we saw with different learning rate values. The dataset we used for the SmolLM3 training run was 169k preference pairs, but the results show that smaller datasets also show improvements over the SFT checkpoint. For future projects, we know we can experiment with smaller datasets during the iteration phase, as it is important to try multiple ideas and quickly identify the most promising configurations.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-tnv58dlue0k"><div class="d3-apo-size-ablation"></div>
<style>
  .d3-apo-size-ablation {
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    position: relative;
    --axis-color: var(--text-color, #333);
    --tick-color: var(--muted-color, #666);
    --grid-color: rgba(0,0,0,.08);
  }
  [data-theme="dark"] .d3-apo-size-ablation {
    --axis-color: var(--text-color, #ccc);
    --tick-color: var(--muted-color, #999);
    --grid-color: rgba(255,255,255,.10);
  }
  .d3-apo-size-ablation svg {
    display: block;
    overflow: visible;
  }
  .d3-apo-size-ablation .axes path,
  .d3-apo-size-ablation .axes line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }
  .d3-apo-size-ablation .axes text {
    fill: var(--tick-color);
    font-size: 11px;
  }
  .d3-apo-size-ablation .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2,2;
    shape-rendering: crispEdges;
  }
  .d3-apo-size-ablation .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }
  .d3-apo-size-ablation .line-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .d3-apo-size-ablation .line-no-think {
    fill: none;
    stroke-width: 2.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .d3-apo-size-ablation .reference-line {
    fill: none;
    stroke-width: 1.5;
    stroke-dasharray: 5, 5;
    opacity: 0.4;
  }
  .d3-apo-size-ablation .dot {
    stroke: var(--surface-bg);
    stroke-width: 2;
  }
  .d3-apo-size-ablation .header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 16px;
    margin-top: 16px;
    flex-wrap: wrap;
  }
  .d3-apo-size-ablation .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }
  .d3-apo-size-ablation .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }
  .d3-apo-size-ablation .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }
  .d3-apo-size-ablation .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }
  .d3-apo-size-ablation .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }
  .d3-apo-size-ablation .legend .swatch-line {
    width: 20px;
    height: 2px;
    border: none;
  }
  .d3-apo-size-ablation .legend .swatch-dashed {
    width: 20px;
    height: 2px;
    border: none;
    background: repeating-linear-gradient(
      to right,
      var(--text-color) 0,
      var(--text-color) 4px,
      transparent 4px,
      transparent 8px
    );
  }
  .d3-apo-size-ablation .controls {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: flex-end;
    flex-wrap: wrap;
  }
  .d3-apo-size-ablation .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }
  .d3-apo-size-ablation .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }
  .d3-apo-size-ablation .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
  }
  .d3-apo-size-ablation .controls select:focus {
    outline: 2px solid var(--primary-color);
    outline-offset: 2px;
  }
  .d3-apo-size-ablation .d3-tooltip {
    position: absolute;
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    font-size: 12px;
    z-index: 1000;
  }
  .d3-apo-size-ablation .tooltip-title {
    font-weight: 700;
    margin-bottom: 8px;
    color: var(--text-color);
  }
  .d3-apo-size-ablation .tooltip-item {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 4px 0;
    color: var(--text-color);
  }
  .d3-apo-size-ablation .tooltip-color {
    width: 12px;
    height: 12px;
    border-radius: 2px;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-apo-size-ablation'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-apo-size-ablation'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Data embedded inline
      const data = [{"system_prompt":"/think","Evaluation":"AIME25","Score":45.47,"Data Subset":169346},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":7.92,"Data Subset":169346},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":42.49,"Data Subset":169346},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":32.58,"Data Subset":169346},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":69.88,"Data Subset":169346},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":74.46,"Data Subset":169346},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":23.76,"Data Subset":169346},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":13.86,"Data Subset":169346},{"system_prompt":"/think","Evaluation":"Average","Score":45.4,"Data Subset":169346},{"system_prompt":"/no_think","Evaluation":"Average","Score":32.205,"Data Subset":169346},{"system_prompt":"/think","Evaluation":"AIME25","Score":42.4,"Data Subset":1693},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":4.43,"Data Subset":1693},{"system_prompt":"/think","Evaluation":"AIME25","Score":45.36,"Data Subset":8467},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":8.23,"Data Subset":8467},{"system_prompt":"/think","Evaluation":"AIME25","Score":48.54,"Data Subset":16934},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":8.54,"Data Subset":16934},{"system_prompt":"/think","Evaluation":"AIME25","Score":48.65,"Data Subset":42336},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":7.4,"Data Subset":42336},{"system_prompt":"/think","Evaluation":"AIME25","Score":48.65,"Data Subset":84673},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":6.93,"Data Subset":84673},{"system_prompt":"/think","Evaluation":"AIME25","Score":45.16,"Data Subset":127009},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":7.97,"Data Subset":127009},{"system_prompt":"/think","Evaluation":"AIME25","Score":43.18,"Data Subset":338692},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":5.94,"Data Subset":338692},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":43.75,"Data Subset":1693},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":32.32,"Data Subset":1693},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":43.94,"Data Subset":8467},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":31.76,"Data Subset":8467},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":45.39,"Data Subset":16934},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":31.19,"Data Subset":16934},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":42.55,"Data Subset":42336},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":31.69,"Data Subset":42336},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":44.51,"Data Subset":84673},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":33.84,"Data Subset":84673},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":43.12,"Data Subset":127009},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":31.12,"Data Subset":127009},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":43.12,"Data Subset":338692},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":30.3,"Data Subset":338692},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":71.13,"Data Subset":1693},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":70.93,"Data Subset":1693},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":71.97,"Data Subset":8467},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":74.24,"Data Subset":8467},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":75.99,"Data Subset":16934},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":77.05,"Data Subset":16934},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":74.66,"Data Subset":42336},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":78.93,"Data Subset":42336},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":73.22,"Data Subset":84673},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":78.24,"Data Subset":84673},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":72.09,"Data Subset":127009},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":78.27,"Data Subset":127009},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":69.23,"Data Subset":338692},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":76.14,"Data Subset":338692},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":41.58,"Data Subset":1693},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":11.88,"Data Subset":1693},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":32.67,"Data Subset":8467},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":9.9,"Data Subset":8467},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":32.67,"Data Subset":16934},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":9.9,"Data Subset":16934},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":32.67,"Data Subset":42336},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":11.88,"Data Subset":42336},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":29.7,"Data Subset":84673},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":15.84,"Data Subset":84673},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":25.74,"Data Subset":127009},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":13.86,"Data Subset":127009},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":25.74,"Data Subset":338692},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":14.85,"Data Subset":338692},{"system_prompt":"/think","Evaluation":"Average","Score":49.715,"Data Subset":1693},{"system_prompt":"/no_think","Evaluation":"Average","Score":29.89,"Data Subset":1693},{"system_prompt":"/think","Evaluation":"Average","Score":48.485,"Data Subset":8467},{"system_prompt":"/no_think","Evaluation":"Average","Score":31.0325,"Data Subset":8467},{"system_prompt":"/think","Evaluation":"Average","Score":50.6475,"Data Subset":16934},{"system_prompt":"/no_think","Evaluation":"Average","Score":31.67,"Data Subset":16934},{"system_prompt":"/think","Evaluation":"Average","Score":49.6325,"Data Subset":42336},{"system_prompt":"/no_think","Evaluation":"Average","Score":32.475,"Data Subset":42336},{"system_prompt":"/think","Evaluation":"Average","Score":49.02,"Data Subset":84673},{"system_prompt":"/no_think","Evaluation":"Average","Score":33.7125,"Data Subset":84673},{"system_prompt":"/think","Evaluation":"Average","Score":46.5275,"Data Subset":127009},{"system_prompt":"/no_think","Evaluation":"Average","Score":32.805,"Data Subset":127009},{"system_prompt":"/think","Evaluation":"Average","Score":45.3175,"Data Subset":338692},{"system_prompt":"/no_think","Evaluation":"Average","Score":31.8075,"Data Subset":338692}];
      const sftData = [{"system_prompt":"/think","Evaluation":"AIME25","Score":36.56},{"system_prompt":"/no_think","Evaluation":"AIME25","Score":4.01},{"system_prompt":"/think","Evaluation":"GPQA Diamond","Score":42.23},{"system_prompt":"/no_think","Evaluation":"GPQA Diamond","Score":30.43},{"system_prompt":"/think","Evaluation":"IF-Eval","Score":70.03},{"system_prompt":"/no_think","Evaluation":"IF-Eval","Score":67.29},{"system_prompt":"/think","Evaluation":"LiveCodeBench v4","Score":36.63},{"system_prompt":"/no_think","Evaluation":"LiveCodeBench v4","Score":12.87},{"system_prompt":"/think","Evaluation":"Average","Score":46.3625},{"system_prompt":"/no_think","Evaluation":"Average","Score":28.65}];

      // Get colors from ColorPalettes or fallback
      const getColors = () => {
        if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
          const colors = window.ColorPalettes.getColors('categorical', 2);
          return { think: colors[0], noThink: colors[1] };
        }
        return { think: '#E377C2', noThink: '#7FC97F' };
      };

      let colors = getColors();

      // Set up dimensions
      const margin = { top: 16, right: 28, bottom: 56, left: 64 };

      // Create SVG
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const g = svg.append('g');

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease',
          zIndex: '1000'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        const [mx, my] = d3.pointer(event, container);
        const offsetX = 12, offsetY = 12;
        tip.style.transform = `translate(${mx + offsetX}px, ${my + offsetY}px)`;
        tip.style.opacity = '1';
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // Get unique evaluations
      const evaluations = [...new Set(data.map(d => d.Evaluation))];

      // Create header with legend and controls
      const header = d3.select(container).append('div').attr('class', 'header');

      const legend = header.append('div').attr('class', 'legend');
      legend.append('div').attr('class', 'legend-title').text('Legend');
      const legendItems = legend.append('div').attr('class', 'items');

      const controls = header.append('div').attr('class', 'controls');
      const controlGroup = controls.append('div').attr('class', 'control-group');
      controlGroup.append('label').attr('for', 'metric-select-size').text('Metric');
      const select = controlGroup.append('select').attr('id', 'metric-select-size');

      // Populate dropdown
      select.selectAll('option')
        .data(evaluations)
        .enter()
        .append('option')
        .text(d => d)
        .attr('value', d => d);

      // Build legend
      const buildLegend = () => {
        legendItems.html('');

        const thinkItem = legendItems.append('span').attr('class', 'item');
        thinkItem.append('span').attr('class', 'swatch-line').style('background', colors.think);
        thinkItem.append('span').text('/think');

        const noThinkItem = legendItems.append('span').attr('class', 'item');
        noThinkItem.append('span').attr('class', 'swatch-line').style('background', colors.noThink);
        noThinkItem.append('span').text('/no_think');

        const sftItem = legendItems.append('span').attr('class', 'item');
        sftItem.append('span').attr('class', 'swatch-dashed');
        sftItem.append('span').text('SFT checkpoint');
      };

      buildLegend();

      // Update chart function
      function updateChart(evaluation) {
        const filtered = data.filter(d => d.Evaluation === evaluation);
        const thinkData = filtered.filter(d => d.system_prompt === "/think").sort((a, b) => a["Data Subset"] - b["Data Subset"]);
        const noThinkData = filtered.filter(d => d.system_prompt === "/no_think").sort((a, b) => a["Data Subset"] - b["Data Subset"]);

        g.selectAll("*").remove();

        const sftThink = sftData.find(d => d.Evaluation === evaluation && d.system_prompt === "/think");
        const sftNoThink = sftData.find(d => d.Evaluation === evaluation && d.system_prompt === "/no_think");

        const width = container.clientWidth || 800;
        const height = Math.max(320, Math.round(width / 2.5));
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        svg.attr('width', width).attr('height', height);
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Scales
        const xScale = d3.scaleLog()
          .domain([d3.min(filtered, d => d["Data Subset"]), d3.max(filtered, d => d["Data Subset"])])
          .range([0, innerWidth]);

        const allScores = filtered.map(d => d.Score);
        if (sftThink) allScores.push(sftThink.Score);
        if (sftNoThink) allScores.push(sftNoThink.Score);
        const maxScore = d3.max(allScores);

        const yScale = d3.scaleLinear()
          .domain([0, maxScore * 1.1])
          .range([innerHeight, 0]);

        // Grid
        g.append("g")
          .attr("class", "grid")
          .attr("transform", `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickSize(-innerHeight).tickFormat("").tickSizeOuter(0));

        g.append("g")
          .attr("class", "grid")
          .call(d3.axisLeft(yScale).tickSize(-innerWidth).tickFormat("").tickSizeOuter(0));

        // Axes
        g.append("g")
          .attr("class", "axes")
          .attr("transform", `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0))
          .call(gAxis => {
            gAxis.selectAll(".tick line").attr("stroke", "var(--axis-color)").style("opacity", 1);
            gAxis.selectAll(".tick text").attr("fill", "var(--tick-color)").style("opacity", 1);
            gAxis.select(".domain").attr("stroke", "var(--axis-color)");
          });

        g.append("g")
          .attr("class", "axes")
          .call(d3.axisLeft(yScale).ticks(6).tickSizeOuter(0))
          .call(gAxis => {
            gAxis.selectAll(".tick line").attr("stroke", "var(--axis-color)").style("opacity", 1);
            gAxis.selectAll(".tick text").attr("fill", "var(--tick-color)").style("opacity", 1);
            gAxis.select(".domain").attr("stroke", "var(--axis-color)");
          });

        // Axis labels
        g.append("text")
          .attr("class", "axis-label")
          .attr("text-anchor", "middle")
          .attr("x", innerWidth / 2)
          .attr("y", innerHeight + 40)
          .text("Dataset size");

        g.append("text")
          .attr("class", "axis-label")
          .attr("text-anchor", "middle")
          .attr("transform", "rotate(-90)")
          .attr("y", -45)
          .attr("x", -innerHeight / 2)
          .text("Score (%)");

        // Line generator
        const line = d3.line()
          .x(d => xScale(d["Data Subset"]))
          .y(d => yScale(d.Score));

        // Reference lines
        if (sftThink) {
          g.append("line")
            .attr("class", "reference-line")
            .style("stroke", colors.think)
            .attr("x1", 0)
            .attr("x2", innerWidth)
            .attr("y1", yScale(sftThink.Score))
            .attr("y2", yScale(sftThink.Score));
        }

        if (sftNoThink) {
          g.append("line")
            .attr("class", "reference-line")
            .style("stroke", colors.noThink)
            .attr("x1", 0)
            .attr("x2", innerWidth)
            .attr("y1", yScale(sftNoThink.Score))
            .attr("y2", yScale(sftNoThink.Score));
        }

        // Lines
        g.append("path")
          .datum(thinkData)
          .attr("class", "line-think")
          .style("stroke", colors.think)
          .attr("d", line);

        g.append("path")
          .datum(noThinkData)
          .attr("class", "line-no-think")
          .style("stroke", colors.noThink)
          .attr("d", line);

        // Dots for /think
        g.selectAll(".dot-think")
          .data(thinkData)
          .enter()
          .append("circle")
          .attr("class", "dot")
          .style("fill", colors.think)
          .attr("cx", d => xScale(d["Data Subset"]))
          .attr("cy", d => yScale(d.Score))
          .attr("r", 4)
          .on("mouseenter", function(event, d) {
            const noThinkValue = noThinkData.find(item => item["Data Subset"] === d["Data Subset"]);
            const html = `
              <div class="tooltip-title">Dataset Size ${d["Data Subset"].toLocaleString()}</div>
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.think};"></div>
                <span>/think: ${d.Score.toFixed(2)}%</span>
              </div>
              ${noThinkValue ? `
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.noThink};"></div>
                <span>/no_think: ${noThinkValue.Score.toFixed(2)}%</span>
              </div>` : ''}
            `;
            showTooltip(html, event);
          })
          .on("mouseleave", hideTooltip);

        // Dots for /no_think
        g.selectAll(".dot-no-think")
          .data(noThinkData)
          .enter()
          .append("circle")
          .attr("class", "dot")
          .style("fill", colors.noThink)
          .attr("cx", d => xScale(d["Data Subset"]))
          .attr("cy", d => yScale(d.Score))
          .attr("r", 4)
          .on("mouseenter", function(event, d) {
            const thinkValue = thinkData.find(item => item["Data Subset"] === d["Data Subset"]);
            const html = `
              <div class="tooltip-title">Dataset Size ${d["Data Subset"].toLocaleString()}</div>
              ${thinkValue ? `
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.think};"></div>
                <span>/think: ${thinkValue.Score.toFixed(2)}%</span>
              </div>` : ''}
              <div class="tooltip-item">
                <div class="tooltip-color" style="background-color: ${colors.noThink};"></div>
                <span>/no_think: ${d.Score.toFixed(2)}%</span>
              </div>
            `;
            showTooltip(html, event);
          })
          .on("mouseleave", hideTooltip);
      }

      // Set default value to "Average" if it exists
      const defaultEval = evaluations.includes("Average") ? "Average" : evaluations[0];
      select.property("value", defaultEval);

      // Initial chart
      updateChart(defaultEval);

      // Update on dropdown change
      select.on("change", function() {
        updateChart(this.value);
      });

      // Resize handling
      const rerender = () => updateChart(select.property("value"));
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => rerender());
        ro.observe(container);
      } else {
        window.addEventListener('resize', rerender);
      }

      // Listen for ColorPalettes changes
      if (window.ColorPalettes && typeof window.ColorPalettes.addListener === 'function') {
        window.ColorPalettes.addListener(() => {
          colors = getColors();
          buildLegend();
          updateChart(select.property("value"));
        });
      }
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div></figure>
<p>Bringing all these choices together led to the final SmolLM3-3B model, which was best-in-class for its size and sat on the Pareto front with Qwen’s own hybrid reasoning models:</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-9mq094jrzvd"><div class="base-model-performance"></div>

<style>
    .base-model-performance {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        max-width: 900px;
        margin: 0 auto;
    }

    .base-model-performance .chart-container {
        position: relative;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1.5 / 1;
    }

    .base-model-performance svg {
        width: 100%;
        height: 100%;
        display: block;
    }

    .base-model-performance .axis-line {
        stroke: var(--border-color);
        stroke-width: 2;
    }

    .base-model-performance .axis-label {
        fill: var(--text-color);
        font-size: 16px;
        font-weight: 600;
    }

    .base-model-performance .axis-sublabel {
        fill: var(--muted-color);
        font-size: 13px;
    }

    .base-model-performance .tick-line {
        stroke: var(--border-color);
        stroke-width: 1;
        opacity: 0.3;
    }

    .base-model-performance .tick-label {
        fill: var(--muted-color);
        font-size: 12px;
    }

    .base-model-performance .pareto-zone {
        fill: var(--text-color);
        opacity: 0.08;
    }

    .base-model-performance .pareto-border {
        stroke: var(--border-color);
        stroke-width: 2;
        fill: none;
        stroke-dasharray: 5, 5;
    }


    .base-model-performance .model-circle {
        /* stroke is set dynamically in JavaScript */
    }

    .base-model-performance .model-icon {
        font-size: 32px;
    }

    .base-model-performance .model-label {
        fill: var(--text-color);
        font-size: 14px;
        font-weight: 600;
        text-anchor: middle;
        pointer-events: none;
    }

    .base-model-performance .model-sublabel {
        fill: var(--muted-color);
        font-size: 12px;
        text-anchor: middle;
        pointer-events: none;
    }

    .base-model-performance .arrow {
        stroke: var(--muted-color);
        stroke-width: 2.5;
        fill: none;
        marker-end: url(#arrowhead);
        opacity: 0.4;
    }

    .base-model-performance .arrow-label {
        fill: var(--text-color);
        font-size: 14px;
        font-weight: 600;
        letter-spacing: 0.3px;
    }


    .base-model-performance .legend {
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        justify-content: center;
    }

    .base-model-performance .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: var(--muted-color);
    }

    .base-model-performance .legend-icon {
        font-size: 20px;
    }

    @media (max-width: 768px) {
        .base-model-performance .chart-container {
            height: 500px;
        }

        .base-model-performance .axis-label {
            font-size: 14px;
        }

        .base-model-performance .model-label {
            font-size: 12px;
        }

        .base-model-performance .arrow-label {
            font-size: 14px;
        }
    }
</style>

<script>
    (() => {
        const bootstrap = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;
            if (!(container && container.classList && container.classList.contains('base-model-performance'))) {
                const candidates = Array.from(document.querySelectorAll('.base-model-performance'))
                    .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
                container = candidates[candidates.length - 1] || null;
            }
            if (!container) return;
            if (container.dataset) {
                if (container.dataset.mounted === 'true') return;
                container.dataset.mounted = 'true';
            }

            // Data for models
            const models = [
                { name: 'Qwen3 1.7B Base', size: 1.7, winRate: 2.1, logo: 'qwen', color: '#8B5CF6' },
                { name: 'Qwen2.5 3B', size: 3.1, winRate: 3.1, logo: 'qwen', color: '#8B5CF6' },
                { name: 'SmolLM3 3B Base', size: 3.0, winRate: 4.0, logo: 'hf', color: '#FFD43B' },
                { name: 'Llama3.2 3B', size: 3.2, winRate: 2.3, logo: 'meta', color: '#4299E1' },
                { name: 'Qwen3 4B Base', size: 4.0, winRate: 4.9, logo: 'qwen', color: '#8B5CF6' },
                { name: 'Gemma3 4B Base', size: 4.3, winRate: 4.5, logo: 'google', color: '#EA4335' }
            ];

            // Chart dimensions
            const padding = 20;
            const margin = { top: 20 + padding, right: 20 + padding, bottom: 80 + padding, left: 100 + padding };
            const width = 900 - margin.left - margin.right;
            const height = 600 - margin.top - margin.bottom;

            // Scales
            const xScale = (value) => margin.left + ((value - 1.5) / (4.5 - 1.5)) * width;
            const yScale = (value) => height + margin.top - ((value - 1.8) / (5.2 - 1.8)) * height;

            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

            // Define arrowhead marker
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '6');
            marker.setAttribute('markerHeight', '6');
            marker.setAttribute('refX', '5');
            marker.setAttribute('refY', '3');
            marker.setAttribute('orient', 'auto');
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 6 3, 0 6');
            polygon.setAttribute('fill', 'var(--muted-color)');
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svg.appendChild(defs);

            // Draw Pareto border - straight diagonal
            const paretoBorder = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const borderD = `M ${xScale(1.5)} ${yScale(1.8)} L ${xScale(4.5)} ${yScale(5.2)}`;
            paretoBorder.setAttribute('d', borderD);
            paretoBorder.setAttribute('class', 'pareto-border');
            svg.appendChild(paretoBorder);

            // Draw X-axis
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', margin.left);
            xAxis.setAttribute('y1', height + margin.top);
            xAxis.setAttribute('x2', width + margin.left);
            xAxis.setAttribute('y2', height + margin.top);
            xAxis.setAttribute('class', 'axis-line');
            svg.appendChild(xAxis);

            // Draw Y-axis
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', margin.left);
            yAxis.setAttribute('y1', margin.top);
            yAxis.setAttribute('x2', margin.left);
            yAxis.setAttribute('y2', height + margin.top);
            yAxis.setAttribute('class', 'axis-line');
            svg.appendChild(yAxis);

            // X-axis ticks and labels
            for (let i = 2.0; i <= 4.5; i += 0.5) {
                const x = xScale(i);
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', x);
                tick.setAttribute('y1', margin.top);
                tick.setAttribute('x2', x);
                tick.setAttribute('y2', height + margin.top);
                tick.setAttribute('class', 'tick-line');
                svg.appendChild(tick);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', height + margin.top + 25);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'tick-label');
                label.textContent = i.toFixed(1);
                svg.appendChild(label);
            }

            // Y-axis ticks and labels
            for (let i = 2.0; i <= 5.0; i += 0.5) {
                const y = yScale(i);
                const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tick.setAttribute('x1', margin.left);
                tick.setAttribute('y1', y);
                tick.setAttribute('x2', width + margin.left);
                tick.setAttribute('y2', y);
                tick.setAttribute('class', 'tick-line');
                svg.appendChild(tick);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', margin.left - 15);
                label.setAttribute('y', y + 5);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('class', 'tick-label');
                label.textContent = i.toFixed(1);
                svg.appendChild(label);
            }

            // X-axis label
            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', margin.left + width / 2);
            xLabel.setAttribute('y', height + margin.top + 65);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('class', 'axis-label');
            xLabel.innerHTML = '<tspan font-weight="700">Model Size</tspan><tspan font-weight="400"> (Billion parameters)</tspan>';
            svg.appendChild(xLabel);

            // Y-axis label
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', -(height / 2 + margin.top));
            yLabel.setAttribute('y', 55);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('transform', 'rotate(-90)');
            yLabel.setAttribute('class', 'axis-label');
            yLabel.innerHTML = '<tspan font-weight="700">Win Rate (%)</tspan><tspan font-weight="400"> - 12 popular LLM Benchmarks</tspan>';
            svg.appendChild(yLabel);

            // Draw arrows
            // "faster/cheaper" arrow (shorter, aligned to left)
            const arrow1StartX = margin.left + 80;
            const arrow1Length = 170;
            const arrow1EndX = arrow1StartX + arrow1Length;
            const arrow1Y = yScale(4.8);

            const arrow1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            arrow1.setAttribute('d', `M ${arrow1EndX} ${arrow1Y} L ${arrow1StartX} ${arrow1Y}`);
            arrow1.setAttribute('class', 'arrow');
            svg.appendChild(arrow1);

            const arrow1Label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            arrow1Label.setAttribute('x', (arrow1StartX + arrow1EndX) / 2);
            arrow1Label.setAttribute('y', arrow1Y - 10);
            arrow1Label.setAttribute('text-anchor', 'middle');
            arrow1Label.setAttribute('class', 'arrow-label');
            arrow1Label.textContent = 'faster / cheaper';
            svg.appendChild(arrow1Label);

            // "better" arrow (pointing up)
            const arrow2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            arrow2.setAttribute('d', `M ${xScale(1.75)} ${yScale(3.5)} L ${xScale(1.75)} ${yScale(4.5)}`);
            arrow2.setAttribute('class', 'arrow');
            svg.appendChild(arrow2);

            const arrow2Label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            arrow2Label.setAttribute('x', xScale(1.75) - 50);
            arrow2Label.setAttribute('y', yScale(4.0) + 35);
            arrow2Label.setAttribute('text-anchor', 'middle');
            arrow2Label.setAttribute('dominant-baseline', 'middle');
            arrow2Label.setAttribute('transform', `rotate(-90 ${xScale(1.75) - 50} ${yScale(4.0)})`);
            arrow2Label.setAttribute('class', 'arrow-label');
            arrow2Label.textContent = 'better';
            svg.appendChild(arrow2Label);


            // Draw model points
            models.forEach(model => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'model-point');

                const x = xScale(model.size);
                const y = yScale(model.winRate);

                // Circle background
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                const isHighlight = model.name.includes('SmolLM3');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', isHighlight ? 35 : 28);
                circle.setAttribute('fill', 'rgba(255, 255, 255, 0.3)');
                circle.setAttribute('class', 'model-circle');
                if (isHighlight) {
                    circle.setAttribute('stroke', model.color);
                    circle.setAttribute('stroke-width', '2');
                } else {
                    circle.setAttribute('stroke', 'rgba(0, 0, 0, 0.25)');
                    circle.setAttribute('stroke-width', '1');
                }
                g.appendChild(circle);

                // Logo as foreignObject
                const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                const isSmolLM3 = isHighlight;
                const logoOffset = isSmolLM3 ? 26 : 22;
                foreignObject.setAttribute('x', x - logoOffset);
                foreignObject.setAttribute('y', isSmolLM3 ? y - 28 : y - 22);
                foreignObject.setAttribute('width', isSmolLM3 ? 54 : 44);
                foreignObject.setAttribute('height', isSmolLM3 ? 54 : 44);
                let logoSize;
                if (model.logo === 'qwen' || model.logo === 'hf') {
                    logoSize = isSmolLM3 ? 52 : 44;
                } else if (model.logo === 'meta') {
                    logoSize = 32;
                } else {
                    logoSize = 36;
                }
                foreignObject.innerHTML = `<div xmlns="http://www.w3.org/1999/xhtml" style="width: ${isSmolLM3 ? 54 : 44}px; height: ${isSmolLM3 ? 54 : 44}px; display: flex; align-items: center; justify-content: center;"><img src="./data/${model.logo}-logo.svg" style="width: ${logoSize}px; height: auto; max-height: ${logoSize}px;" /></div>`;
                g.appendChild(foreignObject);

                // Label below
                const nameParts = model.name.split(' ');
                const label1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label1.setAttribute('x', x);
                label1.setAttribute('y', isSmolLM3 ? y + 55 : y + 50);
                label1.setAttribute('class', 'model-label');
                if (isHighlight) {
                    label1.setAttribute('font-weight', '800');
                    label1.setAttribute('font-size', '16px');
                }
                label1.textContent = nameParts.slice(0, -1).join(' ');
                g.appendChild(label1);

                const label2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label2.setAttribute('x', x);
                label2.setAttribute('y', isSmolLM3 ? y + 73 : y + 66);
                label2.setAttribute('class', 'model-sublabel');
                if (isHighlight) {
                    label2.setAttribute('font-weight', '800');
                    label2.setAttribute('font-size', '14px');
                }
                label2.textContent = nameParts[nameParts.length - 1];
                g.appendChild(label2);


                svg.appendChild(g);
            });

            // Create chart container and add SVG
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.appendChild(svg);
            container.appendChild(chartContainer);
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
            bootstrap();
        }
    })();
</script></div></div></figure> </div>
<p>Not too shabby for a few weeks work!</p>
<h4 id="rules-of-engagement-4"><a href="#rules-of-engagement-4">Rules of engagement</a></h4>
<p>To summarise our findings about preference optimisation that could be useful for your future projects:</p>
<ul>
<li>Don’t be afraid to create your own preference data! With inference becoming “too cheap to meter”, it’s nowadays simple and cost-effective to generate LLM preferences from various <a href="https://huggingface.co/docs/inference-providers/en/index">inference providers</a>.</li>
<li>Pick DPO as your initial baseline and iterate from there. We’ve found that depending on the type of preference data, other algorithms like ORPO, KTO, or APO can provide significant gains over DPO.</li>
<li>Use a learning rate that’s around 10x smaller than the one used for SFT.</li>
<li>Scan over β, usually in the range 0.01 to 0.5</li>
<li>Since most preference algorithms overfit after one epoch, partition your data and train iteratively for best performance.</li>
</ul>
<p>Preference optimisation is often the sweet spot between simplicity and performance, but it still inherits a key limitation: it’s only as good as the offline preference data you can collect. At some point, static datasets run out of signal and you need methods that can generate fresh training feedback online as the model interacts with prompts and environment. That’s where preference optimisation meets the broader family of  <em>online and RL-based methods.</em></p>
<h3 id="going-online-and-beyond-supervised-labels"><a href="#going-online-and-beyond-supervised-labels">Going online and beyond supervised labels</a></h3>
<p>If you want your model to consistently solve math problems, generate executable code, or plan across multiple steps, you often need a  <strong>reward signal</strong>  rather than just “A is better than B”.</p>
<p>This is where RL starts to make sense. Instead of supervising the model with preferences, you let it interact with an environment (which could be a math verifier, a code executor, or even real user feedback), and learn directly from the outcomes. RL shines when:</p>
<ul>
<li><strong>You can check correctness automatically</strong>  (e.g., unit tests, mathematical proofs, API calls) or have access to a high-quality verifier or reward model.</li>
<li><strong>The task requires multi-step reasoning or planning</strong> , where local preferences may not capture long-term success.</li>
<li><strong>You want to optimise for objectives beyond preference labels</strong> , like passing unit tests for code or maximising some objective.</li>
</ul>
<p>When it comes to LLMs, there are two main flavours of RL:</p>
<ul>
<li><strong>Reinforcement Learning from Human Feedback (RLHF):</strong>  this is the approach that was popularised by OpenAI’s InstructGPT paper <span class="" id="citation--instructgpt--150">(<a href="https://arxiv.org/abs/2203.02155" id="refctx-bib-instructgpt-1" data-ref-id="bib-instructgpt" target="_blank" rel="noopener noreferrer">Ouyang et al., 2022</a>)</span> and the basis for gpt-3.5 and many modern models. Here, human annotators compare model outputs (e.g. “A is better than B”) and a reward model is trained to predict those preferences. The policy is then fine-tuned with RL to maximise the learned reward.</li>
</ul>
<div class="sidenote-container"> <aside class="sidenote"> <p>Because the reward model only approximates human preferences, it can sometimes encourage reward hacking, where the policy emits an out-of-distribution sequence like “the the the the” which is given a spurious high reward and is then baked into the model via the RL loop.</p> </aside> </div>  
<ul>
<li><strong>Reinforcement Learning with Verifiable Rewards (RLVR):</strong> this is the approach that was popularised by DeepSeek-R1 and involves the use of verifiers that check whether a model’s output meets some clearly defined correctness criteria (e.g. does the code compile and pass all tests, or is the mathematical answer correct?). The policy is then fine-tuned with RL to produce more verifiably-correct outputs.</li>
</ul>
<p>Both RLHF and RLVR define  <em>what</em> the model is being optimised for, but they don’t tell us  <em>how</em>  that optimisation should be carried out. In practice, the efficiency and stability of RL-based training depends heavily on whether the learning algorithm is  <strong>on-policy</strong> or  <strong>off-policy</strong> .</p>
<p>Methods such as GRPO typically fall into the category of on-policy optimisation algorithms, where the model (the policy) that generates the completions is the same as the one being optimised. While it is broadly the case that GRPO is an on-policy algorithm, there are a few caveats. First, to optimise the generation step, several batches of generations may be sampled and then  <strong>k</strong>  updates are made to the model, with the first batch being on-policy with the next few batches being slightly off-policy.</p>
<p>To account for policy-lag between the model used for generation and the current model being optimised, importance sampling and clipping are used to re-weight the token probabilities and restrict the size of the updates.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>We mention here off-policy RL, but there are several truly off-policy RL algorithms, such as Q-Learning, where the policy used for generate trajectories can be totally different to the policy being optimized. When GRPO is applied to LLMs the policy used for generation can lag behind the one used for optimization, but typically there are less than 16 steps difference between the two.</p> </aside> </div>  
<p>As autoregressive generation from LLMs is slow, many frameworks like verl and PipelineRL have added asynchronous generation of completions and “in-flight” updates of model weights to maximise training throughput. These approaches require more complex and careful implementation, but can achieve training speeds that are 4-5x higher than synchronous training methods. As we’ll see later, these improvements in training efficiency are especially pronounced for reasoning models, which have long-tail token distributions.</p>
<p>For SmolLM3, we skipped RL altogether, mostly due to time constraints and having a model that was already best-in-class with offline preference optimisation. However, since the release, we have revisited the topic and will close out the post-training chapter by sharing some of our lessons from applying RLVR to hybrid reasoning models.</p>
<h4 id="applying-rlvr-to-hybrid-reasoning-models"><a href="#applying-rlvr-to-hybrid-reasoning-models">Applying RLVR to hybrid reasoning models</a></h4>
<p>Hybrid reasoning models pose additional complexity for RLVR because generation lengths vary considerably depending on the reasoning mode. For example, in the figure below, we plot the token length distributions on AIME25 for the <a href="https://huggingface.co/HuggingFaceTB/SmolLM3-3B-checkpoints/tree/it-soup-APO">final APO checkpoint</a> from SmolLM3:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-hsm67fw1wyt"><div class="d3-grpo-token-histogram"></div>
<style>
  .d3-grpo-token-histogram {
    width: 100%;
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  }

  .d3-grpo-token-histogram svg {
    display: block;
    width: 100%;
  }

  .d3-grpo-token-histogram .bar {
    stroke: none;
  }

  .d3-grpo-token-histogram .axes path,
  .d3-grpo-token-histogram .axes line {
    stroke: var(--axis-color, var(--text-color));
  }

  .d3-grpo-token-histogram .axes text {
    fill: var(--tick-color, var(--muted-color));
    font-size: 11px;
  }

  .d3-grpo-token-histogram .grid line {
    stroke: var(--grid-color, rgba(0, 0, 0, .08));
  }

  .d3-grpo-token-histogram .chart-title {
    font-size: 13px;
    font-weight: 600;
    fill: var(--text-color);
  }

  .d3-grpo-token-histogram .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.35;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, .18);
    opacity: 0;
    transition: opacity .12s ease;
  }

  .d3-grpo-token-histogram .d3-tooltip__inner {
    text-align: left;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-grpo-token-histogram'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-grpo-token-histogram'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        tip.style.opacity = '1';
        const [mx, my] = d3.pointer(event, container);
        tip.style.transform = `translate(${mx + 12}px, ${my - 12}px)`;
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // SVG scaffolding
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');

      let width = 800, height = 400;
      const margin = { top: 40, right: 16, bottom: 56, left: 60 };

      // Data loading
      const JSON_PATHS = [
        '/data/HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-APO-no-think_main_aime25_2025-10-02T13-20-35.json',
        './assets/data/HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-APO-no-think_main_aime25_2025-10-02T13-20-35.json',
        '../assets/data/HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-APO-no-think_main_aime25_2025-10-02T13-20-35.json',
        '../../assets/data/HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-APO-no-think_main_aime25_2025-10-02T13-20-35.json'
      ];

      const JSON_PATHS_THINK = [
        '/data/HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-APO-think_main_aime25_2025-10-17T09-02-45.json',
        './assets/data/HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-APO-think_main_aime25_2025-10-17T09-02-45.json',
        '../assets/data/HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-APO-think_main_aime25_2025-10-17T09-02-45.json',
        '../../assets/data/HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-APO-think_main_aime25_2025-10-17T09-02-45.json'
      ];

      const fetchFirstAvailable = async (paths) => {
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.json();
          } catch (e) { }
        }
        throw new Error('JSON not found');
      };

      Promise.all([
        fetchFirstAvailable(JSON_PATHS),
        fetchFirstAvailable(JSON_PATHS_THINK)
      ])
        .then(([dataNoThink, dataThink]) => {
          const datasets = [
            { name: 'No-Think', data: dataNoThink, title: 'APO No-Think' },
            { name: 'Think', data: dataThink, title: 'APO Think' }
          ];

          // Get colors
          const colors = window.ColorPalettes
            ? window.ColorPalettes.getColors('categorical', 2)
            : ['#4e79a7', '#f28e2c'];

          function updateSize() {
            width = container.clientWidth || 800;
            height = Math.max(400, Math.round(width / 2.2));
            svg.attr('width', width).attr('height', height);
            gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
            return {
              innerWidth: width - margin.left - margin.right,
              innerHeight: height - margin.top - margin.bottom
            };
          }

          function render() {
            const { innerWidth, innerHeight } = updateSize();

            // Clear previous
            gRoot.selectAll('*').remove();

            // Calculate histogram bins for each dataset
            const chartWidth = (innerWidth - 40) / 2;
            const histograms = datasets.map((ds, idx) => {
              const tokens = ds.data.token_counts;
              const xOffset = idx * (chartWidth + 40);

              // Use independent x-axis ranges optimized for each dataset
              // No-Think: most data is 0-4k range (median 723)
              // Think: data is spread around median 16,769
              const xDomain = idx === 0
                ? [0, 4000]   // No-Think: focus on 0-4k range
                : [0, 32000]; // Think: show full range

              // Create bins
              const bins = d3.bin()
                .domain(xDomain)
                .thresholds(30)(tokens);

              const xScale = d3.scaleLinear()
                .domain(xDomain)
                .range([0, chartWidth]);

              const yScale = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .range([innerHeight, 0])
                .nice();

              return { ds, bins, xScale, yScale, xOffset, idx };
            });

            // Draw each histogram
            histograms.forEach(({ ds, bins, xScale, yScale, xOffset, idx }) => {
              const g = gRoot.append('g').attr('transform', `translate(${xOffset},0)`);

              // Title
              g.append('text')
                .attr('class', 'chart-title')
                .attr('x', chartWidth / 2)
                .attr('y', -12)
                .attr('text-anchor', 'middle')
                .text(ds.title);

              // Bars
              g.selectAll('rect.bar')
                .data(bins)
                .join('rect')
                .attr('class', 'bar')
                .attr('x', d => xScale(d.x0))
                .attr('y', d => yScale(d.length))
                .attr('width', d => Math.max(1, xScale(d.x1) - xScale(d.x0) - 1))
                .attr('height', d => Math.max(0, innerHeight - yScale(d.length)))
                .attr('fill', colors[idx])
                .attr('opacity', 0.8)
                .on('mouseenter', (event, d) => {
                  const html = `<strong>Tokens: ${d.x0.toFixed(0)} - ${d.x1.toFixed(0)}</strong><br/>Count: ${d.length}`;
                  showTooltip(html, event);
                })
                .on('mouseleave', hideTooltip);

              // X axis
              const xAxis = g.append('g')
                .attr('class', 'axes')
                .attr('transform', `translate(0,${innerHeight})`)
                .call(d3.axisBottom(xScale).ticks(5).tickFormat(d3.format(',d')));

              xAxis.select('.domain').remove();

              // Y axis
              const yAxis = g.append('g')
                .attr('class', 'axes')
                .call(d3.axisLeft(yScale).ticks(5));

              yAxis.select('.domain').remove();

              // Grid
              g.append('g')
                .attr('class', 'grid')
                .call(
                  d3.axisLeft(yScale)
                    .ticks(5)
                    .tickSize(-chartWidth)
                    .tickFormat('')
                )
                .call(g => g.select('.domain').remove());

              // X axis label
              g.append('text')
                .attr('class', 'axes')
                .attr('x', chartWidth / 2)
                .attr('y', innerHeight + 40)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('fill', 'var(--text-color)')
                .text('Token count');

              // Y axis label (only for left chart)
              if (idx === 0) {
                g.append('text')
                  .attr('class', 'axes')
                  .attr('transform', 'rotate(-90)')
                  .attr('x', -innerHeight / 2)
                  .attr('y', -45)
                  .attr('text-anchor', 'middle')
                  .style('font-size', '12px')
                  .style('fill', 'var(--text-color)')
                  .text('Frequency');
              }

              // Statistics text
              const stats = ds.data.statistics;
              const statsText = `Mean: ${stats.mean.toFixed(0)} | Median: ${stats.median.toFixed(0)}`;
              g.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', innerHeight + 54)
                .attr('text-anchor', 'middle')
                .style('font-size', '11px')
                .style('fill', 'var(--muted-color)')
                .text(statsText);
            });
          }

          render();

          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch((err) => {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + err.message;
          pre.style.cssText = 'color:red;font-size:12px;padding:12px;margin:0;';
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>As you can see, the  <code>/no_think</code>  mode generates solutions of around 2k tokens, while the  <code>/think</code>  mode is much larger with 16k tokens and a fat-tailed distribution. Ideally, we would like to improve the overall performance of both modes with RLVR, without changing their respective length distributions too radically.</p>
<p>To explore this, we focused on optimising the  <code>/no_think</code>  mode first and took a subset of prompts from <a href="https://huggingface.co/datasets/SynthLabsAI/Big-Math-RL-Verified">Big-Math</a>, a dataset of over 250k math problems with verified answers.</p>
<p>To our surprise, naively applying GRPO leads to a form of reward hacking: despite being never being prompted to emit a long CoT, the model learns to exploit its base reasoning capabilities to increase the reward. As shown in the figure below, not only does the reward go up, but so too does the length of the completions:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-yic4tu902k"><div class="d3-grpo-full-length"></div>
<style>
  .d3-grpo-full-length {
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    position: relative;
  }

  .d3-grpo-full-length svg {
    display: block;
    width: 100%;
  }

  .d3-grpo-full-length .axis path {
    stroke: none;
  }

  .d3-grpo-full-length .axis line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }

  .d3-grpo-full-length .axis text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-grpo-full-length .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2,2;
  }

  .d3-grpo-full-length .confidence-band {
    opacity: 0.15;
  }

  .d3-grpo-full-length .line {
    fill: none;
    stroke-width: 2;
    stroke-linejoin: round;
    stroke-linecap: round;
  }

  .d3-grpo-full-length .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .d3-grpo-full-length .axis-label.reward {
    fill: var(--reward-color);
  }

  .d3-grpo-full-length .axis-label.length {
    fill: var(--length-color);
  }

  .d3-grpo-full-length .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 16px;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
  }

  .d3-grpo-full-length .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-grpo-full-length .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-grpo-full-length .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-grpo-full-length .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
    cursor: pointer;
    user-select: none;
    opacity: 1;
    transition: opacity 0.2s ease;
  }

  .d3-grpo-full-length .legend .item.dimmed {
    opacity: 0.3;
  }

  .d3-grpo-full-length .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-grpo-full-length .controls {
    display: flex;
    gap: 16px;
    align-items: center;
    justify-content: flex-end;
    flex-wrap: wrap;
  }

  .d3-grpo-full-length .controls .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-grpo-full-length .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-grpo-full-length .controls .toggle-group {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .d3-grpo-full-length .controls .toggle-btn {
    padding: 6px 12px;
    font-size: 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .d3-grpo-full-length .controls .toggle-btn:hover {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
  }

  .d3-grpo-full-length .controls .toggle-btn.active {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-grpo-full-length'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-grpo-full-length'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Data loading configuration
      let mountEl = container;
      while (mountEl && !mountEl.getAttribute?.('data-datafiles')) {
        mountEl = mountEl.parentElement;
      }
      let providedData = null;
      try {
        const attr = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-datafiles') : null;
        if (attr && attr.trim()) {
          providedData = attr.trim().startsWith('[') ? JSON.parse(attr) : attr.trim();
        }
      } catch (_) {}

      const DEFAULT_CSV = '/data/rl_reward_curves.csv';
      const ensureDataPrefix = (p) => {
        if (typeof p !== 'string' || !p) return p;
        // If it starts with /, it's already absolute
        if (p.startsWith('/')) return p;
        // Otherwise, prefix with /data/
        return `/data/${p}`;
      };
      const normalizeInput = (inp) => Array.isArray(inp)
        ? inp.map(ensureDataPrefix)
        : (typeof inp === 'string' ? [ensureDataPrefix(inp)] : null);

      const CSV_PATHS = Array.isArray(providedData)
        ? normalizeInput(providedData)
        : (typeof providedData === 'string' ? normalizeInput(providedData) || [DEFAULT_CSV] : [
            DEFAULT_CSV,
            './assets/data/rl_reward_curves.csv',
            '../assets/data/rl_reward_curves.csv',
            '../../assets/data/rl_reward_curves.csv'
          ]);

      const fetchFirstAvailable = async (paths) => {
        const errors = [];
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
            errors.push(`${p}: ${r.status}`);
          } catch (e) {
            errors.push(`${p}: ${e.message}`);
          }
        }
        throw new Error(`CSV not found. Tried:\n${errors.join('\n')}`);
      };

      // Tooltip setup
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease',
          zIndex: '1000'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gBands = gRoot.append('g').attr('class', 'bands');
      const gLines = gRoot.append('g').attr('class', 'lines');
      const gAxes = gRoot.append('g').attr('class', 'axes');

      // State
      let width = 800, height = 400;
      const margin = { top: 16, right: 64, bottom: 56, left: 64 };
      let rawData = {}; // Store both datasets
      let rewardSeries = [];
      let lengthSeries = [];
      let hiddenSeries = new Set();
      let showRunningAverage = true;
      const RUNNING_AVG_WINDOW = 50; // steps

      // Define colors for reward and length
      const REWARD_COLOR = '#4E79A7';
      const LENGTH_COLOR = '#F28E2B';

      // Color setup
      const getColors = (count) => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          return window.ColorPalettes.getColors('categorical', count);
        }
        // Fallback colors
        return ['#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F', '#EDC948'];
      };

      // Calculate running average based on step window
      function calculateRunningAverage(points, windowSize) {
        if (points.length === 0) return [];

        const avgPoints = [];
        for (let i = 0; i < points.length; i++) {
          const currentStep = points[i].step;
          const minStep = currentStep - windowSize;

          // Find all points within the window
          const windowPoints = points.filter(p => p.step >= minStep && p.step <= currentStep);

          if (windowPoints.length > 0) {
            const avgMean = d3.mean(windowPoints, p => p.mean);
            const avgMin = d3.mean(windowPoints, p => p.min);
            const avgMax = d3.mean(windowPoints, p => p.max);

            avgPoints.push({
              step: currentStep,
              mean: avgMean,
              min: avgMin,
              max: avgMax
            });
          }
        }

        return avgPoints;
      }

      function parseData(csvText, metricType) {
        const rows = d3.csvParse(csvText);

        // Determine metric column suffix based on type
        const metricSuffix = metricType === 'reward'
          ? 'train/reward'
          : 'train/completions/mean_terminated_length';

        // Extract run names (each run has _step, mean, MIN, MAX columns)
        const runNames = [];
        const headers = Object.keys(rows[0]);

        headers.forEach(h => {
          if (h.includes(` - ${metricSuffix}`) && !h.includes('MIN') && !h.includes('MAX')) {
            const runName = h.split(' - ')[0];
            runNames.push(runName);
          }
        });

        // For v18.00, just use a simple label
        const displayNameMap = {
          'grpo-SmollM3-3B-GRPO-no-think-v18.00': 'No Penalty'
        };

        // Build series data using train/global_step for x-axis
        const series = runNames.map(runName => {
          const meanCol = `${runName} - ${metricSuffix}`;
          const minCol = `${meanCol}__MIN`;
          const maxCol = `${meanCol}__MAX`;

          const points = rows
            .filter(row => row['train/global_step'] && row[meanCol])
            .map(row => ({
              step: +row['train/global_step'],
              mean: +row[meanCol],
              min: +row[minCol],
              max: +row[maxCol]
            }))
            .filter(p => !isNaN(p.step) && !isNaN(p.mean));

          // Calculate running average
          const runningAvgPoints = calculateRunningAverage(points, RUNNING_AVG_WINDOW);

          // Map to display name
          const displayName = displayNameMap[runName] || runName;

          return {
            name: displayName,
            fullName: runName,
            points,
            runningAvgPoints
          };
        });

        // Store in appropriate series array
        if (metricType === 'reward') {
          rewardSeries = series;
        } else {
          lengthSeries = series;
        }
      }

      function updateSize() {
        width = container.clientWidth || 800;
        height = Math.max(320, Math.round(width / 2.5));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      }

      function render() {
        const { innerWidth, innerHeight } = updateSize();
        if (rewardSeries.length === 0 || lengthSeries.length === 0) return;

        // Filter visible series for both metrics
        const visibleReward = rewardSeries.filter(s => !hiddenSeries.has(`reward-${s.name}`));
        const visibleLength = lengthSeries.filter(s => !hiddenSeries.has(`length-${s.name}`));

        // Select which points to use based on running average toggle
        const getPoints = (s) => showRunningAverage ? s.runningAvgPoints : s.points;

        // Get all points for x-domain calculation
        const allRewardPoints = visibleReward.flatMap(s => getPoints(s));
        const allLengthPoints = visibleLength.flatMap(s => getPoints(s));

        // X scale (shared)
        const maxStep = Math.max(
          d3.max(allRewardPoints, d => d.step) || 0,
          d3.max(allLengthPoints, d => d.step) || 0
        );
        const xScale = d3.scaleLinear()
          .domain([0, maxStep || 1])
          .range([0, innerWidth])
          .nice();

        // Y scales (dual axes)
        const minReward = d3.min(allRewardPoints, d => d.mean);
        const maxReward = d3.max(allRewardPoints, d => d.mean);
        const yScaleReward = d3.scaleLinear()
          .domain([minReward * 0.95, maxReward * 1.05])
          .range([innerHeight, 0]);

        const minLength = d3.min(allLengthPoints, d => d.mean);
        const maxLength = d3.max(allLengthPoints, d => d.mean);
        const yScaleLength = d3.scaleLinear()
          .domain([minLength * 0.95, maxLength * 1.05])
          .range([innerHeight, 0]);

        // Grid (based on left axis - reward)
        gGrid.selectAll('.grid-y').data([0])
          .join('g')
          .attr('class', 'grid grid-y')
          .call(d3.axisLeft(yScaleReward)
            .tickSize(-innerWidth)
            .tickFormat('')
          )
          .call(g => g.select('.domain').remove());

        // Line generators
        const rewardLine = d3.line()
          .x(d => xScale(d.step))
          .y(d => yScaleReward(d.mean))
          .curve(d3.curveMonotoneX);

        const lengthLine = d3.line()
          .x(d => xScale(d.step))
          .y(d => yScaleLength(d.mean))
          .curve(d3.curveMonotoneX);

        // Render reward lines
        gLines.selectAll('.line.reward')
          .data(visibleReward, d => `reward-${d.name}`)
          .join('path')
          .attr('class', 'line reward')
          .attr('d', d => rewardLine(getPoints(d)))
          .attr('stroke', REWARD_COLOR);

        // Render length lines
        gLines.selectAll('.line.length')
          .data(visibleLength, d => `length-${d.name}`)
          .join('path')
          .attr('class', 'line length')
          .attr('d', d => lengthLine(getPoints(d)))
          .attr('stroke', LENGTH_COLOR);

        // Axes
        const xAxis = gAxes.selectAll('.x-axis').data([0])
          .join('g')
          .attr('class', 'x-axis axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).ticks(Math.min(10, Math.floor(innerWidth / 80))));

        const yAxisLeft = gAxes.selectAll('.y-axis-left').data([0])
          .join('g')
          .attr('class', 'y-axis-left axis')
          .call(d3.axisLeft(yScaleReward).ticks(8))
          .call(g => g.selectAll('.tick line').attr('stroke', REWARD_COLOR).attr('opacity', 0.3))
          .call(g => g.selectAll('.tick text').attr('fill', REWARD_COLOR));

        const yAxisRight = gAxes.selectAll('.y-axis-right').data([0])
          .join('g')
          .attr('class', 'y-axis-right axis')
          .attr('transform', `translate(${innerWidth},0)`)
          .call(d3.axisRight(yScaleLength).ticks(8))
          .call(g => g.selectAll('.tick line').attr('stroke', LENGTH_COLOR).attr('opacity', 0.3))
          .call(g => g.selectAll('.tick text').attr('fill', LENGTH_COLOR));

        // Axis labels
        gAxes.selectAll('.x-label').data([0])
          .join('text')
          .attr('class', 'x-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 45)
          .text('Training step');

        gAxes.selectAll('.y-label-left').data([0])
          .join('text')
          .attr('class', 'y-label-left axis-label reward')
          .attr('text-anchor', 'middle')
          .attr('transform', `translate(-48,${innerHeight / 2}) rotate(-90)`)
          .text('Reward');

        gAxes.selectAll('.y-label-right').data([0])
          .join('text')
          .attr('class', 'y-label-right axis-label length')
          .attr('text-anchor', 'middle')
          .attr('transform', `translate(${innerWidth + 48},${innerHeight / 2}) rotate(90)`)
          .text('Mean Terminated Length');

        // Set CSS variables for colors
        document.documentElement.style.setProperty('--reward-color', REWARD_COLOR);
        document.documentElement.style.setProperty('--length-color', LENGTH_COLOR);

        // Tooltip interactions
        const bisect = d3.bisector(d => d.step).left;

        svg.on('mousemove', function(event) {
          const [mx] = d3.pointer(event, gRoot.node());
          const step = xScale.invert(mx);

          let tooltipHtml = `<strong>Step: ${Math.round(step)}</strong>`;
          if (showRunningAverage) {
            tooltipHtml += ` <span style="font-weight:normal;font-size:11px">(${RUNNING_AVG_WINDOW}-step avg)</span>`;
          }
          tooltipHtml += `<br/>`;

          // Add reward values
          visibleReward.forEach(s => {
            const points = getPoints(s);
            const idx = bisect(points, step);
            if (idx > 0 && idx < points.length) {
              const p = points[idx];
              const valueStr = `${(p.mean * 100).toFixed(1)}%`;
              tooltipHtml += `<div style="margin-top:4px"><span style="color:${REWARD_COLOR}">●</span> Reward: ${valueStr}</div>`;
            }
          });

          // Add length values
          visibleLength.forEach(s => {
            const points = getPoints(s);
            const idx = bisect(points, step);
            if (idx > 0 && idx < points.length) {
              const p = points[idx];
              const valueStr = `${p.mean.toFixed(1)} tokens`;
              tooltipHtml += `<div style="margin-top:4px"><span style="color:${LENGTH_COLOR}">●</span> Length: ${valueStr}</div>`;
            }
          });

          tipInner.innerHTML = tooltipHtml;
          const tipBounds = tip.getBoundingClientRect();
          const [px, py] = d3.pointer(event, container);

          let tipX = px + 12;
          let tipY = py - 12;

          if (tipX + tipBounds.width > width - 10) {
            tipX = px - tipBounds.width - 12;
          }
          if (tipY - tipBounds.height < 10) {
            tipY = py + 20;
          }

          tip.style.transform = `translate(${tipX}px, ${tipY}px)`;
          tip.style.opacity = '1';
        });

        svg.on('mouseleave', () => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
        });
      }

      function makeLegend() {
        let header = container.querySelector('.header');
        if (!header) {
          header = document.createElement('div');
          header.className = 'header';
          container.appendChild(header);
        }

        let legend = header.querySelector('.legend');
        if (!legend) {
          legend = document.createElement('div');
          legend.className = 'legend';
          header.appendChild(legend);
        }

        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.textContent = 'Legend';
          legend.appendChild(title);
        } else {
          title.textContent = 'Legend';
        }

        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }

        items.innerHTML = '';

        // Add reward legend item
        const rewardItem = document.createElement('span');
        rewardItem.className = 'item';

        const rewardSwatch = document.createElement('span');
        rewardSwatch.className = 'swatch';
        rewardSwatch.style.background = REWARD_COLOR;

        const rewardText = document.createElement('span');
        rewardText.textContent = 'Reward';

        rewardItem.appendChild(rewardSwatch);
        rewardItem.appendChild(rewardText);
        items.appendChild(rewardItem);

        // Add length legend item
        const lengthItem = document.createElement('span');
        lengthItem.className = 'item';

        const lengthSwatch = document.createElement('span');
        lengthSwatch.className = 'swatch';
        lengthSwatch.style.background = LENGTH_COLOR;

        const lengthText = document.createElement('span');
        lengthText.textContent = 'Mean Terminated Length';

        lengthItem.appendChild(lengthSwatch);
        lengthItem.appendChild(lengthText);
        items.appendChild(lengthItem);
      }

      function makeControls() {
        // No controls needed for dual-axis view
        // This function is kept for consistency but does nothing
      }

      // Load both datasets
      const REWARD_PATHS = [
        '/data/rl_reward_full_length.csv',
        './assets/data/rl_reward_full_length.csv',
        '../assets/data/rl_reward_full_length.csv',
        '../../assets/data/rl_reward_full_length.csv'
      ];

      const LENGTH_PATHS = [
        '/data/rl_mean_terminated_length_full_length.csv',
        './assets/data/rl_mean_terminated_length_full_length.csv',
        '../assets/data/rl_mean_terminated_length_full_length.csv',
        '../../assets/data/rl_mean_terminated_length_full_length.csv'
      ];

      Promise.all([
        fetchFirstAvailable(REWARD_PATHS),
        fetchFirstAvailable(LENGTH_PATHS)
      ])
        .then(([rewardCsvText, lengthCsvText]) => {
          // Store both datasets
          rawData.reward = rewardCsvText;
          rawData.length = lengthCsvText;

          // Parse both datasets
          parseData(rewardCsvText, 'reward');
          parseData(lengthCsvText, 'length');

          makeLegend();
          makeControls();
          render();

          // Responsiveness
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.color = '#f44336';
          pre.style.fontSize = '12px';
          pre.style.padding = '12px';
          pre.textContent = `Error loading data: ${err.message}`;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">Naively applying RLVR to smollm3 achieve high reward and improvements to downstream performance. But we observe an explosion in the completion lengths. The model achieves its improvement by producing more tokens, making the model transition to a long COT reasoning model. This is undersired, we want the model to retain its short reponses while improving the instruct mode performance.</figcaption></figure>
<p>In other words, RLVR with GRPO has converted the  <code>/no_think</code>  mode of our reasoning model into one which looks very similar to the  <code>/think</code>  mode!</p>
<p>When we review the model’s completions, we see that the model now generates long CoT and even includes classic reasoning model grammar such as “Wait, …”. An example of this is shown below:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>However, since the jogger and the train are moving in the same direction, the relative speed between them is the difference of their speeds:</span></span>
<span class="line"><span>\\( v_{\\text{rel}} = v_t - v_j = 12.7778 - 2.7778 = 10 \\) m/s</span></span>
<span class="line"><span></span></span>
<span class="line"><span> **Wait,**  let me double-check the calculation:</span></span>
<span class="line"><span></span></span>
<span class="line"><span> **Wait,**  46 km/hr to m/s:</span></span>
<span class="line"><span>46 * 1000 m / 3600 s = (46 * 10)/36 = 460/36 ≈ 12.7778 m/s (correct)</span></span>
<span class="line"><span>10 km/hr is:</span></span>
<span class="line"><span>10 * 1000 / 3600 = 10000 / 3600 ≈ 2.7778 m/s (correct)</span></span>
<span class="line"><span>Difference: 12.7778 - 2.7778 = 10 m/s (exact, since 46-10=36 km/hr → 36*(1000/3600)=10 m/s exactly)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>The jogger is 340 meters ahead of the train&#39;s engine. When the train passes the jogger, the distance the train needs to cover relative to the jogger is 340 meters plus the length of the train? Wait, actually, let me think about the problem again.</span></span>
<span class="line"><span></span></span>
<span class="line"><span> **Wait,**  actually, when the problem says the train takes 46 seconds to pass the jogger, that usually means the time from the front of the train to the end passing the jogger. The length of the train would then be equal to the relative speed multiplied by the time.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>But first, the initial position: the jogger is 340 meters ahead of the engine. So the engine is 340 meters ahead of the jogger. Wait no, the wording says &quot;340 m ahead of the engine&quot;, so the jogger is ahead by 340 meters. So when the jogger is running alongside, the engine of the train is 340 m away behind the jogger? Wait, maybe I need to clarify.</span></span>
<span class="line"><span></span></span>
<span class="line"><span> **Wait**  the problem says: &quot;A jogger running at 10 km/hr alongside a railway track is 340 m ahead of the engine of a train running at 46 km/hr in the same direction. The train takes 46 seconds to pass the jogger. How long is the train in meters?&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Hmm, so the jogger is 340 m ahead of the engine along the track. Since they&#39;re moving in the same direction, the train is behind the jogger by 340 meters. To pass the jogger, the train has to cover that 340 meters plus the length of the train itself?</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre></div>
<p>This issue can mitigated with an additional overlong completion penalty, that penalizes completions over a certain length. The penalty is parameterized by two arguments max completion length  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> and soft punishment cache  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>c</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{cache}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span> . This penalty was one of the improvements proposed in the DAPO paper <span class="" id="citation--dapo--151">(<a href="https://arxiv.org/abs/2503.14476" id="refctx-bib-dapo-1" data-ref-id="bib-dapo" target="_blank" rel="noopener noreferrer">Yu et al., 2025</a>)</span> and amounts to applying a reward function as follows:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>R</mi><mtext>length</mtext></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><msub><mi>L</mi><mtext>max</mtext></msub><mo>−</mo><msub><mi>L</mi><mtext>cache</mtext></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>L</mi><mtext>max</mtext></msub><mo>−</mo><msub><mi>L</mi><mtext>cache</mtext></msub><mo>−</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><msub><mi>L</mi><mtext>cache</mtext></msub></mfrac><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>L</mi><mtext>max</mtext></msub><mo>−</mo><msub><mi>L</mi><mtext>cache</mtext></msub><mo>&lt;</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><msub><mi>L</mi><mtext>max</mtext></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>L</mi><mtext>max</mtext></msub><mo>&lt;</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
R_{\text{length}}(y) = \begin{cases}
0, &amp; |y| \le L_{\text{max}} - L_{\text{cache}} \\
\frac{(L_{\text{max}} - L_{\text{cache}} - |y|)}{L_{\text{cache}}}, &amp; L_{\text{max}} - L_{\text{cache}} &lt; |y| \le L_{\text{max}} \\
-1, &amp; L_{\text{max}} &lt; |y|
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">length</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:4.3409em;vertical-align:-1.9204em"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em"><span style="top:-2.2em"><span class="pstrut" style="height:3.15em"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em"><span class="pstrut" style="height:3.15em"></span><span style="height:0.316em;width:0.8889em"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"></path></svg></span></span><span style="top:-3.15em"><span class="pstrut" style="height:3.15em"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em"><span class="pstrut" style="height:3.15em"></span><span style="height:0.316em;width:0.8889em"><svg xmlns="http://www.w3.org/2000/svg" width="0.8889em" height="0.316em" style="width:0.8889em" viewBox="0 0 888.89 316" preserveAspectRatio="xMinYMin"><path d="M384 0 H504 V316 H384z M384 0 H504 V316 H384z"></path></svg></span></span><span style="top:-4.6em"><span class="pstrut" style="height:3.15em"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.4204em"><span style="top:-4.4224em"><span class="pstrut" style="height:3.01em"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span></span></span><span style="top:-2.9804em"><span class="pstrut" style="height:3.01em"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">cache</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.485em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">cache</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">∣</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span><span class="mord mtight">∣</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4509em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span></span></span><span style="top:-1.5216em"><span class="pstrut" style="height:3.01em"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9204em"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.4204em"><span style="top:-4.4224em"><span class="pstrut" style="height:3.01em"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">cache</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.9804em"><span class="pstrut" style="height:3.01em"></span><span class="mord"><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">cache</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span><span style="top:-1.5216em"><span class="pstrut" style="height:3.01em"></span><span class="mord"><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">max</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9204em"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<p>Using this penalty you can directly control the model’s output distribution and the tradeoff between increasing length and performance. Where we vary the overlong penalty from 1.5k to 4k in steps of 512 tokens.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-jt4y7vsgjem"><div class="d3-grpo-reward-curves"></div>
<style>
  .d3-grpo-reward-curves {
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    position: relative;
  }

  .d3-grpo-reward-curves svg {
    display: block;
    width: 100%;
  }

  .d3-grpo-reward-curves .axis path {
    stroke: none;
  }

  .d3-grpo-reward-curves .axis line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }

  .d3-grpo-reward-curves .axis text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-grpo-reward-curves .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2,2;
  }

  .d3-grpo-reward-curves .confidence-band {
    opacity: 0.15;
  }

  .d3-grpo-reward-curves .line {
    fill: none;
    stroke-width: 2;
    stroke-linejoin: round;
    stroke-linecap: round;
  }

  .d3-grpo-reward-curves .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .d3-grpo-reward-curves .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 16px;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
  }

  .d3-grpo-reward-curves .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-grpo-reward-curves .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-grpo-reward-curves .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-grpo-reward-curves .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
    cursor: pointer;
    user-select: none;
    opacity: 1;
    transition: opacity 0.2s ease;
  }

  .d3-grpo-reward-curves .legend .item.dimmed {
    opacity: 0.3;
  }

  .d3-grpo-reward-curves .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-grpo-reward-curves .controls {
    display: flex;
    gap: 16px;
    align-items: center;
    justify-content: flex-end;
    flex-wrap: wrap;
  }

  .d3-grpo-reward-curves .controls .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-grpo-reward-curves .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-grpo-reward-curves .controls .toggle-group {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .d3-grpo-reward-curves .controls .toggle-btn {
    padding: 6px 12px;
    font-size: 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .d3-grpo-reward-curves .controls .toggle-btn:hover {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
  }

  .d3-grpo-reward-curves .controls .toggle-btn.active {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-grpo-reward-curves'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-grpo-reward-curves'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Data loading configuration
      let mountEl = container;
      while (mountEl && !mountEl.getAttribute?.('data-datafiles')) {
        mountEl = mountEl.parentElement;
      }
      let providedData = null;
      try {
        const attr = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-datafiles') : null;
        if (attr && attr.trim()) {
          providedData = attr.trim().startsWith('[') ? JSON.parse(attr) : attr.trim();
        }
      } catch (_) {}

      const DEFAULT_CSV = '/data/rl_reward_curves.csv';
      const ensureDataPrefix = (p) => {
        if (typeof p !== 'string' || !p) return p;
        // If it starts with /, it's already absolute
        if (p.startsWith('/')) return p;
        // Otherwise, prefix with /data/
        return `/data/${p}`;
      };
      const normalizeInput = (inp) => Array.isArray(inp)
        ? inp.map(ensureDataPrefix)
        : (typeof inp === 'string' ? [ensureDataPrefix(inp)] : null);

      const CSV_PATHS = Array.isArray(providedData)
        ? normalizeInput(providedData)
        : (typeof providedData === 'string' ? normalizeInput(providedData) || [DEFAULT_CSV] : [
            DEFAULT_CSV,
            './assets/data/rl_reward_curves.csv',
            '../assets/data/rl_reward_curves.csv',
            '../../assets/data/rl_reward_curves.csv'
          ]);

      const fetchFirstAvailable = async (paths) => {
        const errors = [];
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
            errors.push(`${p}: ${r.status}`);
          } catch (e) {
            errors.push(`${p}: ${e.message}`);
          }
        }
        throw new Error(`CSV not found. Tried:\n${errors.join('\n')}`);
      };

      // Tooltip setup
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease',
          zIndex: '1000'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gBands = gRoot.append('g').attr('class', 'bands');
      const gLines = gRoot.append('g').attr('class', 'lines');
      const gAxes = gRoot.append('g').attr('class', 'axes');

      // State
      let width = 800, height = 400;
      const margin = { top: 16, right: 28, bottom: 56, left: 64 };
      let rawData = {}; // Store both datasets
      let series = [];
      let hiddenSeries = new Set();
      let showRunningAverage = true;
      let currentMetric = 'reward'; // 'reward' or 'length'
      const RUNNING_AVG_WINDOW = 50; // steps

      // Color setup
      const getColors = (count) => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          return window.ColorPalettes.getColors('categorical', count);
        }
        // Fallback colors
        return ['#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F', '#EDC948'];
      };

      // Calculate running average based on step window
      function calculateRunningAverage(points, windowSize) {
        if (points.length === 0) return [];

        const avgPoints = [];
        for (let i = 0; i < points.length; i++) {
          const currentStep = points[i].step;
          const minStep = currentStep - windowSize;

          // Find all points within the window
          const windowPoints = points.filter(p => p.step >= minStep && p.step <= currentStep);

          if (windowPoints.length > 0) {
            const avgMean = d3.mean(windowPoints, p => p.mean);
            const avgMin = d3.mean(windowPoints, p => p.min);
            const avgMax = d3.mean(windowPoints, p => p.max);

            avgPoints.push({
              step: currentStep,
              mean: avgMean,
              min: avgMin,
              max: avgMax
            });
          }
        }

        return avgPoints;
      }

      function parseData(csvText, metricType) {
        const rows = d3.csvParse(csvText);

        // Determine metric column suffix based on type
        const metricSuffix = metricType === 'reward'
          ? 'train/rewards/strip_reasoning_accuracy_reward/mean'
          : 'train/completions/mean_terminated_length';

        // Extract run names (each run has _step, mean, MIN, MAX columns)
        const runNames = [];
        const headers = Object.keys(rows[0]);

        headers.forEach(h => {
          if (h.includes(` - ${metricSuffix}`) && !h.includes('MIN') && !h.includes('MAX')) {
            const runName = h.split(' - ')[0];
            runNames.push(runName);
          }
        });

        // Mapping of v27.x to overlong penalty ranges
        const penaltyRangeMap = {
          'v27.00': '1.5-2k',
          'v27.01': '2-2.5k',
          'v27.02': '2.5-3k',
          'v27.03': '3-3.5k',
          'v27.04': '3.5-4k',
          'v27.05': '4-4.5k'
        };

        // Build series data using train/global_step for x-axis
        series = runNames.map(runName => {
          const meanCol = `${runName} - ${metricSuffix}`;
          const minCol = `${meanCol}__MIN`;
          const maxCol = `${meanCol}__MAX`;

          const points = rows
            .filter(row => row['train/global_step'] && row[meanCol])
            .map(row => ({
              step: +row['train/global_step'],
              mean: +row[meanCol],
              min: +row[minCol],
              max: +row[maxCol]
            }))
            .filter(p => !isNaN(p.step) && !isNaN(p.mean));

          // Calculate running average
          const runningAvgPoints = calculateRunningAverage(points, RUNNING_AVG_WINDOW);

          // Extract version from run name
          const versionMatch = runName.match(/v(\d+\.\d+)/);
          const version = versionMatch ? `v${versionMatch[1]}` : runName;

          // Map to penalty range label
          const displayName = penaltyRangeMap[version] || version;

          return {
            name: displayName,
            version: version, // Keep original version for sorting
            fullName: runName,
            points,
            runningAvgPoints
          };
        });

        // Sort series by version number to get correct order
        series.sort((a, b) => {
          const getVersionNum = (v) => {
            const match = v.version?.match(/v(\d+)\.(\d+)/);
            return match ? parseFloat(`${match[1]}.${match[2]}`) : 0;
          };
          return getVersionNum(a) - getVersionNum(b);
        });
      }

      function updateSize() {
        width = container.clientWidth || 800;
        height = Math.max(320, Math.round(width / 2.5));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      }

      function render() {
        const { innerWidth, innerHeight } = updateSize();
        if (series.length === 0) return;

        // Filter visible series
        const visibleSeries = series.filter(s => !hiddenSeries.has(s.name));
        if (visibleSeries.length === 0) return;

        // Select which points to use based on running average toggle
        const getPoints = (s) => showRunningAverage ? s.runningAvgPoints : s.points;

        // Filter points to limit x-axis to 500 steps and y-axis based on metric
        const MAX_STEPS = 500;
        const getFilteredPoints = (s) => {
          const pts = getPoints(s);
          if (currentMetric === 'reward') {
            const MIN_REWARD = 0.55;
            const MAX_REWARD = 0.9;
            return pts.filter(p => p.step <= MAX_STEPS && p.mean >= MIN_REWARD && p.mean <= MAX_REWARD);
          } else {
            // For length, no y-axis filtering
            return pts.filter(p => p.step <= MAX_STEPS);
          }
        };

        // Get all points for domain calculation
        const allPoints = visibleSeries.flatMap(s => getFilteredPoints(s));

        // Scales
        const xScale = d3.scaleLinear()
          .domain([0, MAX_STEPS])
          .range([0, innerWidth])
          .nice();

        // Set y-axis domain based on current metric
        let yDomain;
        if (currentMetric === 'reward') {
          yDomain = [0.55, 0.9];
        } else {
          // For length, calculate from data
          const minVal = d3.min(allPoints, d => d.mean);
          const maxVal = d3.max(allPoints, d => d.mean);
          yDomain = [minVal * 0.95, maxVal * 1.05];
        }

        const yScale = d3.scaleLinear()
          .domain(yDomain)
          .range([innerHeight, 0]);

        // Grid
        gGrid.selectAll('.grid-y').data([0])
          .join('g')
          .attr('class', 'grid grid-y')
          .call(d3.axisLeft(yScale)
            .tickSize(-innerWidth)
            .tickFormat('')
          )
          .call(g => g.select('.domain').remove());

        // Colors
        const colors = getColors(series.length);
        const colorScale = (name) => {
          const idx = series.findIndex(s => s.name === name);
          return colors[idx % colors.length];
        };

        // Line generator
        const line = d3.line()
          .x(d => xScale(d.step))
          .y(d => yScale(d.mean))
          .curve(d3.curveMonotoneX);

        // Render lines
        gLines.selectAll('.line')
          .data(visibleSeries, d => d.name)
          .join('path')
          .attr('class', 'line')
          .attr('d', d => line(getFilteredPoints(d)))
          .attr('stroke', d => colorScale(d.name));

        // Axes
        const xAxis = gAxes.selectAll('.x-axis').data([0])
          .join('g')
          .attr('class', 'x-axis axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).ticks(Math.min(10, Math.floor(innerWidth / 80))));

        const yAxis = gAxes.selectAll('.y-axis').data([0])
          .join('g')
          .attr('class', 'y-axis axis')
          .call(d3.axisLeft(yScale).ticks(8));

        // Axis labels
        gAxes.selectAll('.x-label').data([0])
          .join('text')
          .attr('class', 'x-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 45)
          .text('Training step');

        gAxes.selectAll('.y-label').data([0])
          .join('text')
          .attr('class', 'y-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('transform', `translate(-48,${innerHeight / 2}) rotate(-90)`)
          .text(currentMetric === 'reward' ? 'Reward' : 'Mean Terminated Length');

        // Tooltip interactions
        const bisect = d3.bisector(d => d.step).left;

        svg.on('mousemove', function(event) {
          const [mx] = d3.pointer(event, gRoot.node());
          const step = xScale.invert(mx);

          let tooltipHtml = `<strong>Step: ${Math.round(step)}</strong>`;
          if (showRunningAverage) {
            tooltipHtml += ` <span style="font-weight:normal;font-size:11px">(${RUNNING_AVG_WINDOW}-step avg)</span>`;
          }
          tooltipHtml += `<br/>`;

          visibleSeries.forEach(s => {
            const points = getFilteredPoints(s);
            const idx = bisect(points, step);
            if (idx > 0 && idx < points.length) {
              const p = points[idx];
              const color = colorScale(s.name);
              const valueStr = currentMetric === 'reward'
                ? `${(p.mean * 100).toFixed(1)}%`
                : `${p.mean.toFixed(1)} tokens`;
              tooltipHtml += `<div style="margin-top:4px"><span style="color:${color}">●</span> ${s.name}: ${valueStr}</div>`;
            }
          });

          tipInner.innerHTML = tooltipHtml;
          const tipBounds = tip.getBoundingClientRect();
          const [px, py] = d3.pointer(event, container);

          let tipX = px + 12;
          let tipY = py - 12;

          if (tipX + tipBounds.width > width - 10) {
            tipX = px - tipBounds.width - 12;
          }
          if (tipY - tipBounds.height < 10) {
            tipY = py + 20;
          }

          tip.style.transform = `translate(${tipX}px, ${tipY}px)`;
          tip.style.opacity = '1';
        });

        svg.on('mouseleave', () => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
        });
      }

      function makeLegend() {
        let header = container.querySelector('.header');
        if (!header) {
          header = document.createElement('div');
          header.className = 'header';
          container.appendChild(header);
        }

        let legend = header.querySelector('.legend');
        if (!legend) {
          legend = document.createElement('div');
          legend.className = 'legend';
          header.appendChild(legend);
        }

        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.innerHTML = 'Overlong penalty (L<sub>cache</sub> - L<sub>max</sub>)';
          legend.appendChild(title);
        } else {
          title.innerHTML = 'Overlong penalty (L<sub>cache</sub> - L<sub>max</sub>)';
        }

        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }

        const colors = getColors(series.length);

        items.innerHTML = '';
        series.forEach((s, i) => {
          const item = document.createElement('span');
          item.className = 'item';
          if (hiddenSeries.has(s.name)) {
            item.classList.add('dimmed');
          }

          const swatch = document.createElement('span');
          swatch.className = 'swatch';
          swatch.style.background = colors[i % colors.length];

          const text = document.createElement('span');
          text.textContent = s.name;

          item.appendChild(swatch);
          item.appendChild(text);
          items.appendChild(item);

          item.addEventListener('click', () => {
            if (hiddenSeries.has(s.name)) {
              hiddenSeries.delete(s.name);
            } else {
              hiddenSeries.add(s.name);
            }
            makeLegend();
            render();
          });
        });
      }

      function makeControls() {
        let header = container.querySelector('.header');
        if (!header) {
          header = document.createElement('div');
          header.className = 'header';
          container.appendChild(header);
        }

        let controls = header.querySelector('.controls');
        if (!controls) {
          controls = document.createElement('div');
          controls.className = 'controls';
          header.appendChild(controls);
        }

        controls.innerHTML = '';

        // Metric selection group
        const metricGroup = document.createElement('div');
        metricGroup.className = 'control-group';

        const metricLabel = document.createElement('label');
        metricLabel.textContent = 'Metric';
        metricGroup.appendChild(metricLabel);

        const metricToggleGroup = document.createElement('div');
        metricToggleGroup.className = 'toggle-group';

        const rewardBtn = document.createElement('button');
        rewardBtn.className = 'toggle-btn' + (currentMetric === 'reward' ? ' active' : '');
        rewardBtn.textContent = 'Reward';
        rewardBtn.addEventListener('click', () => {
          if (currentMetric !== 'reward') {
            currentMetric = 'reward';
            parseData(rawData.reward, 'reward');
            makeControls();
            makeLegend();
            render();
          }
        });

        const lengthBtn = document.createElement('button');
        lengthBtn.className = 'toggle-btn' + (currentMetric === 'length' ? ' active' : '');
        lengthBtn.textContent = 'Length';
        lengthBtn.addEventListener('click', () => {
          if (currentMetric !== 'length') {
            currentMetric = 'length';
            parseData(rawData.length, 'length');
            makeControls();
            makeLegend();
            render();
          }
        });

        metricToggleGroup.appendChild(rewardBtn);
        metricToggleGroup.appendChild(lengthBtn);
        metricGroup.appendChild(metricToggleGroup);
        controls.appendChild(metricGroup);
      }

      // Load both datasets
      const REWARD_PATHS = [
        '/data/rl_reward_curves.csv',
        './assets/data/rl_reward_curves.csv',
        '../assets/data/rl_reward_curves.csv',
        '../../assets/data/rl_reward_curves.csv'
      ];

      const LENGTH_PATHS = [
        '/data/rl_mean_teminated_lengths.csv',
        './assets/data/rl_mean_teminated_lengths.csv',
        '../assets/data/rl_mean_teminated_lengths.csv',
        '../../assets/data/rl_mean_teminated_lengths.csv'
      ];

      Promise.all([
        fetchFirstAvailable(REWARD_PATHS),
        fetchFirstAvailable(LENGTH_PATHS)
      ])
        .then(([rewardCsvText, lengthCsvText]) => {
          // Store both datasets
          rawData.reward = rewardCsvText;
          rawData.length = lengthCsvText;

          // Initialize with reward data
          parseData(rewardCsvText, 'reward');
          makeLegend();
          makeControls();
          render();

          // Responsiveness
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.color = '#f44336';
          pre.style.fontSize = '12px';
          pre.style.padding = '12px';
          pre.textContent = `Error loading data: ${err.message}`;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">The tradeoff between higher reward and longer completion lengths, when training Smollm3 with RL on verifable Math problems and an overlong penalty.</figcaption></figure>
<p>This tradeoff is better shown in the downstream performance on the AIME25 benchmark:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-lv5ml3c7afh"><div class="d3-grpo-aime25"></div>
<style>
  .d3-grpo-aime25 {
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    position: relative;
  }

  .d3-grpo-aime25 svg {
    display: block;
    width: 100%;
  }

  .d3-grpo-aime25 .axis path {
    stroke: none;
  }

  .d3-grpo-aime25 .axis line {
    stroke: var(--axis-color);
    shape-rendering: crispEdges;
  }

  .d3-grpo-aime25 .axis text {
    fill: var(--tick-color);
    font-size: 11px;
  }

  .d3-grpo-aime25 .grid line {
    stroke: var(--grid-color);
    stroke-dasharray: 2,2;
  }

  .d3-grpo-aime25 .line {
    fill: none;
    stroke-width: 2.5;
    stroke-linejoin: round;
    stroke-linecap: round;
  }

  .d3-grpo-aime25 .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .d3-grpo-aime25 .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 16px;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
  }

  .d3-grpo-aime25 .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-grpo-aime25 .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-grpo-aime25 .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-grpo-aime25 .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
    cursor: pointer;
    user-select: none;
    opacity: 1;
    transition: opacity 0.2s ease;
  }

  .d3-grpo-aime25 .legend .item.dimmed {
    opacity: 0.3;
  }

  .d3-grpo-aime25 .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-grpo-aime25 .controls {
    display: flex;
    gap: 16px;
    align-items: center;
    justify-content: flex-end;
    flex-wrap: wrap;
  }

  .d3-grpo-aime25 .controls .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-grpo-aime25 .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-grpo-aime25 .controls .toggle-group {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .d3-grpo-aime25 .controls .toggle-btn {
    padding: 6px 12px;
    font-size: 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .d3-grpo-aime25 .controls .toggle-btn:hover {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
  }

  .d3-grpo-aime25 .controls .toggle-btn.active {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-grpo-aime25'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-grpo-aime25'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Data loading configuration
      let mountEl = container;
      while (mountEl && !mountEl.getAttribute?.('data-datafiles')) {
        mountEl = mountEl.parentElement;
      }
      let providedData = null;
      try {
        const attr = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-datafiles') : null;
        if (attr && attr.trim()) {
          providedData = attr.trim().startsWith('[') ? JSON.parse(attr) : attr.trim();
        }
      } catch (_) {}

      const DEFAULT_CSV = '/data/aime25_perf.csv';
      const ensureDataPrefix = (p) => {
        if (typeof p !== 'string' || !p) return p;
        if (p.startsWith('/')) return p;
        return `/data/${p}`;
      };
      const normalizeInput = (inp) => Array.isArray(inp)
        ? inp.map(ensureDataPrefix)
        : (typeof inp === 'string' ? [ensureDataPrefix(inp)] : null);

      const CSV_PATHS = Array.isArray(providedData)
        ? normalizeInput(providedData)
        : (typeof providedData === 'string' ? normalizeInput(providedData) || [DEFAULT_CSV] : [
            DEFAULT_CSV,
            './assets/data/aime25_perf.csv',
            '../assets/data/aime25_perf.csv',
            '../../assets/data/aime25_perf.csv'
          ]);

      const fetchFirstAvailable = async (paths) => {
        const errors = [];
        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.text();
            errors.push(`${p}: ${r.status}`);
          } catch (e) {
            errors.push(`${p}: ${e.message}`);
          }
        }
        throw new Error(`CSV not found. Tried:\n${errors.join('\n')}`);
      };

      // Tooltip setup
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease',
          zIndex: '1000'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // SVG setup
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class', 'grid');
      const gLines = gRoot.append('g').attr('class', 'lines');
      const gAxes = gRoot.append('g').attr('class', 'axes');

      // State
      let width = 800, height = 400;
      const margin = { top: 16, right: 28, bottom: 56, left: 64 };
      let series = [];
      let hiddenSeries = new Set();

      // Color setup
      const getColors = (count) => {
        if (window.ColorPalettes && window.ColorPalettes.getColors) {
          return window.ColorPalettes.getColors('categorical', count);
        }
        return ['#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F', '#EDC948'];
      };

      function parseData(csvText) {
        const rows = d3.csvParse(csvText);

        // Get column names (excluding 'step')
        const headers = Object.keys(rows[0]).filter(h => h !== 'step');

        // Build series data
        series = headers.map(header => {
          const points = rows
            .map(row => ({
              step: +row.step,
              value: +row[header]
            }))
            .filter(p => !isNaN(p.step) && !isNaN(p.value));

          return {
            name: header,
            points
          };
        });
      }

      function updateSize() {
        width = container.clientWidth || 800;
        height = Math.max(320, Math.round(width / 2.5));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        return {
          innerWidth: width - margin.left - margin.right,
          innerHeight: height - margin.top - margin.bottom
        };
      }

      function render() {
        const { innerWidth, innerHeight } = updateSize();
        if (series.length === 0) return;

        // Filter visible series
        const visibleSeries = series.filter(s => !hiddenSeries.has(s.name));
        if (visibleSeries.length === 0) return;

        // Get all points
        const allPoints = visibleSeries.flatMap(s => s.points);

        // Scales
        const xScale = d3.scaleLinear()
          .domain([0, d3.max(allPoints, d => d.step) || 1])
          .range([0, innerWidth])
          .nice();

        const minVal = d3.min(allPoints, d => d.value);
        const maxVal = d3.max(allPoints, d => d.value);
        const yScale = d3.scaleLinear()
          .domain([minVal * 0.95, maxVal * 1.05])
          .range([innerHeight, 0]);

        // Grid
        gGrid.selectAll('.grid-y').data([0])
          .join('g')
          .attr('class', 'grid grid-y')
          .call(d3.axisLeft(yScale)
            .tickSize(-innerWidth)
            .tickFormat('')
          )
          .call(g => g.select('.domain').remove());

        // Colors
        const colors = getColors(series.length);
        const colorScale = (name) => {
          const idx = series.findIndex(s => s.name === name);
          return colors[idx % colors.length];
        };

        // Line generator
        const line = d3.line()
          .x(d => xScale(d.step))
          .y(d => yScale(d.value))
          .curve(d3.curveMonotoneX);

        // Render lines
        gLines.selectAll('.line')
          .data(visibleSeries, d => d.name)
          .join('path')
          .attr('class', 'line')
          .attr('d', d => line(d.points))
          .attr('stroke', d => colorScale(d.name));

        // Axes
        gAxes.selectAll('.x-axis').data([0])
          .join('g')
          .attr('class', 'x-axis axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).ticks(Math.min(10, Math.floor(innerWidth / 80))));

        gAxes.selectAll('.y-axis').data([0])
          .join('g')
          .attr('class', 'y-axis axis')
          .call(d3.axisLeft(yScale).ticks(8));

        // Axis labels
        gAxes.selectAll('.x-label').data([0])
          .join('text')
          .attr('class', 'x-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 45)
          .text('Training step');

        gAxes.selectAll('.y-label').data([0])
          .join('text')
          .attr('class', 'y-label axis-label')
          .attr('text-anchor', 'middle')
          .attr('transform', `translate(-48,${innerHeight / 2}) rotate(-90)`)
          .text('AIME 2025 Score (%)');

        // Tooltip interactions
        const bisect = d3.bisector(d => d.step).left;

        svg.on('mousemove', function(event) {
          const [mx] = d3.pointer(event, gRoot.node());
          const step = xScale.invert(mx);

          let tooltipHtml = `<strong>Step: ${Math.round(step)}</strong><br/>`;

          visibleSeries.forEach(s => {
            const idx = bisect(s.points, step);
            if (idx > 0 && idx < s.points.length) {
              const p = s.points[idx];
              const color = colorScale(s.name);
              tooltipHtml += `<div style="margin-top:4px"><span style="color:${color}">●</span> ${s.name}: ${p.value.toFixed(2)}%</div>`;
            }
          });

          tipInner.innerHTML = tooltipHtml;
          const tipBounds = tip.getBoundingClientRect();
          const [px, py] = d3.pointer(event, container);

          let tipX = px + 12;
          let tipY = py - 12;

          if (tipX + tipBounds.width > width - 10) {
            tipX = px - tipBounds.width - 12;
          }
          if (tipY - tipBounds.height < 10) {
            tipY = py + 20;
          }

          tip.style.transform = `translate(${tipX}px, ${tipY}px)`;
          tip.style.opacity = '1';
        });

        svg.on('mouseleave', () => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
        });
      }

      function makeLegend() {
        let header = container.querySelector('.header');
        if (!header) {
          header = document.createElement('div');
          header.className = 'header';
          container.appendChild(header);
        }

        let legend = header.querySelector('.legend');
        if (!legend) {
          legend = document.createElement('div');
          legend.className = 'legend';
          header.appendChild(legend);
        }

        let title = legend.querySelector('.legend-title');
        if (!title) {
          title = document.createElement('div');
          title.className = 'legend-title';
          title.innerHTML = 'Overlong penalty (L<sub>cache</sub> - L<sub>max</sub>)';
          legend.appendChild(title);
        } else {
          title.innerHTML = 'Overlong penalty (L<sub>cache</sub> - L<sub>max</sub>)';
        }

        let items = legend.querySelector('.items');
        if (!items) {
          items = document.createElement('div');
          items.className = 'items';
          legend.appendChild(items);
        }

        const colors = getColors(series.length);

        items.innerHTML = '';
        series.forEach((s, i) => {
          const item = document.createElement('span');
          item.className = 'item';
          if (hiddenSeries.has(s.name)) {
            item.classList.add('dimmed');
          }

          const swatch = document.createElement('span');
          swatch.className = 'swatch';
          swatch.style.background = colors[i % colors.length];

          const text = document.createElement('span');
          text.textContent = s.name;

          item.appendChild(swatch);
          item.appendChild(text);
          items.appendChild(item);

          item.addEventListener('click', () => {
            if (hiddenSeries.has(s.name)) {
              hiddenSeries.delete(s.name);
            } else {
              hiddenSeries.add(s.name);
            }
            makeLegend();
            render();
          });
        });
      }

      // Load data and initialize
      fetchFirstAvailable(CSV_PATHS)
        .then(csvText => {
          parseData(csvText);
          makeLegend();
          render();

          // Responsiveness
          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch(err => {
          const pre = document.createElement('pre');
          pre.style.color = '#f44336';
          pre.style.fontSize = '12px';
          pre.style.padding = '12px';
          pre.textContent = `Error loading data: ${err.message}`;
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">Downstream performance of Smollm3 on the AIME25 Mathematics benchmark.</figcaption></figure>
<p>If we take the checkpoints from step 400 for the different overlong penalties, we can compare the output token distributions and find a compromise of performance and completion length:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-qas89xxbuug"><div class="d3-grpo-token-comparison"></div>
<style>
  .d3-grpo-token-comparison {
    width: 100%;
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  }

  .d3-grpo-token-comparison svg {
    display: block;
    width: 100%;
  }

  .d3-grpo-token-comparison .bar {
    stroke: none;
  }

  .d3-grpo-token-comparison .axes path,
  .d3-grpo-token-comparison .axes line {
    stroke: var(--axis-color, var(--text-color));
  }

  .d3-grpo-token-comparison .axes text {
    fill: var(--tick-color, var(--muted-color));
    font-size: 11px;
  }

  .d3-grpo-token-comparison .grid line {
    stroke: var(--grid-color, rgba(0, 0, 0, .08));
  }

  .d3-grpo-token-comparison .chart-title {
    font-size: 13px;
    font-weight: 600;
    fill: var(--text-color);
  }

  .d3-grpo-token-comparison .d3-tooltip {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(-9999px, -9999px);
    pointer-events: none;
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.35;
    border: 1px solid var(--border-color);
    background: var(--surface-bg);
    color: var(--text-color);
    box-shadow: 0 4px 24px rgba(0, 0, 0, .18);
    opacity: 0;
    transition: opacity .12s ease;
  }

  .d3-grpo-token-comparison .d3-tooltip__inner {
    text-align: left;
  }

  .d3-grpo-token-comparison .legend {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
    margin-top: 16px;
  }

  .d3-grpo-token-comparison .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-grpo-token-comparison .legend .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-grpo-token-comparison .legend .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    font-size: 12px;
    color: var(--text-color);
  }

  .d3-grpo-token-comparison .legend .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .d3-grpo-token-comparison .controls {
    display: flex;
    gap: 16px;
    align-items: center;
    justify-content: flex-end;
    flex-wrap: wrap;
    margin-top: 8px;
  }

  .d3-grpo-token-comparison .control-group {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
  }

  .d3-grpo-token-comparison .controls label {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-grpo-token-comparison .controls select {
    font-size: 12px;
    padding: 8px 28px 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background: var(--surface-bg);
    color: var(--text-color);
    cursor: pointer;
  }

  .d3-grpo-token-comparison .slider-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
    min-width: 300px;
  }

  .d3-grpo-token-comparison .slider-row {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .d3-grpo-token-comparison input[type="range"] {
    flex: 1;
    height: 6px;
    border-radius: 3px;
    background: var(--border-color);
    outline: none;
    -webkit-appearance: none;
    cursor: pointer;
  }

  .d3-grpo-token-comparison input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--primary-color);
    cursor: pointer;
  }

  .d3-grpo-token-comparison input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--primary-color);
    cursor: pointer;
    border: none;
  }

  .d3-grpo-token-comparison .slider-value {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-color);
    min-width: 60px;
    text-align: right;
  }
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => {
        if (window.d3 && typeof window.d3.select === 'function') cb();
      };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('d3-grpo-token-comparison'))) {
        const candidates = Array.from(document.querySelectorAll('.d3-grpo-token-comparison'))
          .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
        container = candidates[candidates.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      const showTooltip = (html, event) => {
        tipInner.innerHTML = html;
        tip.style.opacity = '1';
        const [mx, my] = d3.pointer(event, container);
        tip.style.transform = `translate(${mx + 12}px, ${my - 12}px)`;
      };

      const hideTooltip = () => {
        tip.style.opacity = '0';
        setTimeout(() => {
          tip.style.transform = 'translate(-9999px, -9999px)';
        }, 120);
      };

      // SVG scaffolding
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');

      let width = 800, height = 400;
      const margin = { top: 40, right: 16, bottom: 56, left: 60 };

      // Dataset configurations
      const datasetConfigs = [
        {
          file: 'HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-GRPO-no-think_v27_00-step-000000400_aime25_2025-10-16T01-18-56.json',
          name: '1.5-2k',
          id: 'grpo-1.5-2k'
        },
        {
          file: 'HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-GRPO-no-think_v27_01-step-000000400_aime25_2025-10-16T01-22-56.json',
          name: '2-2.5k',
          id: 'grpo-2-2.5k'
        },
        {
          file: 'HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-GRPO-no-think_v27_02-step-000000400_aime25_2025-10-16T01-23-56.json',
          name: '2.5-3k',
          id: 'grpo-2.5-3k'
        },
        {
          file: 'HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-GRPO-no-think_v27_03-step-000000400_aime25_2025-10-16T01-58-31.json',
          name: '3-3.5k',
          id: 'grpo-3-3.5k'
        },
        {
          file: 'HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-GRPO-no-think_v27_04-step-000000400_aime25_2025-10-16T04-55-04.json',
          name: '3.5-4k',
          id: 'grpo-3.5-4k'
        },
        {
          file: 'HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-GRPO-no-think_v27_05-step-000000400_aime25_2025-10-16T06-12-05.json',
          name: '4-4.5k',
          id: 'grpo-4-4.5k'
        }
      ];

      const fetchFirstAvailable = async (filename) => {
        const paths = [
          `/data/${filename}`,
          `./assets/data/${filename}`,
          `../assets/data/${filename}`,
          `../../assets/data/${filename}`
        ];

        for (const p of paths) {
          try {
            const r = await fetch(p, { cache: 'no-cache' });
            if (r.ok) return await r.json();
          } catch (e) { }
        }
        throw new Error(`JSON not found: ${filename}`);
      };

      // Load baseline (APO No-Think)
      const baselineFile = 'HuggingFaceH4_details_HuggingFaceH4__SmolLM3-3B-APO-no-think_main_aime25_2025-10-02T13-20-35.json';

      fetchFirstAvailable(baselineFile)
        .then(async (baselineData) => {
          // Load all comparison datasets
          const comparisonData = await Promise.all(
            datasetConfigs.map(async (config) => ({
              ...config,
              data: await fetchFirstAvailable(config.file)
            }))
          );

          // Get colors
          const colors = window.ColorPalettes
            ? window.ColorPalettes.getColors('categorical', 2)
            : ['#4e79a7', '#f28e2c'];

          let selectedComparison = comparisonData[0];
          let currentIndex = 0;

          // Create controls
          const controls = document.createElement('div');
          controls.className = 'controls';

          const sliderContainer = document.createElement('div');
          sliderContainer.className = 'slider-container';

          const label = document.createElement('label');
          label.textContent = 'Overlong Penalty';
          label.style.fontSize = '12px';
          label.style.fontWeight = '700';
          label.style.color = 'var(--text-color)';

          const sliderRow = document.createElement('div');
          sliderRow.className = 'slider-row';

          const slider = document.createElement('input');
          slider.type = 'range';
          slider.min = '0';
          slider.max = String(comparisonData.length - 1);
          slider.value = '0';
          slider.step = '1';

          const sliderValue = document.createElement('span');
          sliderValue.className = 'slider-value';
          sliderValue.textContent = comparisonData[0].name;

          slider.addEventListener('input', (e) => {
            currentIndex = parseInt(e.target.value);
            selectedComparison = comparisonData[currentIndex];
            sliderValue.textContent = selectedComparison.name;
            render();
          });

          sliderRow.appendChild(slider);
          sliderRow.appendChild(sliderValue);
          sliderContainer.appendChild(label);
          sliderContainer.appendChild(sliderRow);
          controls.appendChild(sliderContainer);
          container.appendChild(controls);

          // Create legend
          const legend = document.createElement('div');
          legend.className = 'legend';

          const legendTitle = document.createElement('div');
          legendTitle.className = 'legend-title';
          legendTitle.textContent = 'Legend';

          const legendItems = document.createElement('div');
          legendItems.className = 'items';

          ['APO No-Think (Baseline)', 'GRPO on Math with Overlong Penalty'].forEach((name, idx) => {
            const item = document.createElement('span');
            item.className = 'item';

            const swatch = document.createElement('span');
            swatch.className = 'swatch';
            swatch.style.background = colors[idx];

            const text = document.createElement('span');
            text.textContent = name;

            item.appendChild(swatch);
            item.appendChild(text);
            legendItems.appendChild(item);
          });

          legend.appendChild(legendTitle);
          legend.appendChild(legendItems);
          container.appendChild(legend);

          function updateSize() {
            width = container.clientWidth || 800;
            height = Math.max(400, Math.round(width / 2.2));
            svg.attr('width', width).attr('height', height);
            gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
            return {
              innerWidth: width - margin.left - margin.right,
              innerHeight: height - margin.top - margin.bottom
            };
          }

          function render() {
            const { innerWidth, innerHeight } = updateSize();

            // Clear previous
            gRoot.selectAll('*').remove();

            const datasets = [
              { name: 'APO No-Think (Baseline)', data: baselineData, idx: 0 },
              { name: selectedComparison.name, data: selectedComparison.data, idx: 1 }
            ];

            // Use 0-4k for both to keep scales comparable
            const xDomain = [0, 4000];

            // Create bins for both datasets
            const allBins = datasets.map(ds => {
              const tokens = ds.data.token_counts;
              const bins = d3.bin()
                .domain(xDomain)
                .thresholds(30)(tokens);
              return { ...ds, bins };
            });

            // Find max frequency across both datasets for shared y-scale
            const maxFreq = d3.max(allBins.flatMap(d => d.bins.map(b => b.length)));

            const xScale = d3.scaleLinear()
              .domain(xDomain)
              .range([0, innerWidth]);

            const yScale = d3.scaleLinear()
              .domain([0, maxFreq])
              .range([innerHeight, 0])
              .nice();

            // Grid
            gRoot.append('g')
              .attr('class', 'grid')
              .call(
                d3.axisLeft(yScale)
                  .ticks(5)
                  .tickSize(-innerWidth)
                  .tickFormat('')
              )
              .call(g => g.select('.domain').remove());

            // Draw histograms (comparison first, baseline second so baseline is on top)
            allBins.reverse().forEach(({ name, bins, idx, data }) => {
              gRoot.selectAll(`rect.bar-${idx}`)
                .data(bins)
                .join('rect')
                .attr('class', `bar bar-${idx}`)
                .attr('x', d => xScale(d.x0))
                .attr('y', d => yScale(d.length))
                .attr('width', d => Math.max(1, xScale(d.x1) - xScale(d.x0) - 1))
                .attr('height', d => Math.max(0, innerHeight - yScale(d.length)))
                .attr('fill', colors[idx])
                .attr('opacity', 0.6)
                .on('mouseenter', (event, d) => {
                  const stats = data.statistics;
                  const html = `<strong>${name}</strong><br/>Tokens: ${d.x0.toFixed(0)} - ${d.x1.toFixed(0)}<br/>Count: ${d.length}<br/>Mean: ${stats.mean.toFixed(0)} | Median: ${stats.median.toFixed(0)}`;
                  showTooltip(html, event);
                })
                .on('mouseleave', hideTooltip);
            });

            // X axis
            const xAxis = gRoot.append('g')
              .attr('class', 'axes')
              .attr('transform', `translate(0,${innerHeight})`)
              .call(d3.axisBottom(xScale).ticks(8).tickFormat(d3.format(',d')));

            xAxis.select('.domain').remove();

            // Y axis
            const yAxis = gRoot.append('g')
              .attr('class', 'axes')
              .call(d3.axisLeft(yScale).ticks(6));

            yAxis.select('.domain').remove();

            // X axis label
            gRoot.append('text')
              .attr('class', 'axes')
              .attr('x', innerWidth / 2)
              .attr('y', innerHeight + 40)
              .attr('text-anchor', 'middle')
              .style('font-size', '12px')
              .style('fill', 'var(--text-color)')
              .text('Token count');

            // Y axis label
            gRoot.append('text')
              .attr('class', 'axes')
              .attr('transform', 'rotate(-90)')
              .attr('x', -innerHeight / 2)
              .attr('y', -45)
              .attr('text-anchor', 'middle')
              .style('font-size', '12px')
              .style('fill', 'var(--text-color)')
              .text('Frequency');
          }

          render();

          if (window.ResizeObserver) {
            const ro = new ResizeObserver(() => render());
            ro.observe(container);
          } else {
            window.addEventListener('resize', render);
          }
        })
        .catch((err) => {
          const pre = document.createElement('pre');
          pre.textContent = 'Error loading data: ' + err.message;
          pre.style.cssText = 'color:red;font-size:12px;padding:12px;margin:0;';
          container.appendChild(pre);
        });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div></figure>
<p>We have shown that with a carefully selected reward function and overlong penalty, we can improve Smollm3 instruction mode performance with Reinforcement Learning. The next step in the RL training pipeline would be joint training of the model in both instruct and reasoning mode. With a more relaxed overlong penalty for the reasoning completions. We find however that joint training is challenging. We have observed that trying to improve model performance across a variety of benchmarks, in both instruct and reasoning modes, is a challenging endeavour. It appears that most open models such as the latest Qwen3 models have been released as separate instruct and reasoning variant, we believe the industry is also struggling to balance the performance in these two modes.</p>
<p>Our experiments show that RLVR can steer reasoning behaviour effectively, but only with careful reward shaping and stability mechanisms. Given this complexity, it’s worth asking whether reinforcement learning is the only viable path forward. In fact, several lighter-weight, on-policy optimisation strategies have been proposed in recent literature, yet remain surprisingly under explored by the open-source community. Let’s close out this chapter by taking a look at some of them.</p>
<h4 id="is-rl-the-only-game-in-town"><a href="#is-rl-the-only-game-in-town">Is RL the only game in town?</a></h4>
<p>Other approaches to online learning extend preference learning and distillation into iterative loops that refresh the training signal as the model evolves:</p>
<ul>
<li><strong>Online DPO:</strong>  rather than training once on a fixed preference dataset, the model continually samples new responses, collects fresh preference labels (from humans, reward models, or stronger LLMs), and updates itself. This keeps the optimisation  <em>on-policy</em>  and reduces drift between training data and the model’s current behaviour.</li>
<li><strong>Online knowledge distillation:</strong>  instead of preferences, the signal comes from a stronger teacher model. The student samples responses at every training step and the KL divergence between the student and teacher logits on these samples provides the learning signal. This allows the student to continuously absorb the teacher’s capabilities, without needing explicit preference labels or verifiers.</li>
</ul>
<p>These methods blur the line between static preference optimisation and full RL: you still get the benefits of adapting to the model’s current distribution, but without the full complexity of designing and stabilising a reinforcement learning loop.</p>
<h4 id="which-method-do-i-pick"><a href="#which-method-do-i-pick">Which method do I pick?</a></h4>
<p>Although there are a gazillion research papers about which online method is “best”, in practice the decision depends on a few factors shown in the table below:</p>
<div class="wide"> 






















<div class="table-scroll"><table><thead><tr><th>Algorithm</th><th>When to Use</th><th>Tradeoffs</th><th>Best for Model Size</th></tr></thead><tbody><tr><td><strong>Online DPO</strong></td><td>You can get preference labels cheaply (from humans, reward models, or stronger LLMs). Best for aligning behaviour with evolving distributions.</td><td>Easy to scale iteratively, more stable than RL, but depends on label quality and coverage. Supported in few training frameworks.</td><td>Mid–large models (10B+), where preferences capture improvements beyond imitation.</td></tr><tr><td><strong>Online knowledge distillation</strong></td><td>You have access to a stronger teacher model and want to transfer capabilities efficiently.</td><td>Simple to implement, cheap to run, inherits teacher biases, ceiling limited by teacher. Supported only in TRL</td><td>Most effective for small to mid-sized models (&lt;30B).</td></tr></tbody></table></div><p>| <strong>Reinforcement learning</strong> | Best when you have verifiable rewards (unit tests, math proofs, API success rates) or tasks requiring multi-step reasoning/planning.</p><p>Can be used with reward models, but there are challenges like reward-hacking; where the model takes advantages in weaknesses in the reward model. | Flexible and powerful, but costly and harder to stabilise; requires careful reward shaping. Supported in most post-training frameworks. | Large models (20B+), where extra capacity lets them exploit structured reward signals. |</p> </div>
<p>In the open-source ecosystem, reinforcement learning methods like GRPO and REINFORCE tend to be the most widely used, although the Qwen3 tech report <span class="" id="citation--qwen3--152">(<a href="https://arxiv.org/abs/2505.09388" id="refctx-bib-qwen3-1" data-ref-id="bib-qwen3" target="_blank" rel="noopener noreferrer">A. Yang, Li, et al., 2025</a>)</span> highlighted the use of online knowledge distillation to train the models under 32B:</p>
<div class="wide"> <pre class="mermaid">flowchart LR
    subgraph Flagship [&quot;Flagship Models&quot;]
        Base1[&quot;Base Models&quot;] --&gt; Stage1[&quot;Stage 1:<br/>Long-CoT Cold Start&quot;]
        Stage1 --&gt; Stage2[&quot;Stage 2:<br/>Reasoning RL&quot;]
        Stage2 --&gt; Stage3[&quot;Stage 3:<br/>Thinking Mode Fusion&quot;]
        Stage3 --&gt; Stage4[&quot;Stage 4:<br/>General RL&quot;]
        Stage4 --&gt; FlagshipOut[&quot;Qwen3-235B-A22B<br/>Qwen3-32B&quot;]
    end
    
    subgraph Lightweight [&quot;Lightweight Models&quot;]
        Base2[&quot;Base Models&quot;] --&gt; Distillation[&quot;Strong-to-Weak<br/>Distillation&quot;]
        FlagshipOut --&gt; Distillation
        Distillation --&gt; LightweightOut[&quot;Qwen3-30B-A3B<br/>14B/8B/4B/1.7B/0.6B&quot;]
    end
    
    classDef flagshipStage fill:#ffd0c5
    classDef lightweightStage fill:#fef3c7
    classDef output fill:#f8d7da
    
    class Stage1,Stage2,Stage3,Stage4 flagshipStage
    class Distillation lightweightStage
    class FlagshipOut,LightweightOut output</pre> </div>
<p>Comparison of reinforcement learning and on-policy distillation on Qwen3-8B. Numbers in parentheses indicate pass@64 scores.</p>
<div class="wide"> 












































<div class="table-scroll"><table><thead><tr><th>Method</th><th>AIME’24</th><th>AIME’25</th><th>MATH500</th><th>LiveCodeBench v5</th><th>MMLU -Redux</th><th>GPQA -Diamond</th><th>GPU Hours</th></tr></thead><tbody><tr><td>Off-policy Distillation</td><td>55.0 (90.0)</td><td>42.8 (83.3)</td><td>92.4</td><td>42.0</td><td>86.4</td><td>55.6</td><td>-</td></tr><tr><td>+ Reinforcement Learning</td><td>67.6 (90.0)</td><td>55.5 (83.3)</td><td>94.8</td><td>52.9</td><td>86.9</td><td>61.3</td><td>17,920</td></tr><tr><td>+ On-policy Distillation</td><td><strong>74.4 (93.3)</strong></td><td><strong>65.5 (86.7)</strong></td><td><strong>97.0</strong></td><td><strong>60.3</strong></td><td><strong>88.3</strong></td><td><strong>63.3</strong></td><td>1,800</td></tr></tbody></table></div> </div>
<p>Similarly, researchers at FAIR have compared the effect of being fully offline to online for DPO and shown that it’s possible to match the performance of GRPO using far less compute <span class="" id="citation--online-offline--153">(<a href="https://arxiv.org/abs/2506.21495" id="refctx-bib-online-offline-1" data-ref-id="bib-online-offline" target="_blank" rel="noopener noreferrer">Lanchantin et al., 2025</a>)</span>:</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-jdzi5avrbrf"><div class="rl-training-sync"></div>
<style>
    .rl-training-sync {
        font-family: 'Arial', sans-serif;
        margin: 20px 0;
        padding: 0;
    }

    .rl-training-sync .container {
        display: flex;
        gap: 30px;
        align-items: stretch;
        justify-content: center;
        flex-wrap: wrap;
    }

    .rl-training-sync .left-section {
        flex: 0 0 auto;
        display: flex;
        align-items: center;
        gap: 20px;
    }

    .rl-training-sync .left-diagram {
        position: relative;
        width: 280px;
        height: 320px;
        background: var(--surface-bg, #fafafa);
        border-radius: 12px;
        padding: 10px;
    }

    .rl-training-sync .diagram-separator {
        width: 1px;
        background: linear-gradient(to bottom, transparent, var(--border-color, #ddd) 20%, var(--border-color, #ddd) 80%, transparent);
        align-self: stretch;
    }

    .rl-training-sync .right-modes {
        flex: 1;
        min-width: 400px;
        display: flex;
        align-items: center;
        gap: 0;
    }

    .rl-training-sync .box {
        padding: 8px 14px;
        border-radius: 8px;
        border: 1px solid;
        font-weight: 600;
        font-size: 11px;
        text-align: center;
        position: absolute;
        z-index: 2;
        line-height: 1.3;
        transition: transform 0.2s ease;
        cursor: default;
    }

    .rl-training-sync .rewards {
        background: color-mix(in srgb, var(--color-0, #E889AB) 60%, transparent);
        border-color: var(--color-0, #E889AB);
        color: var(--text-color, #000);
        top: 10px;
        left: 10px;
    }

    .rl-training-sync .verifier {
        background: color-mix(in srgb, var(--color-1, #4EA5B7) 60%, transparent);
        border-color: var(--color-1, #4EA5B7);
        color: var(--text-color, #000);
        top: 10px;
        right: 10px;
    }

    .rl-training-sync .rollouts {
        background: color-mix(in srgb, var(--color-2, #E38A42) 60%, transparent);
        border-color: var(--color-2, #E38A42);
        color: var(--text-color, #000);
        top: 50%;
        right: 10px;
        transform: translateY(-50%);
    }

    .rl-training-sync .trainer {
        background: color-mix(in srgb, var(--color-3, #CEC0FA) 60%, transparent);
        border-color: var(--color-3, #CEC0FA);
        color: var(--text-color, #000);
        bottom: 60px;
        left: 10px;
    }

    .rl-training-sync .generator {
        background: color-mix(in srgb, var(--color-0, #E889AB) 60%, transparent);
        border-color: var(--color-0, #E889AB);
        color: var(--text-color, #000);
        bottom: 60px;
        right: 10px;
    }

    .rl-training-sync .prompt {
        background: color-mix(in srgb, var(--color-1, #4EA5B7) 60%, transparent);
        border-color: var(--color-1, #4EA5B7);
        color: var(--text-color, #000);
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
    }

    /* Arrows */
    .rl-training-sync .arrow {
        stroke: var(--text-color, #666);
        stroke-width: 1.5;
        fill: none;
        opacity: 0.6;
    }

    .rl-training-sync .mode-column {
        flex: 1;
        min-width: 120px;
        padding: 0 15px;
        border-right: 1px solid var(--border-color, #ddd);
        transition: background-color 0.2s ease;
    }

    .rl-training-sync .mode-column:last-child {
        border-right: none;
    }

    .rl-training-sync .mode-header {
        font-size: 13px;
        font-weight: 700;
        text-align: center;
        margin-bottom: 15px;
        color: var(--text-color, #333);
        padding-bottom: 10px;
    }

    .rl-training-sync .step-row {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 12px;
        justify-content: center;
    }

    .rl-training-sync .step-label {
        font-size: 11px;
        font-weight: 600;
        min-width: 60px;
        text-align: right;
        color: var(--muted-color, #666);
    }

    .rl-training-sync .node {
        padding: 7px 15px;
        border-radius: 8px;
        border: 1px solid;
        font-weight: 600;
        font-size: 11px;
        min-width: 38px;
        text-align: center;
        transition: transform 0.2s ease;
    }

    .rl-training-sync .node-t {
        background: color-mix(in srgb, var(--color-3, #CEC0FA) 60%, transparent);
        border-color: var(--color-3, #CEC0FA);
        color: var(--text-color, #000);
    }

    .rl-training-sync .node-g {
        background: color-mix(in srgb, var(--color-0, #E889AB) 60%, transparent);
        border-color: var(--color-0, #E889AB);
        color: var(--text-color, #000);
    }

    .rl-training-sync .sync-arrow {
        position: relative;
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        gap: 0px;
        margin-top: -12px;
    }

    .rl-training-sync .sync-label {
        transform: translateY(10px);
        font-size: 8px;
        color: var(--text-color, #666);
        font-weight: 600;
        text-transform: lowercase;
    }

    .rl-training-sync .sync-symbol {
        font-size: 14px;
        color: var(--muted-color, #999);
        font-weight: normal;
    }

    .rl-training-sync .dots {
        text-align: center;
        font-size: 16px;
        font-weight: bold;
        color: var(--muted-color, #ccc);
        margin: 8px 0;
    }

    @media (max-width: 1100px) {
        .rl-training-sync .left-section {
            flex-direction: column;
        }

        .rl-training-sync .diagram-separator {
            width: 100%;
            height: 1px;
            background: linear-gradient(to right, transparent, var(--border-color, #ddd) 20%, var(--border-color, #ddd) 80%, transparent);
        }
    }

    @media (max-width: 1000px) {
        .rl-training-sync .container {
            flex-direction: column;
        }

        .rl-training-sync .left-diagram {
            max-width: 100%;
        }

        .rl-training-sync .right-modes {
            min-width: 100%;
        }
    }

    @media (max-width: 600px) {
        .rl-training-sync .right-modes {
            flex-direction: column;
        }

        .rl-training-sync .mode-column {
            width: 100%;
            border-right: none;
            border-bottom: 1px solid var(--border-color, #ddd);
            padding: 15px;
        }

        .rl-training-sync .mode-column:last-child {
            border-bottom: none;
        }
    }
</style>

<script>
    (() => {
        const bootstrap = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;
            if (!(container && container.classList && container.classList.contains('rl-training-sync'))) {
                const candidates = Array.from(document.querySelectorAll('.rl-training-sync'))
                    .filter((el) => !(el.dataset && el.dataset.mounted === 'true'));
                container = candidates[candidates.length - 1] || null;
            }
            if (!container) return;
            if (container.dataset) {
                if (container.dataset.mounted === 'true') return;
                container.dataset.mounted = 'true';
            }

            // Apply categorical color palette
            const applyColorPalette = () => {
                try {
                    if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
                        const colors = window.ColorPalettes.getColors('categorical', 4);
                        colors.forEach((color, index) => {
                            document.documentElement.style.setProperty(`--color-${index}`, color);
                        });
                    } else {
                        const fallbackColors = ['#E889AB', '#4EA5B7', '#E38A42', '#CEC0FA'];
                        fallbackColors.forEach((color, index) => {
                            document.documentElement.style.setProperty(`--color-${index}`, color);
                        });
                    }
                } catch (e) {
                    console.warn('ColorPalettes not available, using fallback colors');
                }
            };

            applyColorPalette();
            if (window.ColorPalettes && typeof window.ColorPalettes.refresh === 'function') {
                window.ColorPalettes.refresh();
            }

            // Node positions and sizes (calculated from CSS positions)
            // Container is 280x320
            // Box CSS: padding: 8px 14px, font-size: 11px, line-height: 1.3
            const containerWidth = 280;
            const containerHeight = 320;
            const padding = { x: 14, y: 8 };

            // Estimated text widths + padding (approximate)
            const boxWidth = {
                rewards: 58 + padding.x * 2,          // ~58px text
                verifier: 90 + padding.x * 2,         // ~90px text (2 lines)
                rollouts: 58 + padding.x * 2,         // ~58px text
                trainer: 70 + padding.x * 2,          // ~70px text
                generator: 75 + padding.x * 2,        // ~75px text
                prompt: 48 + padding.x * 2            // ~48px text
            };

            // Height: single line ≈ 14px, double line ≈ 28px + padding
            const boxHeight = {
                rewards: 14 + padding.y * 2,          // 1 line
                verifier: 28 + padding.y * 2,         // 2 lines (with <br/>)
                rollouts: 14 + padding.y * 2,         // 1 line
                trainer: 14 + padding.y * 2,          // 1 line
                generator: 14 + padding.y * 2,        // 1 line
                prompt: 14 + padding.y * 2            // 1 line
            };

            const nodes = {
                // top: 10px, left: 10px
                rewards: {
                    x: 10 + boxWidth.rewards / 2,
                    y: 10 + boxHeight.rewards / 2,
                    width: boxWidth.rewards,
                    height: boxHeight.rewards
                },
                // top: 10px, right: 10px
                verifier: {
                    x: containerWidth - 10 - boxWidth.verifier / 2,
                    y: 10 + boxHeight.verifier / 2,
                    width: boxWidth.verifier,
                    height: boxHeight.verifier
                },
                // top: 50%, right: 10px, transform: translateY(-50%)
                rollouts: {
                    x: containerWidth - 10 - boxWidth.rollouts / 2,
                    y: containerHeight / 2,
                    width: boxWidth.rollouts,
                    height: boxHeight.rollouts
                },
                // bottom: 60px, left: 10px
                trainer: {
                    x: 10 + boxWidth.trainer / 2,
                    y: containerHeight - 60 - boxHeight.trainer / 2,
                    width: boxWidth.trainer,
                    height: boxHeight.trainer
                },
                // bottom: 60px, right: 10px
                generator: {
                    x: containerWidth - 10 - boxWidth.generator / 2,
                    y: containerHeight - 60 - boxHeight.generator / 2,
                    width: boxWidth.generator,
                    height: boxHeight.generator
                },
                // bottom: 10px, left: 50%, transform: translateX(-50%)
                prompt: {
                    x: containerWidth / 2,
                    y: containerHeight - 10 - boxHeight.prompt / 2,
                    width: boxWidth.prompt,
                    height: boxHeight.prompt
                }
            };

            // Get connection point on a node's side (like bottleneck)
            // node.x and node.y are the CENTER of the box
            // We calculate the edge point, then add offset to move away from the box
            // linkIndex and totalLinks allow spacing multiple connections on the same side
            const getPoint = (nodeId, side, offset = 8, linkIndex = 0, totalLinks = 1) => {
                const node = nodes[nodeId];
                if (!node) return { x: 0, y: 0 };

                const points = {
                    top: { x: node.x, y: node.y - node.height / 2 - offset },
                    right: { x: node.x + node.width / 2 + offset, y: node.y },
                    bottom: { x: node.x, y: node.y + node.height / 2 + offset },
                    left: { x: node.x - node.width / 2 - offset, y: node.y }
                };

                let basePoint = points[side] || { x: node.x, y: node.y };

                // Apply spacing for multiple links to the same anchor
                if (totalLinks > 1) {
                    const isVerticalAnchor = (side === 'top' || side === 'bottom');

                    // Vertical anchors (top/bottom) space horizontally, horizontal anchors (left/right) space vertically
                    // Reduced gap: use fixed spacing instead of proportional
                    const spacing = 8;  // Fixed gap of 8px between links
                    const linkOffset = (linkIndex - (totalLinks - 1) / 2) * spacing;

                    // Apply offset in the perpendicular direction to the anchor
                    if (isVerticalAnchor) {
                        basePoint.x += linkOffset;  // Horizontal offset for vertical anchors
                    } else {
                        basePoint.y += linkOffset;  // Vertical offset for horizontal anchors
                    }
                }

                return basePoint;
            };

            // Create SVG paths with arrow markers (simple version)
            const createPath = (from, to, dashed = false, color = 'currentColor') => {
                return `<line x1="${from.x}" y1="${from.y}" x2="${to.x}" y2="${to.y}" 
                    stroke="${color}" stroke-width="2" 
                    ${dashed ? 'stroke-dasharray="4,4"' : ''} 
                    opacity="0.6" 
                    marker-end="url(#arrowhead)" />`;
            };

            // Build all connections
            let connections = '';
            const linkColor = 'var(--text-color, #666)';

            // 1. Rewards → Trainer (dashed, vertical)
            // Trainer top receives 2 links, this is link 0
            connections += createPath(
                getPoint('rewards', 'bottom'),
                getPoint('trainer', 'top', 8, 0, 2),
                true, linkColor
            );

            // 2. Verifier → Rewards (horizontal)
            connections += createPath(
                getPoint('verifier', 'left'),
                getPoint('rewards', 'right'),
                false, linkColor
            );

            // 3. Verifier → Rollouts (vertical)
            connections += createPath(
                getPoint('verifier', 'bottom'),
                getPoint('rollouts', 'top'),
                false, linkColor
            );

            // 4. Rollouts → Generator (vertical, single arrow)
            connections += createPath(
                getPoint('rollouts', 'bottom'),
                getPoint('generator', 'top'),
                false, linkColor
            );

            // 5. Rollouts → Trainer (diagonal: left of rollouts to top of trainer)
            // Trainer top receives 2 links, this is link 1
            connections += createPath(
                getPoint('rollouts', 'left'),
                getPoint('trainer', 'top', 8, 1, 2),
                false, linkColor
            );

            // 6. Trainer → Generator sync (dashed, horizontal)
            const trainerRight = getPoint('trainer', 'right');
            const generatorLeft = getPoint('generator', 'left');
            connections += createPath(trainerRight, generatorLeft, true, linkColor);
            const syncMidX = (trainerRight.x + generatorLeft.x) / 2;
            connections += `<text x="${syncMidX}" y="${trainerRight.y - 8}" font-size="8" fill="currentColor" opacity="0.6" font-weight="600" text-anchor="middle">sync</text>`;
            connections += `<text x="${syncMidX}" y="${trainerRight.y + 13}" font-size="8" fill="currentColor" opacity="0.6" font-weight="600" text-anchor="middle">weights</text>`;

            // 7. Prompt → Trainer (diagonal: left of prompt to bottom of trainer)
            connections += createPath(
                getPoint('prompt', 'left'),
                getPoint('trainer', 'bottom'),
                false, linkColor
            );

            // 8. Prompt → Generator (diagonal: right of prompt to bottom of generator)
            connections += createPath(
                getPoint('prompt', 'right'),
                getPoint('generator', 'bottom'),
                false, linkColor
            );

            container.innerHTML = `
            <div class="container">
                <!-- LEFT SECTION WITH DIAGRAM -->
                <div class="left-section">
                    <div class="left-diagram">
                        <!-- SVG for arrows -->
                        <svg width="100%" height="100%" style="position: absolute; top: 0; left: 0; pointer-events: none;">
                            <defs>
                                <marker id="arrowhead" markerWidth="6" markerHeight="6" 
                                    refX="4" refY="2" orient="auto" markerUnits="strokeWidth">
                                    <path d="M0,0 L4,2 L0,4" 
                                        fill="none" 
                                        stroke="var(--text-color, #666)" 
                                        stroke-width="1" 
                                        stroke-linecap="round" 
                                        stroke-linejoin="round" />
                                </marker>
                            </defs>
                            ${connections}
                        </svg>
                        
                        <!-- Boxes -->
                        <div class="box rewards">Rewards</div>
                        <div class="box verifier">Reward/Verifier<br/>Model</div>
                        <div class="box rollouts">Rollouts</div>
                        <div class="box trainer">Trainer (T)</div>
                        <div class="box generator">Generator (G)</div>
                        <div class="box prompt">Prompt</div>
                    </div>
                    
                    <div class="diagram-separator"></div>
                </div>

                <!-- RIGHT MODES -->
                <div class="right-modes">
                    <!-- OFFLINE -->
                    <div class="mode-column">
                        <div class="mode-header">Offline (s=∞)</div>
                        
                        <div class="step-row">
                            <span class="step-label">Step k+1</span>
                            <span class="node node-t">T</span>
                            <span class="node node-g">G</span>
                        </div>
                        
                        <div class="step-row">
                            <span class="step-label">Step k</span>
                            <span class="node node-t">T</span>
                            <span class="node node-g">G</span>
                        </div>
                        
                        <div class="dots">⋯</div>
                        
                        <div class="step-row">
                            <span class="step-label">Step 1</span>
                            <span class="node node-t">T</span>
                            <span class="node node-g">G</span>
                        </div>
                        
                        <div class="step-row">
                            <span class="step-label">Step 0</span>
                            <span class="node node-t">T</span>
                            <span class="sync-arrow">
                                <span class="sync-label">sync</span>
                                <span class="sync-symbol">⟶</span>
                            </span>
                            <span class="node node-g">G</span>
                        </div>
                    </div>

                    <!-- SEMI-ONLINE -->
                    <div class="mode-column">
                        <div class="mode-header">Semi-Online (s=k)</div>
                        
                        <div class="step-row">
                            <span class="step-label">Step k+1</span>
                            <span class="node node-t">T</span>
                            <span class="node node-g">G</span>
                        </div>
                        
                        <div class="step-row">
                            <span class="step-label">Step k</span>
                            <span class="node node-t">T</span>
                            <span class="sync-arrow">
                                <span class="sync-label">sync</span>
                                <span class="sync-symbol">⟶</span>
                            </span>
                            <span class="node node-g">G</span>
                        </div>
                        
                        <div class="dots">⋯</div>
                        
                        <div class="step-row">
                            <span class="step-label">Step 1</span>
                            <span class="node node-t">T</span>
                            <span class="node node-g">G</span>
                        </div>
                        
                        <div class="step-row">
                            <span class="step-label">Step 0</span>
                            <span class="node node-t">T</span>
                            <span class="sync-arrow">
                                <span class="sync-label">sync</span>
                                <span class="sync-symbol">⟶</span>
                            </span>
                            <span class="node node-g">G</span>
                        </div>
                    </div>

                    <!-- ONLINE -->
                    <div class="mode-column">
                        <div class="mode-header">Online (s=1)</div>
                        
                        <div class="step-row">
                            <span class="step-label">Step k+1</span>
                            <span class="node node-t">T</span>
                            <span class="sync-arrow">
                                <span class="sync-label">sync</span>
                                <span class="sync-symbol">⟶</span>
                            </span>
                            <span class="node node-g">G</span>
                        </div>
                        
                        <div class="step-row">
                            <span class="step-label">Step k</span>
                            <span class="node node-t">T</span>
                            <span class="sync-arrow">
                                <span class="sync-label">sync</span>
                                <span class="sync-symbol">⟶</span>
                            </span>
                            <span class="node node-g">G</span>
                        </div>
                        
                        <div class="dots">⋯</div>
                        
                        <div class="step-row">
                            <span class="step-label">Step 1</span>
                            <span class="node node-t">T</span>
                            <span class="sync-arrow">
                                <span class="sync-label">sync</span>
                                <span class="sync-symbol">⟶</span>
                            </span>
                            <span class="node node-g">G</span>
                        </div>
                        
                        <div class="step-row">
                            <span class="step-label">Step 0</span>
                            <span class="node node-t">T</span>
                            <span class="sync-arrow">
                                <span class="sync-label">sync</span>
                                <span class="sync-symbol">⟶</span>
                            </span>
                            <span class="node node-g">G</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
            bootstrap();
        }
    })();
</script></div></div></figure> </div>
<p>As shown in their paper, online DPO works well for math tasks and even the semi-online variant achieves comparable performance despite being quite off-policy:</p>















































<div class="table-scroll"><table><thead><tr><th>Training method</th><th>Math500</th><th>NuminaMath</th><th>AMC23</th></tr></thead><tbody><tr><td>Seed (Llama-3.1-8B-Instruct)</td><td>47.4 (1.6)</td><td>33.9 (0.6)</td><td>23.7 (5.2)</td></tr><tr><td>Offline DPO (s = ∞)</td><td>53.7 (1.6)</td><td>36.4 (0.6)</td><td>28.8 (7.0)</td></tr><tr><td>Semi-online DPO (s = 100)</td><td><strong>58.9</strong>  (1.2)</td><td>39.3 (0.4)</td><td><strong>35.1</strong>  (5.3)</td></tr><tr><td>Semi-online DPO (s = 10)</td><td>57.2 (1.1)</td><td>39.4 (0.5)</td><td>31.4 (4.3)</td></tr><tr><td>Online DPO (s = 1)</td><td>58.7 (1.2)</td><td><strong>39.6</strong>  (0.5)</td><td>32.9 (5.2)</td></tr><tr><td>GRPO</td><td>58.1 (1.3)</td><td>38.8 (0.5)</td><td>33.6 (5.1)</td></tr></tbody></table></div>
<h3 id="wrapping-up-post-training"><a href="#wrapping-up-post-training">Wrapping up post-training</a></h3>
<p>If you’ve made it this far, congrats: you now have all the core ingredients needed for success with post-training. You’re now ready to run many experiments and test different algorithms to get SOTA results.</p>
<p>But as you’ve probably realised, knowing how to train great models is only half the story. To actually bring those models to life, you need the right infrastructure. Let’s finish this opus with the unsung hero of LLM training.</p>
<h2 id="infrastructure---the-unsung-hero"><a href="#infrastructure---the-unsung-hero">Infrastructure - the unsung hero</a></h2>
<p>Now that you know all that we know about model creation and training, let’s focus on the one  <strong>underrated</strong>  component which can make or break your project (and your bank account) if you don’t understand it properly: infrastructure. Whether you focus on framework development, model architecture, or even data curation, understanding infrastructure basics will help you identify bottlenecks in your training pipeline, make informed decisions about parallelism strategies, and debug throughput issues. (At the very least it’ll help you communicate more effectively with your infrastructure colleagues 😉).</p>
<p>Most people training models care deeply about architecture and data, yet very few understand the infrastructure details. Infrastructure expertise typically lives with framework developers and cluster engineers, and gets treated by the rest as a solved problem: rent some GPUs, install PyTorch, and you’re good to go. We trained SmolLM3 on 384 H100s for nearly a month, processing a total of 11 trillion tokens… and this was not a smooth ride! During that time, we dealt with node failures, storage issues and run restarts (see the <a href="#the-training-marathon">training marathon section</a>). You need to have good contingency plans and strategies to prepare for these issues, and keep training smooth and low-maintenance.</p>
<p>The results reveal an important characteristic of memory</p>
<p>This chapter aims to bridge that knowledge gap. Think of it as a practical guide to the hardware layer, focused on the questions that matter for training. (Note: Each subsection starts with a TL;DR so you can choose your depth level.)</p>
<p>The first two sections tackles the fundamentals of how hardware works: what does a GPU actually consist of? How does memory hierarchy work? How do CPUs and GPUs communicate? We’ll also go over you what to consider when acquiring GPUs and how to test them before committing to long training runs. Most importantly, we’ll show you at each step how to measure and diagnose these systems yourself. The next sections are then more applied, and we’ll see how to make your infra resilient to failure, and how to maximally optimize your training throughput.</p>
<p>The name of the game of this chapter is to find and fix the bottlenecks!</p>
<p>Think of this as building your intuition for why certain design decisions matter. When you understand that your model’s activations need to flow through multiple levels of cache, each with different bandwidth and latency characteristics, you’ll naturally start thinking about how to structure your training to minimize data movement. When you see that inter-node communication is orders of magnitude slower than intra-node, you’ll understand why parallelism strategies matter so much.</p>
<p>Let’s start by cracking open a GPU and seeing what’s inside.</p>
<h3 id="inside-a-gpu-internal-architecture"><a href="#inside-a-gpu-internal-architecture">Inside a GPU: Internal Architecture</a></h3>
<p>A GPU is fundamentally a massively parallel processor optimized for throughput over latency. Unlike CPUs, which excel at executing a few complex instruction streams quickly, GPUs achieve performance by executing thousands of simple operations simultaneously.</p>
<p>The key to understanding GPU performance lies in recognizing that it’s not just about raw compute power, it’s about the interplay between computation and data movement. A GPU can have teraflops of theoretical compute, but if data can’t reach the compute units fast enough, that potential goes unused. This is why we need to understand both the memory hierarchy (how data moves) and the compute pipelines (how work gets done).</p>
<p>At the highest level, a GPU therefore performs two essential tasks:</p>
<ol>
<li><strong>Move and store data</strong>  (the memory system)</li>
<li><strong>Do useful work with the data</strong>  (the compute pipelines)</li>
</ol>
<h4 id="compute-units-and-flops"><a href="#compute-units-and-flops">Compute Units and FLOPs</a></h4>
<div class="note note--neutral" data-astro-cid-qg6lmfty> <!-- When there's no title, emoji is above content -->
    <div class="note__layout" data-astro-cid-qg6lmfty>  <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__content" data-astro-cid-qg6lmfty> <p><b>TL;DR:</b> GPUs measure performance in FLOPs (floating-point operations per second). Modern GPUs like the H100 deliver dramatically higher throughput at lower precision: 990 TFLOPs at BF16 vs 67 TFLOPs at FP32. However, real-world performance is 70-77% of theoretical peaks due to memory bottlenecks. State-of-the-art training achieves 20-41% end-to-end efficiency (MFU). Use realistic numbers, not marketing specs, when planning training runs.</p> </div> </div> </div> </div> 
<p>GPU compute performance is measured in  <strong>FLOPs</strong>  (floating-point operations per second). A FLOP is a single arithmetic operation, typically a floating numbers addition like  <code>a + b</code> , and modern GPUs can execute trillions of these per second (TFLOPs).</p>
<p>The fundamental building blocks of GPU compute are  <strong>Streaming Multiprocessors (SMs)</strong> , independent processing units that execute instructions in parallel. Each SM contains two types of  <strong>cores</strong> :  <strong>CUDA cores</strong>  for standard floating-point operations, and specialized  <strong>Tensor Cores</strong>  optimized for matrix multiplication, the workhorse operation in deep learning (critical for transformer performance).</p>
<p>Modern GPUs organize hundreds of these SMs across the chip! For example, the <a href="https://developer.nvidia.com/blog/nvidia-hopper-architecture-in-depth/">H100</a> SXM5 version (which is the GPU we’re using on our cluster) contains 132 SMs. Each SM operates independently, executing groups of 32 threads called  <strong>warps</strong>  in lockstep. To help there, the SMs rely on another component, the  <strong>warp schedulers:</strong>  by balancing instructions to different warps, they enable the SM to “hide latency” by switching between warps when one is held up. This  <strong>SIMT</strong>  (Single Instruction, Multiple Thread) execution model means all threads in a warp execute the same instruction simultaneously on different data.</p>
<figure class="html-embed"><div class="html-embed__card is-frameless"><div id="frag-vrbssammjxi"><div class="gpu-sm-architecture"></div>

<style>
    .gpu-sm-architecture {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        position: relative;
    }


    .gpu-sm-architecture .diagram-container {
        width: 100%;
        height: auto;
        position: relative;
    }


    .gpu-sm-architecture .sm-label {
        font-size: 14px;
        font-weight: 700;
        fill: white;
        text-anchor: middle;
    }

    .gpu-sm-architecture .component-label {
        font-size: 11px;
        font-weight: 600;
        fill: white;
        text-anchor: middle;
    }

    .gpu-sm-architecture .core-label {
        font-size: 9px;
        font-weight: 600;
        fill: white;
        text-anchor: middle;
    }

    .gpu-sm-architecture .ellipsis-text {
        font-size: 24px;
        font-weight: bold;
        fill: var(--muted-color);
        text-anchor: middle;
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.5/svg.min.js"></script>
<script>
    (() => {
        // Prevent multiple executions
        if (window.gpuSmArchitectureInitialized) return;
        window.gpuSmArchitectureInitialized = true;

        const bootstrap = () => {
            const scriptEl = document.currentScript;
            let container = scriptEl ? scriptEl.previousElementSibling : null;
            if (!(container && container.classList && container.classList.contains('gpu-sm-architecture'))) {
                const cs = Array.from(document.querySelectorAll('.gpu-sm-architecture')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
                container = cs[cs.length - 1] || null;
            }
            if (!container) return;
            if (container.dataset) {
                if (container.dataset.mounted === 'true') return;
                container.dataset.mounted = 'true';
            }

            // Get colors from ColorPalettes
            const getColors = () => {
                try {
                    if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
                        return window.ColorPalettes.getColors('categorical', 4);
                    }
                } catch (_) { }
                return ['#64748b', '#94a3b8', '#cbd5e1', '#e2e8f0'];
            };

            const colors = getColors();

            // Background colors - muted tones like wrong reasons
            const bgColors = {
                sm: 'var(--surface-bg)', // Dark mode ready SM background
                control: `color-mix(in srgb, ${colors[0]} 25%, var(--surface-bg))`, // More visible categorical colors
                registers: `color-mix(in srgb, ${colors[1]} 25%, var(--surface-bg))`,
                cores: `color-mix(in srgb, ${colors[2]} 25%, var(--surface-bg))`,
                cache: `color-mix(in srgb, ${colors[3]} 25%, var(--surface-bg))`
            };

            // Border colors - darker versions of background colors
            const borderColors = {
                control: `color-mix(in srgb, ${colors[0]} 60%, var(--surface-bg))`,
                registers: `color-mix(in srgb, ${colors[1]} 60%, var(--surface-bg))`,
                cores: `color-mix(in srgb, ${colors[2]} 60%, var(--surface-bg))`,
                cache: `color-mix(in srgb, ${colors[3]} 60%, var(--surface-bg))`
            };

            // Create diagram container
            const diagramContainer = document.createElement('div');
            diagramContainer.className = 'diagram-container';
            container.appendChild(diagramContainer);

            // Create responsive SVG with fixed internal dimensions
            const containerWidth = diagramContainer.clientWidth || 1200;
            const smHeight = 375; // Fixed internal height (375 + 15)
            const containerHeight = smHeight + 0; // Fixed internal height
            const draw = SVG().addTo(diagramContainer).size('100%', containerHeight).viewbox(0, 0, containerWidth, containerHeight);

            // SM dimensions - scaled to fit container width
            const totalWidth = containerWidth - 20; // Leave 10px margin on each side (20px total reduction)
            const smWidth = (totalWidth - 80) / 3; // Total width minus spacings, divided by 3 SMs
            const normalSpacing = 20; // Normal spacing between blocks
            const ellipsisSpacing = 80; // Much larger spacing for ellipsis

            // Perfect centering
            const startX = 0; // Fixed margin from left edge
            const startY = 0; // Small top margin instead of centering vertically

            // Create 3 SM blocks with different spacing
            let currentX = startX;
            for (let i = 0; i < 3; i++) {
                const x = currentX;
                const y = startY;

                // Adjust spacing based on position
                if (i === 0) {
                    // After 1st SM: normal spacing (no ellipsis)
                    currentX += smWidth + normalSpacing;
                } else if (i === 1) {
                    // After 2nd SM: large spacing (with ellipsis)
                    currentX += smWidth + ellipsisSpacing;
                }

                // Create SM group
                const smGroup = draw.group().id(`sm-${i}`);

                // SM background
                const smBg = smGroup.rect(smWidth, smHeight)
                    .fill(bgColors.sm)
                    .stroke({ color: 'var(--border-color)', width: 1.5 })
                    .radius(12)
                    .move(x, y);

                // SM label
                smGroup.text('SM')
                    .font({ size: 28, weight: 'bold' })
                    .fill('var(--text-color)')
                    .center(x + smWidth / 2, y + 35);

                // Control Unit
                const controlY = y + 70;
                smGroup.rect(smWidth - 30, 35)
                    .fill(bgColors.control)
                    .stroke({ color: borderColors.control, width: 1 })
                    .radius(8)
                    .move(x + 15, controlY);
                smGroup.text('Control')
                    .font({ size: 16, weight: '600' })
                    .fill('white')
                    .center(x + smWidth / 2, controlY + 17.5);

                // Registers
                const registersY = controlY + 50;
                smGroup.rect(smWidth - 30, 35)
                    .fill(bgColors.registers)
                    .stroke({ color: borderColors.registers, width: 1 })
                    .radius(8)
                    .move(x + 15, registersY);
                smGroup.text('Registers')
                    .font({ size: 16, weight: '600' })
                    .fill('white')
                    .center(x + smWidth / 2, registersY + 17.5);

                // Cores container
                const coresY = registersY + 50;
                const coresWidth = smWidth - 30;
                const coresHeight = 82.5; // Slightly increased height
                const coresPerRow = 4;
                const coresRows = 2;
                const coreSpacing = 8;

                // Calculate core size to fill available width
                const availableWidth = coresWidth - (coresPerRow - 1) * coreSpacing - 20; // 20px padding
                const coreSize = availableWidth / coresPerRow;

                // Cores background
                smGroup.rect(coresWidth, coresHeight)
                    .fill('rgba(0,0,0,0.05)')
                    .radius(8)
                    .stroke({ color: 'var(--border-color)', width: 1.5 })
                    .move(x + 15, coresY);

                // Create 8 cores (4x2 grid) - fill full width
                const startCoreX = x + 15 + 10; // Left padding
                const startCoreY = coresY + 10; // Top padding

                for (let row = 0; row < coresRows; row++) {
                    for (let col = 0; col < coresPerRow; col++) {
                        const coreX = startCoreX + col * (coreSize + coreSpacing);
                        const coreY = startCoreY + row * (coreSize + coreSpacing);

                        smGroup.rect(coreSize, coreSize)
                            .fill(bgColors.cores)
                            .stroke({ color: borderColors.cores, width: 1 })
                            .radius(4)
                            .move(coreX, coreY);

                        smGroup.text('Core')
                            .font({ size: 10, weight: '600' })
                            .fill('white')
                            .center(coreX + coreSize / 2, coreY + coreSize / 2);
                    }
                }

                // Constant Cache
                const cacheY = coresY + coresHeight + 15;
                smGroup.rect(smWidth - 30, 35)
                    .fill(bgColors.cache)
                    .stroke({ color: borderColors.cache, width: 1 })
                    .radius(8)
                    .move(x + 15, cacheY);
                smGroup.text('Constant Cache')
                    .font({ size: 16, weight: '600' })
                    .fill('white')
                    .center(x + smWidth / 2, cacheY + 17.5);

                // Shared Memory and L1 Cache (side by side with line breaks)
                const memoryY = cacheY + 50;
                const memoryWidth = (smWidth - 40) / 2;

                // Shared Memory (left side)
                smGroup.rect(memoryWidth, 40)
                    .fill(bgColors.cache)
                    .stroke({ color: borderColors.cache, width: 1 })
                    .radius(8)
                    .move(x + 15, memoryY);
                smGroup.text('Shared')
                    .font({ size: 12, weight: '600' })
                    .fill('white')
                    .center(x + 15 + memoryWidth / 2, memoryY + 12);
                smGroup.text('Memory')
                    .font({ size: 12, weight: '600' })
                    .fill('white')
                    .center(x + 15 + memoryWidth / 2, memoryY + 28);

                // L1 Cache (right side)
                smGroup.rect(memoryWidth, 40)
                    .fill(bgColors.cache)
                    .stroke({ color: borderColors.cache, width: 1 })
                    .radius(8)
                    .move(x + 15 + memoryWidth + 10, memoryY);
                smGroup.text('L1')
                    .font({ size: 12, weight: '600' })
                    .fill('white')
                    .center(x + 15 + memoryWidth + 10 + memoryWidth / 2, memoryY + 12);
                smGroup.text('Cache')
                    .font({ size: 12, weight: '600' })
                    .fill('white')
                    .center(x + 15 + memoryWidth + 10 + memoryWidth / 2, memoryY + 28);

                // Add ellipsis between SMs (only between 2nd and 3rd)
                if (i === 1) {
                    draw.text('...')
                        .font({ size: 42, weight: 'bold' })
                        .fill('var(--muted-color)')
                        .center(x + smWidth + ellipsisSpacing / 2, y + smHeight / 2);
                }
            }

        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
        } else {
            bootstrap();
        }
    })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">Multiple SMs within a single GPU -  <a href='https://www.youtube.com/watch?v=ZQKMZIP3Fzg'>

Source</a></figcaption></figure>
<p>With hundreds of SMs each executing multiple warps concurrently, a single GPU can run tens of thousands of threads simultaneously. This massive parallelism is what enables GPUs to excel at the matrix operations that dominate deep learning workloads!</p>
<p><strong>Precision matters significantly</strong>  when discussing FLOPs. Tensor Cores can operate at different precisions (FP64, FP32, FP16/BF16, FP8, FP4 - see <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">here for a reminder on floating point numbers</a>). The achievable throughput therefore varies dramatically, often by orders of magnitude, depending on the data type. Lower precision formats enable higher throughput because they require less data movement and can pack more operations into the same silicon area, but were formerly avoided because of training instabilities. However, nowadays, both training and inference are increasingly pushed toward lower precision, reaching FP8 and FP4, thanks to a range of new techniques.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>If you want to learn more about our experience with FP8 mixed precision training check out the <a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook">Ultra Scale Playbook</a>.</p> </aside> </div>  
<p>The table below shows theoretical peak performance across different NVIDIA GPU generations and precision:</p>





















































<div class="table-scroll"><table><thead><tr><th>Precision\GPU Type</th><th>A100</th><th>H100</th><th>H200</th><th>B100</th><th>B200</th></tr></thead><tbody><tr><td><strong>FP64</strong></td><td>9.7</td><td>34</td><td>34</td><td>40</td><td>40</td></tr><tr><td><strong>FP32</strong></td><td>19.5</td><td>67</td><td>67</td><td>80</td><td>80</td></tr><tr><td><strong>FP16/BF16</strong></td><td>312</td><td>990</td><td>990</td><td>1750</td><td>2250</td></tr><tr><td><strong>FP8</strong></td><td>-</td><td>3960</td><td>3960</td><td>4500</td><td>5000</td></tr><tr><td><strong>FP4</strong></td><td>-</td><td>-</td><td>-</td><td>9000</td><td>10000</td></tr></tbody></table></div>
<p><em>Table showing theoretical TFLOPs depending on precision and GPU generation. Source: Nvidia, SemiAnalysis</em></p>
<p>The dramatic increase in throughput at a lower precision isn’t just about raw speed, it reflects a fundamental shift in how we think about numerical computation. FP8 and FP4 enable models to perform more operations per  <strong>watt</strong>  and per  <strong>second</strong> , making them essential for both training and inference at scale. The H100’s 3960 TFLOPs at FP8 represents a 4x improvement over FP16/BF16, while the B200’s 10,000 TFLOPs at FP4 pushes this even further.</p>
<p><strong>Understanding the numbers</strong> : These theoretical peak FLOPs represent the  <em>maximum computational throughput achievable under ideal conditions</em> , when all compute units are fully utilized and data is readily available. In practice, actual performance depends heavily on how well your workload can keep the compute units fed with data and whether your operations can be efficiently mapped to the available hardware.</p>
<p>For SmolLM3, we were going to train on NVIDIA H100 80GB HBM3 GPUs, so we first wanted to test the H100’s theoretical TFLOPs specifications against real world performance. For this, we used the <a href="https://www.ray.so/#theme=prisma&darkMode=false&code=IyBBTUQgVklQIGltYWdlCmFsaWFzIGRydW49InN1ZG8gZG9ja2VyIHJ1biAtLXByaXZpbGVnZWQgLS1uZXR3b3JrPWhvc3QgLS1kZXZpY2U9L2Rldi9rZmQgLS1kZXZpY2U9L2Rldi9kcmkgLS1ncm91cC1hZGQgdmlkZW8gLS1jYXAtYWRkPVNZU19QVFJBQ0UgLS1zZWN1cml0eS1vcHQgc2VjY29tcD11bmNvbmZpbmVkIC0taXBjPWhvc3QgLS1zaG0tc2l6ZT0xOTI2IC0tcm0gLWl0IgpkcnVuIHNlbWlhbmFseXNpc3dvcmsvYW1kLW1hdG11bDpsYXRlc3QKRElTQUJMRV9BREROX0hJUF9MVD0wIFBZVE9SQ0hfVFVOQUJMRV9PUF9FTkFCTEVEPTEgcHl0aG9uIG1hdG11bC5weQoKI0FNRCBweXBpIG5pZ2h0bHkKZHJ1biBhbWQtbGF0ZXN0LXB5cGktbmlnaHRseS1tYXRtdWwKUFlUT1JDSF9UVU5BQkxFX09QX0VOQUJMRUQ9MSBweXRob24gbWF0bXVsLnB5CgojIEFNRCBweXBpIHN0YWJsZSBQeVRvcmNoIDIuNS4xCmRydW4gc2VtaWFuYWx5c2lzd29yay9hbWQtbGF0ZXN0LXB5cGktc3RhYmxlLW1hdG11bApQWVRPUkNIX1RVTkFCTEVfT1BfRU5BQkxFRD0xIHB5dGhvbiBtYXRtdWwucHkKCiMgTnZpZGlhIHN0YWJsZSAyNC4wOQphbGlhcyBkcnVuPSJkb2NrZXIgcnVuIC0tcm0gLWl0IC0tZ3B1cyBhbGwgLS1pcGM9aG9zdCAtLW5ldD1ob3N0IC0tc2htLXNpemU9MTkyNiIKZHJ1biBzZW1pYW5hbHlzaXN3b3JrL252aWRpYS1tYXRtdWw6bGF0ZXN0CnB5dGhvbiBtYXRtdWwucHkKCg&language=shell">SemiAnalysis GEMM benchmark</a>: it <a href="https://newsletter.semianalysis.com/p/mi300x-vs-h100-vs-h200-benchmark-part-1-training#general-matrix-multiply-gemm-performance">tests throughput on real-world matrix multiplication shapes from Meta’s Llama 70B training</a>.</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>## Using docker image semianalysiswork/nvidia-matmul:latest (nvidia stable 24.09)</span></span>
<span class="line"><span>$ python matmul.py</span></span>
<span class="line"><span></span></span></code></pre></div>
<div class="wide"> <div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> 
































































<div class="table-scroll"><table><thead><tr><th>Shape (M, N, K)</th><th>FP64 torch.matmul</th><th>FP32 torch.matmul</th><th>FP16 torch.matmul</th><th>BF16 torch.matmul</th><th>FP8 TE.Linear (autocast, bias=False)</th><th>FP8 torch._scaled_mm (e5m2/e4m3fn)</th><th>FP8 torch._scaled_mm (e4m3)</th></tr></thead><tbody><tr><td>(16384, 8192, 1280)</td><td>51.5 TFLOPS</td><td>364.5 TFLOPS</td><td>686.5 TFLOPS</td><td>714.5 TFLOPS</td><td>837.6 TFLOPS</td><td>1226.7 TFLOPS</td><td>1209.7 TFLOPS</td></tr><tr><td>(16384, 1024, 8192)</td><td>56.1 TFLOPS</td><td>396.1 TFLOPS</td><td>720.0 TFLOPS</td><td>757.7 TFLOPS</td><td>547.3 TFLOPS</td><td>1366.2 TFLOPS</td><td>1329.7 TFLOPS</td></tr><tr><td>(16384, 8192, 7168)</td><td>49.5 TFLOPS</td><td>356.5 TFLOPS</td><td>727.1 TFLOPS</td><td>752.9 TFLOPS</td><td>1120.8 TFLOPS</td><td>1464.6 TFLOPS</td><td>1456.6 TFLOPS</td></tr><tr><td>(16384, 3584, 8192)</td><td>51.0 TFLOPS</td><td>373.3 TFLOPS</td><td>732.2 TFLOPS</td><td>733.0 TFLOPS</td><td>952.9 TFLOPS</td><td>1445.7 TFLOPS</td><td>1370.3 TFLOPS</td></tr><tr><td>(8192, 8192, 8192)</td><td>51.4 TFLOPS</td><td>372.7 TFLOPS</td><td>724.9 TFLOPS</td><td>729.4 TFLOPS</td><td>1029.1 TFLOPS</td><td>1404.4 TFLOPS</td><td>1397.5 TFLOPS</td></tr></tbody></table></div> </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Table showing achieved TFLOPs on H100 80GB depending on precision and matrix shape from the Llama 70B training workload</figcaption> </figure> </div>  </div>
<p><strong>Validating theoretical performance</strong> : Our experiments revealed the gap between theoretical peaks and achievable performance.</p>
<p>For  <strong>FP64</strong>  and  <strong>FP32</strong>  operations, we achieved 49-56 TFLOPs and 356-396 TFLOPs respectively, representing 98-112% and 71-79% of their theoretical peaks. While these show excellent hardware utilization, these precisions are rarely used in modern deep learning training due to their computational cost.</p>
<p>For  <strong>BF16</strong>  operations, we consistently achieved 714-758 TFLOPs across different matrix shapes, approximately 72-77% of the H100’s theoretical 990 TFLOPs peak. This is, in practice, an excellent utilization rate for a real-world workload!</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📊</span> <div class="note__title" data-astro-cid-qg6lmfty>Model FLOPs Utilization (MFU)</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>While kernel benchmarks measure raw TFLOPS, end-to-end training efficiency is captured by <b>Model FLOPs Utilization (MFU)</b>: the ratio of useful model computation to theoretical peak hardware performance.</p><p>Our BF16 matmul benchmarks showed we achieved 72-77% of the H100’s theoretical peak. This represents the upper bound for what’s achievable at the kernel level for our setup. End-to-end training MFU will necessarily be lower due to more complex non-matmul operations, communication overhead, and other auxiliary computations.</p><p><b>State-of-the-art MFU in training</b>: Meta achieved 38-41% when training Llama 3 405B, while DeepSeek-v3 reached ~20-30% on GPUs with tighter communication bottlenecks related to the MoE architecture. For SmolLM3, we achieved ~30% MFU as we’ll see later. Much of the gap comes from inter-node communication overhead in distributed training. Given our kernel-level ceiling of ~77%, these end-to-end numbers represent roughly 50-55% efficiency relative to achievable matmul performance. Inference workloads can reach higher MFU &gt;70%, closer to raw matmul performance, though published results from production deployments are scarce.</p> </div> </div> </div> 
<p>The FP8 results are more nuanced. Let’s look at our results on 3 different matrix multiplication methods/kernels.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>A <a href="https://modal.com/gpu-glossary/device-software/kernel">kernel</a> is the unit of CUDA code.</p> </aside> </div>  
<p>Using PyTorch’s  <code>torch._scaled_mm</code>  kernel with e4m3 precision, we achieved 1,210-1,457 TFLOPs depending on the matrix shape, roughly 31-37% of the theoretical 3,960 TFLOPs peak. 😮 Why? This lower utilization percentage (in FP8) actually doesn’t indicate poor performance; rather, it reflects that these operations become increasingly memory-bound as compute throughput grows. The <a href="https://www.nvidia.com/en-us/data-center/tensor-cores/">Tensor Cores</a> can process FP8 data faster than the memory system can deliver it, making memory bandwidth the limiting factor.</p>
<p>The <a href="https://github.com/NVIDIA/TransformerEngine">Transformer Engine</a>’s  <code>TE.Linear</code>  achieved 547-1,121 TFLOPs depending on the shape, while  <code>torch._scaled_mm</code>  consistently delivered higher throughput. This highlights an important lesson:  <em><strong>kernel implementation matters</strong></em>  <em>significantly, and the choice of API can impact performance by 2-3x even when targeting the same hardware capabilities.</em></p>
<p>For SmolLM3’s training, these practical measurements helped us set realistic throughput expectations. When planning your own training runs, use these achievable numbers rather than theoretical peaks to set your expectations.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>🔧</span> <div class="note__title" data-astro-cid-qg6lmfty>Compute Capability</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Besides choosing the right kernel API, we also need to ensure those kernels are compiled for the right hardware generation. Compute Capability (CC) is NVIDIA’s versioning system that abstracts physical GPU details from the PTX instruction set. It determines which instructions and features your GPU supports.</p><p><b>Why this matters</b>: Kernels compiled for a specific compute capability may not run on older hardware, and you might miss optimizations if your code isn’t compiled for your target GPU’s CC. Even worse, frameworks can silently select suboptimal kernels—we discovered PyTorch selecting sm_75 kernels (compute capability 7.5, designed for Turing GPUs) on our H100s, causing mysterious slowdowns. This is a <a href="https://discuss.pytorch.org/t/performance-issue-torch-matmul-selecting-cutlass-sm75-kernel-for-a100/220682/3" target="_blank">similar issue documented in the PyTorch community</a>, where frameworks often default to older, more compatible kernels rather than optimal ones. This seemingly minor detail can make the difference between getting 720 TFLOPS or 500 TFLOPS from the same hardware.</p><p>When using pre-compiled libraries or custom kernels, always verify they’re built for your hardware’s compute capability to ensure compatibility and optimal performance. For example, sm90_xmma_gemm_…_cublas indicates a kernel compiled for SM 9.0 (compute capability 9.0, used by H100).</p><p>You can check your GPU’s compute capability with <code>nvidia-smi —query-gpu=compute_cap</code> or find the technical specifications in the <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#compute-capabilities" target="_blank">Compute Capability section of the NVIDIA CUDA C Programming Guide</a>.</p> </div> </div> </div> 
<p>As we saw, the GPU memory seems to become a bottleneck when computations get too fast at a low precision. Let’s have a look at how GPU memory works, and at what causes bottlenecks to occur!</p>
<h4 id="gpu-memory-hierarchy-from-registers-to-hbm"><a href="#gpu-memory-hierarchy-from-registers-to-hbm">GPU Memory Hierarchy: From Registers to HBM</a></h4>
<p>In order to make calculations, GPUs need to read/write to memory, so it’s important to know at what speed these transfers happen. Understanding GPU memory hierarchy is crucial for writing high-performance kernels.</p>
<div class="note note--neutral" data-astro-cid-qg6lmfty> <!-- When there's no title, emoji is above content -->
    <div class="note__layout" data-astro-cid-qg6lmfty>  <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__content" data-astro-cid-qg6lmfty> <p>TL;DR: GPUs organize memory in a hierarchy from fast-but-small (registers, shared memory) to slow-but-large (HBM main memory). Understanding this hierarchy is critical because modern AI is often memory-bound: the bottleneck is moving data, not computing on it. Operator fusion (like Flash Attention) achieves 2-4× speedups by keeping intermediate results in fast on-chip memory instead of writing to slow HBM. Benchmarks show H100’s HBM3 delivers ~3 TB/s in practice, matching theoretical specs for large transfers.</p> </div> </div> </div> </div> 
<p>To visualize how memory operations flow through a GPU in practice, let’s first look at the <a href="https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#memory-chart">Memory Chart from NVIDIA Nsight Compute</a>, a profiling graph which shows a graphical representation of how data moves between different memory units for any kernel of your choice:</p>
<div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <div class="ri-root" data-ri-root="ri_0cc8llnpza2i" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/image_2881384e-bcac-80d6-84fe-d705cb1eae0a.DYXAJOyz_1iK6k0.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/image_2881384e-bcac-80d6-84fe-d705cb1eae0a.DYXAJOyz.png" data-astro-cid-6kov3kig width="1800" height="1318" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script>  </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Memory Chart showing data flow through GPU memory hierarchy during FP64 matrix multiplication on H100</figcaption> </figure> </div> 
<p>In general, a Memory Chart shows both  <strong>logical units</strong>  (in green) like Global, Local, Texture, Surface, and Shared memory, and  <strong>physical units</strong>  (in blue) like L1/TEX Cache, Shared Memory, L2 Cache, and Device Memory. Links between units represent the number of instructions (Inst) or requests (Req) happening between units, with colors indicating the percentage of peak utilization: from unused (0%) to operating at peak performance (100%).</p>
<p>You can generate this memory chart for any kernel using <a href="https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html">NVIDIA Nsight Compute</a>:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="bash"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Profile a specific kernel with memory workload analysis</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">ncu</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> full</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --kernel-name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> &quot;your_kernel_name&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --launch-skip</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --launch-count</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> python</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> your_script.py</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D">## Once profiling is complete, open the results in the Nsight Compute GUI to view the Memory Chart</span></span>
<span class="line"></span></code></pre></div>
<p>It provides several key insights:</p>
<ul>
<li><strong>Bottleneck identification</strong> : Saturated links (shown in red/orange) indicate where data movement is constrained</li>
<li><strong>Cache efficiency</strong> : Hit rates for L1/TEX and L2 caches reveal how well your kernel utilizes the memory hierarchy</li>
<li><strong>Memory access patterns</strong> : The flow between logical and physical units shows whether your kernel has good spatial/temporal locality</li>
<li><strong>Port utilization</strong> : Individual memory ports may be saturated even when aggregate bandwidth appears underutilized</li>
</ul>
<p>In our specific case above, you can see how kernel instructions flow through the memory hierarchy (for FP64 matrix multiplications on our hardware): global load instructions generate requests to the L1/TEX cache, which may hit or miss and generate further requests to L2, which ultimately accesses device memory (HBM) on misses. The colored rectangles inside units show port utilization—even if individual links operate below peak, the shared data port may be saturated.</p>
<p>For optimal performance, aim to minimize traffic to slower memory tiers (HBM) while maximizing utilization of faster tiers (shared memory, registers).</p>
<p>Now let’s understand the underlying memory hierarchy that makes this chart possible.</p>
<p>Modern GPUs organize memory in a hierarchy that balances speed, capacity, and cost, a design dictated by fundamental physics and circuit constraints.</p>
<div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <div class="ri-root" data-ri-root="ri_qs58regd9k" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/image_2881384e-bcac-801d-9f3d-c875181b9dd1.CtKK2FLa_Z2eUI4H.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/image_2881384e-bcac-801d-9f3d-c875181b9dd1.CtKK2FLa.png" data-astro-cid-6kov3kig width="1062" height="605" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script>  </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Memory hierarchy of the H100 (SXM5) GPU. Source: [https://www.aleksagordic.com/blog/matmul](https://www.aleksagordic.com/blog/matmul)</figcaption> </figure> </div> 
<p>At the bottom of this hierarchy sits  <strong>HBM (High Bandwidth Memory):</strong> the GPU’s main memory, also called global memory or device memory. The H100 features HBM3 with a theoretical bandwidth of 3.35 TB/s. HBM is the largest but slowest tier in the memory hierarchy.</p>
<p>Moving up the hierarchy toward the compute units, we find progressively faster but smaller memory tiers:</p>
<ul>
<li><strong>L2 cache</strong> : A large SRAM-based cache shared across the GPU, typically several tens of megabytes. On H100, this is 50 MB with a bandwidth of ~13 TB/s</li>
<li><strong>L1 cache and Shared Memory (SMEM)</strong> : Each Streaming Multiprocessor (SM) has its own L1 cache and programmer-managed shared memory, which share the same physical SRAM storage. On H100, this combined space is 256 KB per SM with bandwidth of ~31 TB/s per SM</li>
<li><strong>Register File (RMEM)</strong> : At the top of the hierarchy, registers are the fastest storage, located directly next to compute units. Registers are private to individual threads and offer bandwidth measured in ~100s TB/s per SM</li>
</ul>
<p>This hierarchy exists because SRAM (used for caches and registers) is fast but physically large and expensive, while DRAM (used for HBM) is dense and cheap but slower. The result: fast memory comes in small quantities close to compute, backed by progressively larger pools of slower memory further away.</p>
<p><strong>Why this matters</strong> : Understanding this hierarchy is essential for kernel optimization. The key insight is that memory-bound operations are limited by how fast you can move data, not how fast you can compute. As <a href="https://upload.wikimedia.org/wikipedia/commons/b/b2/Hausziege_04.jpg">Horace He</a> explains in <a href="https://horace.io/brrr_intro.html">Making Deep Learning Go Brrrr From First Principles</a>, “load from memory” → “multiply by itself twice” → “write to memory” takes essentially the same time as “load from memory” → “multiply by itself once” → “write to memory”: the computation is “free” compared to the memory access.</p>
<p>This is why  <strong>operator fusion</strong>  is so powerful: by combining multiple operations into a single kernel, you can keep intermediate results in fast SRAM instead of writing them back to slow HBM between operations. Flash Attention is a perfect example of this principle in action.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>⚡</span> <div class="note__title" data-astro-cid-qg6lmfty>Flash Attention: A Case Study in Memory Hierarchy Optimization</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Standard attention implementations are memory-bound because they materialize the full attention matrix in HBM:</p><ol><li>Compute <code>Q @ K^T</code> → write N×N attention scores to HBM</li><li>Apply softmax → read from HBM, compute, write back to HBM</li><li>Multiply by V → read attention scores from HBM again</li></ol><p>Flash Attention achieves its 2-4× speedup by <b>fusing these operations</b> and keeping intermediate results in SRAM:</p><ul><li>Instead of computing the full attention matrix, it processes attention in tiles that fit in SRAM</li><li>Intermediate attention scores never leave the fast on-chip memory</li><li>Only the final output is written back to HBM</li></ul><p><b>The result</b>: Flash Attention reduces HBM accesses from O(N²) to O(N), transforming a memory-bound operation into one that better utilizes the GPU’s compute capabilities. This is the essence of efficient kernel design: minimize slow memory movement, maximize fast computation.</p> </div> </div> </div> 
<p><strong>Example: Validating our HBM3 Bandwidth in Practice</strong></p>
<p>Now that we understand the memory hierarchy, let’s put theory into practice and validate the actual bandwidth on our H100 GPUs! This is where benchmarking tools become essential.</p>
<p><strong>NVBandwidth</strong>  is NVIDIA’s open-source benchmarking tool designed specifically for measuring bandwidth and latency across GPU systems. It evaluates data transfer rates for various memory copy patterns—host-to-device, device-to-host, and device-to-device operations—using both copy engines and kernel-based methods. The tool is particularly valuable for assessing inter-GPU communication (for example <a href="https://en.wikipedia.org/wiki/NVLink">NVLink</a> and <a href="https://fr.wikipedia.org/wiki/PCI_Express">PCIe</a>, two types of connectors) and validating system performance in multi-GPU environments.</p>
<p>You can install NVBandwidth from <a href="https://github.com/NVIDIA/nvbandwidth">NVIDIA’s GitHub repository</a>. The tool outputs detailed bandwidth matrices showing how efficiently data transfers between different devices, making it ideal for diagnosing performance bottlenecks or verifying healthy GPU interconnects.</p>
<p>Let’s use it to measure our H100’s local memory bandwidth using the  <code>device_local_copy</code>  test, which measures bandwidth of  <code>cuMemcpyAsync</code>  between device buffers local to the GPU across different message sizes.</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>$ ./nvbandwidth -t device_local_copy -b 2048</span></span>
<span class="line"><span>memcpy local GPU(column) bandwidth (GB/s)</span></span>
<span class="line"><span>           0         1         2         3         4         5         6         7</span></span>
<span class="line"><span> 0   1519.07   1518.93   1519.07   1519.60   1519.13   1518.86   1519.13   1519.33</span></span>
<span class="line"><span></span></span></code></pre></div>
<figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">Device local copy bandwidth vs message size</figcaption><div class="html-embed__card"><div id="frag-5w6du30wm3" data-config="{&#34;dataUrl&#34;:&#34;./data/device_local_copy_bandwidth.csv&#34;,&#34;xColumn&#34;:&#34;message_size&#34;,&#34;yColumn&#34;:&#34;bandwidth&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;xScaleType&#34;:&#34;log&#34;,&#34;xAxisLabel&#34;:&#34;Message Size (bytes)&#34;,&#34;yAxisLabel&#34;:&#34;Bandwidth (GB/s)&#34;,&#34;referenceLine&#34;:{&#34;value&#34;:1975,&#34;label&#34;:&#34;Max&#34;},&#34;xFormatAsFileSize&#34;:true}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<p>The results reveal an important characteristic of memory systems:  <strong>for small message sizes (&lt; 1 MB), we’re latency-bound</strong>  rather than bandwidth-bound. The overhead of initiating memory transfers dominates performance, preventing us from reaching peak bandwidth. However,  <strong>for large message sizes (≥ 1 MB), we achieve sustained bandwidth of ~1,500 GB/s for both read and write operations</strong> .</p>
<p>Since HBM bandwidth accounts for both reads and writes happening simultaneously, we sum these to get  <strong>3 TB/s total bidirectional bandwidth</strong>  (1,519 read + 1,519 write), which closely validates the H100’s theoretical 3.35 TB/s HBM3 specification.</p>
<h4 id="roofline-model"><a href="#roofline-model">Roofline Model</a></h4>
<p>Understanding whether your kernel is compute-bound or memory-bound determines which optimizations will help.</p>
<p>There are two scenarios:</p>
<ul>
<li>If you’re  <strong>memory-bound</strong>  (spending most time moving data), increasing compute throughput won’t help: You need to reduce memory traffic through techniques like operator fusion.</li>
<li>If you’re  <strong>compute-bound</strong>  (spending most time on FLOPs), optimizing memory access patterns won’t help: You need more compute power or better algorithms.</li>
</ul>
<p>The  <em>roofline model</em>  provides a visual framework for understanding these performance characteristics and identifying optimization opportunities.</p>
<p>Let’s apply it to a real kernel analysis. It’s available in the NSight Compute profiling tool we mentioned before (under “roofline analysis view”). Here’s what we get:</p>
<div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <div class="ri-root" data-ri-root="ri_q67dup7ees" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/image_2881384e-bcac-80ed-9bdf-c077977d77b8.Dy-eh-v2_Z252kaI.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/image_2881384e-bcac-80ed-9bdf-c077977d77b8.Dy-eh-v2.png" data-astro-cid-6kov3kig width="1007" height="610" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script>  </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Roofline chart showing kernel performance boundaries (source: [NVIDIA NSight Compute Profiling Guide](https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html))</figcaption> </figure> </div> 
<p>Let’s see how we can read this chart, which has two axes:</p>
<ul>
<li><strong>Vertical axis (FLOP/s)</strong> : Shows achieved floating-point operations per second, using a logarithmic scale to accommodate the large range of values</li>
<li><strong>Horizontal axis (Arithmetic Intensity)</strong> : Represents the ratio of work (FLOPs) to memory traffic (bytes), measured in FLOPs per byte. This also uses a logarithmic scale.</li>
</ul>
<p>The roofline itself consists of two boundaries:</p>
<ul>
<li><strong>Memory Bandwidth Boundary</strong>  (sloped line): Determined by the GPU’s memory transfer rate (HBM bandwidth). Performance along this line is limited by how fast data can be moved.</li>
<li><strong>Peak Performance Boundary</strong>  (flat line): Determined by the GPU’s maximum compute throughput. Performance along this line is limited by how fast computations can be executed.</li>
</ul>
<p>The  <strong>ridge point</strong>  where these boundaries meet represents the transition between memory-bound and compute-bound regimes.</p>
<p>We can interpret the performance by looking at the two divided regions of the chart:</p>
<ul>
<li><strong>Memory Bound</strong>  (below the sloped boundary): Kernels in this region are limited by memory bandwidth. The GPU is waiting for data, increasing compute power won’t help. Optimizations should focus on reducing memory traffic through techniques like operator fusion, better memory access patterns, or increasing arithmetic intensity.</li>
<li><strong>Compute Bound</strong>  (below the flat boundary): Kernels in this region are limited by compute throughput. The GPU has enough data but can’t process it fast enough. Optimizations should focus on algorithmic improvements or leveraging specialized hardware like Tensor Cores.</li>
</ul>
<p>The  <strong>achieved value</strong>  (the plotted point) shows where your kernel currently sits. The distance from this point to the roofline boundary represents your optimization headroom, the closer to the boundary, the more optimal your kernel’s performance.</p>
<p>In our example, the kernel sits in the memory-bound region, indicating that there’s still room for improvement by optimizing memory traffic!</p>
<p>For a deeper dive into GPU internals including detailed explanations of CUDA cores, Tensor Cores, memory hierarchies, and low-level optimization techniques, check out the <a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook">Ultrascale Playbook</a>! Now that we understand what happens  <em>inside</em>  a GPU, let’s zoom out and explore how GPUs communicate with the rest of the world.</p>
<h3 id="outside-a-gpu-how-gpus-talk-to-the-world"><a href="#outside-a-gpu-how-gpus-talk-to-the-world">Outside a GPU: How GPUs Talk to the World</a></h3>
<p>Now that we understand how a GPU performs computation using its internal memory hierarchy, we need to address a critical reality: a GPU doesn’t operate in isolation. Before any computation can happen, data must be loaded into the GPU’s memory. The CPU needs to schedule kernels and coordinate work. And in distributed training, GPUs must constantly exchange activations, gradients, and model weights with each other.</p>
<div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <div class="ri-root" data-ri-root="ri_4aramvodfeh" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/h100_dgx_2891384e-bcac-80cf-9f86-ccf0653a79e5.B0aXfJMx_Z2pQ1Hl.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/h100_dgx_2891384e-bcac-80cf-9f86-ccf0653a79e5.B0aXfJMx.gif" data-astro-cid-6kov3kig width="900" height="600" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script>  </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>DGX H100. Source: NVIDIA</figcaption> </figure> </div> 
<p>This is where the external communication infrastructure becomes crucial. No matter how powerful your GPU’s compute units are, if data can’t reach them fast enough, whether from the CPU, from storage, or from other GPUs, your expensive hardware sits idle. Understanding these communication pathways and their bandwidth characteristics is essential for maximizing hardware utilization and minimizing bottlenecks.</p>
<p>In this section, we’ll look at four critical communication links that connect a GPU to the outside world:</p>
<ul>
<li><strong>GPU-CPU</strong> : How the CPU schedules work and transfers data to GPUs</li>
<li><strong>GPU-GPU (same node)</strong> : How GPUs on the same machine communicate</li>
<li><strong>GPU-GPU (different nodes)</strong> : How GPUs across different machines communicate over the network</li>
<li><strong>GPU-Storage</strong> : How data flows from storage to GPU memory</li>
</ul>
<p>Each of these links has different bandwidth and latency characteristics, and understanding them will help you identify where your training pipeline might be bottlenecked. To make this easier to understand, we’ve created a simplified diagram that highlights the most important components and communication links:</p>
<div class="wide"> <div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <figure class="html-embed"><div class="html-embed__card"><div id="frag-iym9b08s34o"><!--
  AWS Bandwidth Bottleneck Visualization
  
  Usage:
  
  Basic:
    <HtmlEmbed src="/embeds/aws-bandwidth-bottleneck.html" />
  
  With initial filter:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ initialFilter: 'cpu-gpu' }} 
    />
  
  With real bandwidths display:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ showRealBandwidths: true }} 
    />
  
  Available filters:
    - cpu-gpu (Intranode: CPU ⟷ GPU)
    - gpu-gpu-cpu (Intranode: GPU ⟷ GPU via CPU)
    - gpu-gpu-nvswitch (Intranode: GPU ⟷ GPU via NVSwitch)
    - gpu-gpu-efa-intranode (Intranode: GPU ⟷ GPU via EFA)
    - gpu-gpu-efa-internode (Internode: GPU ⟷ GPU via EFA)
    - gpu-storage (Storage: GPU ⟷ Storage)
    - cpu-storage (Storage: CPU ⟷ Storage)
    - gpu-cpu-storage (Storage: GPU ⟷ Storage via CPU)
-->
<div class="aws-topology-wrapper">
  <div class="aws-topology-container"></div>
  <div class="aws-topology-controls"></div>
  <div class="aws-topology-legend"></div>
  <div class="aws-topology-tooltip"></div>
  <div class="aws-topology-bottleneck">
    <div class="bottleneck-label">Bandwidth Max</div>
    <div class="bottleneck-path">for CPU → GPU</div>
    <div class="bottleneck-value">-</div>
    <div class="bottleneck-unit">GB/s</div>
    <div class="bottleneck-efficiency" style="display: none;">
      <div class="efficiency-value">-</div>
      <div class="efficiency-label">Efficiency</div>
    </div>
    <div class="real-bandwidths" style="display: none;">
      <div class="real-bandwidths-title">Real Bandwidths</div>
      <div class="real-bandwidths-content"></div>
    </div>
  </div>
</div>

<style>
  .aws-topology-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .aws-topology-container {
    width: 100%;
    height: auto;
    min-height: 400px;
    position: relative;
    transition: opacity 0.15s ease;
  }

  .aws-topology-container.fixed-height {
    height: 850px;
  }

  .aws-topology-container svg {
    width: 100%;
    height: 100%;
  }

  .aws-topology-container svg g {
    transition: opacity 0.2s ease;
  }

  /* Add drop shadow to all links */
  .aws-topology-container svg g[data-link-type] line,
  .aws-topology-container svg g[data-link-type] path {
    filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
  }

  .aws-topology-controls {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 800px;
  }

  .aws-topology-controls-section {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .aws-topology-controls-row {
    display: flex;
    flex-direction: row;
    gap: 16px;
    align-items: flex-start;
  }

  .aws-topology-controls-label {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0.7;
  }

  .aws-topology-controls-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }

  .aws-topology-controls-buttons .button {
    flex-shrink: 0;
  }

  /* Hide controls on mobile */
  @media (max-width: 768px) {
    .aws-topology-controls {
      display: none;
    }
  }

  .aws-topology-legend {
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 264px;
    /* 220 * 1.2 */
    height: 120px;
    /* 100 * 1.2 */
  }

  .aws-topology-tooltip {
    position: absolute;
    padding: 8px 12px;
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 12px;
    color: var(--text-color);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .aws-topology-tooltip.visible {
    opacity: 1;
  }

  .tooltip-label {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-color);
  }

  .tooltip-bandwidth {
    font-size: 11px;
    color: var(--text-secondary);
  }

  .aws-topology-bottleneck {
    position: absolute;
    top: 10px;
    right: 10px;
    text-align: right;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .aws-topology-bottleneck.visible {
    opacity: 1;
  }

  .bottleneck-label {
    font-size: 11px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-value {
    font-size: 24px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    margin-bottom: 2px;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .bottleneck-unit {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-path {
    font-size: 10px;
    color: var(--text-secondary);
    font-style: italic;
    margin-bottom: 6px;
    opacity: 0.8;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-efficiency {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    margin-top: 12px;
    margin-bottom: 4px;
  }

  .efficiency-label {
    font-size: 9px;
    color: var(--text-secondary);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 2px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .efficiency-value {
    font-size: 20px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .real-bandwidths {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
    opacity: 0.9;
  }

  .real-bandwidths-title {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content {
    font-size: 11px;
    color: var(--text-color);
    line-height: 1.4;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content .bandwidth-item {
    margin-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .real-bandwidths-content .bandwidth-label {
    font-size: 10px;
    color: var(--text-secondary);
    opacity: 0.8;
  }

  .real-bandwidths-content .bandwidth-value {
    font-size: 11px;
    font-weight: 600;
    color: var(--primary-color);
  }

  /* Checkbox styling for the bandwidth toggle */
  #real-bandwidth-toggle {
    appearance: none;
    width: 16px;
    height: 16px;
    border: 2px solid var(--border-color);
    border-radius: 3px;
    background-color: var(--page-bg);
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    margin-right: 8px;
  }

  #real-bandwidth-toggle:hover {
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(from var(--primary-color) r g b / 0.1);
  }

  #real-bandwidth-toggle:checked {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:checked::before {
    content: '';
    position: absolute;
    top: 1px;
    left: 4px;
    width: 4px;
    height: 8px;
    border: solid var(--on-primary);
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }

  #real-bandwidth-toggle:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.5/svg.min.js"></script>
<script>
  (function () {
    // Generate unique ID for this instance
    const instanceId = 'aws-topology-' + Math.random().toString(36).substr(2, 9);

    // Store reference to current script to find wrapper later
    const scriptEl = document.currentScript;

    // Function to find wrapper (will be called after DOM is ready)
    let wrapperEl = null;
    const findWrapper = () => {
      if (!wrapperEl) {
        wrapperEl = scriptEl.previousElementSibling;
        if (!wrapperEl || !wrapperEl.classList.contains('aws-topology-wrapper')) {
          // Fallback: search for unmounted wrappers
          const allWrappers = document.querySelectorAll('.aws-topology-wrapper');
          for (const wrapper of allWrappers) {
            if (!wrapper.dataset.mounted) {
              wrapperEl = wrapper;
              break;
            }
          }
        }
        if (wrapperEl && !wrapperEl.dataset.mounted) {
          wrapperEl.dataset.mounted = 'true';
        }
      }
      return wrapperEl;
    };

    // Get all child elements for this instance
    const getElement = (className) => {
      const wrapper = findWrapper();
      return wrapper ? wrapper.querySelector('.' + className) : null;
    };

    // ============================================================================
    // CONFIGURATION - All settings in one place
    // ============================================================================
    const CONFIG = {
      // Canvas settings
      viewbox: {
        width: 2400,  // Width for 2 ensembles side by side
        get height() {
          // Calculate height based on vertical elements × systemCount
          const singleSystemHeight = this.parent.gaps.topMargin +
            this.parent.sizes.cpu +
            this.parent.gaps.cpuToPcie +
            this.parent.sizes.pcie.height +
            this.parent.gaps.pcieToGpu +
            this.parent.sizes.gpu.height +
            this.parent.gaps.gpuToNvswitch +
            this.parent.sizes.nvswitch.height +
            this.parent.gaps.bottomMargin;

          return singleSystemHeight * this.parent.systemCount +
            this.parent.gaps.systemGap * (this.parent.systemCount - 1);
        },
        parent: null  // Will be set to CONFIG
      },

      // System replication
      systemCount: 2,      // Number of complete systems (each has 2 ensembles)
      ensembleCount: 2,    // Number of ensembles per system (each ensemble = CPU + 4 groups + 2 NVSwitches)
      groupCount: 4,       // Groups per ensemble
      nvswitchCount: 2,    // NVSwitches per ensemble

      // Node sizes (all based on CPU size)
      sizes: {
        cpu: 80,
        get pcie() { return { width: this.cpu * 0.75, height: this.cpu * 0.625 * 3 }; },
        get gpu() { return { width: this.cpu, height: this.cpu }; },
        get efa() { return { width: 60, height: 30 }; },
        get nvme() { return { width: 60, height: 30 }; },
        get nvswitch() { return { width: 100, height: 60 }; }
      },

      // Gaps and spacing
      gaps: {
        topMargin: 0,        // Margin from top to CPU
        cpuToPcie: 80,        // Vertical gap CPU → PCIe
        pcieToGpu: 80,        // Vertical gap PCIe → GPU
        gpuToNvswitch: 200,    // Vertical gap GPU → NVSwitch
        bottomMargin: 40,     // Margin from NVSwitch to bottom
        horizontal: 230,      // Horizontal gap between groups
        ensembleGap: 50,     // Horizontal gap between ensembles (within a system)
        systemGap: 30,       // Horizontal gap between complete systems
        connectionOffset: 15  // Gap between node edge and arrow anchor
      },

      // Group layout offsets (all relative positions within a group)
      layout: {
        pcieOffsetX: -40,      // PCIe X offset from group center (to the left)
        efaNvmeOffsetX: 60,    // EFA/NVMe X offset from group center (to the right)
        efaOffsetY: -30,       // EFA Y offset from PCIe Y (above)
        nvmeOffsetY: 30,       // NVMe Y offset from PCIe Y (below)
        groupPadding: 20       // Padding around group bounding box
      },

      // Debug mode
      debug: {
        showPhantoms: false    // Set to true to visualize phantom nodes
      },

      // Highlight paths (for interactive buttons)
      paths: {
        'cpu-gpu': {
          label: 'CPU ⟷ GPU',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'gpu'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' }
          ]
        },
        'gpu-gpu-cpu': {
          label: 'GPU ⟷ GPU via CPU',
          requiredEnsembles: 1,  // Need only 1 ensemble (2 groups within)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'cpu', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'pcie', to: 'cpu' },
            { from: 'cpu', to: 'pcie' },
            { from: 'cpu', to: 'pcie-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-nvswitch': {
          label: 'GPU ⟷ GPU via NVSwitch',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'nvswitch-0', 'gpu-1'],
          links: [
            { from: 'gpu', to: 'nvswitch-0' },
            { from: 'gpu-1', to: 'nvswitch-0' }
          ]
        },
        'gpu-gpu-efa': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-1', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-1', to: 'efa-external-1' },
            { from: 'efa-1', to: 'pcie-efa-phantom-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-efa-intranode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles (same system)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-4', 'pcie-4', 'gpu-4'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-4' },  // EFA cross-link between ensembles (12.5GB/s)
            { from: 'efa-4', to: 'efa-external-4' },
            { from: 'efa-4', to: 'pcie-efa-phantom-4' },
            { from: 'pcie-4', to: 'gpu-4' }
          ]
        },
        'gpu-gpu-efa-internode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles per system
          requiredSystems: 2,    // Need 2 systems
          nodes: ['gpu', 'pcie', 'efa', 'efa-8', 'pcie-8', 'gpu-8'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-8' },  // EFA cross-link between systems
            { from: 'efa-8', to: 'efa-external-8' },
            { from: 'efa-8', to: 'pcie-efa-phantom-8' },
            { from: 'pcie-8', to: 'gpu-8' }
          ]
        },
        'gpu-storage': {
          label: 'GPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'nvme'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'cpu-storage': {
          label: 'CPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'gpu-cpu-storage': {
          label: 'GPU ⟷ Storage via CPU',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'gpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        }
      },


      // Bandwidth levels
      bandwidths: [
        { speed: '900GB/s', label: 'NVLink 4.0', width: 9 },
        { speed: '64GB/s', label: 'PCIe Gen5', width: 6 },
        { speed: '16GB/s', label: 'PCIe Gen4', width: 3 },
        { speed: '12.5GB/s', label: 'EFA Link', width: 1.25 }
      ],

      // Link definitions for groups
      groupLinks: [
        { from: 'cpu', to: 'pcie', bandwidth: '16GB/s', type: 'cpu', fromSide: 'bottom', toSide: 'top', multiLink: true },
        { from: 'efa', to: 'pcie-efa-phantom', bandwidth: '16GB/s', type: 'network', fromSide: 'left', toSide: 'right', stacked: 4 },
        { from: 'nvme', to: 'pcie-nvme-phantom', bandwidth: '16GB/s', type: 'storage', fromSide: 'left', toSide: 'right' },
        { from: 'pcie', to: 'gpu', bandwidth: '64GB/s', type: 'gpu', fromSide: 'bottom', toSide: 'top' },
        { from: 'efa', to: 'efa-external', bandwidth: '12.5GB/s', type: 'network', fromSide: 'right', toSide: 'left', stacked: 4 }
      ],

      // GPU to NVSwitch links (full mesh)
      gpuNvswitchLink: {
        bandwidth: '900GB/s',
        type: 'gpu',
        fromSide: 'bottom',
        toSide: 'top'
      },

      // Colors (using CSS variables for dark mode compatibility)
      colors: {
        // Node colors
        nodeFill: 'var(--page-bg)',
        nodeStroke: 'var(--muted-color)',     // More contrast than border-color
        nodeText: 'var(--text-color)',
        nodePins: 'var(--muted-color)',
        nodeCoreFill: 'rgba(0, 0, 0, 0.05)',  // Very light gray for cores
        nodeCoreStroke: 'rgba(0, 0, 0, 0.2)', // More visible border for cores

        // Link colors
        linkColor: 'var(--primary-color)',
        linkCircleBorder: 'rgba(0, 0, 0, 0.1)', // Border for link circles

        // Group border
        groupBorder: 'var(--border-color)',

        // Phantom debug
        phantomFill: 'rgba(255, 0, 255, 0.2)',
        phantomStroke: 'magenta'
      },

      // Real bandwidth data for display
      realBandwidths: {
        'cpu-gpu': '14.2GB/s',
        'gpu-gpu-same-node': '786GB/s',
        'gpu-gpu-efa-intranode': '40GB/s',
        'gpu-gpu-efa-internode': '40GB/s',
        'allreduce-same-node': '480GB/s',
        'all2all-same-node': '340GB/s',
        'allreduce-internode': '320GB/s',
        'alltoall-internode': '45GB/s',
        'gpu-storage': '14.2GB/s'
      }
    };

    // Initialize viewbox parent reference
    CONFIG.viewbox.parent = CONFIG;

    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================
    function getBandwidth(speed) {
      const bw = CONFIG.bandwidths.find(b => b.speed === speed);
      if (bw) {
        // Add numericValue for comparison
        bw.numericValue = parseFloat(bw.speed.replace('GB/s', ''));
      }
      return bw;
    }

    // Calculate connection offset proportional to link width
    function getLinkOffset(linkWidth) {
      const minOffset = 5;   // Minimum offset for thin links
      const maxOffset = 20;  // Maximum offset for thick links

      // Proportional offset: thinner links = smaller offset
      const proportionalOffset = minOffset + (linkWidth / 10) * (maxOffset - minOffset);
      return Math.min(Math.max(proportionalOffset, minOffset), maxOffset);
    }

    // ============================================================================
    // EFA CROSS-LINKS HELPER
    // ============================================================================
    function drawEfaCrossLinks(renderer, fromId, toId, linkType = 'efa-crosslink') {
      const phantom0 = renderer.nodes.get(fromId);
      const phantom1 = renderer.nodes.get(toId);

      if (!phantom0 || !phantom1) return;

      const efaBw = getBandwidth('12.5GB/s');
      const efaColor = CONFIG.colors.linkColor;

      // Draw 4 stacked links manually (EFA has 4 connections) - randomized order
      const stackCount = 4;
      const spacing = 6; // Fixed spacing between stacked links
      const verticalShift = -95; // Shift up to align with EFA nodes
      const horizontalShift = -40; // Shift left to better position the arrows
      const horizontalExtension = 20; // Extend arrows horizontally on each side

      // Create array of indices and randomize
      const linkIndices = Array.from({ length: stackCount }, (_, i) => i);
      const shuffledIndices = linkIndices.sort(() => Math.random() - 0.5);

      // Draw horizontal lines with vertical offset for stacking
      shuffledIndices.forEach(i => {
        const offsetY = (i - (stackCount - 1) / 2) * spacing;

        const efaCrossGroup = renderer.crossLinksGroup.group();
        efaCrossGroup.attr('data-link-type', linkType);
        efaCrossGroup.attr('data-from', fromId);
        efaCrossGroup.attr('data-to', toId);
        efaCrossGroup.attr('data-bandwidth', '12.5GB/s');
        efaCrossGroup.attr('data-label', 'EFA Link');

        // Draw line with vertical offset for stacking + shifts + horizontal extension
        const x0 = phantom0.x + horizontalShift;
        const x1 = phantom1.x + horizontalShift + horizontalExtension;
        const y0 = phantom0.y + offsetY + verticalShift;
        const y1 = phantom1.y + offsetY + verticalShift;

        // Draw border
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: efaColor, width: efaBw.width, opacity: 1 });

        // Draw circles at both ends
        const r = efaBw.width * 0.8;
        const startCircle = efaCrossGroup.circle(r * 2).move(x0 - r, y0 - r);
        startCircle.fill(efaColor);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = efaCrossGroup.circle(r * 2).move(x1 - r, y1 - r);
        endCircle.fill(efaColor);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');
      });

      // Add vertical bars at both ends (connect horizontal arrows to EFA phantoms)
      const barColor = CONFIG.colors.linkColor;

      shuffledIndices.forEach(i => {
        const offsetX = (i - (stackCount - 1) / 2) * spacing + 12; // Horizontal offset for vertical bars
        const yHorizontal = phantom0.y + verticalShift + 10;
        const yPhantom = phantom0.y + 8; // End a bit higher (5px above phantom center)

        // Left vertical bar (one per horizontal arrow)
        const leftBarGroup = renderer.crossLinksGroup.group();
        leftBarGroup.attr('data-link-type', linkType);
        leftBarGroup.attr('data-from', fromId);
        leftBarGroup.attr('data-to', toId);
        leftBarGroup.attr('data-bandwidth', '12.5GB/s');
        leftBarGroup.attr('data-label', 'EFA Link');

        const x0 = phantom0.x + horizontalShift + offsetX;

        // Draw border
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const r = efaBw.width * 0.8;
        const bottomCircle0 = leftBarGroup.circle(r * 2).move(x0 - r, yPhantom - r);
        bottomCircle0.fill(barColor);
        bottomCircle0.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle0.attr('data-link-circle', 'true');

        // Right vertical bar (one per horizontal arrow)
        const rightBarGroup = renderer.crossLinksGroup.group();
        rightBarGroup.attr('data-link-type', linkType);
        rightBarGroup.attr('data-from', fromId);
        rightBarGroup.attr('data-to', toId);
        rightBarGroup.attr('data-bandwidth', '12.5GB/s');
        rightBarGroup.attr('data-label', 'EFA Link');

        const x1 = phantom1.x + horizontalShift + offsetX;

        // Draw border
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const bottomCircle1 = rightBarGroup.circle(r * 2).move(x1 - r, yPhantom - r);
        bottomCircle1.fill(barColor);
        bottomCircle1.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle1.attr('data-link-circle', 'true');
      });
    }

    // ============================================================================
    // SVG HELPERS
    // ============================================================================
    class TopologyRenderer {
      constructor(draw) {
        this.draw = draw;
        this.nodes = new Map();
        this.structuralGroup = draw.group();  // Structural elements (Node/NUMA borders, never ghosted)
        this.structuralGroup.attr('data-group', 'structural');
        this.baseLinksGroup = draw.group();   // Base links layer (will be ghosted)
        this.baseLinksGroup.attr('data-group', 'base-links');
        this.linksGroup = this.baseLinksGroup; // Alias for compatibility
        this.nodesGroup = draw.group();   // Nodes layer (middle)
        this.phantomsGroup = draw.group(); // Phantoms layer (for debug)
        this.baseCrossLinksGroup = draw.group(); // Base EFA cross-links layer
        this.baseCrossLinksGroup.attr('data-group', 'base-cross-links');
        this.crossLinksGroup = this.baseCrossLinksGroup; // Alias for compatibility
        this.activeLinksGroup = draw.group(); // Active (duplicated) links layer (top, non-ghosted)
        this.activeLinksGroup.attr('data-group', 'active-links');
      }

      // Draw a simple rectangular node
      // Helper: Draw text with consistent styling
      drawText(x, y, label, group = this.nodesGroup) {
        if (!label) return;

        const lines = label.split('\n');
        lines.forEach((line, i) => {
          group.text(line)
            .font({ family: 'Inter, sans-serif', size: 12, weight: '600', anchor: 'middle' })
            .fill(CONFIG.colors.nodeText)
            .cx(x)
            .cy(y + (i - (lines.length - 1) / 2) * 14);
        });
      }

      // Helper: Draw pins around a node
      drawPins(x, y, width, height, pinConfig = {}, targetGroup = null) {
        const group = targetGroup || this.nodesGroup;

        const defaultConfig = {
          pinsPerSide: width >= 80 ? 18 : 15,
          pinLength: 3,
          pinOffset: width / 2 + 1.5,
          pinPadding: 12
        };

        const config = { ...defaultConfig, ...pinConfig };
        const pinStartOffset = -width / 2 + config.pinPadding;
        const pinEndOffset = width / 2 - config.pinPadding;
        const pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);

        const sides = [
          { side: 'left', xOffset: -config.pinOffset, yOffset: 0 },
          { side: 'right', xOffset: config.pinOffset, yOffset: 0 },
          { side: 'top', xOffset: 0, yOffset: -config.pinOffset },
          { side: 'bottom', xOffset: 0, yOffset: config.pinOffset }
        ];

        sides.forEach(({ side, xOffset, yOffset }) => {
          for (let i = 0; i < config.pinsPerSide; i++) {
            const pinX = x + xOffset + (side === 'left' || side === 'right' ? 0 : pinStartOffset + (i * pinSpacing));
            const pinY = y + yOffset + (side === 'top' || side === 'bottom' ? 0 : pinStartOffset + (i * pinSpacing));

            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      drawNode(id, x, y, width, height, label, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      drawNodeWithPins(id, x, y, width, height, label, pinConfig = {}, nodeType = '') {
        const node = this.drawNode(id, x, y, width, height, label, nodeType);
        this.drawPins(x, y, width, height, pinConfig);
        return node;
      }

      drawNodeWithCores(id, x, y, width, height, label, coreConfig = {}, nodeType = '') {
        // Draw main node
        const node = this.drawNode(id, x, y, width, height, label, nodeType);

        // Default core configuration
        const defaultCoreConfig = {
          coresX: 2,              // 2x2 for CPU, 8x8 for GPU
          coresY: 2,
          coreSpacing: 2,         // Space between cores
          coreMargin: 8           // Margin from node edges
        };

        const config = { ...defaultCoreConfig, ...coreConfig };

        // Calculate core size
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coreSpacing * (config.coresX - 1))) / config.coresX;
        const coreHeight = (availableHeight - (config.coreSpacing * (config.coresY - 1))) / config.coresY;

        // Draw cores
        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            this.nodesGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        return node;
      }

      drawProcessorNode(id, x, y, width, height, label, type = 'cpu') {
        // Create main group for the node
        const nodeGroup = this.nodesGroup.group();
        nodeGroup.attr('id', id);
        nodeGroup.attr('data-node-type', type);

        // Draw node background
        nodeGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Draw cores
        const coreConfig = type === 'gpu' ? { coresX: 8, coresY: 8 } : { coresX: 2, coresY: 2 };
        const config = { coreSpacing: 2, coreMargin: 8, ...coreConfig };
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coresX - 1) * config.coreSpacing) / config.coresX;
        const coreHeight = (availableHeight - (config.coresY - 1) * config.coreSpacing) / config.coresY;

        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            nodeGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        // Draw pins in the same group
        this.drawPins(x, y, width, height, {}, nodeGroup);

        // Draw text on top
        this.drawText(x, y, label, nodeGroup);

        // Store node position
        this.nodes.set(id, { x, y, width, height });

        return nodeGroup;
      }

      // Add pins to an existing node (without changing the node design)
      addPinsToNode(nodeId, pinConfig = {}) {
        const node = this.nodes.get(nodeId);
        if (!node) return;

        // Find the node's SVG group
        const svg = getElement('aws-topology-container').querySelector('svg');
        if (!svg) return;
        const nodeGroup = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeGroup) return;

        // Use SVG.js to manipulate the group
        const group = this.draw.findOne(`#${nodeId}`);
        if (!group) return;

        // Default pin configuration
        const defaultPinConfig = {
          pinsPerSide: node.width >= 80 ? 18 : 15,
          sides: ['left', 'right', 'top', 'bottom'],
          pinLength: 3,
          pinPadding: 12
        };

        const config = { ...defaultPinConfig, ...pinConfig };

        // Generate pins on specified sides only
        config.sides.forEach(side => {
          let pinSpacing, pinStartOffset, pinEndOffset;

          if (side === 'left' || side === 'right') {
            pinStartOffset = -node.height / 2 + config.pinPadding;
            pinEndOffset = node.height / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          } else {
            pinStartOffset = -node.width / 2 + config.pinPadding;
            pinEndOffset = node.width / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          }

          for (let i = 0; i < config.pinsPerSide; i++) {
            let pinX, pinY;

            if (side === 'left') {
              pinX = node.x - node.width / 2 - 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'right') {
              pinX = node.x + node.width / 2 + 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'top') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y - node.height / 2 - 1.5;
            } else if (side === 'bottom') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y + node.height / 2 + 1.5;
            }

            // Draw pin in the node's group
            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      // Draw a stacked node (visual stack effect)
      drawStackedNode(id, x, y, width, height, label, stackCount, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        for (let i = stackCount - 1; i >= 0; i--) {
          const offsetY = i * 3;
          group.rect(width, height)
            .move(x - width / 2, y - height / 2 + offsetY)
            .fill(CONFIG.colors.nodeFill)
            .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
            .radius(4)
            .opacity(1);
        }

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw a storage node (NVMe) with internal rectangle
      drawStorageNode(id, x, y, width, height, label, nodeType = 'storage') {
        const group = this.nodesGroup.group();
        group.attr('id', id);
        if (nodeType) group.attr('data-node-type', nodeType);

        // Main node background
        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Internal rectangle on the left side (flush with edge)
        const internalRectWidth = 5;
        const internalRectHeight = height * .6; // Full height
        const internalRectX = x - width / 2; // Flush with left edge
        const internalRectY = y - height / 2 + height * .20;

        group.rect(internalRectWidth, internalRectHeight)
          .move(internalRectX, internalRectY)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: '#ffffff', width: 1 })
          .opacity(.4)
          .radius(0); // No radius

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw background rectangle
      drawBackground(id, x, y, width, height) {
        const bg = this.linksGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 2,
            dasharray: '5,5'
          })
          .radius(8);

        this.nodes.set(id, { x, y, width, height });
        return bg;
      }

      // Get connection point on a node's side with configurable offset and multi-link spacing
      getPoint(nodeId, side, offset = CONFIG.gaps.connectionOffset, linkIndex = 0, totalLinks = 1) {
        const node = this.nodes.get(nodeId);
        if (!node) return { x: 0, y: 0 };

        const points = {
          top: { x: node.x, y: node.y - node.height / 2 - offset },
          right: { x: node.x + node.width / 2 + offset, y: node.y },
          bottom: { x: node.x, y: node.y + node.height / 2 + offset },
          left: { x: node.x - node.width / 2 - offset, y: node.y }
        };

        let basePoint = points[side] || { x: node.x, y: node.y };

        // Apply spacing for multiple links to the same anchor
        if (totalLinks > 1) {
          const isVerticalAnchor = (side === 'top' || side === 'bottom');

          // Vertical anchors (top/bottom) space horizontally, horizontal anchors (left/right) space vertically
          const spacing = isVerticalAnchor ? node.width / (totalLinks + 1) : node.height / (totalLinks + 1);
          const linkOffset = (linkIndex - (totalLinks - 1) / 2) * spacing;

          // Apply offset in the perpendicular direction to the anchor
          if (isVerticalAnchor) {
            basePoint.x += linkOffset;  // Horizontal offset for vertical anchors
          } else {
            basePoint.y += linkOffset;  // Vertical offset for horizontal anchors
          }
        }

        return basePoint;
      }

      // Draw single link with optional multi-link spacing
      drawLink(fromId, toId, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, fromLinkIndex = 0, fromTotalLinks = 1, toLinkIndex = 0, toTotalLinks = 1, linkType = '', bandwidth = '') {
        const start = this.getPoint(fromId, fromSide, offset, fromLinkIndex, fromTotalLinks);
        const end = this.getPoint(toId, toSide, offset, toLinkIndex, toTotalLinks);

        const group = this.linksGroup.group();
        if (linkType) group.attr('data-link-type', linkType);
        if (bandwidth) {
          group.attr('data-bandwidth', bandwidth);
          // Find label from bandwidth config
          const bwConfig = getBandwidth(bandwidth);
          if (bwConfig && bwConfig.label) {
            group.attr('data-label', bwConfig.label);
          }
        }
        group.attr('data-from', fromId);
        group.attr('data-to', toId);

        // Check if this is a vertical connection (GPU-NVSwitch or CPU-PCIe)
        const isVerticalConnection = fromSide === 'bottom' && toSide === 'top';

        if (isVerticalConnection) {
          // Use curved paths for vertical connections
          const curvature = 45; // Fixed curvature value for consistent curve strength

          // Create a smooth cubic bezier curve with vertical control points
          const pathData = `M ${start.x} ${start.y} C ${start.x} ${start.y + curvature}, ${end.x} ${end.y - curvature}, ${end.x} ${end.y}`;

          // Draw border (wider path behind)
          group.path(pathData)
            .fill('none')
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main path on top
          group.path(pathData)
            .fill('none')
            .stroke({ color, width, opacity: 1 });
        } else {
          // Draw straight lines for other connections
          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });
        }

        const r = width * 0.8;
        const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');

        return group;
      }

      // Draw stacked links
      drawStackedLinks(fromId, toId, count, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, linkType = '', bandwidth = '') {
        const fromNode = this.nodes.get(fromId);
        const toNode = this.nodes.get(toId);
        if (!fromNode || !toNode) return [];

        const isHorizontal = (fromSide === 'left' || fromSide === 'right') &&
          (toSide === 'left' || toSide === 'right');
        const spacing = isHorizontal
          ? Math.min(fromNode.height, toNode.height) / (count + 1)
          : Math.min(fromNode.width, toNode.width) / (count + 1);

        const arrows = [];
        for (let i = 0; i < count; i++) {
          const stackOffset = (i - (count - 1) / 2) * spacing;
          let start = this.getPoint(fromId, fromSide, offset);
          let end = this.getPoint(toId, toSide, offset);

          if (isHorizontal) {
            start.y += stackOffset;
            end.y += stackOffset;
          } else {
            start.x += stackOffset;
            end.x += stackOffset;
          }

          const group = this.linksGroup.group();
          if (linkType) group.attr('data-link-type', linkType);
          if (bandwidth) {
            group.attr('data-bandwidth', bandwidth);
            // Find label from bandwidth config
            const bwConfig = getBandwidth(bandwidth);
            if (bwConfig && bwConfig.label) {
              group.attr('data-label', bwConfig.label);
            }
          }
          group.attr('data-from', fromId);
          group.attr('data-to', toId);

          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });

          const r = width * 0.8;
          const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
          startCircle.fill(color);
          startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          startCircle.attr('data-link-circle', 'true');

          const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
          endCircle.fill(color);
          endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          endCircle.attr('data-link-circle', 'true');

          arrows.push(group);
        }
        return arrows;
      }

      // Add phantom node (invisible connection point)
      addPhantom(id, x, y, width = 30, height = 30) {
        this.nodes.set(id, { x, y, width, height });

        // Draw phantom for debug visualization
        if (CONFIG.debug.showPhantoms) {
          this.phantomsGroup.rect(width, height)
            .move(x - width / 2, y - height / 2)
            .fill('rgba(255, 0, 255, 0.2)')  // Semi-transparent magenta
            .stroke({ color: 'magenta', width: 2, dasharray: '4,4' })
            .radius(4);

          // Add label
          this.phantomsGroup.text(id)
            .move(x, y)
            .font({
              family: 'system-ui, -apple-system, sans-serif',
              size: 10,
              anchor: 'middle',
              fill: 'magenta',
              weight: 'bold'
            })
            .dy(-height / 2 - 5);
        }
      }
    }

    // ============================================================================
    // DRAW SINGLE GROUP
    // ============================================================================
    function drawGroup(renderer, globalIndex, localIndex, x, cpuY, nvswitchY, cpuId = 'cpu') {
      const s = CONFIG.sizes;
      const g = CONFIG.gaps;
      const l = CONFIG.layout;
      const suffix = globalIndex > 0 ? `-${globalIndex}` : '';

      // Calculate Y positions
      const pcieY = cpuY + s.cpu / 2 + g.cpuToPcie + s.pcie.height / 2;
      const gpuY = pcieY + s.pcie.height / 2 + g.pcieToGpu + s.gpu.height / 2;

      // Calculate node positions
      const pcieX = x + l.pcieOffsetX;
      const efaX = x + l.efaNvmeOffsetX;
      const nvmeX = x + l.efaNvmeOffsetX;
      const efaY = pcieY + l.efaOffsetY;
      const nvmeY = pcieY + l.nvmeOffsetY;

      // Calculate bounding box BEFORE creating nodes
      const nodeBounds = [
        { x: pcieX, y: pcieY, width: s.pcie.width, height: s.pcie.height },
        { x: efaX, y: efaY, width: s.efa.width, height: s.efa.height },
        { x: nvmeX, y: nvmeY, width: s.nvme.width, height: s.nvme.height },
        { x: pcieX, y: gpuY, width: s.gpu.width, height: s.gpu.height }
      ];

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      nodeBounds.forEach(node => {
        minX = Math.min(minX, node.x - node.width / 2);
        maxX = Math.max(maxX, node.x + node.width / 2);
        minY = Math.min(minY, node.y - node.height / 2);
        maxY = Math.max(maxY, node.y + node.height / 2);
      });

      const bgWidth = maxX - minX + l.groupPadding * 2;
      const bgHeight = maxY - minY + l.groupPadding * 2;
      const bgCenterX = (minX + maxX) / 2;
      const bgCenterY = (minY + maxY) / 2;

      // Draw background FIRST (will be behind nodes)
      renderer.drawBackground(`group${suffix}`, bgCenterX, bgCenterY, bgWidth, bgHeight);

      // Nodes
      renderer.drawNode(`pcie${suffix}`, pcieX, pcieY, s.pcie.width, s.pcie.height, 'PCIe\nSwitch', 'network');
      renderer.addPinsToNode(`pcie${suffix}`, {
        pinsPerSide: 6,
        sides: ['left', 'right'],
        pinLength: 3,
        pinPadding: 8
      });
      renderer.drawStackedNode(`efa${suffix}`, efaX, efaY, s.efa.width, s.efa.height, 'EFA', 4, 'network');
      renderer.drawStorageNode(`nvme${suffix}`, nvmeX, nvmeY, s.nvme.width, s.nvme.height, 'NVMe', 'storage');
      renderer.drawProcessorNode(`gpu${suffix}`, pcieX, gpuY, s.gpu.width, s.gpu.height, 'GPU', 'gpu');

      // Phantom nodes for routing
      // PCIe phantoms: bord gauche aligné avec PCIe, largeur du PCIe
      const pcieLeftEdge = pcieX;
      const pciePhantomX = pcieLeftEdge;
      renderer.addPhantom(`pcie-efa-phantom${suffix}`, pciePhantomX, efaY, s.pcie.width, s.efa.height);
      renderer.addPhantom(`pcie-nvme-phantom${suffix}`, pciePhantomX, nvmeY, s.pcie.width, s.nvme.height);

      // EFA external phantom: à droite de EFA
      const efaRightEdge = efaX + s.efa.width / 2;
      const efaPhantomX = efaRightEdge + g.connectionOffset + s.efa.width / 2 + 20;  // Centre du phantom + décalage réduit
      renderer.addPhantom(`efa-external${suffix}`, efaPhantomX, efaY, s.efa.width, s.efa.height);

      // Create links from configuration
      CONFIG.groupLinks.forEach(linkDef => {
        const bw = getBandwidth(linkDef.bandwidth);
        const fromId = linkDef.from === 'cpu' ? cpuId : `${linkDef.from}${suffix}`;  // Use cpuId from parameter
        const toId = `${linkDef.to}${suffix}`;
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const offset = getLinkOffset(bw.width);  // Proportional offset based on link width

        if (linkDef.stacked) {
          renderer.drawStackedLinks(fromId, toId, linkDef.stacked, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, linkDef.type, linkDef.bandwidth);
        } else if (linkDef.multiLink) {
          // Use localIndex for multi-link spacing (0-3 within ensemble)
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, localIndex, CONFIG.groupCount, 0, 1, linkDef.type, linkDef.bandwidth);
        } else {
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, 0, 1, 0, 1, linkDef.type, linkDef.bandwidth);
        }
      });
    }

    // ============================================================================
    // DRAW SINGLE ENSEMBLE (CPU + 4 groups + 2 NVSwitches)
    // ============================================================================
    function drawEnsemble(renderer, ensembleGlobalIndex, centerX, cpuY, nvswitchY) {
      const cpuId = ensembleGlobalIndex === 0 ? 'cpu' : `cpu-${ensembleGlobalIndex}`;

      // CPU for this ensemble
      renderer.drawProcessorNode(cpuId, centerX, cpuY, CONFIG.sizes.cpu, CONFIG.sizes.cpu, 'CPU', 'cpu');

      // Groups for this ensemble
      for (let i = 0; i < CONFIG.groupCount; i++) {
        const groupGlobalIndex = ensembleGlobalIndex * CONFIG.groupCount + i;
        const offsetX = (i - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal;
        drawGroup(renderer, groupGlobalIndex, i, centerX + offsetX, cpuY, nvswitchY, cpuId);  // Pass i as localIndex
      }

      // NVSwitches: positioned between pairs of groups
      for (let i = 0; i < CONFIG.nvswitchCount; i++) {
        const nvswitchGlobalIndex = ensembleGlobalIndex * CONFIG.nvswitchCount + i;
        const groupPairStart = i * 2;
        const groupPairEnd = groupPairStart + 1;

        const group1X = centerX + ((groupPairStart - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const group2X = centerX + ((groupPairEnd - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const nvswitchX = (group1X + group2X) / 2;

        renderer.drawNode(`nvswitch-${nvswitchGlobalIndex}`, nvswitchX, nvswitchY,
          CONFIG.sizes.nvswitch.width, CONFIG.sizes.nvswitch.height, 'NVSwitch', 'network');

        // Add pins to NVSwitch (like PCIe Switch)
        renderer.addPinsToNode(`nvswitch-${nvswitchGlobalIndex}`, {
          pinsPerSide: 6,
          sides: ['left', 'right'],
          pinLength: 3,
          pinPadding: 8
        });
      }

    }


    // ============================================================================
    // DRAW SINGLE SYSTEM (variable number of ensembles)
    // ============================================================================
    function drawSystem(renderer, systemIndex, systemCenterX, cpuY, nvswitchY, ensembleCount = 1, systemCount = 1, shouldDrawEfaCrossLinks = false) {
      // For internode (2 systems), only show 1 ensemble per system for clarity
      const ensemblesToShow = (systemCount === 2) ? 1 : ensembleCount;

      // Calculate ensemble width (4 groups)
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;

      // Calculate system bounding box based on actual ensembles shown
      const systemWidth = ensemblesToShow * ensembleWidth + (ensemblesToShow - 1) * CONFIG.gaps.ensembleGap;
      const systemHeight = CONFIG.sizes.cpu + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height;

      const systemBgCenterY = cpuY + (nvswitchY - cpuY) / 2;
      const systemPadding = 30;

      // In internode mode, extend the rectangle slightly to the right
      const isInternode = systemCount === 2;
      const extraWidth = isInternode && ensembleCount === 2 ? 210 : 0;

      // Draw system background ONLY if 2 ensembles (intra-node vs inter-node distinction)
      if (ensembleCount === 2) {
        // Adjust rectX to center the extended rectangle
        const totalWidth = systemWidth + systemPadding * 2 + extraWidth;
        const rectX = systemCenterX - totalWidth / 2;
        const rectY = systemBgCenterY - (systemHeight + systemPadding * 2) / 2;
        const rectWidth = totalWidth;
        const rectHeight = systemHeight + systemPadding * 2;

        renderer.structuralGroup.rect(rectWidth, rectHeight)
          .move(rectX, rectY)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 3,
            opacity: 1
          })
          .radius(12)
          .attr('data-group-border', 'node');

        // Add "Node" label at top left of the system box
        renderer.nodesGroup.text('Node')
          .move(rectX + 35, rectY + 40)
          .font({
            size: 32,
            family: 'var(--font-family)',
            weight: 900,
            fill: CONFIG.colors.textSecondary
          })
          .opacity(0.8);

        // Add NUMA 1 group with "..." in the extended area for internode mode
        if (isInternode) {
          const numaPadding = 15;
          const numaWidth = extraWidth - 15; // Margin for spacing
          const numaHeight = systemHeight;

          const numaX = rectX + rectWidth - extraWidth; // Left margin
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth;
          const numaRectHeight = numaHeight + numaPadding * 2;

          // Draw NUMA 1 border
          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA 1" label at top right
          renderer.nodesGroup.text('NUMA 1')
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);

          // Add "..." centered in NUMA 1
          renderer.nodesGroup.text('...')
            .move(numaX + numaRectWidth / 2, numaY + numaRectHeight / 2)
            .font({
              size: 40,
              family: 'var(--font-family)',
              weight: 900,
              fill: CONFIG.colors.textSecondary,
              anchor: 'middle'
            })
            .opacity(0.6);
        }
      }

      // Draw each ensemble in the system
      for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
        const ensembleGlobalIndex = systemIndex * CONFIG.ensembleCount + ensIndex;

        // Position ensemble within system
        let ensembleCenterX;
        if (isInternode) {
          // In internode mode, align NUMA 0 to the left of the Node rectangle
          const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
          ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
        } else {
          // Normal centered positioning
          const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
          ensembleCenterX = systemCenterX + ensembleOffsetX;
        }

        drawEnsemble(renderer, ensembleGlobalIndex, ensembleCenterX, cpuY, nvswitchY);
      }

      // Draw NUMA node borders (one per ensemble) if 2 ensembles
      if (ensembleCount === 2) {
        for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
          let ensembleCenterX;
          if (isInternode) {
            // In internode mode, align NUMA 0 to the left
            const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
            ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
          } else {
            // Normal centered positioning
            const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
            ensembleCenterX = systemCenterX + ensembleOffsetX;
          }

          // Calculate NUMA node bounding box (same as system but for single ensemble)
          const numaWidth = ensembleWidth;
          const numaHeight = systemHeight;
          const numaPadding = 15;

          const numaX = ensembleCenterX - (numaWidth + numaPadding * 2) / 2;
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth + numaPadding * 2;
          const numaRectHeight = numaHeight + numaPadding * 2;

          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA" label at top right
          renderer.nodesGroup.text(`NUMA ${ensIndex}`)
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);
        }
      }

      // GPU to NVSwitch connections (full mesh - all GPUs to all NVSwitches in system)
      const linkDef = CONFIG.gpuNvswitchLink;
      const bw = getBandwidth(linkDef.bandwidth);
      const color = CONFIG.colors.linkColor;
      const offset = getLinkOffset(bw.width);

      // Connect all GPUs in the system to all NVSwitches in the system
      const totalGpusInSystem = ensemblesToShow * CONFIG.groupCount;
      const totalNVSwitchesInSystem = ensemblesToShow * CONFIG.nvswitchCount;

      // Collect all GPU-NVSwitch connections for randomized drawing
      const gpuNvswitchConnections = [];
      for (let gpuIndex = 0; gpuIndex < totalGpusInSystem; gpuIndex++) {
        const gpuGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + gpuIndex;
        const gpuId = gpuGlobalIndex === 0 ? 'gpu' : `gpu-${gpuGlobalIndex}`;

        for (let nvIndex = 0; nvIndex < totalNVSwitchesInSystem; nvIndex++) {
          const nvswitchGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.nvswitchCount + nvIndex;
          gpuNvswitchConnections.push({
            fromId: gpuId,
            toId: `nvswitch-${nvswitchGlobalIndex}`,
            color: color,
            width: bw.width,
            fromSide: linkDef.fromSide,
            toSide: linkDef.toSide,
            offset: offset,
            type: linkDef.type,
            bandwidth: linkDef.bandwidth
          });
        }
      }

      // Randomize and draw GPU-NVSwitch connections
      const shuffledGpuNvswitchConnections = gpuNvswitchConnections.sort(() => Math.random() - 0.5);
      shuffledGpuNvswitchConnections.forEach(conn => {
        renderer.drawLink(conn.fromId, conn.toId, conn.color, conn.width, conn.fromSide, conn.toSide, conn.offset, 0, 1, 0, 1, conn.type, conn.bandwidth);
      });

      // Draw CPU-to-CPU link between ensembles (only if 2 ensembles visible)
      if (ensemblesToShow === 2) {
        const cpu0Id = systemIndex * CONFIG.ensembleCount === 0 ? 'cpu' : `cpu-${systemIndex * CONFIG.ensembleCount}`;
        const cpu1Id = `cpu-${systemIndex * CONFIG.ensembleCount + 1}`;

        // Use a bandwidth for CPU-CPU connection (assuming similar to CPU-PCIe)
        const bw = getBandwidth('16GB/s');
        const color = CONFIG.colors.linkColor;
        const offset = getLinkOffset(bw.width);

        renderer.drawLink(cpu0Id, cpu1Id, color, bw.width, 'right', 'left', offset, 0, 1, 0, 1, 'cpu', '16GB/s');

        // Draw EFA-to-EFA link between ensembles (only if 2 ensembles visible and explicitly requested)
        if (ensemblesToShow === 2 && shouldDrawEfaCrossLinks) {
          const efaExt0Id = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount === 0 ? 'efa-external' : `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount}`;
          const efaExt1Id = `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + CONFIG.groupCount}`;

          // Use unified EFA cross-links function
          drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
        }
      }
    }

    // ============================================================================
    // DRAW COMPLETE TOPOLOGY
    // ============================================================================
    let currentEnsembleCount = 2;  // Start with 2 ensembles (1 complete node)
    let currentSystemCount = 1;    // Start with 1 system
    let currentActivePathId = null; // Track active path for conditional rendering
    let showRealBandwidthsOverride = null; // User override via checkbox (null = use config)

    function drawTopology(ensembleCount = currentEnsembleCount, systemCount = currentSystemCount) {
      // Clear existing
      const container = getElement('aws-topology-container');
      container.innerHTML = '';

      // Use FIXED viewbox size for consistent zoom across all modes
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;
      const isInternodeLayout = systemCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode';

      // Calculate single system height (used in both layouts)
      const singleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;

      // Always use max viewbox dimensions for consistent zoom level
      const maxEnsembleWidthForViewbox = 2 * ensembleWidth;
      let viewboxWidth = maxEnsembleWidthForViewbox + CONFIG.gaps.ensembleGap + 200;
      let viewboxHeight = singleSystemHeight;

      // For single ensemble (CPU-GPU, GPU-GPU via CPU, storage paths), zoom in more
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxWidth *= 0.65;  // Zoom in by reducing viewbox width (increased from 0.75)
        viewboxHeight *= 0.65; // Zoom in by reducing viewbox height (increased from 0.75)
      }

      // For 2 systems in vertical layout, use scaled dimensions
      if (systemCount === 2 && !isInternodeLayout) {
        viewboxHeight = singleSystemHeight * 2 + CONFIG.gaps.systemGap;
        viewboxWidth *= 1.15;
        viewboxHeight *= 1.15;
      }

      // For internode horizontal layout, extend viewbox width to accommodate both extended systems
      if (isInternodeLayout) {
        const extraWidth = 210; // Extension per system for NUMA 1
        const systemPadding = 30;
        const singleEnsembleWidth = ensembleWidth;
        const totalSystemWidth = singleEnsembleWidth + systemPadding * 2 + extraWidth;
        const gap = 80;
        viewboxWidth = totalSystemWidth * 2 + gap + 200; // Extra margin for comfort
      }

      // Fixed height based on screen width for better consistency
      const embedConfig = readEmbedConfig();
      const containerWidth = container.clientWidth || 800;

      // Calculate fixed height: use max viewbox dimensions to determine aspect ratio
      // Max viewbox is for 2 ensembles, 2 systems (vertical layout)
      const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
      const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;
      const maxViewboxHeight = maxSingleSystemHeight * 1.15; // Account for 2-system scaling
      const maxViewboxWidth = maxEnsembleWidth + 200;

      const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
      const baseHeight = containerWidth * maxAspectRatio;
      const legendHeight = embedConfig.initialFilter ? 150 : 200;

      // Set fixed height once, won't change on filter change
      if (!container.dataset.heightSet) {
        container.style.height = `${baseHeight + legendHeight}px`;
        container.dataset.heightSet = 'true';
      }

      // Viewbox will auto-center/zoom content
      let viewboxY = 0;
      let paddedViewboxHeight = viewboxHeight;
      const verticalPadding = 0;
      viewboxY = -verticalPadding / 2 + 100;
      paddedViewboxHeight = viewboxHeight + verticalPadding;

      // For single ensemble, shift content up slightly
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxY += 150;  // Shift up by reducing viewboxY (reduced from 80)
      }

      // For single node mode (no Node/NUMA groups), shift content down by 80px
      // BUT only if: 1) not an EFA filter, 2) a filter is active
      const isEfaFilter = currentActivePathId === 'gpu-gpu-efa-intranode' || currentActivePathId === 'gpu-gpu-efa-internode';
      const hasActiveFilter = currentActivePathId && currentActivePathId !== '';
      if (!isInternodeLayout && hasActiveFilter && !isEfaFilter) {
        viewboxY -= 80;  // Shift down by decreasing viewboxY (increased from 50px)
      }

      const draw = SVG().addTo(container).size('100%', '100%').viewbox(0, viewboxY, viewboxWidth, paddedViewboxHeight);
      const renderer = new TopologyRenderer(draw);

      const centerX = viewboxWidth / 2;

      // Draw each system - horizontally for internode, vertically for others
      const isInternodeHorizontalLayout = isInternodeLayout;

      for (let sysIndex = 0; sysIndex < systemCount; sysIndex++) {
        let systemCenterX, cpuY, nvswitchY;

        if (isInternodeHorizontalLayout) {
          // Horizontal layout for internode: systems side by side (rapprochés mais sans overlap)
          // Pour internode, on affiche 1 seul ensemble (NUMA) par système, donc largeur réelle = 50%
          const fullSystemWidth = ensembleCount * ensembleWidth + (ensembleCount - 1) * CONFIG.gaps.ensembleGap;
          const actualSystemWidth = fullSystemWidth * 0.5; // On n'affiche qu'1 ensemble sur 2
          const extraWidth = 210; // Extension pour le groupe NUMA 1
          const systemPadding = 10;
          const totalSystemWidth = actualSystemWidth + systemPadding * 2 + extraWidth; // Largeur totale incluant l'extension
          const gap = 80; // Gap visible entre les systèmes

          // Positionner les systèmes avec le gap (en prenant en compte la largeur totale)
          if (sysIndex === 0) {
            systemCenterX = centerX - (totalSystemWidth / 2 + gap / 2); // Premier système à gauche
          } else {
            systemCenterX = centerX + (totalSystemWidth / 2 + gap / 2); // Deuxième système à droite
          }
          cpuY = CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        } else {
          // Vertical layout for other cases: systems stacked vertically
          const systemOffsetY = sysIndex * (singleSystemHeight + CONFIG.gaps.systemGap);
          systemCenterX = centerX;
          cpuY = systemOffsetY + CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        }

        // Only draw EFA cross-links for intranode EFA path
        const shouldDrawEfaCrossLinks = currentActivePathId === 'gpu-gpu-efa-intranode';
        drawSystem(renderer, sysIndex, systemCenterX, cpuY, nvswitchY, ensembleCount, systemCount, shouldDrawEfaCrossLinks);
      }

      // Draw EFA cross-link between systems (for internode)
      if (systemCount === 2 && ensembleCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode') {
        const efaExt0Id = 'efa-external';  // System 0, ensemble 0, group 0
        const efaExt1Id = 'efa-external-8';  // System 1, ensemble 0, group 0 (4 groups per ensemble, 2 ensembles per system = group 8)

        // Use unified EFA cross-links function
        drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
      }

      currentEnsembleCount = ensembleCount;
      currentSystemCount = systemCount;
    }

    // ============================================================================
    // REAL BANDWIDTH HELPERS
    // ============================================================================
    function getRealBandwidthForPath(pathId) {
      const pathToRealBandwidth = {
        'cpu-gpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-cpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-nvswitch': { value: '786', unit: 'GB/s' },
        'gpu-gpu-efa-intranode': { value: '40', unit: 'GB/s' },
        'gpu-gpu-efa-internode': { value: '40', unit: 'GB/s' },
        'gpu-storage': { value: '14.2', unit: 'GB/s' },
        'cpu-storage': { value: '14.2', unit: 'GB/s' },
        'gpu-cpu-storage': { value: '14.2', unit: 'GB/s' }
      };

      const bandwidth = pathToRealBandwidth[pathId];
      if (bandwidth) {
        return {
          value: bandwidth.value,
          unit: bandwidth.unit
        };
      }
      return null;
    }

    // ============================================================================
    // HIGHLIGHT HELPERS
    // ============================================================================
    function highlightPath(path, pathLabel = '', pathId = '') {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear previous active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Ghost all base links and cross-links groups at once
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '0.35';

        // Increase stroke width of group borders to make them more visible when ghosted
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '5');
          // border.setAttribute('stroke-opacity', '0.8');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '0.25';
      }

      // Dim nodes individually (they're not in a group)
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '0.6';
        // Dim text labels
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '0.25';
        });
      });

      // Highlight path nodes
      path.nodes.forEach(nodeId => {
        let nodeEl = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeEl) {
          const candidates = svg.querySelectorAll(`g[id^="${nodeId}"]`);
          nodeEl = candidates[0];
        }
        if (nodeEl) {
          nodeEl.style.opacity = '1';
          // Restore text opacity
          nodeEl.querySelectorAll('text').forEach(text => {
            text.style.opacity = '1';
          });
        }
      });

      // Duplicate active links into activeLinksGroup
      if (activeLinksGroup) {
        path.links.forEach(linkSpec => {
          // Find matching links in base groups
          const allBaseLinks = [
            ...svg.querySelectorAll('g[data-group="base-links"] > g[data-link-type]'),
            ...svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type]')
          ];

          allBaseLinks.forEach(linkGroup => {
            const linkFrom = linkGroup.getAttribute('data-from');
            const linkTo = linkGroup.getAttribute('data-to');

            const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
            const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

            if (matchesFrom && matchesTo) {
              // Clone the link and append to active group
              const clonedLink = linkGroup.cloneNode(true);
              activeLinksGroup.appendChild(clonedLink);
            }
          });
        });

        // Duplicate EFA cross-links if they match the current path
        const currentPathId = currentActivePathId;
        if (currentPathId === 'gpu-gpu-efa-intranode' || currentPathId === 'gpu-gpu-efa-internode') {
          const efaCrossLinks = svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type="efa-crosslink"]');
          efaCrossLinks.forEach(linkGroup => {
            const clonedLink = linkGroup.cloneNode(true);
            activeLinksGroup.appendChild(clonedLink);
          });
        }
      }

      // Calculate and show bottleneck (minimum bandwidth in the path)
      let minBandwidth = Infinity;
      let minBandwidthValue = null;
      const usedBandwidths = new Set();

      path.links.forEach(linkSpec => {
        svg.querySelectorAll('g[data-link-type]').forEach(linkGroup => {
          const linkFrom = linkGroup.getAttribute('data-from');
          const linkTo = linkGroup.getAttribute('data-to');

          const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
          const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

          if (matchesFrom && matchesTo) {
            const bandwidth = linkGroup.getAttribute('data-bandwidth');
            if (bandwidth) {
              const bw = getBandwidth(bandwidth);
              if (bw && bw.numericValue < minBandwidth) {
                minBandwidth = bw.numericValue;
                minBandwidthValue = bw.speed;
              }
              if (bw) {
                usedBandwidths.add(bw.speed);
              }
            }
          }
        });
      });

      // Highlight all used bandwidths in the legend
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          const bandwidth = legendItem.getAttribute('data-legend-bandwidth');
          if (usedBandwidths.has(bandwidth)) {
            // Used in the path - active
            legendItem.style.opacity = '1';
          } else {
            // Not used - ghosted
            legendItem.style.opacity = '0.4';
          }
        });
      }

      // Show bottleneck info
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      const efficiencyValueEl = bottleneckEl.querySelector('.efficiency-value');

      // Check if real bandwidths are enabled
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (showRealBandwidths) {
        // When real bandwidths are shown, display real bandwidth value directly
        const realBandwidth = getRealBandwidthForPath(pathId);
        if (realBandwidth) {
          bottleneckValueEl.textContent = realBandwidth.value;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');

          // Calculate and display efficiency
          if (minBandwidthValue && efficiencyEl && efficiencyValueEl) {
            const theoreticalBandwidth = parseFloat(minBandwidthValue.replace('GB/s', ''));
            const realBandwidthNum = parseFloat(realBandwidth.value);

            // For EFA (12.5GB/s), multiply by 4 to get total theoretical bandwidth
            const adjustedTheoretical = minBandwidthValue === '12.5GB/s' ? theoreticalBandwidth * 4 : theoreticalBandwidth;

            const efficiency = (realBandwidthNum / adjustedTheoretical) * 100;
            efficiencyValueEl.textContent = `${efficiency.toFixed(1)}%`;
            efficiencyEl.style.display = 'block';
          }
        } else {
          // Fallback if no real bandwidth found
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');
          if (efficiencyEl) {
            efficiencyEl.style.display = 'none';
          }
        }
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      } else {
        // Normal bottleneck display
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        if (minBandwidthValue) {
          const value = minBandwidthValue.replace('GB/s', '');
          // For EFA (12.5GB/s), display as 50 (4 links × 12.5)
          const displayValue = value === '12.5' ? '50' : value;
          bottleneckValueEl.textContent = displayValue;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        } else {
          // Debug: show the module even without bandwidth data
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        }
        // Hide efficiency in normal mode
        if (efficiencyEl) {
          efficiencyEl.style.display = 'none';
        }
      }
    }

    function resetHighlight() {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Restore opacity to base links groups
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '1';

        // Restore original stroke width for group borders
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '3');
          border.setAttribute('stroke-opacity', '1');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '1';
      }

      // Reset nodes opacity
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '1';
        // Reset text opacity
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '1';
        });
      });

      // Clear current active path to ensure EFA cross-links are not drawn
      currentActivePathId = null;

      // Reset legend opacity
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          legendItem.style.opacity = '1';
        });
      }

      // Hide bottleneck (unless real bandwidths are enabled)
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (!showRealBandwidths) {
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        bottleneckEl.classList.remove('visible');
      } else {
        // When real bandwidths are enabled, hide the module when no path is active
        bottleneckLabelEl.textContent = 'Real Bandwidth';
        bottleneckEl.classList.remove('visible');
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      }

      // Hide efficiency display
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      if (efficiencyEl) {
        efficiencyEl.style.display = 'none';
      }
    }

    // ============================================================================
    // CONFIG READING (from HtmlEmbed props)
    // ============================================================================
    function readEmbedConfig() {
      // Find the closest ancestor that carries the data-config attribute
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let providedConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      const config = providedConfig || {};

      // Apply user override from checkbox if set
      if (showRealBandwidthsOverride !== null) {
        config.showRealBandwidths = showRealBandwidthsOverride;
      }

      return config;
    }

    // ============================================================================
    // REAL BANDWIDTHS DISPLAY
    // ============================================================================
    function displayContextualRealBandwidths(pathId, pathLabel) {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Map path IDs to relevant real bandwidths
      const pathToBandwidths = {
        'cpu-gpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-cpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-GPU (via CPU)', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-nvswitch': [
          { label: 'GPU-GPU (NVSwitch)', value: CONFIG.realBandwidths['gpu-gpu-same-node'] }
        ],
        'gpu-gpu-efa-intranode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-intranode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
          { label: 'All2All', value: CONFIG.realBandwidths['all2all-same-node'] }
        ],
        'gpu-gpu-efa-internode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-internode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
          { label: 'All2All', value: CONFIG.realBandwidths['alltoall-internode'] }
        ],
        'gpu-storage': [
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'cpu-storage': [
          { label: 'CPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'gpu-cpu-storage': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ]
      };

      const relevantBandwidths = pathToBandwidths[pathId] || [];

      if (relevantBandwidths.length > 0) {
        // Clear normal bottleneck display
        bottleneckValueEl.textContent = '';
        bottleneckPathEl.textContent = '';

        // Create HTML for relevant bandwidths
        const html = relevantBandwidths.map(item => `
          <div class="bandwidth-item">
            <span class="bandwidth-label">${item.label}</span>
            <span class="bandwidth-value">${item.value}</span>
          </div>
        `).join('');

        realBandwidthsContentEl.innerHTML = html;
      } else {
        // Fallback: show all bandwidths if path not found
        setupRealBandwidthsDisplay();
      }
    }

    function setupRealBandwidthsDisplay() {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Create the bandwidth items HTML
      const bandwidthItems = [
        { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
        { label: 'Same Node', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-same-node'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
        { label: '  All2All', value: CONFIG.realBandwidths['all2all-same-node'] },
        { label: 'Internode', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-internode'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
        { label: '  All2All', value: CONFIG.realBandwidths['alltoall-internode'] },
        { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
      ];

      const html = bandwidthItems.map(item => {
        if (item.value === '') {
          // Section header
          return `<div class="bandwidth-section-header" style="font-weight: 600; margin: 6px 0 4px 0; color: var(--text-secondary);">${item.label}</div>`;
        } else {
          // Bandwidth item
          return `
            <div class="bandwidth-item">
              <span class="bandwidth-label">${item.label}</span>
              <span class="bandwidth-value">${item.value}</span>
            </div>
          `;
        }
      }).join('');

      realBandwidthsContentEl.innerHTML = html;
    }

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    function initialize() {
      const container = getElement('aws-topology-container');
      const tooltip = getElement('aws-topology-tooltip');

      // Read initial config from HtmlEmbed props (before any override)
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let initialConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          initialConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      // Initialize override with initial config value (so checkbox is in sync)
      if (initialConfig && initialConfig.showRealBandwidths !== undefined) {
        showRealBandwidthsOverride = initialConfig.showRealBandwidths;
      }

      // Now read config (which will use override if set)
      const embedConfig = readEmbedConfig();

      // Setup real bandwidths display if enabled
      if (embedConfig.showRealBandwidths) {
        const bottleneckEl = getElement('aws-topology-bottleneck');
        const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');

        // Change label to "Real Bandwidth"
        bottleneckLabelEl.textContent = 'Real Bandwidth';

        // Hide the detailed real bandwidths list initially
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
        // Don't show the module initially - only when a path is selected
        bottleneckEl.classList.remove('visible');
      }

      drawTopology();

      // Initial fade in
      requestAnimationFrame(() => {
        container.style.opacity = '1';
      });

      // Setup tooltip

      container.addEventListener('mouseover', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          const bandwidth = target.getAttribute('data-bandwidth');
          const label = target.getAttribute('data-label');

          // Clear and rebuild tooltip content
          tooltip.innerHTML = '';

          if (label) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'tooltip-label';
            labelDiv.textContent = label;
            tooltip.appendChild(labelDiv);
          }

          const bandwidthDiv = document.createElement('div');
          bandwidthDiv.className = 'tooltip-bandwidth';
          bandwidthDiv.textContent = bandwidth;
          tooltip.appendChild(bandwidthDiv);

          tooltip.classList.add('visible');
        }
      });

      container.addEventListener('mousemove', (e) => {
        if (tooltip.classList.contains('visible')) {
          const rect = container.getBoundingClientRect();
          tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
          tooltip.style.top = (e.clientY - rect.top + 10) + 'px';
        }
      });

      container.addEventListener('mouseout', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          tooltip.classList.remove('visible');
        }
      });

      // Create control buttons organized by category
      const controlsContainer = getElement('aws-topology-controls');

      // Hide controls if an initial filter is provided
      if (embedConfig.initialFilter) {
        controlsContainer.style.display = 'none';
      } else {
        // Categorize paths
        const pathsByCategory = {
          intranode: [
            { id: 'cpu-gpu', label: CONFIG.paths['cpu-gpu'].label },
            { id: 'gpu-gpu-cpu', label: CONFIG.paths['gpu-gpu-cpu'].label },
            { id: 'gpu-gpu-nvswitch', label: CONFIG.paths['gpu-gpu-nvswitch'].label },
            { id: 'gpu-gpu-efa-intranode', label: CONFIG.paths['gpu-gpu-efa-intranode'].label }
          ],
          internode: [
            { id: 'gpu-gpu-efa-internode', label: CONFIG.paths['gpu-gpu-efa-internode'].label }
          ],
          storage: [
            { id: 'gpu-storage', label: CONFIG.paths['gpu-storage'].label },
            { id: 'cpu-storage', label: CONFIG.paths['cpu-storage'].label },
            { id: 'gpu-cpu-storage', label: CONFIG.paths['gpu-cpu-storage'].label }
          ]
        };

        // Create single select with prefixed options and checkbox
        const isChecked = showRealBandwidthsOverride === true || (showRealBandwidthsOverride === null && embedConfig.showRealBandwidths);
        const controlsHTML = `
          <div>
            <label id="real-bandwidth-label" style="display: flex; align-items: center; gap: 0px; font-size: 14px; color: var(--text-color); cursor: pointer; opacity: 0.3; transition: opacity 0.2s;">
              <input type="checkbox" id="real-bandwidth-toggle" ${isChecked ? 'checked' : ''} disabled>
              <span>Show Real Bandwidths</span>
            </label>
          </div>
          
          <div style="display: flex; gap: 12px; align-items: center; margin-top: 8px;">
            <select id="path-select" style="min-width: 250px;">
              <option value="">Select path...</option>
            </select>
          </div>
        `;
        controlsContainer.innerHTML = controlsHTML;

        const pathSelect = controlsContainer.querySelector('#path-select');
        const realBandwidthToggle = controlsContainer.querySelector('#real-bandwidth-toggle');
        const realBandwidthLabel = controlsContainer.querySelector('#real-bandwidth-label');

        // Populate single select with prefixed options
        Object.entries(pathsByCategory).forEach(([category, paths]) => {
          const categoryLabel = category.charAt(0).toUpperCase() + category.slice(1);

          paths.forEach(path => {
            const option = document.createElement('option');
            option.value = path.id;
            option.textContent = `${categoryLabel}: ${path.label}`;
            pathSelect.appendChild(option);
          });
        });

        // Helper function to enable/disable real bandwidth toggle
        const updateRealBandwidthToggleState = (enabled) => {
          if (enabled) {
            realBandwidthToggle.disabled = false;
            realBandwidthLabel.style.opacity = '1';
            realBandwidthLabel.style.cursor = 'pointer';
          } else {
            realBandwidthToggle.disabled = true;
            realBandwidthLabel.style.opacity = '0.3';
            realBandwidthLabel.style.cursor = 'default';
          }
        };

        // Real bandwidth toggle handler
        realBandwidthToggle.addEventListener('change', (e) => {
          showRealBandwidthsOverride = e.target.checked;

          // Re-apply highlight if a path is active
          if (currentActivePathId) {
            const path = CONFIG.paths[currentActivePathId];
            if (path) {
              highlightPath(path, path.label, currentActivePathId);
            }
          } else {
            // If no path active, just reset to clear any displayed values
            resetHighlight();
          }
        });

        // Function to activate a path
        const activatePath = (pathId) => {
          if (!pathId) {
            // Reset to default
            currentActivePathId = null;
            updateRealBandwidthToggleState(false); // Disable toggle when no path selected
            const needsRedraw = currentEnsembleCount !== 2 || currentSystemCount !== 1;

            if (needsRedraw) {
              const container = getElement('aws-topology-container');
              container.style.opacity = '0';

              setTimeout(() => {
                drawTopology(2, 1);
                resetHighlight();

                requestAnimationFrame(() => {
                  container.style.opacity = '1';
                });
              }, 150);
            } else {
              resetHighlight();
            }
            return;
          }

          const path = CONFIG.paths[pathId];
          if (!path) return;

          currentActivePathId = pathId;
          updateRealBandwidthToggleState(true); // Enable toggle when path is selected

          // Check if we need to redraw
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            pathId === 'gpu-gpu-efa-intranode' ||
            pathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            const container = getElement('aws-topology-container');
            container.style.opacity = '0';

            setTimeout(() => {
              currentActivePathId = pathId;
              drawTopology(path.requiredEnsembles, path.requiredSystems);
              highlightPath(path, path.label, pathId);

              requestAnimationFrame(() => {
                container.style.opacity = '1';
              });
            }, 150);
          } else {
            currentActivePathId = pathId;
            highlightPath(path, path.label, pathId);
          }
        };

        // Path select change handler
        pathSelect.addEventListener('change', (e) => {
          const pathId = e.target.value;
          activatePath(pathId);
        });
      }

      // Apply initial filter from embedConfig if provided
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          currentActivePathId = initialPathId;

          // Draw topology with correct requirements
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            initialPathId === 'gpu-gpu-efa-intranode' ||
            initialPathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            drawTopology(path.requiredEnsembles, path.requiredSystems);
          }
        }
      }

      // Create SVG legend
      const legendContainer = getElement('aws-topology-legend');
      const legendSvg = SVG().addTo(legendContainer).size('100%', '100%');

      const lineLength = 36;  // 30 * 1.2
      const itemSpacing = 30;  // 25 * 1.2
      const startX = 96;  // 80 * 1.2
      const startY = 42;  // 35 * 1.2
      const textOffset = 24;  // 20 * 1.2

      // Calculate actual legend width based on content
      const legendWidth = startX + lineLength + textOffset + 168;  // 140 * 1.2
      const legendHeight = 144;  // 120 * 1.2
      legendSvg.viewbox(0, 0, legendWidth, legendHeight);

      [...CONFIG.bandwidths].reverse().forEach((bw, index) => {
        const y = startY + (index * itemSpacing);
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const width = bw.width;

        // Create a group for each legend item with a data attribute for bandwidth
        const legendItemGroup = legendSvg.group();
        legendItemGroup.attr('data-legend-bandwidth', bw.speed);

        // Dessiner la ligne
        legendItemGroup.line(startX, y, startX + lineLength, y)
          .stroke({ color, width });

        // Dessiner les cercles aux extrémités
        const r = width * 0.8;
        const startCircle = legendItemGroup.circle(r * 2).move(startX - r, y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        const endCircle = legendItemGroup.circle(r * 2).move(startX + lineLength - r, y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        // Ajouter le texte (aligné à droite, valeur en gras)
        const textX = legendWidth - 5;
        const value = bw.speed.replace('GB/s', '').trim();

        // Format: "Label - 900 GB/s" avec 900 en gras
        const textEl = legendItemGroup.text(function (add) {
          add.tspan(bw.label + ' - ').font({ weight: 'normal' });
          add.tspan(value).font({ weight: 'bold' });
          add.tspan(' GB/s').font({ weight: 'normal' });
        })
          .move(textX, y)
          .font({
            family: 'system-ui, -apple-system, sans-serif',
            size: 14,  // 12 * 1.2 ≈ 14
            anchor: 'end',
            fill: CONFIG.colors.nodeText
          })
          .dy(-7);  // -6 * 1.2 ≈ -7
      });
    }

    // Initialize only if wrapper is found
    if (findWrapper()) {
      initialize();

      // Apply initial filter highlight after legend is created
      const embedConfig = readEmbedConfig();
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          // Apply highlight to both topology and legend
          highlightPath(path, path.label, initialPathId);
        }
      }

      // Add resize handler for responsive width changes (mobile/desktop)
      const handleResize = () => {
        const container = getElement('aws-topology-container');
        if (!container) return;

        // Recalculate fixed height based on new width (for responsive design)
        const containerWidth = container.clientWidth || 800;

        // Use max viewbox dimensions for consistent aspect ratio
        const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
        const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
          CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
          CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
          CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
          CONFIG.gaps.bottomMargin;
        const maxViewboxHeight = maxSingleSystemHeight * 1.15;
        const maxViewboxWidth = maxEnsembleWidth + 200;

        const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
        const baseHeight = containerWidth * maxAspectRatio;
        const legendHeight = embedConfig.initialFilter ? 150 : 200;

        // Update height based on current width (responsive)
        container.style.height = `${baseHeight + legendHeight}px`;
      };

      // Use ResizeObserver for better performance (only for window resize, not content changes)
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => handleResize());
        ro.observe(findWrapper());
      } else {
        window.addEventListener('resize', handleResize);
      }
    } else {
      console.warn('AWS topology: wrapper not found, skipping initialization');
    }
  })();
</script></div></div></figure> </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Simplified diagram of the key components and communication links in our AWS p5 instance setup</figcaption> </figure> </div>  </div>
<p>If this looks overwhelming, don’t worry. We’ll dive into each of these connections in detail and measure their actual bandwidths to understand the performance characteristics of each link.</p>
<h4 id="gpu-to-cpu"><a href="#gpu-to-cpu">GPU-to-CPU</a></h4>
<div class="note note--neutral" data-astro-cid-qg6lmfty> <!-- When there's no title, emoji is above content -->
    <div class="note__layout" data-astro-cid-qg6lmfty>  <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__content" data-astro-cid-qg6lmfty> <p><b>TL;DR:</b> The CPU orchestrates GPU work via PCIe connections, which bottleneck at ~14.2 GB/s (PCIe Gen4 x8) for CPU-to-GPU transfers in our p5 instance. CPU-GPU latency is ~1.4 microseconds, which adds kernel launch overhead that is problematic for workloads with many small kernels. CUDA Graphs can reduce this overhead by batching operations. NUMA affinity is critical on multi-socket systems; running GPU processes on the wrong CPU socket adds significant latency. Modern architectures like Grace Hopper eliminate PCIe bottlenecks with NVLink-C2C (900 GB/s vs 128 GB/s).</p> </div> </div> </div> </div> 
<p>The CPU is the orchestrator of GPU computation. It’s responsible for launching kernels, managing memory allocations, and coordinating data transfers. But how fast can the CPU actually communicate with the GPU? This is determined by the  <strong>PCIe (Peripheral Component Interconnect Express)</strong>  connection between them.</p>
<p>Understanding this link is crucial because it affects:</p>
<ul>
<li><strong>Kernel launch latency</strong> : How quickly the CPU can schedule work on the GPU</li>
<li><strong>Data transfer speed</strong> : How fast we can move data between CPU and GPU memory</li>
<li><strong>Synchronization overhead</strong> : The cost of CPU-GPU coordination points</li>
</ul>
<p>In modern GPU servers, the CPU-GPU connection has evolved significantly. While earlier systems used direct PCIe connections, modern high-performance systems like the DGX H100 use more sophisticated topologies with PCIe  <em>switches</em>  to manage multiple GPUs efficiently. And with the latest <a href="https://newsletter.semianalysis.com/p/nvidias-blackwell-reworked-shipment">GB200 architecture</a>, NVIDIA has taken this even further by placing the CPU and GPU on the same printed circuit board, eliminating the need for external switches altogether.</p>
<p>Let’s examine the physical topology of our p5 instance using  <code>lstopo</code>  and then measure the actual performance of this critical link, to identify potential bottlenecks.</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>$ lstopo -v</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>HostBridge L#1 (buses=0000:[44-54])</span></span>
<span class="line"><span>    PCIBridge L#2 (busid=0000:44:00.0 id=1d0f:0200 class=0604(PCIBridge) link=15.75GB/s buses=0000:[45-54] PCISlot=64)</span></span>
<span class="line"><span>        PCIBridge L#3 (busid=0000:45:00.0 id=1d0f:0200 class=0604(PCIBridge) link=15.75GB/s buses=0000:[46-54] PCISlot=1-1)</span></span>
<span class="line"><span>            ...</span></span>
<span class="line"><span>            PCIBridge L#12 (busid=0000:46:01.4 id=1d0f:0200 class=0604(PCIBridge) link=63.02GB/s buses=0000:[53-53])</span></span>
<span class="line"><span>                PCI L#11 (busid=0000:53:00.0 id=10de:2330 class=0302(3D) link=63.02GB/s PCISlot=86-1)</span></span>
<span class="line"><span>                    Co-Processor(CUDA) L#8 (Backend=CUDA GPUVendor=&quot;NVIDIA Corporation&quot; GPUModel=&quot;NVIDIA H100 80GB HBM3&quot; CUDAGlobalMemorySize=83295872 CUDAL2CacheSize=51200 CUDAMultiProcessors=132 CUDACoresPerMP=128 CUDASharedMemorySizePerMP=48) &quot;cuda0&quot;</span></span>
<span class="line"><span>                    GPU(NVML) L#9 (Backend=NVML GPUVendor=&quot;NVIDIA Corporation&quot; GPUModel=&quot;NVIDIA H100 80GB HBM3&quot; NVIDIASerial=1654922006536 NVIDIAUUID=GPU-ba136838-6443-7991-9143-1bf4e48b2994) &quot;nvml0&quot;</span></span>
<span class="line"><span>            ...</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span></code></pre></div>
<p>From the  <code>lstopo</code>  output, we can see two key PCIe bandwidth values in our system:</p>
<ul>
<li><strong>15.75GB/s</strong> : corresponds to PCIe Gen4 x8 links (CPU to PCIe switches)</li>
<li><strong>63.02GB/s</strong> : corresponds to PCIe Gen5 x16 links (PCIe switches to GPUs)</li>
</ul>
<p>To have a better understanding of the whole topology, we can visualize it using:</p>
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>lstopo --whole-system lstopo-diagram.png</span></span>
<span class="line"><span></span></span></code></pre></div>
<div class="ri-root" data-ri-root="ri_jw2trlbg5re" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/lstopo_2951384e-bcac-808f-a7c5-c244e7ac69db.l9jGw6GM_kvO2G.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/lstopo_2951384e-bcac-808f-a7c5-c244e7ac69db.l9jGw6GM.jpg" data-astro-cid-6kov3kig width="1800" height="920" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script> 
<p>This diagram showcases the hierarchical structure of our system:</p>
<ul>
<li>It contains two NUMA (Non-Uniform Memory Access) nodes (NUMA is memory zone per CPU socket)</li>
<li>Each CPU socket connects to four PCIe switches via PCIe Gen4 x8 links (15.75GB/s)</li>
<li>Each PCIe switch connects to one H100 GPU via PCIe Gen5 x16 links (63.02GB/s)</li>
<li>… (We’ll explore the other components like NVSwitch, EFA network cards and NVMe drives in next sections.)</li>
</ul>
<p>The PCIe specification differs between generations, each doubling the transfer rate per lane. Note that Transfer Rate is measured in GT/s (GigaTransfers per second), which represents the raw signaling rate, while Throughput is measured in GB/s (Gigabytes per second), which accounts for encoding overhead and represents the actual usable bandwidth:</p>
<div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> 

















































<div class="table-scroll"><table><thead><tr><th>PCIe Version</th><th>Transfer Rate (per lane)</th><th>Throughput (GB/s)</th></tr></thead><tbody><tr><td>×1</td><td>×2</td><td>×4</td></tr><tr><td>1.0</td><td>2.5 GT/s</td><td>0.25</td></tr><tr><td>2.0</td><td>5.0 GT/s</td><td>0.5</td></tr><tr><td>3.0</td><td>8.0 GT/s</td><td>0.985</td></tr><tr><td>4.0</td><td>16.0 GT/s</td><td>1.969</td></tr><tr><td>5.0</td><td>32.0 GT/s</td><td>3.938</td></tr><tr><td>6.0</td><td>64.0 GT/s</td><td>7.563</td></tr><tr><td>7.0</td><td>128.0 GT/s</td><td>15.125</td></tr></tbody></table></div> </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Theoretical PCIe bandwidths. Source: https://en.wikipedia.org/wiki/PCI_Express</figcaption> </figure> </div> 
<figure class="html-embed"><div class="html-embed__card"><div id="frag-s9nfexfryxj" data-config="{&#34;initialFilter&#34;:&#34;cpu-gpu&#34;}"><!--
  AWS Bandwidth Bottleneck Visualization
  
  Usage:
  
  Basic:
    <HtmlEmbed src="/embeds/aws-bandwidth-bottleneck.html" />
  
  With initial filter:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ initialFilter: 'cpu-gpu' }} 
    />
  
  With real bandwidths display:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ showRealBandwidths: true }} 
    />
  
  Available filters:
    - cpu-gpu (Intranode: CPU ⟷ GPU)
    - gpu-gpu-cpu (Intranode: GPU ⟷ GPU via CPU)
    - gpu-gpu-nvswitch (Intranode: GPU ⟷ GPU via NVSwitch)
    - gpu-gpu-efa-intranode (Intranode: GPU ⟷ GPU via EFA)
    - gpu-gpu-efa-internode (Internode: GPU ⟷ GPU via EFA)
    - gpu-storage (Storage: GPU ⟷ Storage)
    - cpu-storage (Storage: CPU ⟷ Storage)
    - gpu-cpu-storage (Storage: GPU ⟷ Storage via CPU)
-->
<div class="aws-topology-wrapper">
  <div class="aws-topology-container"></div>
  <div class="aws-topology-controls"></div>
  <div class="aws-topology-legend"></div>
  <div class="aws-topology-tooltip"></div>
  <div class="aws-topology-bottleneck">
    <div class="bottleneck-label">Bandwidth Max</div>
    <div class="bottleneck-path">for CPU → GPU</div>
    <div class="bottleneck-value">-</div>
    <div class="bottleneck-unit">GB/s</div>
    <div class="bottleneck-efficiency" style="display: none;">
      <div class="efficiency-value">-</div>
      <div class="efficiency-label">Efficiency</div>
    </div>
    <div class="real-bandwidths" style="display: none;">
      <div class="real-bandwidths-title">Real Bandwidths</div>
      <div class="real-bandwidths-content"></div>
    </div>
  </div>
</div>

<style>
  .aws-topology-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .aws-topology-container {
    width: 100%;
    height: auto;
    min-height: 400px;
    position: relative;
    transition: opacity 0.15s ease;
  }

  .aws-topology-container.fixed-height {
    height: 850px;
  }

  .aws-topology-container svg {
    width: 100%;
    height: 100%;
  }

  .aws-topology-container svg g {
    transition: opacity 0.2s ease;
  }

  /* Add drop shadow to all links */
  .aws-topology-container svg g[data-link-type] line,
  .aws-topology-container svg g[data-link-type] path {
    filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
  }

  .aws-topology-controls {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 800px;
  }

  .aws-topology-controls-section {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .aws-topology-controls-row {
    display: flex;
    flex-direction: row;
    gap: 16px;
    align-items: flex-start;
  }

  .aws-topology-controls-label {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0.7;
  }

  .aws-topology-controls-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }

  .aws-topology-controls-buttons .button {
    flex-shrink: 0;
  }

  /* Hide controls on mobile */
  @media (max-width: 768px) {
    .aws-topology-controls {
      display: none;
    }
  }

  .aws-topology-legend {
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 264px;
    /* 220 * 1.2 */
    height: 120px;
    /* 100 * 1.2 */
  }

  .aws-topology-tooltip {
    position: absolute;
    padding: 8px 12px;
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 12px;
    color: var(--text-color);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .aws-topology-tooltip.visible {
    opacity: 1;
  }

  .tooltip-label {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-color);
  }

  .tooltip-bandwidth {
    font-size: 11px;
    color: var(--text-secondary);
  }

  .aws-topology-bottleneck {
    position: absolute;
    top: 10px;
    right: 10px;
    text-align: right;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .aws-topology-bottleneck.visible {
    opacity: 1;
  }

  .bottleneck-label {
    font-size: 11px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-value {
    font-size: 24px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    margin-bottom: 2px;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .bottleneck-unit {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-path {
    font-size: 10px;
    color: var(--text-secondary);
    font-style: italic;
    margin-bottom: 6px;
    opacity: 0.8;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-efficiency {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    margin-top: 12px;
    margin-bottom: 4px;
  }

  .efficiency-label {
    font-size: 9px;
    color: var(--text-secondary);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 2px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .efficiency-value {
    font-size: 20px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .real-bandwidths {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
    opacity: 0.9;
  }

  .real-bandwidths-title {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content {
    font-size: 11px;
    color: var(--text-color);
    line-height: 1.4;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content .bandwidth-item {
    margin-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .real-bandwidths-content .bandwidth-label {
    font-size: 10px;
    color: var(--text-secondary);
    opacity: 0.8;
  }

  .real-bandwidths-content .bandwidth-value {
    font-size: 11px;
    font-weight: 600;
    color: var(--primary-color);
  }

  /* Checkbox styling for the bandwidth toggle */
  #real-bandwidth-toggle {
    appearance: none;
    width: 16px;
    height: 16px;
    border: 2px solid var(--border-color);
    border-radius: 3px;
    background-color: var(--page-bg);
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    margin-right: 8px;
  }

  #real-bandwidth-toggle:hover {
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(from var(--primary-color) r g b / 0.1);
  }

  #real-bandwidth-toggle:checked {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:checked::before {
    content: '';
    position: absolute;
    top: 1px;
    left: 4px;
    width: 4px;
    height: 8px;
    border: solid var(--on-primary);
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }

  #real-bandwidth-toggle:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.5/svg.min.js"></script>
<script>
  (function () {
    // Generate unique ID for this instance
    const instanceId = 'aws-topology-' + Math.random().toString(36).substr(2, 9);

    // Store reference to current script to find wrapper later
    const scriptEl = document.currentScript;

    // Function to find wrapper (will be called after DOM is ready)
    let wrapperEl = null;
    const findWrapper = () => {
      if (!wrapperEl) {
        wrapperEl = scriptEl.previousElementSibling;
        if (!wrapperEl || !wrapperEl.classList.contains('aws-topology-wrapper')) {
          // Fallback: search for unmounted wrappers
          const allWrappers = document.querySelectorAll('.aws-topology-wrapper');
          for (const wrapper of allWrappers) {
            if (!wrapper.dataset.mounted) {
              wrapperEl = wrapper;
              break;
            }
          }
        }
        if (wrapperEl && !wrapperEl.dataset.mounted) {
          wrapperEl.dataset.mounted = 'true';
        }
      }
      return wrapperEl;
    };

    // Get all child elements for this instance
    const getElement = (className) => {
      const wrapper = findWrapper();
      return wrapper ? wrapper.querySelector('.' + className) : null;
    };

    // ============================================================================
    // CONFIGURATION - All settings in one place
    // ============================================================================
    const CONFIG = {
      // Canvas settings
      viewbox: {
        width: 2400,  // Width for 2 ensembles side by side
        get height() {
          // Calculate height based on vertical elements × systemCount
          const singleSystemHeight = this.parent.gaps.topMargin +
            this.parent.sizes.cpu +
            this.parent.gaps.cpuToPcie +
            this.parent.sizes.pcie.height +
            this.parent.gaps.pcieToGpu +
            this.parent.sizes.gpu.height +
            this.parent.gaps.gpuToNvswitch +
            this.parent.sizes.nvswitch.height +
            this.parent.gaps.bottomMargin;

          return singleSystemHeight * this.parent.systemCount +
            this.parent.gaps.systemGap * (this.parent.systemCount - 1);
        },
        parent: null  // Will be set to CONFIG
      },

      // System replication
      systemCount: 2,      // Number of complete systems (each has 2 ensembles)
      ensembleCount: 2,    // Number of ensembles per system (each ensemble = CPU + 4 groups + 2 NVSwitches)
      groupCount: 4,       // Groups per ensemble
      nvswitchCount: 2,    // NVSwitches per ensemble

      // Node sizes (all based on CPU size)
      sizes: {
        cpu: 80,
        get pcie() { return { width: this.cpu * 0.75, height: this.cpu * 0.625 * 3 }; },
        get gpu() { return { width: this.cpu, height: this.cpu }; },
        get efa() { return { width: 60, height: 30 }; },
        get nvme() { return { width: 60, height: 30 }; },
        get nvswitch() { return { width: 100, height: 60 }; }
      },

      // Gaps and spacing
      gaps: {
        topMargin: 0,        // Margin from top to CPU
        cpuToPcie: 80,        // Vertical gap CPU → PCIe
        pcieToGpu: 80,        // Vertical gap PCIe → GPU
        gpuToNvswitch: 200,    // Vertical gap GPU → NVSwitch
        bottomMargin: 40,     // Margin from NVSwitch to bottom
        horizontal: 230,      // Horizontal gap between groups
        ensembleGap: 50,     // Horizontal gap between ensembles (within a system)
        systemGap: 30,       // Horizontal gap between complete systems
        connectionOffset: 15  // Gap between node edge and arrow anchor
      },

      // Group layout offsets (all relative positions within a group)
      layout: {
        pcieOffsetX: -40,      // PCIe X offset from group center (to the left)
        efaNvmeOffsetX: 60,    // EFA/NVMe X offset from group center (to the right)
        efaOffsetY: -30,       // EFA Y offset from PCIe Y (above)
        nvmeOffsetY: 30,       // NVMe Y offset from PCIe Y (below)
        groupPadding: 20       // Padding around group bounding box
      },

      // Debug mode
      debug: {
        showPhantoms: false    // Set to true to visualize phantom nodes
      },

      // Highlight paths (for interactive buttons)
      paths: {
        'cpu-gpu': {
          label: 'CPU ⟷ GPU',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'gpu'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' }
          ]
        },
        'gpu-gpu-cpu': {
          label: 'GPU ⟷ GPU via CPU',
          requiredEnsembles: 1,  // Need only 1 ensemble (2 groups within)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'cpu', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'pcie', to: 'cpu' },
            { from: 'cpu', to: 'pcie' },
            { from: 'cpu', to: 'pcie-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-nvswitch': {
          label: 'GPU ⟷ GPU via NVSwitch',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'nvswitch-0', 'gpu-1'],
          links: [
            { from: 'gpu', to: 'nvswitch-0' },
            { from: 'gpu-1', to: 'nvswitch-0' }
          ]
        },
        'gpu-gpu-efa': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-1', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-1', to: 'efa-external-1' },
            { from: 'efa-1', to: 'pcie-efa-phantom-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-efa-intranode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles (same system)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-4', 'pcie-4', 'gpu-4'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-4' },  // EFA cross-link between ensembles (12.5GB/s)
            { from: 'efa-4', to: 'efa-external-4' },
            { from: 'efa-4', to: 'pcie-efa-phantom-4' },
            { from: 'pcie-4', to: 'gpu-4' }
          ]
        },
        'gpu-gpu-efa-internode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles per system
          requiredSystems: 2,    // Need 2 systems
          nodes: ['gpu', 'pcie', 'efa', 'efa-8', 'pcie-8', 'gpu-8'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-8' },  // EFA cross-link between systems
            { from: 'efa-8', to: 'efa-external-8' },
            { from: 'efa-8', to: 'pcie-efa-phantom-8' },
            { from: 'pcie-8', to: 'gpu-8' }
          ]
        },
        'gpu-storage': {
          label: 'GPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'nvme'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'cpu-storage': {
          label: 'CPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'gpu-cpu-storage': {
          label: 'GPU ⟷ Storage via CPU',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'gpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        }
      },


      // Bandwidth levels
      bandwidths: [
        { speed: '900GB/s', label: 'NVLink 4.0', width: 9 },
        { speed: '64GB/s', label: 'PCIe Gen5', width: 6 },
        { speed: '16GB/s', label: 'PCIe Gen4', width: 3 },
        { speed: '12.5GB/s', label: 'EFA Link', width: 1.25 }
      ],

      // Link definitions for groups
      groupLinks: [
        { from: 'cpu', to: 'pcie', bandwidth: '16GB/s', type: 'cpu', fromSide: 'bottom', toSide: 'top', multiLink: true },
        { from: 'efa', to: 'pcie-efa-phantom', bandwidth: '16GB/s', type: 'network', fromSide: 'left', toSide: 'right', stacked: 4 },
        { from: 'nvme', to: 'pcie-nvme-phantom', bandwidth: '16GB/s', type: 'storage', fromSide: 'left', toSide: 'right' },
        { from: 'pcie', to: 'gpu', bandwidth: '64GB/s', type: 'gpu', fromSide: 'bottom', toSide: 'top' },
        { from: 'efa', to: 'efa-external', bandwidth: '12.5GB/s', type: 'network', fromSide: 'right', toSide: 'left', stacked: 4 }
      ],

      // GPU to NVSwitch links (full mesh)
      gpuNvswitchLink: {
        bandwidth: '900GB/s',
        type: 'gpu',
        fromSide: 'bottom',
        toSide: 'top'
      },

      // Colors (using CSS variables for dark mode compatibility)
      colors: {
        // Node colors
        nodeFill: 'var(--page-bg)',
        nodeStroke: 'var(--muted-color)',     // More contrast than border-color
        nodeText: 'var(--text-color)',
        nodePins: 'var(--muted-color)',
        nodeCoreFill: 'rgba(0, 0, 0, 0.05)',  // Very light gray for cores
        nodeCoreStroke: 'rgba(0, 0, 0, 0.2)', // More visible border for cores

        // Link colors
        linkColor: 'var(--primary-color)',
        linkCircleBorder: 'rgba(0, 0, 0, 0.1)', // Border for link circles

        // Group border
        groupBorder: 'var(--border-color)',

        // Phantom debug
        phantomFill: 'rgba(255, 0, 255, 0.2)',
        phantomStroke: 'magenta'
      },

      // Real bandwidth data for display
      realBandwidths: {
        'cpu-gpu': '14.2GB/s',
        'gpu-gpu-same-node': '786GB/s',
        'gpu-gpu-efa-intranode': '40GB/s',
        'gpu-gpu-efa-internode': '40GB/s',
        'allreduce-same-node': '480GB/s',
        'all2all-same-node': '340GB/s',
        'allreduce-internode': '320GB/s',
        'alltoall-internode': '45GB/s',
        'gpu-storage': '14.2GB/s'
      }
    };

    // Initialize viewbox parent reference
    CONFIG.viewbox.parent = CONFIG;

    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================
    function getBandwidth(speed) {
      const bw = CONFIG.bandwidths.find(b => b.speed === speed);
      if (bw) {
        // Add numericValue for comparison
        bw.numericValue = parseFloat(bw.speed.replace('GB/s', ''));
      }
      return bw;
    }

    // Calculate connection offset proportional to link width
    function getLinkOffset(linkWidth) {
      const minOffset = 5;   // Minimum offset for thin links
      const maxOffset = 20;  // Maximum offset for thick links

      // Proportional offset: thinner links = smaller offset
      const proportionalOffset = minOffset + (linkWidth / 10) * (maxOffset - minOffset);
      return Math.min(Math.max(proportionalOffset, minOffset), maxOffset);
    }

    // ============================================================================
    // EFA CROSS-LINKS HELPER
    // ============================================================================
    function drawEfaCrossLinks(renderer, fromId, toId, linkType = 'efa-crosslink') {
      const phantom0 = renderer.nodes.get(fromId);
      const phantom1 = renderer.nodes.get(toId);

      if (!phantom0 || !phantom1) return;

      const efaBw = getBandwidth('12.5GB/s');
      const efaColor = CONFIG.colors.linkColor;

      // Draw 4 stacked links manually (EFA has 4 connections) - randomized order
      const stackCount = 4;
      const spacing = 6; // Fixed spacing between stacked links
      const verticalShift = -95; // Shift up to align with EFA nodes
      const horizontalShift = -40; // Shift left to better position the arrows
      const horizontalExtension = 20; // Extend arrows horizontally on each side

      // Create array of indices and randomize
      const linkIndices = Array.from({ length: stackCount }, (_, i) => i);
      const shuffledIndices = linkIndices.sort(() => Math.random() - 0.5);

      // Draw horizontal lines with vertical offset for stacking
      shuffledIndices.forEach(i => {
        const offsetY = (i - (stackCount - 1) / 2) * spacing;

        const efaCrossGroup = renderer.crossLinksGroup.group();
        efaCrossGroup.attr('data-link-type', linkType);
        efaCrossGroup.attr('data-from', fromId);
        efaCrossGroup.attr('data-to', toId);
        efaCrossGroup.attr('data-bandwidth', '12.5GB/s');
        efaCrossGroup.attr('data-label', 'EFA Link');

        // Draw line with vertical offset for stacking + shifts + horizontal extension
        const x0 = phantom0.x + horizontalShift;
        const x1 = phantom1.x + horizontalShift + horizontalExtension;
        const y0 = phantom0.y + offsetY + verticalShift;
        const y1 = phantom1.y + offsetY + verticalShift;

        // Draw border
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: efaColor, width: efaBw.width, opacity: 1 });

        // Draw circles at both ends
        const r = efaBw.width * 0.8;
        const startCircle = efaCrossGroup.circle(r * 2).move(x0 - r, y0 - r);
        startCircle.fill(efaColor);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = efaCrossGroup.circle(r * 2).move(x1 - r, y1 - r);
        endCircle.fill(efaColor);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');
      });

      // Add vertical bars at both ends (connect horizontal arrows to EFA phantoms)
      const barColor = CONFIG.colors.linkColor;

      shuffledIndices.forEach(i => {
        const offsetX = (i - (stackCount - 1) / 2) * spacing + 12; // Horizontal offset for vertical bars
        const yHorizontal = phantom0.y + verticalShift + 10;
        const yPhantom = phantom0.y + 8; // End a bit higher (5px above phantom center)

        // Left vertical bar (one per horizontal arrow)
        const leftBarGroup = renderer.crossLinksGroup.group();
        leftBarGroup.attr('data-link-type', linkType);
        leftBarGroup.attr('data-from', fromId);
        leftBarGroup.attr('data-to', toId);
        leftBarGroup.attr('data-bandwidth', '12.5GB/s');
        leftBarGroup.attr('data-label', 'EFA Link');

        const x0 = phantom0.x + horizontalShift + offsetX;

        // Draw border
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const r = efaBw.width * 0.8;
        const bottomCircle0 = leftBarGroup.circle(r * 2).move(x0 - r, yPhantom - r);
        bottomCircle0.fill(barColor);
        bottomCircle0.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle0.attr('data-link-circle', 'true');

        // Right vertical bar (one per horizontal arrow)
        const rightBarGroup = renderer.crossLinksGroup.group();
        rightBarGroup.attr('data-link-type', linkType);
        rightBarGroup.attr('data-from', fromId);
        rightBarGroup.attr('data-to', toId);
        rightBarGroup.attr('data-bandwidth', '12.5GB/s');
        rightBarGroup.attr('data-label', 'EFA Link');

        const x1 = phantom1.x + horizontalShift + offsetX;

        // Draw border
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const bottomCircle1 = rightBarGroup.circle(r * 2).move(x1 - r, yPhantom - r);
        bottomCircle1.fill(barColor);
        bottomCircle1.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle1.attr('data-link-circle', 'true');
      });
    }

    // ============================================================================
    // SVG HELPERS
    // ============================================================================
    class TopologyRenderer {
      constructor(draw) {
        this.draw = draw;
        this.nodes = new Map();
        this.structuralGroup = draw.group();  // Structural elements (Node/NUMA borders, never ghosted)
        this.structuralGroup.attr('data-group', 'structural');
        this.baseLinksGroup = draw.group();   // Base links layer (will be ghosted)
        this.baseLinksGroup.attr('data-group', 'base-links');
        this.linksGroup = this.baseLinksGroup; // Alias for compatibility
        this.nodesGroup = draw.group();   // Nodes layer (middle)
        this.phantomsGroup = draw.group(); // Phantoms layer (for debug)
        this.baseCrossLinksGroup = draw.group(); // Base EFA cross-links layer
        this.baseCrossLinksGroup.attr('data-group', 'base-cross-links');
        this.crossLinksGroup = this.baseCrossLinksGroup; // Alias for compatibility
        this.activeLinksGroup = draw.group(); // Active (duplicated) links layer (top, non-ghosted)
        this.activeLinksGroup.attr('data-group', 'active-links');
      }

      // Draw a simple rectangular node
      // Helper: Draw text with consistent styling
      drawText(x, y, label, group = this.nodesGroup) {
        if (!label) return;

        const lines = label.split('\n');
        lines.forEach((line, i) => {
          group.text(line)
            .font({ family: 'Inter, sans-serif', size: 12, weight: '600', anchor: 'middle' })
            .fill(CONFIG.colors.nodeText)
            .cx(x)
            .cy(y + (i - (lines.length - 1) / 2) * 14);
        });
      }

      // Helper: Draw pins around a node
      drawPins(x, y, width, height, pinConfig = {}, targetGroup = null) {
        const group = targetGroup || this.nodesGroup;

        const defaultConfig = {
          pinsPerSide: width >= 80 ? 18 : 15,
          pinLength: 3,
          pinOffset: width / 2 + 1.5,
          pinPadding: 12
        };

        const config = { ...defaultConfig, ...pinConfig };
        const pinStartOffset = -width / 2 + config.pinPadding;
        const pinEndOffset = width / 2 - config.pinPadding;
        const pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);

        const sides = [
          { side: 'left', xOffset: -config.pinOffset, yOffset: 0 },
          { side: 'right', xOffset: config.pinOffset, yOffset: 0 },
          { side: 'top', xOffset: 0, yOffset: -config.pinOffset },
          { side: 'bottom', xOffset: 0, yOffset: config.pinOffset }
        ];

        sides.forEach(({ side, xOffset, yOffset }) => {
          for (let i = 0; i < config.pinsPerSide; i++) {
            const pinX = x + xOffset + (side === 'left' || side === 'right' ? 0 : pinStartOffset + (i * pinSpacing));
            const pinY = y + yOffset + (side === 'top' || side === 'bottom' ? 0 : pinStartOffset + (i * pinSpacing));

            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      drawNode(id, x, y, width, height, label, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      drawNodeWithPins(id, x, y, width, height, label, pinConfig = {}, nodeType = '') {
        const node = this.drawNode(id, x, y, width, height, label, nodeType);
        this.drawPins(x, y, width, height, pinConfig);
        return node;
      }

      drawNodeWithCores(id, x, y, width, height, label, coreConfig = {}, nodeType = '') {
        // Draw main node
        const node = this.drawNode(id, x, y, width, height, label, nodeType);

        // Default core configuration
        const defaultCoreConfig = {
          coresX: 2,              // 2x2 for CPU, 8x8 for GPU
          coresY: 2,
          coreSpacing: 2,         // Space between cores
          coreMargin: 8           // Margin from node edges
        };

        const config = { ...defaultCoreConfig, ...coreConfig };

        // Calculate core size
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coreSpacing * (config.coresX - 1))) / config.coresX;
        const coreHeight = (availableHeight - (config.coreSpacing * (config.coresY - 1))) / config.coresY;

        // Draw cores
        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            this.nodesGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        return node;
      }

      drawProcessorNode(id, x, y, width, height, label, type = 'cpu') {
        // Create main group for the node
        const nodeGroup = this.nodesGroup.group();
        nodeGroup.attr('id', id);
        nodeGroup.attr('data-node-type', type);

        // Draw node background
        nodeGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Draw cores
        const coreConfig = type === 'gpu' ? { coresX: 8, coresY: 8 } : { coresX: 2, coresY: 2 };
        const config = { coreSpacing: 2, coreMargin: 8, ...coreConfig };
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coresX - 1) * config.coreSpacing) / config.coresX;
        const coreHeight = (availableHeight - (config.coresY - 1) * config.coreSpacing) / config.coresY;

        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            nodeGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        // Draw pins in the same group
        this.drawPins(x, y, width, height, {}, nodeGroup);

        // Draw text on top
        this.drawText(x, y, label, nodeGroup);

        // Store node position
        this.nodes.set(id, { x, y, width, height });

        return nodeGroup;
      }

      // Add pins to an existing node (without changing the node design)
      addPinsToNode(nodeId, pinConfig = {}) {
        const node = this.nodes.get(nodeId);
        if (!node) return;

        // Find the node's SVG group
        const svg = getElement('aws-topology-container').querySelector('svg');
        if (!svg) return;
        const nodeGroup = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeGroup) return;

        // Use SVG.js to manipulate the group
        const group = this.draw.findOne(`#${nodeId}`);
        if (!group) return;

        // Default pin configuration
        const defaultPinConfig = {
          pinsPerSide: node.width >= 80 ? 18 : 15,
          sides: ['left', 'right', 'top', 'bottom'],
          pinLength: 3,
          pinPadding: 12
        };

        const config = { ...defaultPinConfig, ...pinConfig };

        // Generate pins on specified sides only
        config.sides.forEach(side => {
          let pinSpacing, pinStartOffset, pinEndOffset;

          if (side === 'left' || side === 'right') {
            pinStartOffset = -node.height / 2 + config.pinPadding;
            pinEndOffset = node.height / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          } else {
            pinStartOffset = -node.width / 2 + config.pinPadding;
            pinEndOffset = node.width / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          }

          for (let i = 0; i < config.pinsPerSide; i++) {
            let pinX, pinY;

            if (side === 'left') {
              pinX = node.x - node.width / 2 - 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'right') {
              pinX = node.x + node.width / 2 + 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'top') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y - node.height / 2 - 1.5;
            } else if (side === 'bottom') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y + node.height / 2 + 1.5;
            }

            // Draw pin in the node's group
            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      // Draw a stacked node (visual stack effect)
      drawStackedNode(id, x, y, width, height, label, stackCount, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        for (let i = stackCount - 1; i >= 0; i--) {
          const offsetY = i * 3;
          group.rect(width, height)
            .move(x - width / 2, y - height / 2 + offsetY)
            .fill(CONFIG.colors.nodeFill)
            .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
            .radius(4)
            .opacity(1);
        }

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw a storage node (NVMe) with internal rectangle
      drawStorageNode(id, x, y, width, height, label, nodeType = 'storage') {
        const group = this.nodesGroup.group();
        group.attr('id', id);
        if (nodeType) group.attr('data-node-type', nodeType);

        // Main node background
        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Internal rectangle on the left side (flush with edge)
        const internalRectWidth = 5;
        const internalRectHeight = height * .6; // Full height
        const internalRectX = x - width / 2; // Flush with left edge
        const internalRectY = y - height / 2 + height * .20;

        group.rect(internalRectWidth, internalRectHeight)
          .move(internalRectX, internalRectY)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: '#ffffff', width: 1 })
          .opacity(.4)
          .radius(0); // No radius

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw background rectangle
      drawBackground(id, x, y, width, height) {
        const bg = this.linksGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 2,
            dasharray: '5,5'
          })
          .radius(8);

        this.nodes.set(id, { x, y, width, height });
        return bg;
      }

      // Get connection point on a node's side with configurable offset and multi-link spacing
      getPoint(nodeId, side, offset = CONFIG.gaps.connectionOffset, linkIndex = 0, totalLinks = 1) {
        const node = this.nodes.get(nodeId);
        if (!node) return { x: 0, y: 0 };

        const points = {
          top: { x: node.x, y: node.y - node.height / 2 - offset },
          right: { x: node.x + node.width / 2 + offset, y: node.y },
          bottom: { x: node.x, y: node.y + node.height / 2 + offset },
          left: { x: node.x - node.width / 2 - offset, y: node.y }
        };

        let basePoint = points[side] || { x: node.x, y: node.y };

        // Apply spacing for multiple links to the same anchor
        if (totalLinks > 1) {
          const isVerticalAnchor = (side === 'top' || side === 'bottom');

          // Vertical anchors (top/bottom) space horizontally, horizontal anchors (left/right) space vertically
          const spacing = isVerticalAnchor ? node.width / (totalLinks + 1) : node.height / (totalLinks + 1);
          const linkOffset = (linkIndex - (totalLinks - 1) / 2) * spacing;

          // Apply offset in the perpendicular direction to the anchor
          if (isVerticalAnchor) {
            basePoint.x += linkOffset;  // Horizontal offset for vertical anchors
          } else {
            basePoint.y += linkOffset;  // Vertical offset for horizontal anchors
          }
        }

        return basePoint;
      }

      // Draw single link with optional multi-link spacing
      drawLink(fromId, toId, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, fromLinkIndex = 0, fromTotalLinks = 1, toLinkIndex = 0, toTotalLinks = 1, linkType = '', bandwidth = '') {
        const start = this.getPoint(fromId, fromSide, offset, fromLinkIndex, fromTotalLinks);
        const end = this.getPoint(toId, toSide, offset, toLinkIndex, toTotalLinks);

        const group = this.linksGroup.group();
        if (linkType) group.attr('data-link-type', linkType);
        if (bandwidth) {
          group.attr('data-bandwidth', bandwidth);
          // Find label from bandwidth config
          const bwConfig = getBandwidth(bandwidth);
          if (bwConfig && bwConfig.label) {
            group.attr('data-label', bwConfig.label);
          }
        }
        group.attr('data-from', fromId);
        group.attr('data-to', toId);

        // Check if this is a vertical connection (GPU-NVSwitch or CPU-PCIe)
        const isVerticalConnection = fromSide === 'bottom' && toSide === 'top';

        if (isVerticalConnection) {
          // Use curved paths for vertical connections
          const curvature = 45; // Fixed curvature value for consistent curve strength

          // Create a smooth cubic bezier curve with vertical control points
          const pathData = `M ${start.x} ${start.y} C ${start.x} ${start.y + curvature}, ${end.x} ${end.y - curvature}, ${end.x} ${end.y}`;

          // Draw border (wider path behind)
          group.path(pathData)
            .fill('none')
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main path on top
          group.path(pathData)
            .fill('none')
            .stroke({ color, width, opacity: 1 });
        } else {
          // Draw straight lines for other connections
          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });
        }

        const r = width * 0.8;
        const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');

        return group;
      }

      // Draw stacked links
      drawStackedLinks(fromId, toId, count, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, linkType = '', bandwidth = '') {
        const fromNode = this.nodes.get(fromId);
        const toNode = this.nodes.get(toId);
        if (!fromNode || !toNode) return [];

        const isHorizontal = (fromSide === 'left' || fromSide === 'right') &&
          (toSide === 'left' || toSide === 'right');
        const spacing = isHorizontal
          ? Math.min(fromNode.height, toNode.height) / (count + 1)
          : Math.min(fromNode.width, toNode.width) / (count + 1);

        const arrows = [];
        for (let i = 0; i < count; i++) {
          const stackOffset = (i - (count - 1) / 2) * spacing;
          let start = this.getPoint(fromId, fromSide, offset);
          let end = this.getPoint(toId, toSide, offset);

          if (isHorizontal) {
            start.y += stackOffset;
            end.y += stackOffset;
          } else {
            start.x += stackOffset;
            end.x += stackOffset;
          }

          const group = this.linksGroup.group();
          if (linkType) group.attr('data-link-type', linkType);
          if (bandwidth) {
            group.attr('data-bandwidth', bandwidth);
            // Find label from bandwidth config
            const bwConfig = getBandwidth(bandwidth);
            if (bwConfig && bwConfig.label) {
              group.attr('data-label', bwConfig.label);
            }
          }
          group.attr('data-from', fromId);
          group.attr('data-to', toId);

          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });

          const r = width * 0.8;
          const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
          startCircle.fill(color);
          startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          startCircle.attr('data-link-circle', 'true');

          const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
          endCircle.fill(color);
          endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          endCircle.attr('data-link-circle', 'true');

          arrows.push(group);
        }
        return arrows;
      }

      // Add phantom node (invisible connection point)
      addPhantom(id, x, y, width = 30, height = 30) {
        this.nodes.set(id, { x, y, width, height });

        // Draw phantom for debug visualization
        if (CONFIG.debug.showPhantoms) {
          this.phantomsGroup.rect(width, height)
            .move(x - width / 2, y - height / 2)
            .fill('rgba(255, 0, 255, 0.2)')  // Semi-transparent magenta
            .stroke({ color: 'magenta', width: 2, dasharray: '4,4' })
            .radius(4);

          // Add label
          this.phantomsGroup.text(id)
            .move(x, y)
            .font({
              family: 'system-ui, -apple-system, sans-serif',
              size: 10,
              anchor: 'middle',
              fill: 'magenta',
              weight: 'bold'
            })
            .dy(-height / 2 - 5);
        }
      }
    }

    // ============================================================================
    // DRAW SINGLE GROUP
    // ============================================================================
    function drawGroup(renderer, globalIndex, localIndex, x, cpuY, nvswitchY, cpuId = 'cpu') {
      const s = CONFIG.sizes;
      const g = CONFIG.gaps;
      const l = CONFIG.layout;
      const suffix = globalIndex > 0 ? `-${globalIndex}` : '';

      // Calculate Y positions
      const pcieY = cpuY + s.cpu / 2 + g.cpuToPcie + s.pcie.height / 2;
      const gpuY = pcieY + s.pcie.height / 2 + g.pcieToGpu + s.gpu.height / 2;

      // Calculate node positions
      const pcieX = x + l.pcieOffsetX;
      const efaX = x + l.efaNvmeOffsetX;
      const nvmeX = x + l.efaNvmeOffsetX;
      const efaY = pcieY + l.efaOffsetY;
      const nvmeY = pcieY + l.nvmeOffsetY;

      // Calculate bounding box BEFORE creating nodes
      const nodeBounds = [
        { x: pcieX, y: pcieY, width: s.pcie.width, height: s.pcie.height },
        { x: efaX, y: efaY, width: s.efa.width, height: s.efa.height },
        { x: nvmeX, y: nvmeY, width: s.nvme.width, height: s.nvme.height },
        { x: pcieX, y: gpuY, width: s.gpu.width, height: s.gpu.height }
      ];

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      nodeBounds.forEach(node => {
        minX = Math.min(minX, node.x - node.width / 2);
        maxX = Math.max(maxX, node.x + node.width / 2);
        minY = Math.min(minY, node.y - node.height / 2);
        maxY = Math.max(maxY, node.y + node.height / 2);
      });

      const bgWidth = maxX - minX + l.groupPadding * 2;
      const bgHeight = maxY - minY + l.groupPadding * 2;
      const bgCenterX = (minX + maxX) / 2;
      const bgCenterY = (minY + maxY) / 2;

      // Draw background FIRST (will be behind nodes)
      renderer.drawBackground(`group${suffix}`, bgCenterX, bgCenterY, bgWidth, bgHeight);

      // Nodes
      renderer.drawNode(`pcie${suffix}`, pcieX, pcieY, s.pcie.width, s.pcie.height, 'PCIe\nSwitch', 'network');
      renderer.addPinsToNode(`pcie${suffix}`, {
        pinsPerSide: 6,
        sides: ['left', 'right'],
        pinLength: 3,
        pinPadding: 8
      });
      renderer.drawStackedNode(`efa${suffix}`, efaX, efaY, s.efa.width, s.efa.height, 'EFA', 4, 'network');
      renderer.drawStorageNode(`nvme${suffix}`, nvmeX, nvmeY, s.nvme.width, s.nvme.height, 'NVMe', 'storage');
      renderer.drawProcessorNode(`gpu${suffix}`, pcieX, gpuY, s.gpu.width, s.gpu.height, 'GPU', 'gpu');

      // Phantom nodes for routing
      // PCIe phantoms: bord gauche aligné avec PCIe, largeur du PCIe
      const pcieLeftEdge = pcieX;
      const pciePhantomX = pcieLeftEdge;
      renderer.addPhantom(`pcie-efa-phantom${suffix}`, pciePhantomX, efaY, s.pcie.width, s.efa.height);
      renderer.addPhantom(`pcie-nvme-phantom${suffix}`, pciePhantomX, nvmeY, s.pcie.width, s.nvme.height);

      // EFA external phantom: à droite de EFA
      const efaRightEdge = efaX + s.efa.width / 2;
      const efaPhantomX = efaRightEdge + g.connectionOffset + s.efa.width / 2 + 20;  // Centre du phantom + décalage réduit
      renderer.addPhantom(`efa-external${suffix}`, efaPhantomX, efaY, s.efa.width, s.efa.height);

      // Create links from configuration
      CONFIG.groupLinks.forEach(linkDef => {
        const bw = getBandwidth(linkDef.bandwidth);
        const fromId = linkDef.from === 'cpu' ? cpuId : `${linkDef.from}${suffix}`;  // Use cpuId from parameter
        const toId = `${linkDef.to}${suffix}`;
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const offset = getLinkOffset(bw.width);  // Proportional offset based on link width

        if (linkDef.stacked) {
          renderer.drawStackedLinks(fromId, toId, linkDef.stacked, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, linkDef.type, linkDef.bandwidth);
        } else if (linkDef.multiLink) {
          // Use localIndex for multi-link spacing (0-3 within ensemble)
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, localIndex, CONFIG.groupCount, 0, 1, linkDef.type, linkDef.bandwidth);
        } else {
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, 0, 1, 0, 1, linkDef.type, linkDef.bandwidth);
        }
      });
    }

    // ============================================================================
    // DRAW SINGLE ENSEMBLE (CPU + 4 groups + 2 NVSwitches)
    // ============================================================================
    function drawEnsemble(renderer, ensembleGlobalIndex, centerX, cpuY, nvswitchY) {
      const cpuId = ensembleGlobalIndex === 0 ? 'cpu' : `cpu-${ensembleGlobalIndex}`;

      // CPU for this ensemble
      renderer.drawProcessorNode(cpuId, centerX, cpuY, CONFIG.sizes.cpu, CONFIG.sizes.cpu, 'CPU', 'cpu');

      // Groups for this ensemble
      for (let i = 0; i < CONFIG.groupCount; i++) {
        const groupGlobalIndex = ensembleGlobalIndex * CONFIG.groupCount + i;
        const offsetX = (i - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal;
        drawGroup(renderer, groupGlobalIndex, i, centerX + offsetX, cpuY, nvswitchY, cpuId);  // Pass i as localIndex
      }

      // NVSwitches: positioned between pairs of groups
      for (let i = 0; i < CONFIG.nvswitchCount; i++) {
        const nvswitchGlobalIndex = ensembleGlobalIndex * CONFIG.nvswitchCount + i;
        const groupPairStart = i * 2;
        const groupPairEnd = groupPairStart + 1;

        const group1X = centerX + ((groupPairStart - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const group2X = centerX + ((groupPairEnd - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const nvswitchX = (group1X + group2X) / 2;

        renderer.drawNode(`nvswitch-${nvswitchGlobalIndex}`, nvswitchX, nvswitchY,
          CONFIG.sizes.nvswitch.width, CONFIG.sizes.nvswitch.height, 'NVSwitch', 'network');

        // Add pins to NVSwitch (like PCIe Switch)
        renderer.addPinsToNode(`nvswitch-${nvswitchGlobalIndex}`, {
          pinsPerSide: 6,
          sides: ['left', 'right'],
          pinLength: 3,
          pinPadding: 8
        });
      }

    }


    // ============================================================================
    // DRAW SINGLE SYSTEM (variable number of ensembles)
    // ============================================================================
    function drawSystem(renderer, systemIndex, systemCenterX, cpuY, nvswitchY, ensembleCount = 1, systemCount = 1, shouldDrawEfaCrossLinks = false) {
      // For internode (2 systems), only show 1 ensemble per system for clarity
      const ensemblesToShow = (systemCount === 2) ? 1 : ensembleCount;

      // Calculate ensemble width (4 groups)
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;

      // Calculate system bounding box based on actual ensembles shown
      const systemWidth = ensemblesToShow * ensembleWidth + (ensemblesToShow - 1) * CONFIG.gaps.ensembleGap;
      const systemHeight = CONFIG.sizes.cpu + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height;

      const systemBgCenterY = cpuY + (nvswitchY - cpuY) / 2;
      const systemPadding = 30;

      // In internode mode, extend the rectangle slightly to the right
      const isInternode = systemCount === 2;
      const extraWidth = isInternode && ensembleCount === 2 ? 210 : 0;

      // Draw system background ONLY if 2 ensembles (intra-node vs inter-node distinction)
      if (ensembleCount === 2) {
        // Adjust rectX to center the extended rectangle
        const totalWidth = systemWidth + systemPadding * 2 + extraWidth;
        const rectX = systemCenterX - totalWidth / 2;
        const rectY = systemBgCenterY - (systemHeight + systemPadding * 2) / 2;
        const rectWidth = totalWidth;
        const rectHeight = systemHeight + systemPadding * 2;

        renderer.structuralGroup.rect(rectWidth, rectHeight)
          .move(rectX, rectY)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 3,
            opacity: 1
          })
          .radius(12)
          .attr('data-group-border', 'node');

        // Add "Node" label at top left of the system box
        renderer.nodesGroup.text('Node')
          .move(rectX + 35, rectY + 40)
          .font({
            size: 32,
            family: 'var(--font-family)',
            weight: 900,
            fill: CONFIG.colors.textSecondary
          })
          .opacity(0.8);

        // Add NUMA 1 group with "..." in the extended area for internode mode
        if (isInternode) {
          const numaPadding = 15;
          const numaWidth = extraWidth - 15; // Margin for spacing
          const numaHeight = systemHeight;

          const numaX = rectX + rectWidth - extraWidth; // Left margin
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth;
          const numaRectHeight = numaHeight + numaPadding * 2;

          // Draw NUMA 1 border
          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA 1" label at top right
          renderer.nodesGroup.text('NUMA 1')
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);

          // Add "..." centered in NUMA 1
          renderer.nodesGroup.text('...')
            .move(numaX + numaRectWidth / 2, numaY + numaRectHeight / 2)
            .font({
              size: 40,
              family: 'var(--font-family)',
              weight: 900,
              fill: CONFIG.colors.textSecondary,
              anchor: 'middle'
            })
            .opacity(0.6);
        }
      }

      // Draw each ensemble in the system
      for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
        const ensembleGlobalIndex = systemIndex * CONFIG.ensembleCount + ensIndex;

        // Position ensemble within system
        let ensembleCenterX;
        if (isInternode) {
          // In internode mode, align NUMA 0 to the left of the Node rectangle
          const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
          ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
        } else {
          // Normal centered positioning
          const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
          ensembleCenterX = systemCenterX + ensembleOffsetX;
        }

        drawEnsemble(renderer, ensembleGlobalIndex, ensembleCenterX, cpuY, nvswitchY);
      }

      // Draw NUMA node borders (one per ensemble) if 2 ensembles
      if (ensembleCount === 2) {
        for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
          let ensembleCenterX;
          if (isInternode) {
            // In internode mode, align NUMA 0 to the left
            const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
            ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
          } else {
            // Normal centered positioning
            const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
            ensembleCenterX = systemCenterX + ensembleOffsetX;
          }

          // Calculate NUMA node bounding box (same as system but for single ensemble)
          const numaWidth = ensembleWidth;
          const numaHeight = systemHeight;
          const numaPadding = 15;

          const numaX = ensembleCenterX - (numaWidth + numaPadding * 2) / 2;
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth + numaPadding * 2;
          const numaRectHeight = numaHeight + numaPadding * 2;

          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA" label at top right
          renderer.nodesGroup.text(`NUMA ${ensIndex}`)
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);
        }
      }

      // GPU to NVSwitch connections (full mesh - all GPUs to all NVSwitches in system)
      const linkDef = CONFIG.gpuNvswitchLink;
      const bw = getBandwidth(linkDef.bandwidth);
      const color = CONFIG.colors.linkColor;
      const offset = getLinkOffset(bw.width);

      // Connect all GPUs in the system to all NVSwitches in the system
      const totalGpusInSystem = ensemblesToShow * CONFIG.groupCount;
      const totalNVSwitchesInSystem = ensemblesToShow * CONFIG.nvswitchCount;

      // Collect all GPU-NVSwitch connections for randomized drawing
      const gpuNvswitchConnections = [];
      for (let gpuIndex = 0; gpuIndex < totalGpusInSystem; gpuIndex++) {
        const gpuGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + gpuIndex;
        const gpuId = gpuGlobalIndex === 0 ? 'gpu' : `gpu-${gpuGlobalIndex}`;

        for (let nvIndex = 0; nvIndex < totalNVSwitchesInSystem; nvIndex++) {
          const nvswitchGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.nvswitchCount + nvIndex;
          gpuNvswitchConnections.push({
            fromId: gpuId,
            toId: `nvswitch-${nvswitchGlobalIndex}`,
            color: color,
            width: bw.width,
            fromSide: linkDef.fromSide,
            toSide: linkDef.toSide,
            offset: offset,
            type: linkDef.type,
            bandwidth: linkDef.bandwidth
          });
        }
      }

      // Randomize and draw GPU-NVSwitch connections
      const shuffledGpuNvswitchConnections = gpuNvswitchConnections.sort(() => Math.random() - 0.5);
      shuffledGpuNvswitchConnections.forEach(conn => {
        renderer.drawLink(conn.fromId, conn.toId, conn.color, conn.width, conn.fromSide, conn.toSide, conn.offset, 0, 1, 0, 1, conn.type, conn.bandwidth);
      });

      // Draw CPU-to-CPU link between ensembles (only if 2 ensembles visible)
      if (ensemblesToShow === 2) {
        const cpu0Id = systemIndex * CONFIG.ensembleCount === 0 ? 'cpu' : `cpu-${systemIndex * CONFIG.ensembleCount}`;
        const cpu1Id = `cpu-${systemIndex * CONFIG.ensembleCount + 1}`;

        // Use a bandwidth for CPU-CPU connection (assuming similar to CPU-PCIe)
        const bw = getBandwidth('16GB/s');
        const color = CONFIG.colors.linkColor;
        const offset = getLinkOffset(bw.width);

        renderer.drawLink(cpu0Id, cpu1Id, color, bw.width, 'right', 'left', offset, 0, 1, 0, 1, 'cpu', '16GB/s');

        // Draw EFA-to-EFA link between ensembles (only if 2 ensembles visible and explicitly requested)
        if (ensemblesToShow === 2 && shouldDrawEfaCrossLinks) {
          const efaExt0Id = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount === 0 ? 'efa-external' : `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount}`;
          const efaExt1Id = `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + CONFIG.groupCount}`;

          // Use unified EFA cross-links function
          drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
        }
      }
    }

    // ============================================================================
    // DRAW COMPLETE TOPOLOGY
    // ============================================================================
    let currentEnsembleCount = 2;  // Start with 2 ensembles (1 complete node)
    let currentSystemCount = 1;    // Start with 1 system
    let currentActivePathId = null; // Track active path for conditional rendering
    let showRealBandwidthsOverride = null; // User override via checkbox (null = use config)

    function drawTopology(ensembleCount = currentEnsembleCount, systemCount = currentSystemCount) {
      // Clear existing
      const container = getElement('aws-topology-container');
      container.innerHTML = '';

      // Use FIXED viewbox size for consistent zoom across all modes
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;
      const isInternodeLayout = systemCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode';

      // Calculate single system height (used in both layouts)
      const singleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;

      // Always use max viewbox dimensions for consistent zoom level
      const maxEnsembleWidthForViewbox = 2 * ensembleWidth;
      let viewboxWidth = maxEnsembleWidthForViewbox + CONFIG.gaps.ensembleGap + 200;
      let viewboxHeight = singleSystemHeight;

      // For single ensemble (CPU-GPU, GPU-GPU via CPU, storage paths), zoom in more
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxWidth *= 0.65;  // Zoom in by reducing viewbox width (increased from 0.75)
        viewboxHeight *= 0.65; // Zoom in by reducing viewbox height (increased from 0.75)
      }

      // For 2 systems in vertical layout, use scaled dimensions
      if (systemCount === 2 && !isInternodeLayout) {
        viewboxHeight = singleSystemHeight * 2 + CONFIG.gaps.systemGap;
        viewboxWidth *= 1.15;
        viewboxHeight *= 1.15;
      }

      // For internode horizontal layout, extend viewbox width to accommodate both extended systems
      if (isInternodeLayout) {
        const extraWidth = 210; // Extension per system for NUMA 1
        const systemPadding = 30;
        const singleEnsembleWidth = ensembleWidth;
        const totalSystemWidth = singleEnsembleWidth + systemPadding * 2 + extraWidth;
        const gap = 80;
        viewboxWidth = totalSystemWidth * 2 + gap + 200; // Extra margin for comfort
      }

      // Fixed height based on screen width for better consistency
      const embedConfig = readEmbedConfig();
      const containerWidth = container.clientWidth || 800;

      // Calculate fixed height: use max viewbox dimensions to determine aspect ratio
      // Max viewbox is for 2 ensembles, 2 systems (vertical layout)
      const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
      const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;
      const maxViewboxHeight = maxSingleSystemHeight * 1.15; // Account for 2-system scaling
      const maxViewboxWidth = maxEnsembleWidth + 200;

      const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
      const baseHeight = containerWidth * maxAspectRatio;
      const legendHeight = embedConfig.initialFilter ? 150 : 200;

      // Set fixed height once, won't change on filter change
      if (!container.dataset.heightSet) {
        container.style.height = `${baseHeight + legendHeight}px`;
        container.dataset.heightSet = 'true';
      }

      // Viewbox will auto-center/zoom content
      let viewboxY = 0;
      let paddedViewboxHeight = viewboxHeight;
      const verticalPadding = 0;
      viewboxY = -verticalPadding / 2 + 100;
      paddedViewboxHeight = viewboxHeight + verticalPadding;

      // For single ensemble, shift content up slightly
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxY += 150;  // Shift up by reducing viewboxY (reduced from 80)
      }

      // For single node mode (no Node/NUMA groups), shift content down by 80px
      // BUT only if: 1) not an EFA filter, 2) a filter is active
      const isEfaFilter = currentActivePathId === 'gpu-gpu-efa-intranode' || currentActivePathId === 'gpu-gpu-efa-internode';
      const hasActiveFilter = currentActivePathId && currentActivePathId !== '';
      if (!isInternodeLayout && hasActiveFilter && !isEfaFilter) {
        viewboxY -= 80;  // Shift down by decreasing viewboxY (increased from 50px)
      }

      const draw = SVG().addTo(container).size('100%', '100%').viewbox(0, viewboxY, viewboxWidth, paddedViewboxHeight);
      const renderer = new TopologyRenderer(draw);

      const centerX = viewboxWidth / 2;

      // Draw each system - horizontally for internode, vertically for others
      const isInternodeHorizontalLayout = isInternodeLayout;

      for (let sysIndex = 0; sysIndex < systemCount; sysIndex++) {
        let systemCenterX, cpuY, nvswitchY;

        if (isInternodeHorizontalLayout) {
          // Horizontal layout for internode: systems side by side (rapprochés mais sans overlap)
          // Pour internode, on affiche 1 seul ensemble (NUMA) par système, donc largeur réelle = 50%
          const fullSystemWidth = ensembleCount * ensembleWidth + (ensembleCount - 1) * CONFIG.gaps.ensembleGap;
          const actualSystemWidth = fullSystemWidth * 0.5; // On n'affiche qu'1 ensemble sur 2
          const extraWidth = 210; // Extension pour le groupe NUMA 1
          const systemPadding = 10;
          const totalSystemWidth = actualSystemWidth + systemPadding * 2 + extraWidth; // Largeur totale incluant l'extension
          const gap = 80; // Gap visible entre les systèmes

          // Positionner les systèmes avec le gap (en prenant en compte la largeur totale)
          if (sysIndex === 0) {
            systemCenterX = centerX - (totalSystemWidth / 2 + gap / 2); // Premier système à gauche
          } else {
            systemCenterX = centerX + (totalSystemWidth / 2 + gap / 2); // Deuxième système à droite
          }
          cpuY = CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        } else {
          // Vertical layout for other cases: systems stacked vertically
          const systemOffsetY = sysIndex * (singleSystemHeight + CONFIG.gaps.systemGap);
          systemCenterX = centerX;
          cpuY = systemOffsetY + CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        }

        // Only draw EFA cross-links for intranode EFA path
        const shouldDrawEfaCrossLinks = currentActivePathId === 'gpu-gpu-efa-intranode';
        drawSystem(renderer, sysIndex, systemCenterX, cpuY, nvswitchY, ensembleCount, systemCount, shouldDrawEfaCrossLinks);
      }

      // Draw EFA cross-link between systems (for internode)
      if (systemCount === 2 && ensembleCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode') {
        const efaExt0Id = 'efa-external';  // System 0, ensemble 0, group 0
        const efaExt1Id = 'efa-external-8';  // System 1, ensemble 0, group 0 (4 groups per ensemble, 2 ensembles per system = group 8)

        // Use unified EFA cross-links function
        drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
      }

      currentEnsembleCount = ensembleCount;
      currentSystemCount = systemCount;
    }

    // ============================================================================
    // REAL BANDWIDTH HELPERS
    // ============================================================================
    function getRealBandwidthForPath(pathId) {
      const pathToRealBandwidth = {
        'cpu-gpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-cpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-nvswitch': { value: '786', unit: 'GB/s' },
        'gpu-gpu-efa-intranode': { value: '40', unit: 'GB/s' },
        'gpu-gpu-efa-internode': { value: '40', unit: 'GB/s' },
        'gpu-storage': { value: '14.2', unit: 'GB/s' },
        'cpu-storage': { value: '14.2', unit: 'GB/s' },
        'gpu-cpu-storage': { value: '14.2', unit: 'GB/s' }
      };

      const bandwidth = pathToRealBandwidth[pathId];
      if (bandwidth) {
        return {
          value: bandwidth.value,
          unit: bandwidth.unit
        };
      }
      return null;
    }

    // ============================================================================
    // HIGHLIGHT HELPERS
    // ============================================================================
    function highlightPath(path, pathLabel = '', pathId = '') {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear previous active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Ghost all base links and cross-links groups at once
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '0.35';

        // Increase stroke width of group borders to make them more visible when ghosted
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '5');
          // border.setAttribute('stroke-opacity', '0.8');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '0.25';
      }

      // Dim nodes individually (they're not in a group)
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '0.6';
        // Dim text labels
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '0.25';
        });
      });

      // Highlight path nodes
      path.nodes.forEach(nodeId => {
        let nodeEl = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeEl) {
          const candidates = svg.querySelectorAll(`g[id^="${nodeId}"]`);
          nodeEl = candidates[0];
        }
        if (nodeEl) {
          nodeEl.style.opacity = '1';
          // Restore text opacity
          nodeEl.querySelectorAll('text').forEach(text => {
            text.style.opacity = '1';
          });
        }
      });

      // Duplicate active links into activeLinksGroup
      if (activeLinksGroup) {
        path.links.forEach(linkSpec => {
          // Find matching links in base groups
          const allBaseLinks = [
            ...svg.querySelectorAll('g[data-group="base-links"] > g[data-link-type]'),
            ...svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type]')
          ];

          allBaseLinks.forEach(linkGroup => {
            const linkFrom = linkGroup.getAttribute('data-from');
            const linkTo = linkGroup.getAttribute('data-to');

            const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
            const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

            if (matchesFrom && matchesTo) {
              // Clone the link and append to active group
              const clonedLink = linkGroup.cloneNode(true);
              activeLinksGroup.appendChild(clonedLink);
            }
          });
        });

        // Duplicate EFA cross-links if they match the current path
        const currentPathId = currentActivePathId;
        if (currentPathId === 'gpu-gpu-efa-intranode' || currentPathId === 'gpu-gpu-efa-internode') {
          const efaCrossLinks = svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type="efa-crosslink"]');
          efaCrossLinks.forEach(linkGroup => {
            const clonedLink = linkGroup.cloneNode(true);
            activeLinksGroup.appendChild(clonedLink);
          });
        }
      }

      // Calculate and show bottleneck (minimum bandwidth in the path)
      let minBandwidth = Infinity;
      let minBandwidthValue = null;
      const usedBandwidths = new Set();

      path.links.forEach(linkSpec => {
        svg.querySelectorAll('g[data-link-type]').forEach(linkGroup => {
          const linkFrom = linkGroup.getAttribute('data-from');
          const linkTo = linkGroup.getAttribute('data-to');

          const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
          const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

          if (matchesFrom && matchesTo) {
            const bandwidth = linkGroup.getAttribute('data-bandwidth');
            if (bandwidth) {
              const bw = getBandwidth(bandwidth);
              if (bw && bw.numericValue < minBandwidth) {
                minBandwidth = bw.numericValue;
                minBandwidthValue = bw.speed;
              }
              if (bw) {
                usedBandwidths.add(bw.speed);
              }
            }
          }
        });
      });

      // Highlight all used bandwidths in the legend
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          const bandwidth = legendItem.getAttribute('data-legend-bandwidth');
          if (usedBandwidths.has(bandwidth)) {
            // Used in the path - active
            legendItem.style.opacity = '1';
          } else {
            // Not used - ghosted
            legendItem.style.opacity = '0.4';
          }
        });
      }

      // Show bottleneck info
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      const efficiencyValueEl = bottleneckEl.querySelector('.efficiency-value');

      // Check if real bandwidths are enabled
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (showRealBandwidths) {
        // When real bandwidths are shown, display real bandwidth value directly
        const realBandwidth = getRealBandwidthForPath(pathId);
        if (realBandwidth) {
          bottleneckValueEl.textContent = realBandwidth.value;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');

          // Calculate and display efficiency
          if (minBandwidthValue && efficiencyEl && efficiencyValueEl) {
            const theoreticalBandwidth = parseFloat(minBandwidthValue.replace('GB/s', ''));
            const realBandwidthNum = parseFloat(realBandwidth.value);

            // For EFA (12.5GB/s), multiply by 4 to get total theoretical bandwidth
            const adjustedTheoretical = minBandwidthValue === '12.5GB/s' ? theoreticalBandwidth * 4 : theoreticalBandwidth;

            const efficiency = (realBandwidthNum / adjustedTheoretical) * 100;
            efficiencyValueEl.textContent = `${efficiency.toFixed(1)}%`;
            efficiencyEl.style.display = 'block';
          }
        } else {
          // Fallback if no real bandwidth found
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');
          if (efficiencyEl) {
            efficiencyEl.style.display = 'none';
          }
        }
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      } else {
        // Normal bottleneck display
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        if (minBandwidthValue) {
          const value = minBandwidthValue.replace('GB/s', '');
          // For EFA (12.5GB/s), display as 50 (4 links × 12.5)
          const displayValue = value === '12.5' ? '50' : value;
          bottleneckValueEl.textContent = displayValue;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        } else {
          // Debug: show the module even without bandwidth data
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        }
        // Hide efficiency in normal mode
        if (efficiencyEl) {
          efficiencyEl.style.display = 'none';
        }
      }
    }

    function resetHighlight() {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Restore opacity to base links groups
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '1';

        // Restore original stroke width for group borders
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '3');
          border.setAttribute('stroke-opacity', '1');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '1';
      }

      // Reset nodes opacity
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '1';
        // Reset text opacity
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '1';
        });
      });

      // Clear current active path to ensure EFA cross-links are not drawn
      currentActivePathId = null;

      // Reset legend opacity
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          legendItem.style.opacity = '1';
        });
      }

      // Hide bottleneck (unless real bandwidths are enabled)
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (!showRealBandwidths) {
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        bottleneckEl.classList.remove('visible');
      } else {
        // When real bandwidths are enabled, hide the module when no path is active
        bottleneckLabelEl.textContent = 'Real Bandwidth';
        bottleneckEl.classList.remove('visible');
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      }

      // Hide efficiency display
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      if (efficiencyEl) {
        efficiencyEl.style.display = 'none';
      }
    }

    // ============================================================================
    // CONFIG READING (from HtmlEmbed props)
    // ============================================================================
    function readEmbedConfig() {
      // Find the closest ancestor that carries the data-config attribute
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let providedConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      const config = providedConfig || {};

      // Apply user override from checkbox if set
      if (showRealBandwidthsOverride !== null) {
        config.showRealBandwidths = showRealBandwidthsOverride;
      }

      return config;
    }

    // ============================================================================
    // REAL BANDWIDTHS DISPLAY
    // ============================================================================
    function displayContextualRealBandwidths(pathId, pathLabel) {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Map path IDs to relevant real bandwidths
      const pathToBandwidths = {
        'cpu-gpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-cpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-GPU (via CPU)', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-nvswitch': [
          { label: 'GPU-GPU (NVSwitch)', value: CONFIG.realBandwidths['gpu-gpu-same-node'] }
        ],
        'gpu-gpu-efa-intranode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-intranode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
          { label: 'All2All', value: CONFIG.realBandwidths['all2all-same-node'] }
        ],
        'gpu-gpu-efa-internode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-internode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
          { label: 'All2All', value: CONFIG.realBandwidths['alltoall-internode'] }
        ],
        'gpu-storage': [
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'cpu-storage': [
          { label: 'CPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'gpu-cpu-storage': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ]
      };

      const relevantBandwidths = pathToBandwidths[pathId] || [];

      if (relevantBandwidths.length > 0) {
        // Clear normal bottleneck display
        bottleneckValueEl.textContent = '';
        bottleneckPathEl.textContent = '';

        // Create HTML for relevant bandwidths
        const html = relevantBandwidths.map(item => `
          <div class="bandwidth-item">
            <span class="bandwidth-label">${item.label}</span>
            <span class="bandwidth-value">${item.value}</span>
          </div>
        `).join('');

        realBandwidthsContentEl.innerHTML = html;
      } else {
        // Fallback: show all bandwidths if path not found
        setupRealBandwidthsDisplay();
      }
    }

    function setupRealBandwidthsDisplay() {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Create the bandwidth items HTML
      const bandwidthItems = [
        { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
        { label: 'Same Node', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-same-node'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
        { label: '  All2All', value: CONFIG.realBandwidths['all2all-same-node'] },
        { label: 'Internode', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-internode'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
        { label: '  All2All', value: CONFIG.realBandwidths['alltoall-internode'] },
        { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
      ];

      const html = bandwidthItems.map(item => {
        if (item.value === '') {
          // Section header
          return `<div class="bandwidth-section-header" style="font-weight: 600; margin: 6px 0 4px 0; color: var(--text-secondary);">${item.label}</div>`;
        } else {
          // Bandwidth item
          return `
            <div class="bandwidth-item">
              <span class="bandwidth-label">${item.label}</span>
              <span class="bandwidth-value">${item.value}</span>
            </div>
          `;
        }
      }).join('');

      realBandwidthsContentEl.innerHTML = html;
    }

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    function initialize() {
      const container = getElement('aws-topology-container');
      const tooltip = getElement('aws-topology-tooltip');

      // Read initial config from HtmlEmbed props (before any override)
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let initialConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          initialConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      // Initialize override with initial config value (so checkbox is in sync)
      if (initialConfig && initialConfig.showRealBandwidths !== undefined) {
        showRealBandwidthsOverride = initialConfig.showRealBandwidths;
      }

      // Now read config (which will use override if set)
      const embedConfig = readEmbedConfig();

      // Setup real bandwidths display if enabled
      if (embedConfig.showRealBandwidths) {
        const bottleneckEl = getElement('aws-topology-bottleneck');
        const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');

        // Change label to "Real Bandwidth"
        bottleneckLabelEl.textContent = 'Real Bandwidth';

        // Hide the detailed real bandwidths list initially
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
        // Don't show the module initially - only when a path is selected
        bottleneckEl.classList.remove('visible');
      }

      drawTopology();

      // Initial fade in
      requestAnimationFrame(() => {
        container.style.opacity = '1';
      });

      // Setup tooltip

      container.addEventListener('mouseover', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          const bandwidth = target.getAttribute('data-bandwidth');
          const label = target.getAttribute('data-label');

          // Clear and rebuild tooltip content
          tooltip.innerHTML = '';

          if (label) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'tooltip-label';
            labelDiv.textContent = label;
            tooltip.appendChild(labelDiv);
          }

          const bandwidthDiv = document.createElement('div');
          bandwidthDiv.className = 'tooltip-bandwidth';
          bandwidthDiv.textContent = bandwidth;
          tooltip.appendChild(bandwidthDiv);

          tooltip.classList.add('visible');
        }
      });

      container.addEventListener('mousemove', (e) => {
        if (tooltip.classList.contains('visible')) {
          const rect = container.getBoundingClientRect();
          tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
          tooltip.style.top = (e.clientY - rect.top + 10) + 'px';
        }
      });

      container.addEventListener('mouseout', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          tooltip.classList.remove('visible');
        }
      });

      // Create control buttons organized by category
      const controlsContainer = getElement('aws-topology-controls');

      // Hide controls if an initial filter is provided
      if (embedConfig.initialFilter) {
        controlsContainer.style.display = 'none';
      } else {
        // Categorize paths
        const pathsByCategory = {
          intranode: [
            { id: 'cpu-gpu', label: CONFIG.paths['cpu-gpu'].label },
            { id: 'gpu-gpu-cpu', label: CONFIG.paths['gpu-gpu-cpu'].label },
            { id: 'gpu-gpu-nvswitch', label: CONFIG.paths['gpu-gpu-nvswitch'].label },
            { id: 'gpu-gpu-efa-intranode', label: CONFIG.paths['gpu-gpu-efa-intranode'].label }
          ],
          internode: [
            { id: 'gpu-gpu-efa-internode', label: CONFIG.paths['gpu-gpu-efa-internode'].label }
          ],
          storage: [
            { id: 'gpu-storage', label: CONFIG.paths['gpu-storage'].label },
            { id: 'cpu-storage', label: CONFIG.paths['cpu-storage'].label },
            { id: 'gpu-cpu-storage', label: CONFIG.paths['gpu-cpu-storage'].label }
          ]
        };

        // Create single select with prefixed options and checkbox
        const isChecked = showRealBandwidthsOverride === true || (showRealBandwidthsOverride === null && embedConfig.showRealBandwidths);
        const controlsHTML = `
          <div>
            <label id="real-bandwidth-label" style="display: flex; align-items: center; gap: 0px; font-size: 14px; color: var(--text-color); cursor: pointer; opacity: 0.3; transition: opacity 0.2s;">
              <input type="checkbox" id="real-bandwidth-toggle" ${isChecked ? 'checked' : ''} disabled>
              <span>Show Real Bandwidths</span>
            </label>
          </div>
          
          <div style="display: flex; gap: 12px; align-items: center; margin-top: 8px;">
            <select id="path-select" style="min-width: 250px;">
              <option value="">Select path...</option>
            </select>
          </div>
        `;
        controlsContainer.innerHTML = controlsHTML;

        const pathSelect = controlsContainer.querySelector('#path-select');
        const realBandwidthToggle = controlsContainer.querySelector('#real-bandwidth-toggle');
        const realBandwidthLabel = controlsContainer.querySelector('#real-bandwidth-label');

        // Populate single select with prefixed options
        Object.entries(pathsByCategory).forEach(([category, paths]) => {
          const categoryLabel = category.charAt(0).toUpperCase() + category.slice(1);

          paths.forEach(path => {
            const option = document.createElement('option');
            option.value = path.id;
            option.textContent = `${categoryLabel}: ${path.label}`;
            pathSelect.appendChild(option);
          });
        });

        // Helper function to enable/disable real bandwidth toggle
        const updateRealBandwidthToggleState = (enabled) => {
          if (enabled) {
            realBandwidthToggle.disabled = false;
            realBandwidthLabel.style.opacity = '1';
            realBandwidthLabel.style.cursor = 'pointer';
          } else {
            realBandwidthToggle.disabled = true;
            realBandwidthLabel.style.opacity = '0.3';
            realBandwidthLabel.style.cursor = 'default';
          }
        };

        // Real bandwidth toggle handler
        realBandwidthToggle.addEventListener('change', (e) => {
          showRealBandwidthsOverride = e.target.checked;

          // Re-apply highlight if a path is active
          if (currentActivePathId) {
            const path = CONFIG.paths[currentActivePathId];
            if (path) {
              highlightPath(path, path.label, currentActivePathId);
            }
          } else {
            // If no path active, just reset to clear any displayed values
            resetHighlight();
          }
        });

        // Function to activate a path
        const activatePath = (pathId) => {
          if (!pathId) {
            // Reset to default
            currentActivePathId = null;
            updateRealBandwidthToggleState(false); // Disable toggle when no path selected
            const needsRedraw = currentEnsembleCount !== 2 || currentSystemCount !== 1;

            if (needsRedraw) {
              const container = getElement('aws-topology-container');
              container.style.opacity = '0';

              setTimeout(() => {
                drawTopology(2, 1);
                resetHighlight();

                requestAnimationFrame(() => {
                  container.style.opacity = '1';
                });
              }, 150);
            } else {
              resetHighlight();
            }
            return;
          }

          const path = CONFIG.paths[pathId];
          if (!path) return;

          currentActivePathId = pathId;
          updateRealBandwidthToggleState(true); // Enable toggle when path is selected

          // Check if we need to redraw
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            pathId === 'gpu-gpu-efa-intranode' ||
            pathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            const container = getElement('aws-topology-container');
            container.style.opacity = '0';

            setTimeout(() => {
              currentActivePathId = pathId;
              drawTopology(path.requiredEnsembles, path.requiredSystems);
              highlightPath(path, path.label, pathId);

              requestAnimationFrame(() => {
                container.style.opacity = '1';
              });
            }, 150);
          } else {
            currentActivePathId = pathId;
            highlightPath(path, path.label, pathId);
          }
        };

        // Path select change handler
        pathSelect.addEventListener('change', (e) => {
          const pathId = e.target.value;
          activatePath(pathId);
        });
      }

      // Apply initial filter from embedConfig if provided
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          currentActivePathId = initialPathId;

          // Draw topology with correct requirements
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            initialPathId === 'gpu-gpu-efa-intranode' ||
            initialPathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            drawTopology(path.requiredEnsembles, path.requiredSystems);
          }
        }
      }

      // Create SVG legend
      const legendContainer = getElement('aws-topology-legend');
      const legendSvg = SVG().addTo(legendContainer).size('100%', '100%');

      const lineLength = 36;  // 30 * 1.2
      const itemSpacing = 30;  // 25 * 1.2
      const startX = 96;  // 80 * 1.2
      const startY = 42;  // 35 * 1.2
      const textOffset = 24;  // 20 * 1.2

      // Calculate actual legend width based on content
      const legendWidth = startX + lineLength + textOffset + 168;  // 140 * 1.2
      const legendHeight = 144;  // 120 * 1.2
      legendSvg.viewbox(0, 0, legendWidth, legendHeight);

      [...CONFIG.bandwidths].reverse().forEach((bw, index) => {
        const y = startY + (index * itemSpacing);
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const width = bw.width;

        // Create a group for each legend item with a data attribute for bandwidth
        const legendItemGroup = legendSvg.group();
        legendItemGroup.attr('data-legend-bandwidth', bw.speed);

        // Dessiner la ligne
        legendItemGroup.line(startX, y, startX + lineLength, y)
          .stroke({ color, width });

        // Dessiner les cercles aux extrémités
        const r = width * 0.8;
        const startCircle = legendItemGroup.circle(r * 2).move(startX - r, y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        const endCircle = legendItemGroup.circle(r * 2).move(startX + lineLength - r, y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        // Ajouter le texte (aligné à droite, valeur en gras)
        const textX = legendWidth - 5;
        const value = bw.speed.replace('GB/s', '').trim();

        // Format: "Label - 900 GB/s" avec 900 en gras
        const textEl = legendItemGroup.text(function (add) {
          add.tspan(bw.label + ' - ').font({ weight: 'normal' });
          add.tspan(value).font({ weight: 'bold' });
          add.tspan(' GB/s').font({ weight: 'normal' });
        })
          .move(textX, y)
          .font({
            family: 'system-ui, -apple-system, sans-serif',
            size: 14,  // 12 * 1.2 ≈ 14
            anchor: 'end',
            fill: CONFIG.colors.nodeText
          })
          .dy(-7);  // -6 * 1.2 ≈ -7
      });
    }

    // Initialize only if wrapper is found
    if (findWrapper()) {
      initialize();

      // Apply initial filter highlight after legend is created
      const embedConfig = readEmbedConfig();
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          // Apply highlight to both topology and legend
          highlightPath(path, path.label, initialPathId);
        }
      }

      // Add resize handler for responsive width changes (mobile/desktop)
      const handleResize = () => {
        const container = getElement('aws-topology-container');
        if (!container) return;

        // Recalculate fixed height based on new width (for responsive design)
        const containerWidth = container.clientWidth || 800;

        // Use max viewbox dimensions for consistent aspect ratio
        const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
        const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
          CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
          CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
          CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
          CONFIG.gaps.bottomMargin;
        const maxViewboxHeight = maxSingleSystemHeight * 1.15;
        const maxViewboxWidth = maxEnsembleWidth + 200;

        const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
        const baseHeight = containerWidth * maxAspectRatio;
        const legendHeight = embedConfig.initialFilter ? 150 : 200;

        // Update height based on current width (responsive)
        container.style.height = `${baseHeight + legendHeight}px`;
      };

      // Use ResizeObserver for better performance (only for window resize, not content changes)
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => handleResize());
        ro.observe(findWrapper());
      } else {
        window.addEventListener('resize', handleResize);
      }
    } else {
      console.warn('AWS topology: wrapper not found, skipping initialization');
    }
  })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">CPU-to-GPU communication path.</figcaption></figure>
<p>From the topology diagram and the PCIe bandwidth table, we can see that the CPU-to-GPU path goes through two PCIe hops: first from the CPU to the PCIe switch via PCIe Gen4 x8 (15.754 GB/s), then from the PCIe switch to the GPU via PCIe Gen5 x16 (63.015 GB/s).  <em>This means the bottleneck for CPU-GPU communication is the first hop at 15.754 GB/s</em> . Let’s validate this with another util,  <code>nvbandwidth</code> !</p>
<p>The  <code>host_to_device_memcpy_ce</code>  command measures bandwidth of  <code>cuMemcpyAsync</code>  from host (CPU) memory to device (GPU) memory using the GPU’s copy engines.</p>
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="markdown"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">./nvbandwidth -t host_to_device_memcpy_ce -b &lt;message_size&gt; -i 5</span></span>
<span class="line"></span></code></pre></div>
<figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">CPU-&gt;

GPU measured bandwidth</figcaption><div class="html-embed__card"><div id="frag-inc124cp4vd" data-config="{&#34;dataUrl&#34;:&#34;./data/host_device_memcpy_bandwidth.csv&#34;,&#34;xColumn&#34;:&#34;message_size&#34;,&#34;yColumn&#34;:&#34;bandwidth&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;xScaleType&#34;:&#34;log&#34;,&#34;xAxisLabel&#34;:&#34;Message Size (bytes)&#34;,&#34;yAxisLabel&#34;:&#34;Bandwidth (GB/s)&#34;,&#34;referenceLine&#34;:{&#34;value&#34;:14.2,&#34;label&#34;:&#34;Max&#34;},&#34;xFormatAsFileSize&#34;:true}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">CPU-to-GPU bandwidth measured with nvbandwidth's host_to_device test, showing the PCIe Gen4 x8 bottleneck at ~14.2 GB/s for large transfers</figcaption></figure>
<p>The results indeed show that for small message sizes we’re latency-bound, but for large message sizes we achieve  <strong>~14.2 GB/s</strong> , which is about 90% of the theoretical 15.754 GB/s bandwidth for PCIe Gen4 x8. This confirms that in  <strong>CPU-GPU</strong>  communication, the CPU-to-PCIe switch link is indeed our bottleneck.</p>
<p>Beyond bandwidth,  <strong>latency</strong>  is equally important for CPU-GPU communication since it determines how quickly we can schedule kernels. To measure this, we use  <code>nvbandwidth</code> ‘s  <code>host_device_latency_sm</code>  test, which employs a pointer-chase kernel to measure round-trip latency. The  <code>host_device_latency_sm</code>  test measures round-trip latency by allocating a buffer on the host (CPU) and accessing it from the GPU using a pointer-chase kernel. This simulates the real-world latency of CPU-GPU communication.</p>
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="markdown"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">./nvbandwidth -t host_device_latency_sm -i 5</span></span>
<span class="line"></span></code></pre></div>
<figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">CPU-&gt;

GPU measured latency</figcaption><div class="html-embed__card"><div id="frag-sxfnsmobz5k" data-config="{&#34;dataUrl&#34;:&#34;./data/host_device_latency.csv&#34;,&#34;xColumn&#34;:&#34;message_size&#34;,&#34;yColumn&#34;:&#34;latency&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;xScaleType&#34;:&#34;log&#34;,&#34;xAxisLabel&#34;:&#34;Message Size (bytes)&#34;,&#34;yAxisLabel&#34;:&#34;Latency (μs)&#34;,&#34;referenceLine&#34;:{&#34;value&#34;:1440,&#34;label&#34;:&#34;Max&#34;},&#34;xFormatAsFileSize&#34;:true}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">CPU-to-GPU latency measured with nvbandwidth's host_device_latency_sm test (adapted to make buffer size variable), showing approximately 1.4 microseconds round-trip latency</figcaption></figure>
<p>The results show that latency is approximately  <strong>1.4 microseconds</strong> . This explains the kernel launch overhead of a few microseconds we often observe in ML workloads. For workloads launching many small kernels, the added latency can become a bottleneck; otherwise, overhead is hidden by overlapping execution.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>For example for small models or with small batches we can see inference saturate on the GPU because of the kernel launches. FlashFormer addresses this by fusing a whole layer to gain speedups [@nrusimha2025flashformerwholemodelkernelsefficient].</p> </aside> </div>  
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>🚀</span> <div class="note__title" data-astro-cid-qg6lmfty>CUDA Graphs for Reducing Launch Overhead</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>CUDA Graphs can significantly reduce kernel launch overhead by capturing a sequence of operations and replaying them as a single unit, eliminating microseconds of CPU-GPU round-trip latency for each kernel launch. This is particularly beneficial for workloads with many small kernels or frequent CPU-GPU synchronization. For more details on understanding and optimizing launch overhead, see <a href="https://developer.nvidia.com/blog/understanding-the-visualization-of-overhead-and-latency-in-nsight-systems/">Understanding the Visualization of Overhead and Latency in NVIDIA Nsight Systems</a>.</p> </div> </div> </div> 
<div class="note note--warning" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>⚠️</span> <div class="note__title" data-astro-cid-qg6lmfty>MoE Models and CPU-GPU Synchronization Overhead</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Some implementations of Mixture-of-Experts (MoE) models require CPU-GPU synchronization in each iteration to schedule the appropriate kernels for the selected experts. This introduces kernel launch overhead that can significantly affect throughput, especially when the CPU-GPU connection is slow. For example, in <a href="https://www.mako.ai/blog/mako-generate-achieves-1-83x-performance-over-torch-compile-on-deepseek-moe-kernels">MakoGenerate’s optimization of DeepSeek MOE kernels</a>, the reference implementation dispatched 1,043 kernels with 67 CPU-GPU synchronization points per forward pass. By restructuring the expert routing mechanism, they reduced this to 533 kernel launches and just 3 synchronization points, achieving a 97% reduction in synchronization overhead and 44% reduction in end-to-end latency. Note that not all MoE implementations require CPU-GPU synchronization (modern implementations often keep routing entirely on the GPU), but for those that do, efficient CPU-GPU communication becomes critical for performance.</p> </div> </div> </div> 
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>🔗</span> <div class="note__title" data-astro-cid-qg6lmfty>Grace Hopper Superchips: A Different Approach to CPU-GPU Communication</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>NVIDIA’s Grace Hopper superchips take a fundamentally different approach to CPU-GPU communication compared to traditional x86+Hopper systems. Key improvements include:</p><ul><li><b>1:1 GPU to CPU ratio</b> (compared to 4:1 for x86+Hopper), providing 3.5x higher CPU memory bandwidth per GPU</li><li><b>NVLink-C2C</b> replacing PCIe Gen5 lanes, delivering 900 GB/s vs 128 GB/s (7x higher GPU-CPU link bandwidth)</li><li><b>NVLink Switch System</b> providing 9x higher GPU-GPU link bandwidth than InfiniBand NDR400 NICs connected via PCIe Gen4</li></ul><p>For more details, see the <a href="https://download.deltacomputer.com/NVIDIA%20Grace%20Hopper%20Superchip%20Architecture%20Whitepaper.pdf">NVIDIA Grace Hopper Superchip Architecture Whitepaper</a> (page 11).</p> </div> </div> </div> 
<p><strong>⚠️ NUMA Affinity: Critical for Multi-Socket Performance</strong></p>
<p>On multi-socket systems like our AMD EPYC 7R13 nodes (2 sockets, 48 cores each),  <strong>NUMA affinity</strong>is crucial for GPU performance** . It refers to running processes on CPU cores that share the same socket as their target devices (like GPUs). When your GPU process runs on CPUs from a different NUMA node than where the GPU is attached, operations must traverse the CPU interconnect (AMD Infinity Fabric), adding significant latency and bandwidth constraints.</p>
<p><strong>First, let’s examine the NUMA topology and node distances to understand the performance implications</strong> :</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="bash"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> numactl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF"> --hardware</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF"> distances:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">node</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">   1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  0:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  10</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0">  1:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  32</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF">  10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8"> </span></span>
<span class="line"></span></code></pre></div>
<p>The distance values show that accessing memory on the same NUMA node (distance 10) is much faster than crossing to the other NUMA node (distance 32). This 3.2x difference in memory access latency can significantly impact GPU performance when your process is pinned to the wrong NUMA node.</p>
<p>For detailed steps on diagnosing and resolving NUMA-related performance issues, see the Troubleshooting Interconnect Performance section.</p>
<h4 id="gpu-to-gpu-intranode"><a href="#gpu-to-gpu-intranode">GPU-to-GPU Intranode</a></h4>
<p>In distributed training, GPUs must frequently exchange gradients, weights, and activations, often gigabytes of data per iteration. This huge amount of data requires careful handling of communication. While the H100’s internal HBM can read at about 3 TB/s, did you know that accidentally using the wrong flags will completely flunk your gpu-to-gpu communication bandwidth?</p>
<p>Let’s see why by examining all the ways you can do communication between GPUs within the same node (and all the flags you should - or should not - set) 🙂</p>
<div class="note note--neutral" data-astro-cid-qg6lmfty> <!-- When there's no title, emoji is above content -->
    <div class="note__layout" data-astro-cid-qg6lmfty>  <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__content" data-astro-cid-qg6lmfty> <p><b>TL;DR:</b> GPUs within a node can communicate three ways: through CPU (slowest, ~3 GB/s, bottlenecked by PCIe), via GPUDirect RDMA over EFA NICs (~38 GB/s), or GPUDirect RDMA via NVLink (~786 GB/s bidirectional). NVLink is 9-112x faster and bypasses CPU/PCIe entirely. NCCL automatically prioritizes NVLink when available. NVLink SHARP (NVLS) provides hardware-accelerated collectives, boosting allreduce performance by 1.3x to 480 GB/s. However, alltoall operations (340 GB/s) don’t benefit from NVLS acceleration.</p> </div> </div> </div> </div> 
<h4 id="through-cpu"><a href="#through-cpu"><strong>Through CPU</strong></a></h4>
<p>The naive approach uses host memory (SHM): data travels from GPU1 through the PCIe switch to the CPU, into host memory, back through the CPU, through the PCIe switch again, and finally to GPU2. This can be achieved (although not recommended) using  <code>NCCL_P2P_DISABLE=1</code>  and  <code>FI_PROVIDER=tcp</code>  environment variable by NCCL. When this mode is activated, you can verify it by setting  <code>NCCL_DEBUG=INFO</code> , which will show messages like:</p>
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>NCCL INFO Channel 00 : 1[1] -&gt; 0[0] via SHM/direct/direct</span></span>
<span class="line"><span></span></span></code></pre></div>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-k3ax898reo" data-config="{&#34;initialFilter&#34;:&#34;gpu-gpu-cpu&#34;}"><!--
  AWS Bandwidth Bottleneck Visualization
  
  Usage:
  
  Basic:
    <HtmlEmbed src="/embeds/aws-bandwidth-bottleneck.html" />
  
  With initial filter:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ initialFilter: 'cpu-gpu' }} 
    />
  
  With real bandwidths display:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ showRealBandwidths: true }} 
    />
  
  Available filters:
    - cpu-gpu (Intranode: CPU ⟷ GPU)
    - gpu-gpu-cpu (Intranode: GPU ⟷ GPU via CPU)
    - gpu-gpu-nvswitch (Intranode: GPU ⟷ GPU via NVSwitch)
    - gpu-gpu-efa-intranode (Intranode: GPU ⟷ GPU via EFA)
    - gpu-gpu-efa-internode (Internode: GPU ⟷ GPU via EFA)
    - gpu-storage (Storage: GPU ⟷ Storage)
    - cpu-storage (Storage: CPU ⟷ Storage)
    - gpu-cpu-storage (Storage: GPU ⟷ Storage via CPU)
-->
<div class="aws-topology-wrapper">
  <div class="aws-topology-container"></div>
  <div class="aws-topology-controls"></div>
  <div class="aws-topology-legend"></div>
  <div class="aws-topology-tooltip"></div>
  <div class="aws-topology-bottleneck">
    <div class="bottleneck-label">Bandwidth Max</div>
    <div class="bottleneck-path">for CPU → GPU</div>
    <div class="bottleneck-value">-</div>
    <div class="bottleneck-unit">GB/s</div>
    <div class="bottleneck-efficiency" style="display: none;">
      <div class="efficiency-value">-</div>
      <div class="efficiency-label">Efficiency</div>
    </div>
    <div class="real-bandwidths" style="display: none;">
      <div class="real-bandwidths-title">Real Bandwidths</div>
      <div class="real-bandwidths-content"></div>
    </div>
  </div>
</div>

<style>
  .aws-topology-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .aws-topology-container {
    width: 100%;
    height: auto;
    min-height: 400px;
    position: relative;
    transition: opacity 0.15s ease;
  }

  .aws-topology-container.fixed-height {
    height: 850px;
  }

  .aws-topology-container svg {
    width: 100%;
    height: 100%;
  }

  .aws-topology-container svg g {
    transition: opacity 0.2s ease;
  }

  /* Add drop shadow to all links */
  .aws-topology-container svg g[data-link-type] line,
  .aws-topology-container svg g[data-link-type] path {
    filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
  }

  .aws-topology-controls {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 800px;
  }

  .aws-topology-controls-section {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .aws-topology-controls-row {
    display: flex;
    flex-direction: row;
    gap: 16px;
    align-items: flex-start;
  }

  .aws-topology-controls-label {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0.7;
  }

  .aws-topology-controls-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }

  .aws-topology-controls-buttons .button {
    flex-shrink: 0;
  }

  /* Hide controls on mobile */
  @media (max-width: 768px) {
    .aws-topology-controls {
      display: none;
    }
  }

  .aws-topology-legend {
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 264px;
    /* 220 * 1.2 */
    height: 120px;
    /* 100 * 1.2 */
  }

  .aws-topology-tooltip {
    position: absolute;
    padding: 8px 12px;
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 12px;
    color: var(--text-color);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .aws-topology-tooltip.visible {
    opacity: 1;
  }

  .tooltip-label {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-color);
  }

  .tooltip-bandwidth {
    font-size: 11px;
    color: var(--text-secondary);
  }

  .aws-topology-bottleneck {
    position: absolute;
    top: 10px;
    right: 10px;
    text-align: right;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .aws-topology-bottleneck.visible {
    opacity: 1;
  }

  .bottleneck-label {
    font-size: 11px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-value {
    font-size: 24px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    margin-bottom: 2px;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .bottleneck-unit {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-path {
    font-size: 10px;
    color: var(--text-secondary);
    font-style: italic;
    margin-bottom: 6px;
    opacity: 0.8;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-efficiency {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    margin-top: 12px;
    margin-bottom: 4px;
  }

  .efficiency-label {
    font-size: 9px;
    color: var(--text-secondary);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 2px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .efficiency-value {
    font-size: 20px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .real-bandwidths {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
    opacity: 0.9;
  }

  .real-bandwidths-title {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content {
    font-size: 11px;
    color: var(--text-color);
    line-height: 1.4;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content .bandwidth-item {
    margin-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .real-bandwidths-content .bandwidth-label {
    font-size: 10px;
    color: var(--text-secondary);
    opacity: 0.8;
  }

  .real-bandwidths-content .bandwidth-value {
    font-size: 11px;
    font-weight: 600;
    color: var(--primary-color);
  }

  /* Checkbox styling for the bandwidth toggle */
  #real-bandwidth-toggle {
    appearance: none;
    width: 16px;
    height: 16px;
    border: 2px solid var(--border-color);
    border-radius: 3px;
    background-color: var(--page-bg);
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    margin-right: 8px;
  }

  #real-bandwidth-toggle:hover {
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(from var(--primary-color) r g b / 0.1);
  }

  #real-bandwidth-toggle:checked {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:checked::before {
    content: '';
    position: absolute;
    top: 1px;
    left: 4px;
    width: 4px;
    height: 8px;
    border: solid var(--on-primary);
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }

  #real-bandwidth-toggle:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.5/svg.min.js"></script>
<script>
  (function () {
    // Generate unique ID for this instance
    const instanceId = 'aws-topology-' + Math.random().toString(36).substr(2, 9);

    // Store reference to current script to find wrapper later
    const scriptEl = document.currentScript;

    // Function to find wrapper (will be called after DOM is ready)
    let wrapperEl = null;
    const findWrapper = () => {
      if (!wrapperEl) {
        wrapperEl = scriptEl.previousElementSibling;
        if (!wrapperEl || !wrapperEl.classList.contains('aws-topology-wrapper')) {
          // Fallback: search for unmounted wrappers
          const allWrappers = document.querySelectorAll('.aws-topology-wrapper');
          for (const wrapper of allWrappers) {
            if (!wrapper.dataset.mounted) {
              wrapperEl = wrapper;
              break;
            }
          }
        }
        if (wrapperEl && !wrapperEl.dataset.mounted) {
          wrapperEl.dataset.mounted = 'true';
        }
      }
      return wrapperEl;
    };

    // Get all child elements for this instance
    const getElement = (className) => {
      const wrapper = findWrapper();
      return wrapper ? wrapper.querySelector('.' + className) : null;
    };

    // ============================================================================
    // CONFIGURATION - All settings in one place
    // ============================================================================
    const CONFIG = {
      // Canvas settings
      viewbox: {
        width: 2400,  // Width for 2 ensembles side by side
        get height() {
          // Calculate height based on vertical elements × systemCount
          const singleSystemHeight = this.parent.gaps.topMargin +
            this.parent.sizes.cpu +
            this.parent.gaps.cpuToPcie +
            this.parent.sizes.pcie.height +
            this.parent.gaps.pcieToGpu +
            this.parent.sizes.gpu.height +
            this.parent.gaps.gpuToNvswitch +
            this.parent.sizes.nvswitch.height +
            this.parent.gaps.bottomMargin;

          return singleSystemHeight * this.parent.systemCount +
            this.parent.gaps.systemGap * (this.parent.systemCount - 1);
        },
        parent: null  // Will be set to CONFIG
      },

      // System replication
      systemCount: 2,      // Number of complete systems (each has 2 ensembles)
      ensembleCount: 2,    // Number of ensembles per system (each ensemble = CPU + 4 groups + 2 NVSwitches)
      groupCount: 4,       // Groups per ensemble
      nvswitchCount: 2,    // NVSwitches per ensemble

      // Node sizes (all based on CPU size)
      sizes: {
        cpu: 80,
        get pcie() { return { width: this.cpu * 0.75, height: this.cpu * 0.625 * 3 }; },
        get gpu() { return { width: this.cpu, height: this.cpu }; },
        get efa() { return { width: 60, height: 30 }; },
        get nvme() { return { width: 60, height: 30 }; },
        get nvswitch() { return { width: 100, height: 60 }; }
      },

      // Gaps and spacing
      gaps: {
        topMargin: 0,        // Margin from top to CPU
        cpuToPcie: 80,        // Vertical gap CPU → PCIe
        pcieToGpu: 80,        // Vertical gap PCIe → GPU
        gpuToNvswitch: 200,    // Vertical gap GPU → NVSwitch
        bottomMargin: 40,     // Margin from NVSwitch to bottom
        horizontal: 230,      // Horizontal gap between groups
        ensembleGap: 50,     // Horizontal gap between ensembles (within a system)
        systemGap: 30,       // Horizontal gap between complete systems
        connectionOffset: 15  // Gap between node edge and arrow anchor
      },

      // Group layout offsets (all relative positions within a group)
      layout: {
        pcieOffsetX: -40,      // PCIe X offset from group center (to the left)
        efaNvmeOffsetX: 60,    // EFA/NVMe X offset from group center (to the right)
        efaOffsetY: -30,       // EFA Y offset from PCIe Y (above)
        nvmeOffsetY: 30,       // NVMe Y offset from PCIe Y (below)
        groupPadding: 20       // Padding around group bounding box
      },

      // Debug mode
      debug: {
        showPhantoms: false    // Set to true to visualize phantom nodes
      },

      // Highlight paths (for interactive buttons)
      paths: {
        'cpu-gpu': {
          label: 'CPU ⟷ GPU',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'gpu'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' }
          ]
        },
        'gpu-gpu-cpu': {
          label: 'GPU ⟷ GPU via CPU',
          requiredEnsembles: 1,  // Need only 1 ensemble (2 groups within)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'cpu', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'pcie', to: 'cpu' },
            { from: 'cpu', to: 'pcie' },
            { from: 'cpu', to: 'pcie-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-nvswitch': {
          label: 'GPU ⟷ GPU via NVSwitch',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'nvswitch-0', 'gpu-1'],
          links: [
            { from: 'gpu', to: 'nvswitch-0' },
            { from: 'gpu-1', to: 'nvswitch-0' }
          ]
        },
        'gpu-gpu-efa': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-1', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-1', to: 'efa-external-1' },
            { from: 'efa-1', to: 'pcie-efa-phantom-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-efa-intranode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles (same system)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-4', 'pcie-4', 'gpu-4'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-4' },  // EFA cross-link between ensembles (12.5GB/s)
            { from: 'efa-4', to: 'efa-external-4' },
            { from: 'efa-4', to: 'pcie-efa-phantom-4' },
            { from: 'pcie-4', to: 'gpu-4' }
          ]
        },
        'gpu-gpu-efa-internode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles per system
          requiredSystems: 2,    // Need 2 systems
          nodes: ['gpu', 'pcie', 'efa', 'efa-8', 'pcie-8', 'gpu-8'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-8' },  // EFA cross-link between systems
            { from: 'efa-8', to: 'efa-external-8' },
            { from: 'efa-8', to: 'pcie-efa-phantom-8' },
            { from: 'pcie-8', to: 'gpu-8' }
          ]
        },
        'gpu-storage': {
          label: 'GPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'nvme'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'cpu-storage': {
          label: 'CPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'gpu-cpu-storage': {
          label: 'GPU ⟷ Storage via CPU',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'gpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        }
      },


      // Bandwidth levels
      bandwidths: [
        { speed: '900GB/s', label: 'NVLink 4.0', width: 9 },
        { speed: '64GB/s', label: 'PCIe Gen5', width: 6 },
        { speed: '16GB/s', label: 'PCIe Gen4', width: 3 },
        { speed: '12.5GB/s', label: 'EFA Link', width: 1.25 }
      ],

      // Link definitions for groups
      groupLinks: [
        { from: 'cpu', to: 'pcie', bandwidth: '16GB/s', type: 'cpu', fromSide: 'bottom', toSide: 'top', multiLink: true },
        { from: 'efa', to: 'pcie-efa-phantom', bandwidth: '16GB/s', type: 'network', fromSide: 'left', toSide: 'right', stacked: 4 },
        { from: 'nvme', to: 'pcie-nvme-phantom', bandwidth: '16GB/s', type: 'storage', fromSide: 'left', toSide: 'right' },
        { from: 'pcie', to: 'gpu', bandwidth: '64GB/s', type: 'gpu', fromSide: 'bottom', toSide: 'top' },
        { from: 'efa', to: 'efa-external', bandwidth: '12.5GB/s', type: 'network', fromSide: 'right', toSide: 'left', stacked: 4 }
      ],

      // GPU to NVSwitch links (full mesh)
      gpuNvswitchLink: {
        bandwidth: '900GB/s',
        type: 'gpu',
        fromSide: 'bottom',
        toSide: 'top'
      },

      // Colors (using CSS variables for dark mode compatibility)
      colors: {
        // Node colors
        nodeFill: 'var(--page-bg)',
        nodeStroke: 'var(--muted-color)',     // More contrast than border-color
        nodeText: 'var(--text-color)',
        nodePins: 'var(--muted-color)',
        nodeCoreFill: 'rgba(0, 0, 0, 0.05)',  // Very light gray for cores
        nodeCoreStroke: 'rgba(0, 0, 0, 0.2)', // More visible border for cores

        // Link colors
        linkColor: 'var(--primary-color)',
        linkCircleBorder: 'rgba(0, 0, 0, 0.1)', // Border for link circles

        // Group border
        groupBorder: 'var(--border-color)',

        // Phantom debug
        phantomFill: 'rgba(255, 0, 255, 0.2)',
        phantomStroke: 'magenta'
      },

      // Real bandwidth data for display
      realBandwidths: {
        'cpu-gpu': '14.2GB/s',
        'gpu-gpu-same-node': '786GB/s',
        'gpu-gpu-efa-intranode': '40GB/s',
        'gpu-gpu-efa-internode': '40GB/s',
        'allreduce-same-node': '480GB/s',
        'all2all-same-node': '340GB/s',
        'allreduce-internode': '320GB/s',
        'alltoall-internode': '45GB/s',
        'gpu-storage': '14.2GB/s'
      }
    };

    // Initialize viewbox parent reference
    CONFIG.viewbox.parent = CONFIG;

    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================
    function getBandwidth(speed) {
      const bw = CONFIG.bandwidths.find(b => b.speed === speed);
      if (bw) {
        // Add numericValue for comparison
        bw.numericValue = parseFloat(bw.speed.replace('GB/s', ''));
      }
      return bw;
    }

    // Calculate connection offset proportional to link width
    function getLinkOffset(linkWidth) {
      const minOffset = 5;   // Minimum offset for thin links
      const maxOffset = 20;  // Maximum offset for thick links

      // Proportional offset: thinner links = smaller offset
      const proportionalOffset = minOffset + (linkWidth / 10) * (maxOffset - minOffset);
      return Math.min(Math.max(proportionalOffset, minOffset), maxOffset);
    }

    // ============================================================================
    // EFA CROSS-LINKS HELPER
    // ============================================================================
    function drawEfaCrossLinks(renderer, fromId, toId, linkType = 'efa-crosslink') {
      const phantom0 = renderer.nodes.get(fromId);
      const phantom1 = renderer.nodes.get(toId);

      if (!phantom0 || !phantom1) return;

      const efaBw = getBandwidth('12.5GB/s');
      const efaColor = CONFIG.colors.linkColor;

      // Draw 4 stacked links manually (EFA has 4 connections) - randomized order
      const stackCount = 4;
      const spacing = 6; // Fixed spacing between stacked links
      const verticalShift = -95; // Shift up to align with EFA nodes
      const horizontalShift = -40; // Shift left to better position the arrows
      const horizontalExtension = 20; // Extend arrows horizontally on each side

      // Create array of indices and randomize
      const linkIndices = Array.from({ length: stackCount }, (_, i) => i);
      const shuffledIndices = linkIndices.sort(() => Math.random() - 0.5);

      // Draw horizontal lines with vertical offset for stacking
      shuffledIndices.forEach(i => {
        const offsetY = (i - (stackCount - 1) / 2) * spacing;

        const efaCrossGroup = renderer.crossLinksGroup.group();
        efaCrossGroup.attr('data-link-type', linkType);
        efaCrossGroup.attr('data-from', fromId);
        efaCrossGroup.attr('data-to', toId);
        efaCrossGroup.attr('data-bandwidth', '12.5GB/s');
        efaCrossGroup.attr('data-label', 'EFA Link');

        // Draw line with vertical offset for stacking + shifts + horizontal extension
        const x0 = phantom0.x + horizontalShift;
        const x1 = phantom1.x + horizontalShift + horizontalExtension;
        const y0 = phantom0.y + offsetY + verticalShift;
        const y1 = phantom1.y + offsetY + verticalShift;

        // Draw border
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: efaColor, width: efaBw.width, opacity: 1 });

        // Draw circles at both ends
        const r = efaBw.width * 0.8;
        const startCircle = efaCrossGroup.circle(r * 2).move(x0 - r, y0 - r);
        startCircle.fill(efaColor);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = efaCrossGroup.circle(r * 2).move(x1 - r, y1 - r);
        endCircle.fill(efaColor);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');
      });

      // Add vertical bars at both ends (connect horizontal arrows to EFA phantoms)
      const barColor = CONFIG.colors.linkColor;

      shuffledIndices.forEach(i => {
        const offsetX = (i - (stackCount - 1) / 2) * spacing + 12; // Horizontal offset for vertical bars
        const yHorizontal = phantom0.y + verticalShift + 10;
        const yPhantom = phantom0.y + 8; // End a bit higher (5px above phantom center)

        // Left vertical bar (one per horizontal arrow)
        const leftBarGroup = renderer.crossLinksGroup.group();
        leftBarGroup.attr('data-link-type', linkType);
        leftBarGroup.attr('data-from', fromId);
        leftBarGroup.attr('data-to', toId);
        leftBarGroup.attr('data-bandwidth', '12.5GB/s');
        leftBarGroup.attr('data-label', 'EFA Link');

        const x0 = phantom0.x + horizontalShift + offsetX;

        // Draw border
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const r = efaBw.width * 0.8;
        const bottomCircle0 = leftBarGroup.circle(r * 2).move(x0 - r, yPhantom - r);
        bottomCircle0.fill(barColor);
        bottomCircle0.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle0.attr('data-link-circle', 'true');

        // Right vertical bar (one per horizontal arrow)
        const rightBarGroup = renderer.crossLinksGroup.group();
        rightBarGroup.attr('data-link-type', linkType);
        rightBarGroup.attr('data-from', fromId);
        rightBarGroup.attr('data-to', toId);
        rightBarGroup.attr('data-bandwidth', '12.5GB/s');
        rightBarGroup.attr('data-label', 'EFA Link');

        const x1 = phantom1.x + horizontalShift + offsetX;

        // Draw border
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const bottomCircle1 = rightBarGroup.circle(r * 2).move(x1 - r, yPhantom - r);
        bottomCircle1.fill(barColor);
        bottomCircle1.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle1.attr('data-link-circle', 'true');
      });
    }

    // ============================================================================
    // SVG HELPERS
    // ============================================================================
    class TopologyRenderer {
      constructor(draw) {
        this.draw = draw;
        this.nodes = new Map();
        this.structuralGroup = draw.group();  // Structural elements (Node/NUMA borders, never ghosted)
        this.structuralGroup.attr('data-group', 'structural');
        this.baseLinksGroup = draw.group();   // Base links layer (will be ghosted)
        this.baseLinksGroup.attr('data-group', 'base-links');
        this.linksGroup = this.baseLinksGroup; // Alias for compatibility
        this.nodesGroup = draw.group();   // Nodes layer (middle)
        this.phantomsGroup = draw.group(); // Phantoms layer (for debug)
        this.baseCrossLinksGroup = draw.group(); // Base EFA cross-links layer
        this.baseCrossLinksGroup.attr('data-group', 'base-cross-links');
        this.crossLinksGroup = this.baseCrossLinksGroup; // Alias for compatibility
        this.activeLinksGroup = draw.group(); // Active (duplicated) links layer (top, non-ghosted)
        this.activeLinksGroup.attr('data-group', 'active-links');
      }

      // Draw a simple rectangular node
      // Helper: Draw text with consistent styling
      drawText(x, y, label, group = this.nodesGroup) {
        if (!label) return;

        const lines = label.split('\n');
        lines.forEach((line, i) => {
          group.text(line)
            .font({ family: 'Inter, sans-serif', size: 12, weight: '600', anchor: 'middle' })
            .fill(CONFIG.colors.nodeText)
            .cx(x)
            .cy(y + (i - (lines.length - 1) / 2) * 14);
        });
      }

      // Helper: Draw pins around a node
      drawPins(x, y, width, height, pinConfig = {}, targetGroup = null) {
        const group = targetGroup || this.nodesGroup;

        const defaultConfig = {
          pinsPerSide: width >= 80 ? 18 : 15,
          pinLength: 3,
          pinOffset: width / 2 + 1.5,
          pinPadding: 12
        };

        const config = { ...defaultConfig, ...pinConfig };
        const pinStartOffset = -width / 2 + config.pinPadding;
        const pinEndOffset = width / 2 - config.pinPadding;
        const pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);

        const sides = [
          { side: 'left', xOffset: -config.pinOffset, yOffset: 0 },
          { side: 'right', xOffset: config.pinOffset, yOffset: 0 },
          { side: 'top', xOffset: 0, yOffset: -config.pinOffset },
          { side: 'bottom', xOffset: 0, yOffset: config.pinOffset }
        ];

        sides.forEach(({ side, xOffset, yOffset }) => {
          for (let i = 0; i < config.pinsPerSide; i++) {
            const pinX = x + xOffset + (side === 'left' || side === 'right' ? 0 : pinStartOffset + (i * pinSpacing));
            const pinY = y + yOffset + (side === 'top' || side === 'bottom' ? 0 : pinStartOffset + (i * pinSpacing));

            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      drawNode(id, x, y, width, height, label, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      drawNodeWithPins(id, x, y, width, height, label, pinConfig = {}, nodeType = '') {
        const node = this.drawNode(id, x, y, width, height, label, nodeType);
        this.drawPins(x, y, width, height, pinConfig);
        return node;
      }

      drawNodeWithCores(id, x, y, width, height, label, coreConfig = {}, nodeType = '') {
        // Draw main node
        const node = this.drawNode(id, x, y, width, height, label, nodeType);

        // Default core configuration
        const defaultCoreConfig = {
          coresX: 2,              // 2x2 for CPU, 8x8 for GPU
          coresY: 2,
          coreSpacing: 2,         // Space between cores
          coreMargin: 8           // Margin from node edges
        };

        const config = { ...defaultCoreConfig, ...coreConfig };

        // Calculate core size
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coreSpacing * (config.coresX - 1))) / config.coresX;
        const coreHeight = (availableHeight - (config.coreSpacing * (config.coresY - 1))) / config.coresY;

        // Draw cores
        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            this.nodesGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        return node;
      }

      drawProcessorNode(id, x, y, width, height, label, type = 'cpu') {
        // Create main group for the node
        const nodeGroup = this.nodesGroup.group();
        nodeGroup.attr('id', id);
        nodeGroup.attr('data-node-type', type);

        // Draw node background
        nodeGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Draw cores
        const coreConfig = type === 'gpu' ? { coresX: 8, coresY: 8 } : { coresX: 2, coresY: 2 };
        const config = { coreSpacing: 2, coreMargin: 8, ...coreConfig };
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coresX - 1) * config.coreSpacing) / config.coresX;
        const coreHeight = (availableHeight - (config.coresY - 1) * config.coreSpacing) / config.coresY;

        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            nodeGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        // Draw pins in the same group
        this.drawPins(x, y, width, height, {}, nodeGroup);

        // Draw text on top
        this.drawText(x, y, label, nodeGroup);

        // Store node position
        this.nodes.set(id, { x, y, width, height });

        return nodeGroup;
      }

      // Add pins to an existing node (without changing the node design)
      addPinsToNode(nodeId, pinConfig = {}) {
        const node = this.nodes.get(nodeId);
        if (!node) return;

        // Find the node's SVG group
        const svg = getElement('aws-topology-container').querySelector('svg');
        if (!svg) return;
        const nodeGroup = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeGroup) return;

        // Use SVG.js to manipulate the group
        const group = this.draw.findOne(`#${nodeId}`);
        if (!group) return;

        // Default pin configuration
        const defaultPinConfig = {
          pinsPerSide: node.width >= 80 ? 18 : 15,
          sides: ['left', 'right', 'top', 'bottom'],
          pinLength: 3,
          pinPadding: 12
        };

        const config = { ...defaultPinConfig, ...pinConfig };

        // Generate pins on specified sides only
        config.sides.forEach(side => {
          let pinSpacing, pinStartOffset, pinEndOffset;

          if (side === 'left' || side === 'right') {
            pinStartOffset = -node.height / 2 + config.pinPadding;
            pinEndOffset = node.height / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          } else {
            pinStartOffset = -node.width / 2 + config.pinPadding;
            pinEndOffset = node.width / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          }

          for (let i = 0; i < config.pinsPerSide; i++) {
            let pinX, pinY;

            if (side === 'left') {
              pinX = node.x - node.width / 2 - 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'right') {
              pinX = node.x + node.width / 2 + 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'top') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y - node.height / 2 - 1.5;
            } else if (side === 'bottom') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y + node.height / 2 + 1.5;
            }

            // Draw pin in the node's group
            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      // Draw a stacked node (visual stack effect)
      drawStackedNode(id, x, y, width, height, label, stackCount, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        for (let i = stackCount - 1; i >= 0; i--) {
          const offsetY = i * 3;
          group.rect(width, height)
            .move(x - width / 2, y - height / 2 + offsetY)
            .fill(CONFIG.colors.nodeFill)
            .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
            .radius(4)
            .opacity(1);
        }

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw a storage node (NVMe) with internal rectangle
      drawStorageNode(id, x, y, width, height, label, nodeType = 'storage') {
        const group = this.nodesGroup.group();
        group.attr('id', id);
        if (nodeType) group.attr('data-node-type', nodeType);

        // Main node background
        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Internal rectangle on the left side (flush with edge)
        const internalRectWidth = 5;
        const internalRectHeight = height * .6; // Full height
        const internalRectX = x - width / 2; // Flush with left edge
        const internalRectY = y - height / 2 + height * .20;

        group.rect(internalRectWidth, internalRectHeight)
          .move(internalRectX, internalRectY)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: '#ffffff', width: 1 })
          .opacity(.4)
          .radius(0); // No radius

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw background rectangle
      drawBackground(id, x, y, width, height) {
        const bg = this.linksGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 2,
            dasharray: '5,5'
          })
          .radius(8);

        this.nodes.set(id, { x, y, width, height });
        return bg;
      }

      // Get connection point on a node's side with configurable offset and multi-link spacing
      getPoint(nodeId, side, offset = CONFIG.gaps.connectionOffset, linkIndex = 0, totalLinks = 1) {
        const node = this.nodes.get(nodeId);
        if (!node) return { x: 0, y: 0 };

        const points = {
          top: { x: node.x, y: node.y - node.height / 2 - offset },
          right: { x: node.x + node.width / 2 + offset, y: node.y },
          bottom: { x: node.x, y: node.y + node.height / 2 + offset },
          left: { x: node.x - node.width / 2 - offset, y: node.y }
        };

        let basePoint = points[side] || { x: node.x, y: node.y };

        // Apply spacing for multiple links to the same anchor
        if (totalLinks > 1) {
          const isVerticalAnchor = (side === 'top' || side === 'bottom');

          // Vertical anchors (top/bottom) space horizontally, horizontal anchors (left/right) space vertically
          const spacing = isVerticalAnchor ? node.width / (totalLinks + 1) : node.height / (totalLinks + 1);
          const linkOffset = (linkIndex - (totalLinks - 1) / 2) * spacing;

          // Apply offset in the perpendicular direction to the anchor
          if (isVerticalAnchor) {
            basePoint.x += linkOffset;  // Horizontal offset for vertical anchors
          } else {
            basePoint.y += linkOffset;  // Vertical offset for horizontal anchors
          }
        }

        return basePoint;
      }

      // Draw single link with optional multi-link spacing
      drawLink(fromId, toId, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, fromLinkIndex = 0, fromTotalLinks = 1, toLinkIndex = 0, toTotalLinks = 1, linkType = '', bandwidth = '') {
        const start = this.getPoint(fromId, fromSide, offset, fromLinkIndex, fromTotalLinks);
        const end = this.getPoint(toId, toSide, offset, toLinkIndex, toTotalLinks);

        const group = this.linksGroup.group();
        if (linkType) group.attr('data-link-type', linkType);
        if (bandwidth) {
          group.attr('data-bandwidth', bandwidth);
          // Find label from bandwidth config
          const bwConfig = getBandwidth(bandwidth);
          if (bwConfig && bwConfig.label) {
            group.attr('data-label', bwConfig.label);
          }
        }
        group.attr('data-from', fromId);
        group.attr('data-to', toId);

        // Check if this is a vertical connection (GPU-NVSwitch or CPU-PCIe)
        const isVerticalConnection = fromSide === 'bottom' && toSide === 'top';

        if (isVerticalConnection) {
          // Use curved paths for vertical connections
          const curvature = 45; // Fixed curvature value for consistent curve strength

          // Create a smooth cubic bezier curve with vertical control points
          const pathData = `M ${start.x} ${start.y} C ${start.x} ${start.y + curvature}, ${end.x} ${end.y - curvature}, ${end.x} ${end.y}`;

          // Draw border (wider path behind)
          group.path(pathData)
            .fill('none')
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main path on top
          group.path(pathData)
            .fill('none')
            .stroke({ color, width, opacity: 1 });
        } else {
          // Draw straight lines for other connections
          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });
        }

        const r = width * 0.8;
        const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');

        return group;
      }

      // Draw stacked links
      drawStackedLinks(fromId, toId, count, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, linkType = '', bandwidth = '') {
        const fromNode = this.nodes.get(fromId);
        const toNode = this.nodes.get(toId);
        if (!fromNode || !toNode) return [];

        const isHorizontal = (fromSide === 'left' || fromSide === 'right') &&
          (toSide === 'left' || toSide === 'right');
        const spacing = isHorizontal
          ? Math.min(fromNode.height, toNode.height) / (count + 1)
          : Math.min(fromNode.width, toNode.width) / (count + 1);

        const arrows = [];
        for (let i = 0; i < count; i++) {
          const stackOffset = (i - (count - 1) / 2) * spacing;
          let start = this.getPoint(fromId, fromSide, offset);
          let end = this.getPoint(toId, toSide, offset);

          if (isHorizontal) {
            start.y += stackOffset;
            end.y += stackOffset;
          } else {
            start.x += stackOffset;
            end.x += stackOffset;
          }

          const group = this.linksGroup.group();
          if (linkType) group.attr('data-link-type', linkType);
          if (bandwidth) {
            group.attr('data-bandwidth', bandwidth);
            // Find label from bandwidth config
            const bwConfig = getBandwidth(bandwidth);
            if (bwConfig && bwConfig.label) {
              group.attr('data-label', bwConfig.label);
            }
          }
          group.attr('data-from', fromId);
          group.attr('data-to', toId);

          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });

          const r = width * 0.8;
          const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
          startCircle.fill(color);
          startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          startCircle.attr('data-link-circle', 'true');

          const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
          endCircle.fill(color);
          endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          endCircle.attr('data-link-circle', 'true');

          arrows.push(group);
        }
        return arrows;
      }

      // Add phantom node (invisible connection point)
      addPhantom(id, x, y, width = 30, height = 30) {
        this.nodes.set(id, { x, y, width, height });

        // Draw phantom for debug visualization
        if (CONFIG.debug.showPhantoms) {
          this.phantomsGroup.rect(width, height)
            .move(x - width / 2, y - height / 2)
            .fill('rgba(255, 0, 255, 0.2)')  // Semi-transparent magenta
            .stroke({ color: 'magenta', width: 2, dasharray: '4,4' })
            .radius(4);

          // Add label
          this.phantomsGroup.text(id)
            .move(x, y)
            .font({
              family: 'system-ui, -apple-system, sans-serif',
              size: 10,
              anchor: 'middle',
              fill: 'magenta',
              weight: 'bold'
            })
            .dy(-height / 2 - 5);
        }
      }
    }

    // ============================================================================
    // DRAW SINGLE GROUP
    // ============================================================================
    function drawGroup(renderer, globalIndex, localIndex, x, cpuY, nvswitchY, cpuId = 'cpu') {
      const s = CONFIG.sizes;
      const g = CONFIG.gaps;
      const l = CONFIG.layout;
      const suffix = globalIndex > 0 ? `-${globalIndex}` : '';

      // Calculate Y positions
      const pcieY = cpuY + s.cpu / 2 + g.cpuToPcie + s.pcie.height / 2;
      const gpuY = pcieY + s.pcie.height / 2 + g.pcieToGpu + s.gpu.height / 2;

      // Calculate node positions
      const pcieX = x + l.pcieOffsetX;
      const efaX = x + l.efaNvmeOffsetX;
      const nvmeX = x + l.efaNvmeOffsetX;
      const efaY = pcieY + l.efaOffsetY;
      const nvmeY = pcieY + l.nvmeOffsetY;

      // Calculate bounding box BEFORE creating nodes
      const nodeBounds = [
        { x: pcieX, y: pcieY, width: s.pcie.width, height: s.pcie.height },
        { x: efaX, y: efaY, width: s.efa.width, height: s.efa.height },
        { x: nvmeX, y: nvmeY, width: s.nvme.width, height: s.nvme.height },
        { x: pcieX, y: gpuY, width: s.gpu.width, height: s.gpu.height }
      ];

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      nodeBounds.forEach(node => {
        minX = Math.min(minX, node.x - node.width / 2);
        maxX = Math.max(maxX, node.x + node.width / 2);
        minY = Math.min(minY, node.y - node.height / 2);
        maxY = Math.max(maxY, node.y + node.height / 2);
      });

      const bgWidth = maxX - minX + l.groupPadding * 2;
      const bgHeight = maxY - minY + l.groupPadding * 2;
      const bgCenterX = (minX + maxX) / 2;
      const bgCenterY = (minY + maxY) / 2;

      // Draw background FIRST (will be behind nodes)
      renderer.drawBackground(`group${suffix}`, bgCenterX, bgCenterY, bgWidth, bgHeight);

      // Nodes
      renderer.drawNode(`pcie${suffix}`, pcieX, pcieY, s.pcie.width, s.pcie.height, 'PCIe\nSwitch', 'network');
      renderer.addPinsToNode(`pcie${suffix}`, {
        pinsPerSide: 6,
        sides: ['left', 'right'],
        pinLength: 3,
        pinPadding: 8
      });
      renderer.drawStackedNode(`efa${suffix}`, efaX, efaY, s.efa.width, s.efa.height, 'EFA', 4, 'network');
      renderer.drawStorageNode(`nvme${suffix}`, nvmeX, nvmeY, s.nvme.width, s.nvme.height, 'NVMe', 'storage');
      renderer.drawProcessorNode(`gpu${suffix}`, pcieX, gpuY, s.gpu.width, s.gpu.height, 'GPU', 'gpu');

      // Phantom nodes for routing
      // PCIe phantoms: bord gauche aligné avec PCIe, largeur du PCIe
      const pcieLeftEdge = pcieX;
      const pciePhantomX = pcieLeftEdge;
      renderer.addPhantom(`pcie-efa-phantom${suffix}`, pciePhantomX, efaY, s.pcie.width, s.efa.height);
      renderer.addPhantom(`pcie-nvme-phantom${suffix}`, pciePhantomX, nvmeY, s.pcie.width, s.nvme.height);

      // EFA external phantom: à droite de EFA
      const efaRightEdge = efaX + s.efa.width / 2;
      const efaPhantomX = efaRightEdge + g.connectionOffset + s.efa.width / 2 + 20;  // Centre du phantom + décalage réduit
      renderer.addPhantom(`efa-external${suffix}`, efaPhantomX, efaY, s.efa.width, s.efa.height);

      // Create links from configuration
      CONFIG.groupLinks.forEach(linkDef => {
        const bw = getBandwidth(linkDef.bandwidth);
        const fromId = linkDef.from === 'cpu' ? cpuId : `${linkDef.from}${suffix}`;  // Use cpuId from parameter
        const toId = `${linkDef.to}${suffix}`;
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const offset = getLinkOffset(bw.width);  // Proportional offset based on link width

        if (linkDef.stacked) {
          renderer.drawStackedLinks(fromId, toId, linkDef.stacked, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, linkDef.type, linkDef.bandwidth);
        } else if (linkDef.multiLink) {
          // Use localIndex for multi-link spacing (0-3 within ensemble)
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, localIndex, CONFIG.groupCount, 0, 1, linkDef.type, linkDef.bandwidth);
        } else {
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, 0, 1, 0, 1, linkDef.type, linkDef.bandwidth);
        }
      });
    }

    // ============================================================================
    // DRAW SINGLE ENSEMBLE (CPU + 4 groups + 2 NVSwitches)
    // ============================================================================
    function drawEnsemble(renderer, ensembleGlobalIndex, centerX, cpuY, nvswitchY) {
      const cpuId = ensembleGlobalIndex === 0 ? 'cpu' : `cpu-${ensembleGlobalIndex}`;

      // CPU for this ensemble
      renderer.drawProcessorNode(cpuId, centerX, cpuY, CONFIG.sizes.cpu, CONFIG.sizes.cpu, 'CPU', 'cpu');

      // Groups for this ensemble
      for (let i = 0; i < CONFIG.groupCount; i++) {
        const groupGlobalIndex = ensembleGlobalIndex * CONFIG.groupCount + i;
        const offsetX = (i - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal;
        drawGroup(renderer, groupGlobalIndex, i, centerX + offsetX, cpuY, nvswitchY, cpuId);  // Pass i as localIndex
      }

      // NVSwitches: positioned between pairs of groups
      for (let i = 0; i < CONFIG.nvswitchCount; i++) {
        const nvswitchGlobalIndex = ensembleGlobalIndex * CONFIG.nvswitchCount + i;
        const groupPairStart = i * 2;
        const groupPairEnd = groupPairStart + 1;

        const group1X = centerX + ((groupPairStart - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const group2X = centerX + ((groupPairEnd - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const nvswitchX = (group1X + group2X) / 2;

        renderer.drawNode(`nvswitch-${nvswitchGlobalIndex}`, nvswitchX, nvswitchY,
          CONFIG.sizes.nvswitch.width, CONFIG.sizes.nvswitch.height, 'NVSwitch', 'network');

        // Add pins to NVSwitch (like PCIe Switch)
        renderer.addPinsToNode(`nvswitch-${nvswitchGlobalIndex}`, {
          pinsPerSide: 6,
          sides: ['left', 'right'],
          pinLength: 3,
          pinPadding: 8
        });
      }

    }


    // ============================================================================
    // DRAW SINGLE SYSTEM (variable number of ensembles)
    // ============================================================================
    function drawSystem(renderer, systemIndex, systemCenterX, cpuY, nvswitchY, ensembleCount = 1, systemCount = 1, shouldDrawEfaCrossLinks = false) {
      // For internode (2 systems), only show 1 ensemble per system for clarity
      const ensemblesToShow = (systemCount === 2) ? 1 : ensembleCount;

      // Calculate ensemble width (4 groups)
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;

      // Calculate system bounding box based on actual ensembles shown
      const systemWidth = ensemblesToShow * ensembleWidth + (ensemblesToShow - 1) * CONFIG.gaps.ensembleGap;
      const systemHeight = CONFIG.sizes.cpu + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height;

      const systemBgCenterY = cpuY + (nvswitchY - cpuY) / 2;
      const systemPadding = 30;

      // In internode mode, extend the rectangle slightly to the right
      const isInternode = systemCount === 2;
      const extraWidth = isInternode && ensembleCount === 2 ? 210 : 0;

      // Draw system background ONLY if 2 ensembles (intra-node vs inter-node distinction)
      if (ensembleCount === 2) {
        // Adjust rectX to center the extended rectangle
        const totalWidth = systemWidth + systemPadding * 2 + extraWidth;
        const rectX = systemCenterX - totalWidth / 2;
        const rectY = systemBgCenterY - (systemHeight + systemPadding * 2) / 2;
        const rectWidth = totalWidth;
        const rectHeight = systemHeight + systemPadding * 2;

        renderer.structuralGroup.rect(rectWidth, rectHeight)
          .move(rectX, rectY)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 3,
            opacity: 1
          })
          .radius(12)
          .attr('data-group-border', 'node');

        // Add "Node" label at top left of the system box
        renderer.nodesGroup.text('Node')
          .move(rectX + 35, rectY + 40)
          .font({
            size: 32,
            family: 'var(--font-family)',
            weight: 900,
            fill: CONFIG.colors.textSecondary
          })
          .opacity(0.8);

        // Add NUMA 1 group with "..." in the extended area for internode mode
        if (isInternode) {
          const numaPadding = 15;
          const numaWidth = extraWidth - 15; // Margin for spacing
          const numaHeight = systemHeight;

          const numaX = rectX + rectWidth - extraWidth; // Left margin
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth;
          const numaRectHeight = numaHeight + numaPadding * 2;

          // Draw NUMA 1 border
          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA 1" label at top right
          renderer.nodesGroup.text('NUMA 1')
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);

          // Add "..." centered in NUMA 1
          renderer.nodesGroup.text('...')
            .move(numaX + numaRectWidth / 2, numaY + numaRectHeight / 2)
            .font({
              size: 40,
              family: 'var(--font-family)',
              weight: 900,
              fill: CONFIG.colors.textSecondary,
              anchor: 'middle'
            })
            .opacity(0.6);
        }
      }

      // Draw each ensemble in the system
      for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
        const ensembleGlobalIndex = systemIndex * CONFIG.ensembleCount + ensIndex;

        // Position ensemble within system
        let ensembleCenterX;
        if (isInternode) {
          // In internode mode, align NUMA 0 to the left of the Node rectangle
          const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
          ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
        } else {
          // Normal centered positioning
          const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
          ensembleCenterX = systemCenterX + ensembleOffsetX;
        }

        drawEnsemble(renderer, ensembleGlobalIndex, ensembleCenterX, cpuY, nvswitchY);
      }

      // Draw NUMA node borders (one per ensemble) if 2 ensembles
      if (ensembleCount === 2) {
        for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
          let ensembleCenterX;
          if (isInternode) {
            // In internode mode, align NUMA 0 to the left
            const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
            ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
          } else {
            // Normal centered positioning
            const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
            ensembleCenterX = systemCenterX + ensembleOffsetX;
          }

          // Calculate NUMA node bounding box (same as system but for single ensemble)
          const numaWidth = ensembleWidth;
          const numaHeight = systemHeight;
          const numaPadding = 15;

          const numaX = ensembleCenterX - (numaWidth + numaPadding * 2) / 2;
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth + numaPadding * 2;
          const numaRectHeight = numaHeight + numaPadding * 2;

          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA" label at top right
          renderer.nodesGroup.text(`NUMA ${ensIndex}`)
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);
        }
      }

      // GPU to NVSwitch connections (full mesh - all GPUs to all NVSwitches in system)
      const linkDef = CONFIG.gpuNvswitchLink;
      const bw = getBandwidth(linkDef.bandwidth);
      const color = CONFIG.colors.linkColor;
      const offset = getLinkOffset(bw.width);

      // Connect all GPUs in the system to all NVSwitches in the system
      const totalGpusInSystem = ensemblesToShow * CONFIG.groupCount;
      const totalNVSwitchesInSystem = ensemblesToShow * CONFIG.nvswitchCount;

      // Collect all GPU-NVSwitch connections for randomized drawing
      const gpuNvswitchConnections = [];
      for (let gpuIndex = 0; gpuIndex < totalGpusInSystem; gpuIndex++) {
        const gpuGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + gpuIndex;
        const gpuId = gpuGlobalIndex === 0 ? 'gpu' : `gpu-${gpuGlobalIndex}`;

        for (let nvIndex = 0; nvIndex < totalNVSwitchesInSystem; nvIndex++) {
          const nvswitchGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.nvswitchCount + nvIndex;
          gpuNvswitchConnections.push({
            fromId: gpuId,
            toId: `nvswitch-${nvswitchGlobalIndex}`,
            color: color,
            width: bw.width,
            fromSide: linkDef.fromSide,
            toSide: linkDef.toSide,
            offset: offset,
            type: linkDef.type,
            bandwidth: linkDef.bandwidth
          });
        }
      }

      // Randomize and draw GPU-NVSwitch connections
      const shuffledGpuNvswitchConnections = gpuNvswitchConnections.sort(() => Math.random() - 0.5);
      shuffledGpuNvswitchConnections.forEach(conn => {
        renderer.drawLink(conn.fromId, conn.toId, conn.color, conn.width, conn.fromSide, conn.toSide, conn.offset, 0, 1, 0, 1, conn.type, conn.bandwidth);
      });

      // Draw CPU-to-CPU link between ensembles (only if 2 ensembles visible)
      if (ensemblesToShow === 2) {
        const cpu0Id = systemIndex * CONFIG.ensembleCount === 0 ? 'cpu' : `cpu-${systemIndex * CONFIG.ensembleCount}`;
        const cpu1Id = `cpu-${systemIndex * CONFIG.ensembleCount + 1}`;

        // Use a bandwidth for CPU-CPU connection (assuming similar to CPU-PCIe)
        const bw = getBandwidth('16GB/s');
        const color = CONFIG.colors.linkColor;
        const offset = getLinkOffset(bw.width);

        renderer.drawLink(cpu0Id, cpu1Id, color, bw.width, 'right', 'left', offset, 0, 1, 0, 1, 'cpu', '16GB/s');

        // Draw EFA-to-EFA link between ensembles (only if 2 ensembles visible and explicitly requested)
        if (ensemblesToShow === 2 && shouldDrawEfaCrossLinks) {
          const efaExt0Id = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount === 0 ? 'efa-external' : `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount}`;
          const efaExt1Id = `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + CONFIG.groupCount}`;

          // Use unified EFA cross-links function
          drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
        }
      }
    }

    // ============================================================================
    // DRAW COMPLETE TOPOLOGY
    // ============================================================================
    let currentEnsembleCount = 2;  // Start with 2 ensembles (1 complete node)
    let currentSystemCount = 1;    // Start with 1 system
    let currentActivePathId = null; // Track active path for conditional rendering
    let showRealBandwidthsOverride = null; // User override via checkbox (null = use config)

    function drawTopology(ensembleCount = currentEnsembleCount, systemCount = currentSystemCount) {
      // Clear existing
      const container = getElement('aws-topology-container');
      container.innerHTML = '';

      // Use FIXED viewbox size for consistent zoom across all modes
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;
      const isInternodeLayout = systemCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode';

      // Calculate single system height (used in both layouts)
      const singleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;

      // Always use max viewbox dimensions for consistent zoom level
      const maxEnsembleWidthForViewbox = 2 * ensembleWidth;
      let viewboxWidth = maxEnsembleWidthForViewbox + CONFIG.gaps.ensembleGap + 200;
      let viewboxHeight = singleSystemHeight;

      // For single ensemble (CPU-GPU, GPU-GPU via CPU, storage paths), zoom in more
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxWidth *= 0.65;  // Zoom in by reducing viewbox width (increased from 0.75)
        viewboxHeight *= 0.65; // Zoom in by reducing viewbox height (increased from 0.75)
      }

      // For 2 systems in vertical layout, use scaled dimensions
      if (systemCount === 2 && !isInternodeLayout) {
        viewboxHeight = singleSystemHeight * 2 + CONFIG.gaps.systemGap;
        viewboxWidth *= 1.15;
        viewboxHeight *= 1.15;
      }

      // For internode horizontal layout, extend viewbox width to accommodate both extended systems
      if (isInternodeLayout) {
        const extraWidth = 210; // Extension per system for NUMA 1
        const systemPadding = 30;
        const singleEnsembleWidth = ensembleWidth;
        const totalSystemWidth = singleEnsembleWidth + systemPadding * 2 + extraWidth;
        const gap = 80;
        viewboxWidth = totalSystemWidth * 2 + gap + 200; // Extra margin for comfort
      }

      // Fixed height based on screen width for better consistency
      const embedConfig = readEmbedConfig();
      const containerWidth = container.clientWidth || 800;

      // Calculate fixed height: use max viewbox dimensions to determine aspect ratio
      // Max viewbox is for 2 ensembles, 2 systems (vertical layout)
      const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
      const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;
      const maxViewboxHeight = maxSingleSystemHeight * 1.15; // Account for 2-system scaling
      const maxViewboxWidth = maxEnsembleWidth + 200;

      const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
      const baseHeight = containerWidth * maxAspectRatio;
      const legendHeight = embedConfig.initialFilter ? 150 : 200;

      // Set fixed height once, won't change on filter change
      if (!container.dataset.heightSet) {
        container.style.height = `${baseHeight + legendHeight}px`;
        container.dataset.heightSet = 'true';
      }

      // Viewbox will auto-center/zoom content
      let viewboxY = 0;
      let paddedViewboxHeight = viewboxHeight;
      const verticalPadding = 0;
      viewboxY = -verticalPadding / 2 + 100;
      paddedViewboxHeight = viewboxHeight + verticalPadding;

      // For single ensemble, shift content up slightly
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxY += 150;  // Shift up by reducing viewboxY (reduced from 80)
      }

      // For single node mode (no Node/NUMA groups), shift content down by 80px
      // BUT only if: 1) not an EFA filter, 2) a filter is active
      const isEfaFilter = currentActivePathId === 'gpu-gpu-efa-intranode' || currentActivePathId === 'gpu-gpu-efa-internode';
      const hasActiveFilter = currentActivePathId && currentActivePathId !== '';
      if (!isInternodeLayout && hasActiveFilter && !isEfaFilter) {
        viewboxY -= 80;  // Shift down by decreasing viewboxY (increased from 50px)
      }

      const draw = SVG().addTo(container).size('100%', '100%').viewbox(0, viewboxY, viewboxWidth, paddedViewboxHeight);
      const renderer = new TopologyRenderer(draw);

      const centerX = viewboxWidth / 2;

      // Draw each system - horizontally for internode, vertically for others
      const isInternodeHorizontalLayout = isInternodeLayout;

      for (let sysIndex = 0; sysIndex < systemCount; sysIndex++) {
        let systemCenterX, cpuY, nvswitchY;

        if (isInternodeHorizontalLayout) {
          // Horizontal layout for internode: systems side by side (rapprochés mais sans overlap)
          // Pour internode, on affiche 1 seul ensemble (NUMA) par système, donc largeur réelle = 50%
          const fullSystemWidth = ensembleCount * ensembleWidth + (ensembleCount - 1) * CONFIG.gaps.ensembleGap;
          const actualSystemWidth = fullSystemWidth * 0.5; // On n'affiche qu'1 ensemble sur 2
          const extraWidth = 210; // Extension pour le groupe NUMA 1
          const systemPadding = 10;
          const totalSystemWidth = actualSystemWidth + systemPadding * 2 + extraWidth; // Largeur totale incluant l'extension
          const gap = 80; // Gap visible entre les systèmes

          // Positionner les systèmes avec le gap (en prenant en compte la largeur totale)
          if (sysIndex === 0) {
            systemCenterX = centerX - (totalSystemWidth / 2 + gap / 2); // Premier système à gauche
          } else {
            systemCenterX = centerX + (totalSystemWidth / 2 + gap / 2); // Deuxième système à droite
          }
          cpuY = CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        } else {
          // Vertical layout for other cases: systems stacked vertically
          const systemOffsetY = sysIndex * (singleSystemHeight + CONFIG.gaps.systemGap);
          systemCenterX = centerX;
          cpuY = systemOffsetY + CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        }

        // Only draw EFA cross-links for intranode EFA path
        const shouldDrawEfaCrossLinks = currentActivePathId === 'gpu-gpu-efa-intranode';
        drawSystem(renderer, sysIndex, systemCenterX, cpuY, nvswitchY, ensembleCount, systemCount, shouldDrawEfaCrossLinks);
      }

      // Draw EFA cross-link between systems (for internode)
      if (systemCount === 2 && ensembleCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode') {
        const efaExt0Id = 'efa-external';  // System 0, ensemble 0, group 0
        const efaExt1Id = 'efa-external-8';  // System 1, ensemble 0, group 0 (4 groups per ensemble, 2 ensembles per system = group 8)

        // Use unified EFA cross-links function
        drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
      }

      currentEnsembleCount = ensembleCount;
      currentSystemCount = systemCount;
    }

    // ============================================================================
    // REAL BANDWIDTH HELPERS
    // ============================================================================
    function getRealBandwidthForPath(pathId) {
      const pathToRealBandwidth = {
        'cpu-gpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-cpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-nvswitch': { value: '786', unit: 'GB/s' },
        'gpu-gpu-efa-intranode': { value: '40', unit: 'GB/s' },
        'gpu-gpu-efa-internode': { value: '40', unit: 'GB/s' },
        'gpu-storage': { value: '14.2', unit: 'GB/s' },
        'cpu-storage': { value: '14.2', unit: 'GB/s' },
        'gpu-cpu-storage': { value: '14.2', unit: 'GB/s' }
      };

      const bandwidth = pathToRealBandwidth[pathId];
      if (bandwidth) {
        return {
          value: bandwidth.value,
          unit: bandwidth.unit
        };
      }
      return null;
    }

    // ============================================================================
    // HIGHLIGHT HELPERS
    // ============================================================================
    function highlightPath(path, pathLabel = '', pathId = '') {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear previous active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Ghost all base links and cross-links groups at once
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '0.35';

        // Increase stroke width of group borders to make them more visible when ghosted
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '5');
          // border.setAttribute('stroke-opacity', '0.8');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '0.25';
      }

      // Dim nodes individually (they're not in a group)
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '0.6';
        // Dim text labels
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '0.25';
        });
      });

      // Highlight path nodes
      path.nodes.forEach(nodeId => {
        let nodeEl = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeEl) {
          const candidates = svg.querySelectorAll(`g[id^="${nodeId}"]`);
          nodeEl = candidates[0];
        }
        if (nodeEl) {
          nodeEl.style.opacity = '1';
          // Restore text opacity
          nodeEl.querySelectorAll('text').forEach(text => {
            text.style.opacity = '1';
          });
        }
      });

      // Duplicate active links into activeLinksGroup
      if (activeLinksGroup) {
        path.links.forEach(linkSpec => {
          // Find matching links in base groups
          const allBaseLinks = [
            ...svg.querySelectorAll('g[data-group="base-links"] > g[data-link-type]'),
            ...svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type]')
          ];

          allBaseLinks.forEach(linkGroup => {
            const linkFrom = linkGroup.getAttribute('data-from');
            const linkTo = linkGroup.getAttribute('data-to');

            const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
            const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

            if (matchesFrom && matchesTo) {
              // Clone the link and append to active group
              const clonedLink = linkGroup.cloneNode(true);
              activeLinksGroup.appendChild(clonedLink);
            }
          });
        });

        // Duplicate EFA cross-links if they match the current path
        const currentPathId = currentActivePathId;
        if (currentPathId === 'gpu-gpu-efa-intranode' || currentPathId === 'gpu-gpu-efa-internode') {
          const efaCrossLinks = svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type="efa-crosslink"]');
          efaCrossLinks.forEach(linkGroup => {
            const clonedLink = linkGroup.cloneNode(true);
            activeLinksGroup.appendChild(clonedLink);
          });
        }
      }

      // Calculate and show bottleneck (minimum bandwidth in the path)
      let minBandwidth = Infinity;
      let minBandwidthValue = null;
      const usedBandwidths = new Set();

      path.links.forEach(linkSpec => {
        svg.querySelectorAll('g[data-link-type]').forEach(linkGroup => {
          const linkFrom = linkGroup.getAttribute('data-from');
          const linkTo = linkGroup.getAttribute('data-to');

          const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
          const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

          if (matchesFrom && matchesTo) {
            const bandwidth = linkGroup.getAttribute('data-bandwidth');
            if (bandwidth) {
              const bw = getBandwidth(bandwidth);
              if (bw && bw.numericValue < minBandwidth) {
                minBandwidth = bw.numericValue;
                minBandwidthValue = bw.speed;
              }
              if (bw) {
                usedBandwidths.add(bw.speed);
              }
            }
          }
        });
      });

      // Highlight all used bandwidths in the legend
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          const bandwidth = legendItem.getAttribute('data-legend-bandwidth');
          if (usedBandwidths.has(bandwidth)) {
            // Used in the path - active
            legendItem.style.opacity = '1';
          } else {
            // Not used - ghosted
            legendItem.style.opacity = '0.4';
          }
        });
      }

      // Show bottleneck info
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      const efficiencyValueEl = bottleneckEl.querySelector('.efficiency-value');

      // Check if real bandwidths are enabled
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (showRealBandwidths) {
        // When real bandwidths are shown, display real bandwidth value directly
        const realBandwidth = getRealBandwidthForPath(pathId);
        if (realBandwidth) {
          bottleneckValueEl.textContent = realBandwidth.value;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');

          // Calculate and display efficiency
          if (minBandwidthValue && efficiencyEl && efficiencyValueEl) {
            const theoreticalBandwidth = parseFloat(minBandwidthValue.replace('GB/s', ''));
            const realBandwidthNum = parseFloat(realBandwidth.value);

            // For EFA (12.5GB/s), multiply by 4 to get total theoretical bandwidth
            const adjustedTheoretical = minBandwidthValue === '12.5GB/s' ? theoreticalBandwidth * 4 : theoreticalBandwidth;

            const efficiency = (realBandwidthNum / adjustedTheoretical) * 100;
            efficiencyValueEl.textContent = `${efficiency.toFixed(1)}%`;
            efficiencyEl.style.display = 'block';
          }
        } else {
          // Fallback if no real bandwidth found
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');
          if (efficiencyEl) {
            efficiencyEl.style.display = 'none';
          }
        }
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      } else {
        // Normal bottleneck display
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        if (minBandwidthValue) {
          const value = minBandwidthValue.replace('GB/s', '');
          // For EFA (12.5GB/s), display as 50 (4 links × 12.5)
          const displayValue = value === '12.5' ? '50' : value;
          bottleneckValueEl.textContent = displayValue;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        } else {
          // Debug: show the module even without bandwidth data
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        }
        // Hide efficiency in normal mode
        if (efficiencyEl) {
          efficiencyEl.style.display = 'none';
        }
      }
    }

    function resetHighlight() {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Restore opacity to base links groups
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '1';

        // Restore original stroke width for group borders
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '3');
          border.setAttribute('stroke-opacity', '1');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '1';
      }

      // Reset nodes opacity
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '1';
        // Reset text opacity
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '1';
        });
      });

      // Clear current active path to ensure EFA cross-links are not drawn
      currentActivePathId = null;

      // Reset legend opacity
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          legendItem.style.opacity = '1';
        });
      }

      // Hide bottleneck (unless real bandwidths are enabled)
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (!showRealBandwidths) {
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        bottleneckEl.classList.remove('visible');
      } else {
        // When real bandwidths are enabled, hide the module when no path is active
        bottleneckLabelEl.textContent = 'Real Bandwidth';
        bottleneckEl.classList.remove('visible');
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      }

      // Hide efficiency display
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      if (efficiencyEl) {
        efficiencyEl.style.display = 'none';
      }
    }

    // ============================================================================
    // CONFIG READING (from HtmlEmbed props)
    // ============================================================================
    function readEmbedConfig() {
      // Find the closest ancestor that carries the data-config attribute
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let providedConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      const config = providedConfig || {};

      // Apply user override from checkbox if set
      if (showRealBandwidthsOverride !== null) {
        config.showRealBandwidths = showRealBandwidthsOverride;
      }

      return config;
    }

    // ============================================================================
    // REAL BANDWIDTHS DISPLAY
    // ============================================================================
    function displayContextualRealBandwidths(pathId, pathLabel) {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Map path IDs to relevant real bandwidths
      const pathToBandwidths = {
        'cpu-gpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-cpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-GPU (via CPU)', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-nvswitch': [
          { label: 'GPU-GPU (NVSwitch)', value: CONFIG.realBandwidths['gpu-gpu-same-node'] }
        ],
        'gpu-gpu-efa-intranode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-intranode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
          { label: 'All2All', value: CONFIG.realBandwidths['all2all-same-node'] }
        ],
        'gpu-gpu-efa-internode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-internode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
          { label: 'All2All', value: CONFIG.realBandwidths['alltoall-internode'] }
        ],
        'gpu-storage': [
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'cpu-storage': [
          { label: 'CPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'gpu-cpu-storage': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ]
      };

      const relevantBandwidths = pathToBandwidths[pathId] || [];

      if (relevantBandwidths.length > 0) {
        // Clear normal bottleneck display
        bottleneckValueEl.textContent = '';
        bottleneckPathEl.textContent = '';

        // Create HTML for relevant bandwidths
        const html = relevantBandwidths.map(item => `
          <div class="bandwidth-item">
            <span class="bandwidth-label">${item.label}</span>
            <span class="bandwidth-value">${item.value}</span>
          </div>
        `).join('');

        realBandwidthsContentEl.innerHTML = html;
      } else {
        // Fallback: show all bandwidths if path not found
        setupRealBandwidthsDisplay();
      }
    }

    function setupRealBandwidthsDisplay() {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Create the bandwidth items HTML
      const bandwidthItems = [
        { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
        { label: 'Same Node', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-same-node'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
        { label: '  All2All', value: CONFIG.realBandwidths['all2all-same-node'] },
        { label: 'Internode', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-internode'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
        { label: '  All2All', value: CONFIG.realBandwidths['alltoall-internode'] },
        { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
      ];

      const html = bandwidthItems.map(item => {
        if (item.value === '') {
          // Section header
          return `<div class="bandwidth-section-header" style="font-weight: 600; margin: 6px 0 4px 0; color: var(--text-secondary);">${item.label}</div>`;
        } else {
          // Bandwidth item
          return `
            <div class="bandwidth-item">
              <span class="bandwidth-label">${item.label}</span>
              <span class="bandwidth-value">${item.value}</span>
            </div>
          `;
        }
      }).join('');

      realBandwidthsContentEl.innerHTML = html;
    }

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    function initialize() {
      const container = getElement('aws-topology-container');
      const tooltip = getElement('aws-topology-tooltip');

      // Read initial config from HtmlEmbed props (before any override)
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let initialConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          initialConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      // Initialize override with initial config value (so checkbox is in sync)
      if (initialConfig && initialConfig.showRealBandwidths !== undefined) {
        showRealBandwidthsOverride = initialConfig.showRealBandwidths;
      }

      // Now read config (which will use override if set)
      const embedConfig = readEmbedConfig();

      // Setup real bandwidths display if enabled
      if (embedConfig.showRealBandwidths) {
        const bottleneckEl = getElement('aws-topology-bottleneck');
        const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');

        // Change label to "Real Bandwidth"
        bottleneckLabelEl.textContent = 'Real Bandwidth';

        // Hide the detailed real bandwidths list initially
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
        // Don't show the module initially - only when a path is selected
        bottleneckEl.classList.remove('visible');
      }

      drawTopology();

      // Initial fade in
      requestAnimationFrame(() => {
        container.style.opacity = '1';
      });

      // Setup tooltip

      container.addEventListener('mouseover', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          const bandwidth = target.getAttribute('data-bandwidth');
          const label = target.getAttribute('data-label');

          // Clear and rebuild tooltip content
          tooltip.innerHTML = '';

          if (label) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'tooltip-label';
            labelDiv.textContent = label;
            tooltip.appendChild(labelDiv);
          }

          const bandwidthDiv = document.createElement('div');
          bandwidthDiv.className = 'tooltip-bandwidth';
          bandwidthDiv.textContent = bandwidth;
          tooltip.appendChild(bandwidthDiv);

          tooltip.classList.add('visible');
        }
      });

      container.addEventListener('mousemove', (e) => {
        if (tooltip.classList.contains('visible')) {
          const rect = container.getBoundingClientRect();
          tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
          tooltip.style.top = (e.clientY - rect.top + 10) + 'px';
        }
      });

      container.addEventListener('mouseout', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          tooltip.classList.remove('visible');
        }
      });

      // Create control buttons organized by category
      const controlsContainer = getElement('aws-topology-controls');

      // Hide controls if an initial filter is provided
      if (embedConfig.initialFilter) {
        controlsContainer.style.display = 'none';
      } else {
        // Categorize paths
        const pathsByCategory = {
          intranode: [
            { id: 'cpu-gpu', label: CONFIG.paths['cpu-gpu'].label },
            { id: 'gpu-gpu-cpu', label: CONFIG.paths['gpu-gpu-cpu'].label },
            { id: 'gpu-gpu-nvswitch', label: CONFIG.paths['gpu-gpu-nvswitch'].label },
            { id: 'gpu-gpu-efa-intranode', label: CONFIG.paths['gpu-gpu-efa-intranode'].label }
          ],
          internode: [
            { id: 'gpu-gpu-efa-internode', label: CONFIG.paths['gpu-gpu-efa-internode'].label }
          ],
          storage: [
            { id: 'gpu-storage', label: CONFIG.paths['gpu-storage'].label },
            { id: 'cpu-storage', label: CONFIG.paths['cpu-storage'].label },
            { id: 'gpu-cpu-storage', label: CONFIG.paths['gpu-cpu-storage'].label }
          ]
        };

        // Create single select with prefixed options and checkbox
        const isChecked = showRealBandwidthsOverride === true || (showRealBandwidthsOverride === null && embedConfig.showRealBandwidths);
        const controlsHTML = `
          <div>
            <label id="real-bandwidth-label" style="display: flex; align-items: center; gap: 0px; font-size: 14px; color: var(--text-color); cursor: pointer; opacity: 0.3; transition: opacity 0.2s;">
              <input type="checkbox" id="real-bandwidth-toggle" ${isChecked ? 'checked' : ''} disabled>
              <span>Show Real Bandwidths</span>
            </label>
          </div>
          
          <div style="display: flex; gap: 12px; align-items: center; margin-top: 8px;">
            <select id="path-select" style="min-width: 250px;">
              <option value="">Select path...</option>
            </select>
          </div>
        `;
        controlsContainer.innerHTML = controlsHTML;

        const pathSelect = controlsContainer.querySelector('#path-select');
        const realBandwidthToggle = controlsContainer.querySelector('#real-bandwidth-toggle');
        const realBandwidthLabel = controlsContainer.querySelector('#real-bandwidth-label');

        // Populate single select with prefixed options
        Object.entries(pathsByCategory).forEach(([category, paths]) => {
          const categoryLabel = category.charAt(0).toUpperCase() + category.slice(1);

          paths.forEach(path => {
            const option = document.createElement('option');
            option.value = path.id;
            option.textContent = `${categoryLabel}: ${path.label}`;
            pathSelect.appendChild(option);
          });
        });

        // Helper function to enable/disable real bandwidth toggle
        const updateRealBandwidthToggleState = (enabled) => {
          if (enabled) {
            realBandwidthToggle.disabled = false;
            realBandwidthLabel.style.opacity = '1';
            realBandwidthLabel.style.cursor = 'pointer';
          } else {
            realBandwidthToggle.disabled = true;
            realBandwidthLabel.style.opacity = '0.3';
            realBandwidthLabel.style.cursor = 'default';
          }
        };

        // Real bandwidth toggle handler
        realBandwidthToggle.addEventListener('change', (e) => {
          showRealBandwidthsOverride = e.target.checked;

          // Re-apply highlight if a path is active
          if (currentActivePathId) {
            const path = CONFIG.paths[currentActivePathId];
            if (path) {
              highlightPath(path, path.label, currentActivePathId);
            }
          } else {
            // If no path active, just reset to clear any displayed values
            resetHighlight();
          }
        });

        // Function to activate a path
        const activatePath = (pathId) => {
          if (!pathId) {
            // Reset to default
            currentActivePathId = null;
            updateRealBandwidthToggleState(false); // Disable toggle when no path selected
            const needsRedraw = currentEnsembleCount !== 2 || currentSystemCount !== 1;

            if (needsRedraw) {
              const container = getElement('aws-topology-container');
              container.style.opacity = '0';

              setTimeout(() => {
                drawTopology(2, 1);
                resetHighlight();

                requestAnimationFrame(() => {
                  container.style.opacity = '1';
                });
              }, 150);
            } else {
              resetHighlight();
            }
            return;
          }

          const path = CONFIG.paths[pathId];
          if (!path) return;

          currentActivePathId = pathId;
          updateRealBandwidthToggleState(true); // Enable toggle when path is selected

          // Check if we need to redraw
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            pathId === 'gpu-gpu-efa-intranode' ||
            pathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            const container = getElement('aws-topology-container');
            container.style.opacity = '0';

            setTimeout(() => {
              currentActivePathId = pathId;
              drawTopology(path.requiredEnsembles, path.requiredSystems);
              highlightPath(path, path.label, pathId);

              requestAnimationFrame(() => {
                container.style.opacity = '1';
              });
            }, 150);
          } else {
            currentActivePathId = pathId;
            highlightPath(path, path.label, pathId);
          }
        };

        // Path select change handler
        pathSelect.addEventListener('change', (e) => {
          const pathId = e.target.value;
          activatePath(pathId);
        });
      }

      // Apply initial filter from embedConfig if provided
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          currentActivePathId = initialPathId;

          // Draw topology with correct requirements
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            initialPathId === 'gpu-gpu-efa-intranode' ||
            initialPathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            drawTopology(path.requiredEnsembles, path.requiredSystems);
          }
        }
      }

      // Create SVG legend
      const legendContainer = getElement('aws-topology-legend');
      const legendSvg = SVG().addTo(legendContainer).size('100%', '100%');

      const lineLength = 36;  // 30 * 1.2
      const itemSpacing = 30;  // 25 * 1.2
      const startX = 96;  // 80 * 1.2
      const startY = 42;  // 35 * 1.2
      const textOffset = 24;  // 20 * 1.2

      // Calculate actual legend width based on content
      const legendWidth = startX + lineLength + textOffset + 168;  // 140 * 1.2
      const legendHeight = 144;  // 120 * 1.2
      legendSvg.viewbox(0, 0, legendWidth, legendHeight);

      [...CONFIG.bandwidths].reverse().forEach((bw, index) => {
        const y = startY + (index * itemSpacing);
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const width = bw.width;

        // Create a group for each legend item with a data attribute for bandwidth
        const legendItemGroup = legendSvg.group();
        legendItemGroup.attr('data-legend-bandwidth', bw.speed);

        // Dessiner la ligne
        legendItemGroup.line(startX, y, startX + lineLength, y)
          .stroke({ color, width });

        // Dessiner les cercles aux extrémités
        const r = width * 0.8;
        const startCircle = legendItemGroup.circle(r * 2).move(startX - r, y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        const endCircle = legendItemGroup.circle(r * 2).move(startX + lineLength - r, y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        // Ajouter le texte (aligné à droite, valeur en gras)
        const textX = legendWidth - 5;
        const value = bw.speed.replace('GB/s', '').trim();

        // Format: "Label - 900 GB/s" avec 900 en gras
        const textEl = legendItemGroup.text(function (add) {
          add.tspan(bw.label + ' - ').font({ weight: 'normal' });
          add.tspan(value).font({ weight: 'bold' });
          add.tspan(' GB/s').font({ weight: 'normal' });
        })
          .move(textX, y)
          .font({
            family: 'system-ui, -apple-system, sans-serif',
            size: 14,  // 12 * 1.2 ≈ 14
            anchor: 'end',
            fill: CONFIG.colors.nodeText
          })
          .dy(-7);  // -6 * 1.2 ≈ -7
      });
    }

    // Initialize only if wrapper is found
    if (findWrapper()) {
      initialize();

      // Apply initial filter highlight after legend is created
      const embedConfig = readEmbedConfig();
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          // Apply highlight to both topology and legend
          highlightPath(path, path.label, initialPathId);
        }
      }

      // Add resize handler for responsive width changes (mobile/desktop)
      const handleResize = () => {
        const container = getElement('aws-topology-container');
        if (!container) return;

        // Recalculate fixed height based on new width (for responsive design)
        const containerWidth = container.clientWidth || 800;

        // Use max viewbox dimensions for consistent aspect ratio
        const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
        const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
          CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
          CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
          CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
          CONFIG.gaps.bottomMargin;
        const maxViewboxHeight = maxSingleSystemHeight * 1.15;
        const maxViewboxWidth = maxEnsembleWidth + 200;

        const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
        const baseHeight = containerWidth * maxAspectRatio;
        const legendHeight = embedConfig.initialFilter ? 150 : 200;

        // Update height based on current width (responsive)
        container.style.height = `${baseHeight + legendHeight}px`;
      };

      // Use ResizeObserver for better performance (only for window resize, not content changes)
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => handleResize());
        ro.observe(findWrapper());
      } else {
        window.addEventListener('resize', handleResize);
      }
    } else {
      console.warn('AWS topology: wrapper not found, skipping initialization');
    }
  })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">GPU-to-GPU communication path through CPU and main memory, showing the inefficient roundtrip through the PCIe switch and CPU.</figcaption></figure>
<p>This roundabout path involves multiple memory copies and saturates both PCIe and CPU memory buses, causing congestion. In our topology where 4 H100s share the same CPU memory buses, this congestion becomes even more problematic when multiple GPUs attempt simultaneous communication, as they compete for the same limited CPU memory bandwidth… 😢</p>
<p>With this CPU-mediated approach, we’re fundamentally bottlenecked by the PCIe Gen4 x8 link at ~16 GB/s between the CPU and PCIe switch. Fortunately, there’s a better way for our GPUs to communicate without involving the CPU:  <strong>GPUDirect RDMA</strong> .</p>
<h4 id="through-libfabric-efa"><a href="#through-libfabric-efa">Through Libfabric EFA</a></h4>
<p><strong>GPUDirect RDMA</strong>  (Remote Direct Memory Access or GDRDMA) is a technology that enables direct communication between NVIDIA GPUs by allowing direct access to GPU memory. This eliminates the need for data to pass through the system CPU and avoids buffer copies via system memory, resulting in up to 10x better performance compared to traditional CPU-mediated transfers. GPUDirect RDMA works over PCIe to enable fast GPU-to-GPU communication both within a node (as we see here) and across nodes using  <strong>NICs</strong>  (network interface cards, as we’ll see in a future section) with RDMA capabilities. For more details, see <a href="https://developer.nvidia.com/gpudirect">NVIDIA GPUDirect</a>.</p>
<p>Looking back at our topology diagram, we can see that each  <strong>PCIe switch</strong>  has 4 EFA (Elastic Fabric Adapter) NICs, meaning each GPU has access to 4 EFA adapters.  <strong>EFA</strong>  is AWS’s custom high-performance network interface for cloud instances, designed to provide low-latency, high-throughput inter-instance communication. On p5 instances, EFA exposes a  <strong>libfabric</strong>  interface (a specific communication API for high performance computations) that applications can use, and provides RDMA-like capabilities that enable GPUDirect RDMA for direct GPU-to-GPU communication across nodes.</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>$ lstopo -v</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>## We can see 4 such EFA devices per each PCIe switch</span></span>
<span class="line"><span>PCIBridge L#8 (busid=0000:46:01.0 id=1d0f:0200 class=0604(PCIBridge) link=15.75GB/s buses=0000:[4f-4f] PCIVendor=&quot;Amazon.com, Inc.&quot;)</span></span>
<span class="line"><span>PCI L#6 (busid=0000:4f:00.0 id=1d0f:efa1 class=0200(Ethernet) link=15.75GB/s PCISlot=82-1 PCIVendor=&quot;Amazon.com, Inc.&quot;)</span></span>
<span class="line"><span>    OpenFabrics L#4 (NodeGUID=cd77:f833:0000:1001 SysImageGUID=0000:0000:0000:0000 Port1State=4 Port1LID=0x0 Port1LMC=1 Port1GID0=fe80:0000:0000:0000:14b0:33ff:fef8:77cd) &quot;rdmap79s0&quot;</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>$ fi_info --verbose</span></span>
<span class="line"><span>        fi_link_attr:</span></span>
<span class="line"><span>            address: EFA-fe80::14b0:33ff:fef8:77cd</span></span>
<span class="line"><span>            mtu: 8760            # maximum packet size is 8760 bytes</span></span>
<span class="line"><span>            speed: 100000000000  # each EFA link provides 100 Gbps of bandwidth</span></span>
<span class="line"><span>            state: FI_LINK_UP</span></span>
<span class="line"><span>            network_type: Ethernet</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre></div>
<p>Each EFA link provides 100 Gbps (12.5 GB/s) of bandwidth. With 4 EFA NICs per GPU and 8 GPUs per node, this gives an aggregate bandwidth of 100 × 4 × 8 = 3200 Gbps per node (400GB/s). For a detailed exploration of how to fully harness this 3200 Gbps bandwidth using libfabric and EFA, see Lequn Chen’s excellent blog series: <a href="https://le.qun.ch/en/blog/2024/12/25/libfabric-efa-0-intro/">Harnessing 3200 Gbps Network: A Journey with RDMA, EFA, and libfabric</a>.</p>
<p>To make sure we’re enabling GPUDirect RDMA over EFA, you should set the  <code>FI_PROVIDER=efa</code>  and  <code>NCCL_P2P_DISABLE=1</code>  environment variables. When this mode is activated, you can verify it that it’s working by setting  <code>NCCL_DEBUG=INFO</code> , which will show messages like:</p>
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>NCCL INFO Channel 01/1 : 1[1] -&gt; 0[0] [receive] via NET/Libfabric/0/GDRDMA/Shared</span></span>
<span class="line"><span></span></span></code></pre></div>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-l059x41qdlj" data-config="{&#34;initialFilter&#34;:&#34;gpu-gpu-efa-intranode&#34;}"><!--
  AWS Bandwidth Bottleneck Visualization
  
  Usage:
  
  Basic:
    <HtmlEmbed src="/embeds/aws-bandwidth-bottleneck.html" />
  
  With initial filter:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ initialFilter: 'cpu-gpu' }} 
    />
  
  With real bandwidths display:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ showRealBandwidths: true }} 
    />
  
  Available filters:
    - cpu-gpu (Intranode: CPU ⟷ GPU)
    - gpu-gpu-cpu (Intranode: GPU ⟷ GPU via CPU)
    - gpu-gpu-nvswitch (Intranode: GPU ⟷ GPU via NVSwitch)
    - gpu-gpu-efa-intranode (Intranode: GPU ⟷ GPU via EFA)
    - gpu-gpu-efa-internode (Internode: GPU ⟷ GPU via EFA)
    - gpu-storage (Storage: GPU ⟷ Storage)
    - cpu-storage (Storage: CPU ⟷ Storage)
    - gpu-cpu-storage (Storage: GPU ⟷ Storage via CPU)
-->
<div class="aws-topology-wrapper">
  <div class="aws-topology-container"></div>
  <div class="aws-topology-controls"></div>
  <div class="aws-topology-legend"></div>
  <div class="aws-topology-tooltip"></div>
  <div class="aws-topology-bottleneck">
    <div class="bottleneck-label">Bandwidth Max</div>
    <div class="bottleneck-path">for CPU → GPU</div>
    <div class="bottleneck-value">-</div>
    <div class="bottleneck-unit">GB/s</div>
    <div class="bottleneck-efficiency" style="display: none;">
      <div class="efficiency-value">-</div>
      <div class="efficiency-label">Efficiency</div>
    </div>
    <div class="real-bandwidths" style="display: none;">
      <div class="real-bandwidths-title">Real Bandwidths</div>
      <div class="real-bandwidths-content"></div>
    </div>
  </div>
</div>

<style>
  .aws-topology-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .aws-topology-container {
    width: 100%;
    height: auto;
    min-height: 400px;
    position: relative;
    transition: opacity 0.15s ease;
  }

  .aws-topology-container.fixed-height {
    height: 850px;
  }

  .aws-topology-container svg {
    width: 100%;
    height: 100%;
  }

  .aws-topology-container svg g {
    transition: opacity 0.2s ease;
  }

  /* Add drop shadow to all links */
  .aws-topology-container svg g[data-link-type] line,
  .aws-topology-container svg g[data-link-type] path {
    filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
  }

  .aws-topology-controls {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 800px;
  }

  .aws-topology-controls-section {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .aws-topology-controls-row {
    display: flex;
    flex-direction: row;
    gap: 16px;
    align-items: flex-start;
  }

  .aws-topology-controls-label {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0.7;
  }

  .aws-topology-controls-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }

  .aws-topology-controls-buttons .button {
    flex-shrink: 0;
  }

  /* Hide controls on mobile */
  @media (max-width: 768px) {
    .aws-topology-controls {
      display: none;
    }
  }

  .aws-topology-legend {
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 264px;
    /* 220 * 1.2 */
    height: 120px;
    /* 100 * 1.2 */
  }

  .aws-topology-tooltip {
    position: absolute;
    padding: 8px 12px;
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 12px;
    color: var(--text-color);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .aws-topology-tooltip.visible {
    opacity: 1;
  }

  .tooltip-label {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-color);
  }

  .tooltip-bandwidth {
    font-size: 11px;
    color: var(--text-secondary);
  }

  .aws-topology-bottleneck {
    position: absolute;
    top: 10px;
    right: 10px;
    text-align: right;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .aws-topology-bottleneck.visible {
    opacity: 1;
  }

  .bottleneck-label {
    font-size: 11px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-value {
    font-size: 24px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    margin-bottom: 2px;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .bottleneck-unit {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-path {
    font-size: 10px;
    color: var(--text-secondary);
    font-style: italic;
    margin-bottom: 6px;
    opacity: 0.8;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-efficiency {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    margin-top: 12px;
    margin-bottom: 4px;
  }

  .efficiency-label {
    font-size: 9px;
    color: var(--text-secondary);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 2px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .efficiency-value {
    font-size: 20px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .real-bandwidths {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
    opacity: 0.9;
  }

  .real-bandwidths-title {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content {
    font-size: 11px;
    color: var(--text-color);
    line-height: 1.4;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content .bandwidth-item {
    margin-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .real-bandwidths-content .bandwidth-label {
    font-size: 10px;
    color: var(--text-secondary);
    opacity: 0.8;
  }

  .real-bandwidths-content .bandwidth-value {
    font-size: 11px;
    font-weight: 600;
    color: var(--primary-color);
  }

  /* Checkbox styling for the bandwidth toggle */
  #real-bandwidth-toggle {
    appearance: none;
    width: 16px;
    height: 16px;
    border: 2px solid var(--border-color);
    border-radius: 3px;
    background-color: var(--page-bg);
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    margin-right: 8px;
  }

  #real-bandwidth-toggle:hover {
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(from var(--primary-color) r g b / 0.1);
  }

  #real-bandwidth-toggle:checked {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:checked::before {
    content: '';
    position: absolute;
    top: 1px;
    left: 4px;
    width: 4px;
    height: 8px;
    border: solid var(--on-primary);
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }

  #real-bandwidth-toggle:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.5/svg.min.js"></script>
<script>
  (function () {
    // Generate unique ID for this instance
    const instanceId = 'aws-topology-' + Math.random().toString(36).substr(2, 9);

    // Store reference to current script to find wrapper later
    const scriptEl = document.currentScript;

    // Function to find wrapper (will be called after DOM is ready)
    let wrapperEl = null;
    const findWrapper = () => {
      if (!wrapperEl) {
        wrapperEl = scriptEl.previousElementSibling;
        if (!wrapperEl || !wrapperEl.classList.contains('aws-topology-wrapper')) {
          // Fallback: search for unmounted wrappers
          const allWrappers = document.querySelectorAll('.aws-topology-wrapper');
          for (const wrapper of allWrappers) {
            if (!wrapper.dataset.mounted) {
              wrapperEl = wrapper;
              break;
            }
          }
        }
        if (wrapperEl && !wrapperEl.dataset.mounted) {
          wrapperEl.dataset.mounted = 'true';
        }
      }
      return wrapperEl;
    };

    // Get all child elements for this instance
    const getElement = (className) => {
      const wrapper = findWrapper();
      return wrapper ? wrapper.querySelector('.' + className) : null;
    };

    // ============================================================================
    // CONFIGURATION - All settings in one place
    // ============================================================================
    const CONFIG = {
      // Canvas settings
      viewbox: {
        width: 2400,  // Width for 2 ensembles side by side
        get height() {
          // Calculate height based on vertical elements × systemCount
          const singleSystemHeight = this.parent.gaps.topMargin +
            this.parent.sizes.cpu +
            this.parent.gaps.cpuToPcie +
            this.parent.sizes.pcie.height +
            this.parent.gaps.pcieToGpu +
            this.parent.sizes.gpu.height +
            this.parent.gaps.gpuToNvswitch +
            this.parent.sizes.nvswitch.height +
            this.parent.gaps.bottomMargin;

          return singleSystemHeight * this.parent.systemCount +
            this.parent.gaps.systemGap * (this.parent.systemCount - 1);
        },
        parent: null  // Will be set to CONFIG
      },

      // System replication
      systemCount: 2,      // Number of complete systems (each has 2 ensembles)
      ensembleCount: 2,    // Number of ensembles per system (each ensemble = CPU + 4 groups + 2 NVSwitches)
      groupCount: 4,       // Groups per ensemble
      nvswitchCount: 2,    // NVSwitches per ensemble

      // Node sizes (all based on CPU size)
      sizes: {
        cpu: 80,
        get pcie() { return { width: this.cpu * 0.75, height: this.cpu * 0.625 * 3 }; },
        get gpu() { return { width: this.cpu, height: this.cpu }; },
        get efa() { return { width: 60, height: 30 }; },
        get nvme() { return { width: 60, height: 30 }; },
        get nvswitch() { return { width: 100, height: 60 }; }
      },

      // Gaps and spacing
      gaps: {
        topMargin: 0,        // Margin from top to CPU
        cpuToPcie: 80,        // Vertical gap CPU → PCIe
        pcieToGpu: 80,        // Vertical gap PCIe → GPU
        gpuToNvswitch: 200,    // Vertical gap GPU → NVSwitch
        bottomMargin: 40,     // Margin from NVSwitch to bottom
        horizontal: 230,      // Horizontal gap between groups
        ensembleGap: 50,     // Horizontal gap between ensembles (within a system)
        systemGap: 30,       // Horizontal gap between complete systems
        connectionOffset: 15  // Gap between node edge and arrow anchor
      },

      // Group layout offsets (all relative positions within a group)
      layout: {
        pcieOffsetX: -40,      // PCIe X offset from group center (to the left)
        efaNvmeOffsetX: 60,    // EFA/NVMe X offset from group center (to the right)
        efaOffsetY: -30,       // EFA Y offset from PCIe Y (above)
        nvmeOffsetY: 30,       // NVMe Y offset from PCIe Y (below)
        groupPadding: 20       // Padding around group bounding box
      },

      // Debug mode
      debug: {
        showPhantoms: false    // Set to true to visualize phantom nodes
      },

      // Highlight paths (for interactive buttons)
      paths: {
        'cpu-gpu': {
          label: 'CPU ⟷ GPU',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'gpu'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' }
          ]
        },
        'gpu-gpu-cpu': {
          label: 'GPU ⟷ GPU via CPU',
          requiredEnsembles: 1,  // Need only 1 ensemble (2 groups within)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'cpu', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'pcie', to: 'cpu' },
            { from: 'cpu', to: 'pcie' },
            { from: 'cpu', to: 'pcie-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-nvswitch': {
          label: 'GPU ⟷ GPU via NVSwitch',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'nvswitch-0', 'gpu-1'],
          links: [
            { from: 'gpu', to: 'nvswitch-0' },
            { from: 'gpu-1', to: 'nvswitch-0' }
          ]
        },
        'gpu-gpu-efa': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-1', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-1', to: 'efa-external-1' },
            { from: 'efa-1', to: 'pcie-efa-phantom-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-efa-intranode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles (same system)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-4', 'pcie-4', 'gpu-4'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-4' },  // EFA cross-link between ensembles (12.5GB/s)
            { from: 'efa-4', to: 'efa-external-4' },
            { from: 'efa-4', to: 'pcie-efa-phantom-4' },
            { from: 'pcie-4', to: 'gpu-4' }
          ]
        },
        'gpu-gpu-efa-internode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles per system
          requiredSystems: 2,    // Need 2 systems
          nodes: ['gpu', 'pcie', 'efa', 'efa-8', 'pcie-8', 'gpu-8'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-8' },  // EFA cross-link between systems
            { from: 'efa-8', to: 'efa-external-8' },
            { from: 'efa-8', to: 'pcie-efa-phantom-8' },
            { from: 'pcie-8', to: 'gpu-8' }
          ]
        },
        'gpu-storage': {
          label: 'GPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'nvme'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'cpu-storage': {
          label: 'CPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'gpu-cpu-storage': {
          label: 'GPU ⟷ Storage via CPU',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'gpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        }
      },


      // Bandwidth levels
      bandwidths: [
        { speed: '900GB/s', label: 'NVLink 4.0', width: 9 },
        { speed: '64GB/s', label: 'PCIe Gen5', width: 6 },
        { speed: '16GB/s', label: 'PCIe Gen4', width: 3 },
        { speed: '12.5GB/s', label: 'EFA Link', width: 1.25 }
      ],

      // Link definitions for groups
      groupLinks: [
        { from: 'cpu', to: 'pcie', bandwidth: '16GB/s', type: 'cpu', fromSide: 'bottom', toSide: 'top', multiLink: true },
        { from: 'efa', to: 'pcie-efa-phantom', bandwidth: '16GB/s', type: 'network', fromSide: 'left', toSide: 'right', stacked: 4 },
        { from: 'nvme', to: 'pcie-nvme-phantom', bandwidth: '16GB/s', type: 'storage', fromSide: 'left', toSide: 'right' },
        { from: 'pcie', to: 'gpu', bandwidth: '64GB/s', type: 'gpu', fromSide: 'bottom', toSide: 'top' },
        { from: 'efa', to: 'efa-external', bandwidth: '12.5GB/s', type: 'network', fromSide: 'right', toSide: 'left', stacked: 4 }
      ],

      // GPU to NVSwitch links (full mesh)
      gpuNvswitchLink: {
        bandwidth: '900GB/s',
        type: 'gpu',
        fromSide: 'bottom',
        toSide: 'top'
      },

      // Colors (using CSS variables for dark mode compatibility)
      colors: {
        // Node colors
        nodeFill: 'var(--page-bg)',
        nodeStroke: 'var(--muted-color)',     // More contrast than border-color
        nodeText: 'var(--text-color)',
        nodePins: 'var(--muted-color)',
        nodeCoreFill: 'rgba(0, 0, 0, 0.05)',  // Very light gray for cores
        nodeCoreStroke: 'rgba(0, 0, 0, 0.2)', // More visible border for cores

        // Link colors
        linkColor: 'var(--primary-color)',
        linkCircleBorder: 'rgba(0, 0, 0, 0.1)', // Border for link circles

        // Group border
        groupBorder: 'var(--border-color)',

        // Phantom debug
        phantomFill: 'rgba(255, 0, 255, 0.2)',
        phantomStroke: 'magenta'
      },

      // Real bandwidth data for display
      realBandwidths: {
        'cpu-gpu': '14.2GB/s',
        'gpu-gpu-same-node': '786GB/s',
        'gpu-gpu-efa-intranode': '40GB/s',
        'gpu-gpu-efa-internode': '40GB/s',
        'allreduce-same-node': '480GB/s',
        'all2all-same-node': '340GB/s',
        'allreduce-internode': '320GB/s',
        'alltoall-internode': '45GB/s',
        'gpu-storage': '14.2GB/s'
      }
    };

    // Initialize viewbox parent reference
    CONFIG.viewbox.parent = CONFIG;

    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================
    function getBandwidth(speed) {
      const bw = CONFIG.bandwidths.find(b => b.speed === speed);
      if (bw) {
        // Add numericValue for comparison
        bw.numericValue = parseFloat(bw.speed.replace('GB/s', ''));
      }
      return bw;
    }

    // Calculate connection offset proportional to link width
    function getLinkOffset(linkWidth) {
      const minOffset = 5;   // Minimum offset for thin links
      const maxOffset = 20;  // Maximum offset for thick links

      // Proportional offset: thinner links = smaller offset
      const proportionalOffset = minOffset + (linkWidth / 10) * (maxOffset - minOffset);
      return Math.min(Math.max(proportionalOffset, minOffset), maxOffset);
    }

    // ============================================================================
    // EFA CROSS-LINKS HELPER
    // ============================================================================
    function drawEfaCrossLinks(renderer, fromId, toId, linkType = 'efa-crosslink') {
      const phantom0 = renderer.nodes.get(fromId);
      const phantom1 = renderer.nodes.get(toId);

      if (!phantom0 || !phantom1) return;

      const efaBw = getBandwidth('12.5GB/s');
      const efaColor = CONFIG.colors.linkColor;

      // Draw 4 stacked links manually (EFA has 4 connections) - randomized order
      const stackCount = 4;
      const spacing = 6; // Fixed spacing between stacked links
      const verticalShift = -95; // Shift up to align with EFA nodes
      const horizontalShift = -40; // Shift left to better position the arrows
      const horizontalExtension = 20; // Extend arrows horizontally on each side

      // Create array of indices and randomize
      const linkIndices = Array.from({ length: stackCount }, (_, i) => i);
      const shuffledIndices = linkIndices.sort(() => Math.random() - 0.5);

      // Draw horizontal lines with vertical offset for stacking
      shuffledIndices.forEach(i => {
        const offsetY = (i - (stackCount - 1) / 2) * spacing;

        const efaCrossGroup = renderer.crossLinksGroup.group();
        efaCrossGroup.attr('data-link-type', linkType);
        efaCrossGroup.attr('data-from', fromId);
        efaCrossGroup.attr('data-to', toId);
        efaCrossGroup.attr('data-bandwidth', '12.5GB/s');
        efaCrossGroup.attr('data-label', 'EFA Link');

        // Draw line with vertical offset for stacking + shifts + horizontal extension
        const x0 = phantom0.x + horizontalShift;
        const x1 = phantom1.x + horizontalShift + horizontalExtension;
        const y0 = phantom0.y + offsetY + verticalShift;
        const y1 = phantom1.y + offsetY + verticalShift;

        // Draw border
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: efaColor, width: efaBw.width, opacity: 1 });

        // Draw circles at both ends
        const r = efaBw.width * 0.8;
        const startCircle = efaCrossGroup.circle(r * 2).move(x0 - r, y0 - r);
        startCircle.fill(efaColor);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = efaCrossGroup.circle(r * 2).move(x1 - r, y1 - r);
        endCircle.fill(efaColor);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');
      });

      // Add vertical bars at both ends (connect horizontal arrows to EFA phantoms)
      const barColor = CONFIG.colors.linkColor;

      shuffledIndices.forEach(i => {
        const offsetX = (i - (stackCount - 1) / 2) * spacing + 12; // Horizontal offset for vertical bars
        const yHorizontal = phantom0.y + verticalShift + 10;
        const yPhantom = phantom0.y + 8; // End a bit higher (5px above phantom center)

        // Left vertical bar (one per horizontal arrow)
        const leftBarGroup = renderer.crossLinksGroup.group();
        leftBarGroup.attr('data-link-type', linkType);
        leftBarGroup.attr('data-from', fromId);
        leftBarGroup.attr('data-to', toId);
        leftBarGroup.attr('data-bandwidth', '12.5GB/s');
        leftBarGroup.attr('data-label', 'EFA Link');

        const x0 = phantom0.x + horizontalShift + offsetX;

        // Draw border
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const r = efaBw.width * 0.8;
        const bottomCircle0 = leftBarGroup.circle(r * 2).move(x0 - r, yPhantom - r);
        bottomCircle0.fill(barColor);
        bottomCircle0.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle0.attr('data-link-circle', 'true');

        // Right vertical bar (one per horizontal arrow)
        const rightBarGroup = renderer.crossLinksGroup.group();
        rightBarGroup.attr('data-link-type', linkType);
        rightBarGroup.attr('data-from', fromId);
        rightBarGroup.attr('data-to', toId);
        rightBarGroup.attr('data-bandwidth', '12.5GB/s');
        rightBarGroup.attr('data-label', 'EFA Link');

        const x1 = phantom1.x + horizontalShift + offsetX;

        // Draw border
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const bottomCircle1 = rightBarGroup.circle(r * 2).move(x1 - r, yPhantom - r);
        bottomCircle1.fill(barColor);
        bottomCircle1.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle1.attr('data-link-circle', 'true');
      });
    }

    // ============================================================================
    // SVG HELPERS
    // ============================================================================
    class TopologyRenderer {
      constructor(draw) {
        this.draw = draw;
        this.nodes = new Map();
        this.structuralGroup = draw.group();  // Structural elements (Node/NUMA borders, never ghosted)
        this.structuralGroup.attr('data-group', 'structural');
        this.baseLinksGroup = draw.group();   // Base links layer (will be ghosted)
        this.baseLinksGroup.attr('data-group', 'base-links');
        this.linksGroup = this.baseLinksGroup; // Alias for compatibility
        this.nodesGroup = draw.group();   // Nodes layer (middle)
        this.phantomsGroup = draw.group(); // Phantoms layer (for debug)
        this.baseCrossLinksGroup = draw.group(); // Base EFA cross-links layer
        this.baseCrossLinksGroup.attr('data-group', 'base-cross-links');
        this.crossLinksGroup = this.baseCrossLinksGroup; // Alias for compatibility
        this.activeLinksGroup = draw.group(); // Active (duplicated) links layer (top, non-ghosted)
        this.activeLinksGroup.attr('data-group', 'active-links');
      }

      // Draw a simple rectangular node
      // Helper: Draw text with consistent styling
      drawText(x, y, label, group = this.nodesGroup) {
        if (!label) return;

        const lines = label.split('\n');
        lines.forEach((line, i) => {
          group.text(line)
            .font({ family: 'Inter, sans-serif', size: 12, weight: '600', anchor: 'middle' })
            .fill(CONFIG.colors.nodeText)
            .cx(x)
            .cy(y + (i - (lines.length - 1) / 2) * 14);
        });
      }

      // Helper: Draw pins around a node
      drawPins(x, y, width, height, pinConfig = {}, targetGroup = null) {
        const group = targetGroup || this.nodesGroup;

        const defaultConfig = {
          pinsPerSide: width >= 80 ? 18 : 15,
          pinLength: 3,
          pinOffset: width / 2 + 1.5,
          pinPadding: 12
        };

        const config = { ...defaultConfig, ...pinConfig };
        const pinStartOffset = -width / 2 + config.pinPadding;
        const pinEndOffset = width / 2 - config.pinPadding;
        const pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);

        const sides = [
          { side: 'left', xOffset: -config.pinOffset, yOffset: 0 },
          { side: 'right', xOffset: config.pinOffset, yOffset: 0 },
          { side: 'top', xOffset: 0, yOffset: -config.pinOffset },
          { side: 'bottom', xOffset: 0, yOffset: config.pinOffset }
        ];

        sides.forEach(({ side, xOffset, yOffset }) => {
          for (let i = 0; i < config.pinsPerSide; i++) {
            const pinX = x + xOffset + (side === 'left' || side === 'right' ? 0 : pinStartOffset + (i * pinSpacing));
            const pinY = y + yOffset + (side === 'top' || side === 'bottom' ? 0 : pinStartOffset + (i * pinSpacing));

            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      drawNode(id, x, y, width, height, label, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      drawNodeWithPins(id, x, y, width, height, label, pinConfig = {}, nodeType = '') {
        const node = this.drawNode(id, x, y, width, height, label, nodeType);
        this.drawPins(x, y, width, height, pinConfig);
        return node;
      }

      drawNodeWithCores(id, x, y, width, height, label, coreConfig = {}, nodeType = '') {
        // Draw main node
        const node = this.drawNode(id, x, y, width, height, label, nodeType);

        // Default core configuration
        const defaultCoreConfig = {
          coresX: 2,              // 2x2 for CPU, 8x8 for GPU
          coresY: 2,
          coreSpacing: 2,         // Space between cores
          coreMargin: 8           // Margin from node edges
        };

        const config = { ...defaultCoreConfig, ...coreConfig };

        // Calculate core size
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coreSpacing * (config.coresX - 1))) / config.coresX;
        const coreHeight = (availableHeight - (config.coreSpacing * (config.coresY - 1))) / config.coresY;

        // Draw cores
        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            this.nodesGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        return node;
      }

      drawProcessorNode(id, x, y, width, height, label, type = 'cpu') {
        // Create main group for the node
        const nodeGroup = this.nodesGroup.group();
        nodeGroup.attr('id', id);
        nodeGroup.attr('data-node-type', type);

        // Draw node background
        nodeGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Draw cores
        const coreConfig = type === 'gpu' ? { coresX: 8, coresY: 8 } : { coresX: 2, coresY: 2 };
        const config = { coreSpacing: 2, coreMargin: 8, ...coreConfig };
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coresX - 1) * config.coreSpacing) / config.coresX;
        const coreHeight = (availableHeight - (config.coresY - 1) * config.coreSpacing) / config.coresY;

        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            nodeGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        // Draw pins in the same group
        this.drawPins(x, y, width, height, {}, nodeGroup);

        // Draw text on top
        this.drawText(x, y, label, nodeGroup);

        // Store node position
        this.nodes.set(id, { x, y, width, height });

        return nodeGroup;
      }

      // Add pins to an existing node (without changing the node design)
      addPinsToNode(nodeId, pinConfig = {}) {
        const node = this.nodes.get(nodeId);
        if (!node) return;

        // Find the node's SVG group
        const svg = getElement('aws-topology-container').querySelector('svg');
        if (!svg) return;
        const nodeGroup = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeGroup) return;

        // Use SVG.js to manipulate the group
        const group = this.draw.findOne(`#${nodeId}`);
        if (!group) return;

        // Default pin configuration
        const defaultPinConfig = {
          pinsPerSide: node.width >= 80 ? 18 : 15,
          sides: ['left', 'right', 'top', 'bottom'],
          pinLength: 3,
          pinPadding: 12
        };

        const config = { ...defaultPinConfig, ...pinConfig };

        // Generate pins on specified sides only
        config.sides.forEach(side => {
          let pinSpacing, pinStartOffset, pinEndOffset;

          if (side === 'left' || side === 'right') {
            pinStartOffset = -node.height / 2 + config.pinPadding;
            pinEndOffset = node.height / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          } else {
            pinStartOffset = -node.width / 2 + config.pinPadding;
            pinEndOffset = node.width / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          }

          for (let i = 0; i < config.pinsPerSide; i++) {
            let pinX, pinY;

            if (side === 'left') {
              pinX = node.x - node.width / 2 - 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'right') {
              pinX = node.x + node.width / 2 + 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'top') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y - node.height / 2 - 1.5;
            } else if (side === 'bottom') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y + node.height / 2 + 1.5;
            }

            // Draw pin in the node's group
            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      // Draw a stacked node (visual stack effect)
      drawStackedNode(id, x, y, width, height, label, stackCount, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        for (let i = stackCount - 1; i >= 0; i--) {
          const offsetY = i * 3;
          group.rect(width, height)
            .move(x - width / 2, y - height / 2 + offsetY)
            .fill(CONFIG.colors.nodeFill)
            .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
            .radius(4)
            .opacity(1);
        }

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw a storage node (NVMe) with internal rectangle
      drawStorageNode(id, x, y, width, height, label, nodeType = 'storage') {
        const group = this.nodesGroup.group();
        group.attr('id', id);
        if (nodeType) group.attr('data-node-type', nodeType);

        // Main node background
        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Internal rectangle on the left side (flush with edge)
        const internalRectWidth = 5;
        const internalRectHeight = height * .6; // Full height
        const internalRectX = x - width / 2; // Flush with left edge
        const internalRectY = y - height / 2 + height * .20;

        group.rect(internalRectWidth, internalRectHeight)
          .move(internalRectX, internalRectY)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: '#ffffff', width: 1 })
          .opacity(.4)
          .radius(0); // No radius

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw background rectangle
      drawBackground(id, x, y, width, height) {
        const bg = this.linksGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 2,
            dasharray: '5,5'
          })
          .radius(8);

        this.nodes.set(id, { x, y, width, height });
        return bg;
      }

      // Get connection point on a node's side with configurable offset and multi-link spacing
      getPoint(nodeId, side, offset = CONFIG.gaps.connectionOffset, linkIndex = 0, totalLinks = 1) {
        const node = this.nodes.get(nodeId);
        if (!node) return { x: 0, y: 0 };

        const points = {
          top: { x: node.x, y: node.y - node.height / 2 - offset },
          right: { x: node.x + node.width / 2 + offset, y: node.y },
          bottom: { x: node.x, y: node.y + node.height / 2 + offset },
          left: { x: node.x - node.width / 2 - offset, y: node.y }
        };

        let basePoint = points[side] || { x: node.x, y: node.y };

        // Apply spacing for multiple links to the same anchor
        if (totalLinks > 1) {
          const isVerticalAnchor = (side === 'top' || side === 'bottom');

          // Vertical anchors (top/bottom) space horizontally, horizontal anchors (left/right) space vertically
          const spacing = isVerticalAnchor ? node.width / (totalLinks + 1) : node.height / (totalLinks + 1);
          const linkOffset = (linkIndex - (totalLinks - 1) / 2) * spacing;

          // Apply offset in the perpendicular direction to the anchor
          if (isVerticalAnchor) {
            basePoint.x += linkOffset;  // Horizontal offset for vertical anchors
          } else {
            basePoint.y += linkOffset;  // Vertical offset for horizontal anchors
          }
        }

        return basePoint;
      }

      // Draw single link with optional multi-link spacing
      drawLink(fromId, toId, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, fromLinkIndex = 0, fromTotalLinks = 1, toLinkIndex = 0, toTotalLinks = 1, linkType = '', bandwidth = '') {
        const start = this.getPoint(fromId, fromSide, offset, fromLinkIndex, fromTotalLinks);
        const end = this.getPoint(toId, toSide, offset, toLinkIndex, toTotalLinks);

        const group = this.linksGroup.group();
        if (linkType) group.attr('data-link-type', linkType);
        if (bandwidth) {
          group.attr('data-bandwidth', bandwidth);
          // Find label from bandwidth config
          const bwConfig = getBandwidth(bandwidth);
          if (bwConfig && bwConfig.label) {
            group.attr('data-label', bwConfig.label);
          }
        }
        group.attr('data-from', fromId);
        group.attr('data-to', toId);

        // Check if this is a vertical connection (GPU-NVSwitch or CPU-PCIe)
        const isVerticalConnection = fromSide === 'bottom' && toSide === 'top';

        if (isVerticalConnection) {
          // Use curved paths for vertical connections
          const curvature = 45; // Fixed curvature value for consistent curve strength

          // Create a smooth cubic bezier curve with vertical control points
          const pathData = `M ${start.x} ${start.y} C ${start.x} ${start.y + curvature}, ${end.x} ${end.y - curvature}, ${end.x} ${end.y}`;

          // Draw border (wider path behind)
          group.path(pathData)
            .fill('none')
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main path on top
          group.path(pathData)
            .fill('none')
            .stroke({ color, width, opacity: 1 });
        } else {
          // Draw straight lines for other connections
          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });
        }

        const r = width * 0.8;
        const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');

        return group;
      }

      // Draw stacked links
      drawStackedLinks(fromId, toId, count, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, linkType = '', bandwidth = '') {
        const fromNode = this.nodes.get(fromId);
        const toNode = this.nodes.get(toId);
        if (!fromNode || !toNode) return [];

        const isHorizontal = (fromSide === 'left' || fromSide === 'right') &&
          (toSide === 'left' || toSide === 'right');
        const spacing = isHorizontal
          ? Math.min(fromNode.height, toNode.height) / (count + 1)
          : Math.min(fromNode.width, toNode.width) / (count + 1);

        const arrows = [];
        for (let i = 0; i < count; i++) {
          const stackOffset = (i - (count - 1) / 2) * spacing;
          let start = this.getPoint(fromId, fromSide, offset);
          let end = this.getPoint(toId, toSide, offset);

          if (isHorizontal) {
            start.y += stackOffset;
            end.y += stackOffset;
          } else {
            start.x += stackOffset;
            end.x += stackOffset;
          }

          const group = this.linksGroup.group();
          if (linkType) group.attr('data-link-type', linkType);
          if (bandwidth) {
            group.attr('data-bandwidth', bandwidth);
            // Find label from bandwidth config
            const bwConfig = getBandwidth(bandwidth);
            if (bwConfig && bwConfig.label) {
              group.attr('data-label', bwConfig.label);
            }
          }
          group.attr('data-from', fromId);
          group.attr('data-to', toId);

          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });

          const r = width * 0.8;
          const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
          startCircle.fill(color);
          startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          startCircle.attr('data-link-circle', 'true');

          const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
          endCircle.fill(color);
          endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          endCircle.attr('data-link-circle', 'true');

          arrows.push(group);
        }
        return arrows;
      }

      // Add phantom node (invisible connection point)
      addPhantom(id, x, y, width = 30, height = 30) {
        this.nodes.set(id, { x, y, width, height });

        // Draw phantom for debug visualization
        if (CONFIG.debug.showPhantoms) {
          this.phantomsGroup.rect(width, height)
            .move(x - width / 2, y - height / 2)
            .fill('rgba(255, 0, 255, 0.2)')  // Semi-transparent magenta
            .stroke({ color: 'magenta', width: 2, dasharray: '4,4' })
            .radius(4);

          // Add label
          this.phantomsGroup.text(id)
            .move(x, y)
            .font({
              family: 'system-ui, -apple-system, sans-serif',
              size: 10,
              anchor: 'middle',
              fill: 'magenta',
              weight: 'bold'
            })
            .dy(-height / 2 - 5);
        }
      }
    }

    // ============================================================================
    // DRAW SINGLE GROUP
    // ============================================================================
    function drawGroup(renderer, globalIndex, localIndex, x, cpuY, nvswitchY, cpuId = 'cpu') {
      const s = CONFIG.sizes;
      const g = CONFIG.gaps;
      const l = CONFIG.layout;
      const suffix = globalIndex > 0 ? `-${globalIndex}` : '';

      // Calculate Y positions
      const pcieY = cpuY + s.cpu / 2 + g.cpuToPcie + s.pcie.height / 2;
      const gpuY = pcieY + s.pcie.height / 2 + g.pcieToGpu + s.gpu.height / 2;

      // Calculate node positions
      const pcieX = x + l.pcieOffsetX;
      const efaX = x + l.efaNvmeOffsetX;
      const nvmeX = x + l.efaNvmeOffsetX;
      const efaY = pcieY + l.efaOffsetY;
      const nvmeY = pcieY + l.nvmeOffsetY;

      // Calculate bounding box BEFORE creating nodes
      const nodeBounds = [
        { x: pcieX, y: pcieY, width: s.pcie.width, height: s.pcie.height },
        { x: efaX, y: efaY, width: s.efa.width, height: s.efa.height },
        { x: nvmeX, y: nvmeY, width: s.nvme.width, height: s.nvme.height },
        { x: pcieX, y: gpuY, width: s.gpu.width, height: s.gpu.height }
      ];

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      nodeBounds.forEach(node => {
        minX = Math.min(minX, node.x - node.width / 2);
        maxX = Math.max(maxX, node.x + node.width / 2);
        minY = Math.min(minY, node.y - node.height / 2);
        maxY = Math.max(maxY, node.y + node.height / 2);
      });

      const bgWidth = maxX - minX + l.groupPadding * 2;
      const bgHeight = maxY - minY + l.groupPadding * 2;
      const bgCenterX = (minX + maxX) / 2;
      const bgCenterY = (minY + maxY) / 2;

      // Draw background FIRST (will be behind nodes)
      renderer.drawBackground(`group${suffix}`, bgCenterX, bgCenterY, bgWidth, bgHeight);

      // Nodes
      renderer.drawNode(`pcie${suffix}`, pcieX, pcieY, s.pcie.width, s.pcie.height, 'PCIe\nSwitch', 'network');
      renderer.addPinsToNode(`pcie${suffix}`, {
        pinsPerSide: 6,
        sides: ['left', 'right'],
        pinLength: 3,
        pinPadding: 8
      });
      renderer.drawStackedNode(`efa${suffix}`, efaX, efaY, s.efa.width, s.efa.height, 'EFA', 4, 'network');
      renderer.drawStorageNode(`nvme${suffix}`, nvmeX, nvmeY, s.nvme.width, s.nvme.height, 'NVMe', 'storage');
      renderer.drawProcessorNode(`gpu${suffix}`, pcieX, gpuY, s.gpu.width, s.gpu.height, 'GPU', 'gpu');

      // Phantom nodes for routing
      // PCIe phantoms: bord gauche aligné avec PCIe, largeur du PCIe
      const pcieLeftEdge = pcieX;
      const pciePhantomX = pcieLeftEdge;
      renderer.addPhantom(`pcie-efa-phantom${suffix}`, pciePhantomX, efaY, s.pcie.width, s.efa.height);
      renderer.addPhantom(`pcie-nvme-phantom${suffix}`, pciePhantomX, nvmeY, s.pcie.width, s.nvme.height);

      // EFA external phantom: à droite de EFA
      const efaRightEdge = efaX + s.efa.width / 2;
      const efaPhantomX = efaRightEdge + g.connectionOffset + s.efa.width / 2 + 20;  // Centre du phantom + décalage réduit
      renderer.addPhantom(`efa-external${suffix}`, efaPhantomX, efaY, s.efa.width, s.efa.height);

      // Create links from configuration
      CONFIG.groupLinks.forEach(linkDef => {
        const bw = getBandwidth(linkDef.bandwidth);
        const fromId = linkDef.from === 'cpu' ? cpuId : `${linkDef.from}${suffix}`;  // Use cpuId from parameter
        const toId = `${linkDef.to}${suffix}`;
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const offset = getLinkOffset(bw.width);  // Proportional offset based on link width

        if (linkDef.stacked) {
          renderer.drawStackedLinks(fromId, toId, linkDef.stacked, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, linkDef.type, linkDef.bandwidth);
        } else if (linkDef.multiLink) {
          // Use localIndex for multi-link spacing (0-3 within ensemble)
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, localIndex, CONFIG.groupCount, 0, 1, linkDef.type, linkDef.bandwidth);
        } else {
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, 0, 1, 0, 1, linkDef.type, linkDef.bandwidth);
        }
      });
    }

    // ============================================================================
    // DRAW SINGLE ENSEMBLE (CPU + 4 groups + 2 NVSwitches)
    // ============================================================================
    function drawEnsemble(renderer, ensembleGlobalIndex, centerX, cpuY, nvswitchY) {
      const cpuId = ensembleGlobalIndex === 0 ? 'cpu' : `cpu-${ensembleGlobalIndex}`;

      // CPU for this ensemble
      renderer.drawProcessorNode(cpuId, centerX, cpuY, CONFIG.sizes.cpu, CONFIG.sizes.cpu, 'CPU', 'cpu');

      // Groups for this ensemble
      for (let i = 0; i < CONFIG.groupCount; i++) {
        const groupGlobalIndex = ensembleGlobalIndex * CONFIG.groupCount + i;
        const offsetX = (i - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal;
        drawGroup(renderer, groupGlobalIndex, i, centerX + offsetX, cpuY, nvswitchY, cpuId);  // Pass i as localIndex
      }

      // NVSwitches: positioned between pairs of groups
      for (let i = 0; i < CONFIG.nvswitchCount; i++) {
        const nvswitchGlobalIndex = ensembleGlobalIndex * CONFIG.nvswitchCount + i;
        const groupPairStart = i * 2;
        const groupPairEnd = groupPairStart + 1;

        const group1X = centerX + ((groupPairStart - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const group2X = centerX + ((groupPairEnd - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const nvswitchX = (group1X + group2X) / 2;

        renderer.drawNode(`nvswitch-${nvswitchGlobalIndex}`, nvswitchX, nvswitchY,
          CONFIG.sizes.nvswitch.width, CONFIG.sizes.nvswitch.height, 'NVSwitch', 'network');

        // Add pins to NVSwitch (like PCIe Switch)
        renderer.addPinsToNode(`nvswitch-${nvswitchGlobalIndex}`, {
          pinsPerSide: 6,
          sides: ['left', 'right'],
          pinLength: 3,
          pinPadding: 8
        });
      }

    }


    // ============================================================================
    // DRAW SINGLE SYSTEM (variable number of ensembles)
    // ============================================================================
    function drawSystem(renderer, systemIndex, systemCenterX, cpuY, nvswitchY, ensembleCount = 1, systemCount = 1, shouldDrawEfaCrossLinks = false) {
      // For internode (2 systems), only show 1 ensemble per system for clarity
      const ensemblesToShow = (systemCount === 2) ? 1 : ensembleCount;

      // Calculate ensemble width (4 groups)
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;

      // Calculate system bounding box based on actual ensembles shown
      const systemWidth = ensemblesToShow * ensembleWidth + (ensemblesToShow - 1) * CONFIG.gaps.ensembleGap;
      const systemHeight = CONFIG.sizes.cpu + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height;

      const systemBgCenterY = cpuY + (nvswitchY - cpuY) / 2;
      const systemPadding = 30;

      // In internode mode, extend the rectangle slightly to the right
      const isInternode = systemCount === 2;
      const extraWidth = isInternode && ensembleCount === 2 ? 210 : 0;

      // Draw system background ONLY if 2 ensembles (intra-node vs inter-node distinction)
      if (ensembleCount === 2) {
        // Adjust rectX to center the extended rectangle
        const totalWidth = systemWidth + systemPadding * 2 + extraWidth;
        const rectX = systemCenterX - totalWidth / 2;
        const rectY = systemBgCenterY - (systemHeight + systemPadding * 2) / 2;
        const rectWidth = totalWidth;
        const rectHeight = systemHeight + systemPadding * 2;

        renderer.structuralGroup.rect(rectWidth, rectHeight)
          .move(rectX, rectY)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 3,
            opacity: 1
          })
          .radius(12)
          .attr('data-group-border', 'node');

        // Add "Node" label at top left of the system box
        renderer.nodesGroup.text('Node')
          .move(rectX + 35, rectY + 40)
          .font({
            size: 32,
            family: 'var(--font-family)',
            weight: 900,
            fill: CONFIG.colors.textSecondary
          })
          .opacity(0.8);

        // Add NUMA 1 group with "..." in the extended area for internode mode
        if (isInternode) {
          const numaPadding = 15;
          const numaWidth = extraWidth - 15; // Margin for spacing
          const numaHeight = systemHeight;

          const numaX = rectX + rectWidth - extraWidth; // Left margin
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth;
          const numaRectHeight = numaHeight + numaPadding * 2;

          // Draw NUMA 1 border
          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA 1" label at top right
          renderer.nodesGroup.text('NUMA 1')
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);

          // Add "..." centered in NUMA 1
          renderer.nodesGroup.text('...')
            .move(numaX + numaRectWidth / 2, numaY + numaRectHeight / 2)
            .font({
              size: 40,
              family: 'var(--font-family)',
              weight: 900,
              fill: CONFIG.colors.textSecondary,
              anchor: 'middle'
            })
            .opacity(0.6);
        }
      }

      // Draw each ensemble in the system
      for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
        const ensembleGlobalIndex = systemIndex * CONFIG.ensembleCount + ensIndex;

        // Position ensemble within system
        let ensembleCenterX;
        if (isInternode) {
          // In internode mode, align NUMA 0 to the left of the Node rectangle
          const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
          ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
        } else {
          // Normal centered positioning
          const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
          ensembleCenterX = systemCenterX + ensembleOffsetX;
        }

        drawEnsemble(renderer, ensembleGlobalIndex, ensembleCenterX, cpuY, nvswitchY);
      }

      // Draw NUMA node borders (one per ensemble) if 2 ensembles
      if (ensembleCount === 2) {
        for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
          let ensembleCenterX;
          if (isInternode) {
            // In internode mode, align NUMA 0 to the left
            const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
            ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
          } else {
            // Normal centered positioning
            const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
            ensembleCenterX = systemCenterX + ensembleOffsetX;
          }

          // Calculate NUMA node bounding box (same as system but for single ensemble)
          const numaWidth = ensembleWidth;
          const numaHeight = systemHeight;
          const numaPadding = 15;

          const numaX = ensembleCenterX - (numaWidth + numaPadding * 2) / 2;
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth + numaPadding * 2;
          const numaRectHeight = numaHeight + numaPadding * 2;

          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA" label at top right
          renderer.nodesGroup.text(`NUMA ${ensIndex}`)
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);
        }
      }

      // GPU to NVSwitch connections (full mesh - all GPUs to all NVSwitches in system)
      const linkDef = CONFIG.gpuNvswitchLink;
      const bw = getBandwidth(linkDef.bandwidth);
      const color = CONFIG.colors.linkColor;
      const offset = getLinkOffset(bw.width);

      // Connect all GPUs in the system to all NVSwitches in the system
      const totalGpusInSystem = ensemblesToShow * CONFIG.groupCount;
      const totalNVSwitchesInSystem = ensemblesToShow * CONFIG.nvswitchCount;

      // Collect all GPU-NVSwitch connections for randomized drawing
      const gpuNvswitchConnections = [];
      for (let gpuIndex = 0; gpuIndex < totalGpusInSystem; gpuIndex++) {
        const gpuGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + gpuIndex;
        const gpuId = gpuGlobalIndex === 0 ? 'gpu' : `gpu-${gpuGlobalIndex}`;

        for (let nvIndex = 0; nvIndex < totalNVSwitchesInSystem; nvIndex++) {
          const nvswitchGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.nvswitchCount + nvIndex;
          gpuNvswitchConnections.push({
            fromId: gpuId,
            toId: `nvswitch-${nvswitchGlobalIndex}`,
            color: color,
            width: bw.width,
            fromSide: linkDef.fromSide,
            toSide: linkDef.toSide,
            offset: offset,
            type: linkDef.type,
            bandwidth: linkDef.bandwidth
          });
        }
      }

      // Randomize and draw GPU-NVSwitch connections
      const shuffledGpuNvswitchConnections = gpuNvswitchConnections.sort(() => Math.random() - 0.5);
      shuffledGpuNvswitchConnections.forEach(conn => {
        renderer.drawLink(conn.fromId, conn.toId, conn.color, conn.width, conn.fromSide, conn.toSide, conn.offset, 0, 1, 0, 1, conn.type, conn.bandwidth);
      });

      // Draw CPU-to-CPU link between ensembles (only if 2 ensembles visible)
      if (ensemblesToShow === 2) {
        const cpu0Id = systemIndex * CONFIG.ensembleCount === 0 ? 'cpu' : `cpu-${systemIndex * CONFIG.ensembleCount}`;
        const cpu1Id = `cpu-${systemIndex * CONFIG.ensembleCount + 1}`;

        // Use a bandwidth for CPU-CPU connection (assuming similar to CPU-PCIe)
        const bw = getBandwidth('16GB/s');
        const color = CONFIG.colors.linkColor;
        const offset = getLinkOffset(bw.width);

        renderer.drawLink(cpu0Id, cpu1Id, color, bw.width, 'right', 'left', offset, 0, 1, 0, 1, 'cpu', '16GB/s');

        // Draw EFA-to-EFA link between ensembles (only if 2 ensembles visible and explicitly requested)
        if (ensemblesToShow === 2 && shouldDrawEfaCrossLinks) {
          const efaExt0Id = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount === 0 ? 'efa-external' : `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount}`;
          const efaExt1Id = `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + CONFIG.groupCount}`;

          // Use unified EFA cross-links function
          drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
        }
      }
    }

    // ============================================================================
    // DRAW COMPLETE TOPOLOGY
    // ============================================================================
    let currentEnsembleCount = 2;  // Start with 2 ensembles (1 complete node)
    let currentSystemCount = 1;    // Start with 1 system
    let currentActivePathId = null; // Track active path for conditional rendering
    let showRealBandwidthsOverride = null; // User override via checkbox (null = use config)

    function drawTopology(ensembleCount = currentEnsembleCount, systemCount = currentSystemCount) {
      // Clear existing
      const container = getElement('aws-topology-container');
      container.innerHTML = '';

      // Use FIXED viewbox size for consistent zoom across all modes
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;
      const isInternodeLayout = systemCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode';

      // Calculate single system height (used in both layouts)
      const singleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;

      // Always use max viewbox dimensions for consistent zoom level
      const maxEnsembleWidthForViewbox = 2 * ensembleWidth;
      let viewboxWidth = maxEnsembleWidthForViewbox + CONFIG.gaps.ensembleGap + 200;
      let viewboxHeight = singleSystemHeight;

      // For single ensemble (CPU-GPU, GPU-GPU via CPU, storage paths), zoom in more
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxWidth *= 0.65;  // Zoom in by reducing viewbox width (increased from 0.75)
        viewboxHeight *= 0.65; // Zoom in by reducing viewbox height (increased from 0.75)
      }

      // For 2 systems in vertical layout, use scaled dimensions
      if (systemCount === 2 && !isInternodeLayout) {
        viewboxHeight = singleSystemHeight * 2 + CONFIG.gaps.systemGap;
        viewboxWidth *= 1.15;
        viewboxHeight *= 1.15;
      }

      // For internode horizontal layout, extend viewbox width to accommodate both extended systems
      if (isInternodeLayout) {
        const extraWidth = 210; // Extension per system for NUMA 1
        const systemPadding = 30;
        const singleEnsembleWidth = ensembleWidth;
        const totalSystemWidth = singleEnsembleWidth + systemPadding * 2 + extraWidth;
        const gap = 80;
        viewboxWidth = totalSystemWidth * 2 + gap + 200; // Extra margin for comfort
      }

      // Fixed height based on screen width for better consistency
      const embedConfig = readEmbedConfig();
      const containerWidth = container.clientWidth || 800;

      // Calculate fixed height: use max viewbox dimensions to determine aspect ratio
      // Max viewbox is for 2 ensembles, 2 systems (vertical layout)
      const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
      const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;
      const maxViewboxHeight = maxSingleSystemHeight * 1.15; // Account for 2-system scaling
      const maxViewboxWidth = maxEnsembleWidth + 200;

      const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
      const baseHeight = containerWidth * maxAspectRatio;
      const legendHeight = embedConfig.initialFilter ? 150 : 200;

      // Set fixed height once, won't change on filter change
      if (!container.dataset.heightSet) {
        container.style.height = `${baseHeight + legendHeight}px`;
        container.dataset.heightSet = 'true';
      }

      // Viewbox will auto-center/zoom content
      let viewboxY = 0;
      let paddedViewboxHeight = viewboxHeight;
      const verticalPadding = 0;
      viewboxY = -verticalPadding / 2 + 100;
      paddedViewboxHeight = viewboxHeight + verticalPadding;

      // For single ensemble, shift content up slightly
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxY += 150;  // Shift up by reducing viewboxY (reduced from 80)
      }

      // For single node mode (no Node/NUMA groups), shift content down by 80px
      // BUT only if: 1) not an EFA filter, 2) a filter is active
      const isEfaFilter = currentActivePathId === 'gpu-gpu-efa-intranode' || currentActivePathId === 'gpu-gpu-efa-internode';
      const hasActiveFilter = currentActivePathId && currentActivePathId !== '';
      if (!isInternodeLayout && hasActiveFilter && !isEfaFilter) {
        viewboxY -= 80;  // Shift down by decreasing viewboxY (increased from 50px)
      }

      const draw = SVG().addTo(container).size('100%', '100%').viewbox(0, viewboxY, viewboxWidth, paddedViewboxHeight);
      const renderer = new TopologyRenderer(draw);

      const centerX = viewboxWidth / 2;

      // Draw each system - horizontally for internode, vertically for others
      const isInternodeHorizontalLayout = isInternodeLayout;

      for (let sysIndex = 0; sysIndex < systemCount; sysIndex++) {
        let systemCenterX, cpuY, nvswitchY;

        if (isInternodeHorizontalLayout) {
          // Horizontal layout for internode: systems side by side (rapprochés mais sans overlap)
          // Pour internode, on affiche 1 seul ensemble (NUMA) par système, donc largeur réelle = 50%
          const fullSystemWidth = ensembleCount * ensembleWidth + (ensembleCount - 1) * CONFIG.gaps.ensembleGap;
          const actualSystemWidth = fullSystemWidth * 0.5; // On n'affiche qu'1 ensemble sur 2
          const extraWidth = 210; // Extension pour le groupe NUMA 1
          const systemPadding = 10;
          const totalSystemWidth = actualSystemWidth + systemPadding * 2 + extraWidth; // Largeur totale incluant l'extension
          const gap = 80; // Gap visible entre les systèmes

          // Positionner les systèmes avec le gap (en prenant en compte la largeur totale)
          if (sysIndex === 0) {
            systemCenterX = centerX - (totalSystemWidth / 2 + gap / 2); // Premier système à gauche
          } else {
            systemCenterX = centerX + (totalSystemWidth / 2 + gap / 2); // Deuxième système à droite
          }
          cpuY = CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        } else {
          // Vertical layout for other cases: systems stacked vertically
          const systemOffsetY = sysIndex * (singleSystemHeight + CONFIG.gaps.systemGap);
          systemCenterX = centerX;
          cpuY = systemOffsetY + CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        }

        // Only draw EFA cross-links for intranode EFA path
        const shouldDrawEfaCrossLinks = currentActivePathId === 'gpu-gpu-efa-intranode';
        drawSystem(renderer, sysIndex, systemCenterX, cpuY, nvswitchY, ensembleCount, systemCount, shouldDrawEfaCrossLinks);
      }

      // Draw EFA cross-link between systems (for internode)
      if (systemCount === 2 && ensembleCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode') {
        const efaExt0Id = 'efa-external';  // System 0, ensemble 0, group 0
        const efaExt1Id = 'efa-external-8';  // System 1, ensemble 0, group 0 (4 groups per ensemble, 2 ensembles per system = group 8)

        // Use unified EFA cross-links function
        drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
      }

      currentEnsembleCount = ensembleCount;
      currentSystemCount = systemCount;
    }

    // ============================================================================
    // REAL BANDWIDTH HELPERS
    // ============================================================================
    function getRealBandwidthForPath(pathId) {
      const pathToRealBandwidth = {
        'cpu-gpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-cpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-nvswitch': { value: '786', unit: 'GB/s' },
        'gpu-gpu-efa-intranode': { value: '40', unit: 'GB/s' },
        'gpu-gpu-efa-internode': { value: '40', unit: 'GB/s' },
        'gpu-storage': { value: '14.2', unit: 'GB/s' },
        'cpu-storage': { value: '14.2', unit: 'GB/s' },
        'gpu-cpu-storage': { value: '14.2', unit: 'GB/s' }
      };

      const bandwidth = pathToRealBandwidth[pathId];
      if (bandwidth) {
        return {
          value: bandwidth.value,
          unit: bandwidth.unit
        };
      }
      return null;
    }

    // ============================================================================
    // HIGHLIGHT HELPERS
    // ============================================================================
    function highlightPath(path, pathLabel = '', pathId = '') {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear previous active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Ghost all base links and cross-links groups at once
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '0.35';

        // Increase stroke width of group borders to make them more visible when ghosted
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '5');
          // border.setAttribute('stroke-opacity', '0.8');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '0.25';
      }

      // Dim nodes individually (they're not in a group)
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '0.6';
        // Dim text labels
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '0.25';
        });
      });

      // Highlight path nodes
      path.nodes.forEach(nodeId => {
        let nodeEl = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeEl) {
          const candidates = svg.querySelectorAll(`g[id^="${nodeId}"]`);
          nodeEl = candidates[0];
        }
        if (nodeEl) {
          nodeEl.style.opacity = '1';
          // Restore text opacity
          nodeEl.querySelectorAll('text').forEach(text => {
            text.style.opacity = '1';
          });
        }
      });

      // Duplicate active links into activeLinksGroup
      if (activeLinksGroup) {
        path.links.forEach(linkSpec => {
          // Find matching links in base groups
          const allBaseLinks = [
            ...svg.querySelectorAll('g[data-group="base-links"] > g[data-link-type]'),
            ...svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type]')
          ];

          allBaseLinks.forEach(linkGroup => {
            const linkFrom = linkGroup.getAttribute('data-from');
            const linkTo = linkGroup.getAttribute('data-to');

            const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
            const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

            if (matchesFrom && matchesTo) {
              // Clone the link and append to active group
              const clonedLink = linkGroup.cloneNode(true);
              activeLinksGroup.appendChild(clonedLink);
            }
          });
        });

        // Duplicate EFA cross-links if they match the current path
        const currentPathId = currentActivePathId;
        if (currentPathId === 'gpu-gpu-efa-intranode' || currentPathId === 'gpu-gpu-efa-internode') {
          const efaCrossLinks = svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type="efa-crosslink"]');
          efaCrossLinks.forEach(linkGroup => {
            const clonedLink = linkGroup.cloneNode(true);
            activeLinksGroup.appendChild(clonedLink);
          });
        }
      }

      // Calculate and show bottleneck (minimum bandwidth in the path)
      let minBandwidth = Infinity;
      let minBandwidthValue = null;
      const usedBandwidths = new Set();

      path.links.forEach(linkSpec => {
        svg.querySelectorAll('g[data-link-type]').forEach(linkGroup => {
          const linkFrom = linkGroup.getAttribute('data-from');
          const linkTo = linkGroup.getAttribute('data-to');

          const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
          const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

          if (matchesFrom && matchesTo) {
            const bandwidth = linkGroup.getAttribute('data-bandwidth');
            if (bandwidth) {
              const bw = getBandwidth(bandwidth);
              if (bw && bw.numericValue < minBandwidth) {
                minBandwidth = bw.numericValue;
                minBandwidthValue = bw.speed;
              }
              if (bw) {
                usedBandwidths.add(bw.speed);
              }
            }
          }
        });
      });

      // Highlight all used bandwidths in the legend
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          const bandwidth = legendItem.getAttribute('data-legend-bandwidth');
          if (usedBandwidths.has(bandwidth)) {
            // Used in the path - active
            legendItem.style.opacity = '1';
          } else {
            // Not used - ghosted
            legendItem.style.opacity = '0.4';
          }
        });
      }

      // Show bottleneck info
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      const efficiencyValueEl = bottleneckEl.querySelector('.efficiency-value');

      // Check if real bandwidths are enabled
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (showRealBandwidths) {
        // When real bandwidths are shown, display real bandwidth value directly
        const realBandwidth = getRealBandwidthForPath(pathId);
        if (realBandwidth) {
          bottleneckValueEl.textContent = realBandwidth.value;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');

          // Calculate and display efficiency
          if (minBandwidthValue && efficiencyEl && efficiencyValueEl) {
            const theoreticalBandwidth = parseFloat(minBandwidthValue.replace('GB/s', ''));
            const realBandwidthNum = parseFloat(realBandwidth.value);

            // For EFA (12.5GB/s), multiply by 4 to get total theoretical bandwidth
            const adjustedTheoretical = minBandwidthValue === '12.5GB/s' ? theoreticalBandwidth * 4 : theoreticalBandwidth;

            const efficiency = (realBandwidthNum / adjustedTheoretical) * 100;
            efficiencyValueEl.textContent = `${efficiency.toFixed(1)}%`;
            efficiencyEl.style.display = 'block';
          }
        } else {
          // Fallback if no real bandwidth found
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');
          if (efficiencyEl) {
            efficiencyEl.style.display = 'none';
          }
        }
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      } else {
        // Normal bottleneck display
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        if (minBandwidthValue) {
          const value = minBandwidthValue.replace('GB/s', '');
          // For EFA (12.5GB/s), display as 50 (4 links × 12.5)
          const displayValue = value === '12.5' ? '50' : value;
          bottleneckValueEl.textContent = displayValue;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        } else {
          // Debug: show the module even without bandwidth data
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        }
        // Hide efficiency in normal mode
        if (efficiencyEl) {
          efficiencyEl.style.display = 'none';
        }
      }
    }

    function resetHighlight() {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Restore opacity to base links groups
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '1';

        // Restore original stroke width for group borders
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '3');
          border.setAttribute('stroke-opacity', '1');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '1';
      }

      // Reset nodes opacity
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '1';
        // Reset text opacity
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '1';
        });
      });

      // Clear current active path to ensure EFA cross-links are not drawn
      currentActivePathId = null;

      // Reset legend opacity
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          legendItem.style.opacity = '1';
        });
      }

      // Hide bottleneck (unless real bandwidths are enabled)
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (!showRealBandwidths) {
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        bottleneckEl.classList.remove('visible');
      } else {
        // When real bandwidths are enabled, hide the module when no path is active
        bottleneckLabelEl.textContent = 'Real Bandwidth';
        bottleneckEl.classList.remove('visible');
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      }

      // Hide efficiency display
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      if (efficiencyEl) {
        efficiencyEl.style.display = 'none';
      }
    }

    // ============================================================================
    // CONFIG READING (from HtmlEmbed props)
    // ============================================================================
    function readEmbedConfig() {
      // Find the closest ancestor that carries the data-config attribute
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let providedConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      const config = providedConfig || {};

      // Apply user override from checkbox if set
      if (showRealBandwidthsOverride !== null) {
        config.showRealBandwidths = showRealBandwidthsOverride;
      }

      return config;
    }

    // ============================================================================
    // REAL BANDWIDTHS DISPLAY
    // ============================================================================
    function displayContextualRealBandwidths(pathId, pathLabel) {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Map path IDs to relevant real bandwidths
      const pathToBandwidths = {
        'cpu-gpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-cpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-GPU (via CPU)', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-nvswitch': [
          { label: 'GPU-GPU (NVSwitch)', value: CONFIG.realBandwidths['gpu-gpu-same-node'] }
        ],
        'gpu-gpu-efa-intranode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-intranode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
          { label: 'All2All', value: CONFIG.realBandwidths['all2all-same-node'] }
        ],
        'gpu-gpu-efa-internode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-internode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
          { label: 'All2All', value: CONFIG.realBandwidths['alltoall-internode'] }
        ],
        'gpu-storage': [
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'cpu-storage': [
          { label: 'CPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'gpu-cpu-storage': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ]
      };

      const relevantBandwidths = pathToBandwidths[pathId] || [];

      if (relevantBandwidths.length > 0) {
        // Clear normal bottleneck display
        bottleneckValueEl.textContent = '';
        bottleneckPathEl.textContent = '';

        // Create HTML for relevant bandwidths
        const html = relevantBandwidths.map(item => `
          <div class="bandwidth-item">
            <span class="bandwidth-label">${item.label}</span>
            <span class="bandwidth-value">${item.value}</span>
          </div>
        `).join('');

        realBandwidthsContentEl.innerHTML = html;
      } else {
        // Fallback: show all bandwidths if path not found
        setupRealBandwidthsDisplay();
      }
    }

    function setupRealBandwidthsDisplay() {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Create the bandwidth items HTML
      const bandwidthItems = [
        { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
        { label: 'Same Node', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-same-node'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
        { label: '  All2All', value: CONFIG.realBandwidths['all2all-same-node'] },
        { label: 'Internode', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-internode'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
        { label: '  All2All', value: CONFIG.realBandwidths['alltoall-internode'] },
        { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
      ];

      const html = bandwidthItems.map(item => {
        if (item.value === '') {
          // Section header
          return `<div class="bandwidth-section-header" style="font-weight: 600; margin: 6px 0 4px 0; color: var(--text-secondary);">${item.label}</div>`;
        } else {
          // Bandwidth item
          return `
            <div class="bandwidth-item">
              <span class="bandwidth-label">${item.label}</span>
              <span class="bandwidth-value">${item.value}</span>
            </div>
          `;
        }
      }).join('');

      realBandwidthsContentEl.innerHTML = html;
    }

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    function initialize() {
      const container = getElement('aws-topology-container');
      const tooltip = getElement('aws-topology-tooltip');

      // Read initial config from HtmlEmbed props (before any override)
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let initialConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          initialConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      // Initialize override with initial config value (so checkbox is in sync)
      if (initialConfig && initialConfig.showRealBandwidths !== undefined) {
        showRealBandwidthsOverride = initialConfig.showRealBandwidths;
      }

      // Now read config (which will use override if set)
      const embedConfig = readEmbedConfig();

      // Setup real bandwidths display if enabled
      if (embedConfig.showRealBandwidths) {
        const bottleneckEl = getElement('aws-topology-bottleneck');
        const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');

        // Change label to "Real Bandwidth"
        bottleneckLabelEl.textContent = 'Real Bandwidth';

        // Hide the detailed real bandwidths list initially
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
        // Don't show the module initially - only when a path is selected
        bottleneckEl.classList.remove('visible');
      }

      drawTopology();

      // Initial fade in
      requestAnimationFrame(() => {
        container.style.opacity = '1';
      });

      // Setup tooltip

      container.addEventListener('mouseover', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          const bandwidth = target.getAttribute('data-bandwidth');
          const label = target.getAttribute('data-label');

          // Clear and rebuild tooltip content
          tooltip.innerHTML = '';

          if (label) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'tooltip-label';
            labelDiv.textContent = label;
            tooltip.appendChild(labelDiv);
          }

          const bandwidthDiv = document.createElement('div');
          bandwidthDiv.className = 'tooltip-bandwidth';
          bandwidthDiv.textContent = bandwidth;
          tooltip.appendChild(bandwidthDiv);

          tooltip.classList.add('visible');
        }
      });

      container.addEventListener('mousemove', (e) => {
        if (tooltip.classList.contains('visible')) {
          const rect = container.getBoundingClientRect();
          tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
          tooltip.style.top = (e.clientY - rect.top + 10) + 'px';
        }
      });

      container.addEventListener('mouseout', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          tooltip.classList.remove('visible');
        }
      });

      // Create control buttons organized by category
      const controlsContainer = getElement('aws-topology-controls');

      // Hide controls if an initial filter is provided
      if (embedConfig.initialFilter) {
        controlsContainer.style.display = 'none';
      } else {
        // Categorize paths
        const pathsByCategory = {
          intranode: [
            { id: 'cpu-gpu', label: CONFIG.paths['cpu-gpu'].label },
            { id: 'gpu-gpu-cpu', label: CONFIG.paths['gpu-gpu-cpu'].label },
            { id: 'gpu-gpu-nvswitch', label: CONFIG.paths['gpu-gpu-nvswitch'].label },
            { id: 'gpu-gpu-efa-intranode', label: CONFIG.paths['gpu-gpu-efa-intranode'].label }
          ],
          internode: [
            { id: 'gpu-gpu-efa-internode', label: CONFIG.paths['gpu-gpu-efa-internode'].label }
          ],
          storage: [
            { id: 'gpu-storage', label: CONFIG.paths['gpu-storage'].label },
            { id: 'cpu-storage', label: CONFIG.paths['cpu-storage'].label },
            { id: 'gpu-cpu-storage', label: CONFIG.paths['gpu-cpu-storage'].label }
          ]
        };

        // Create single select with prefixed options and checkbox
        const isChecked = showRealBandwidthsOverride === true || (showRealBandwidthsOverride === null && embedConfig.showRealBandwidths);
        const controlsHTML = `
          <div>
            <label id="real-bandwidth-label" style="display: flex; align-items: center; gap: 0px; font-size: 14px; color: var(--text-color); cursor: pointer; opacity: 0.3; transition: opacity 0.2s;">
              <input type="checkbox" id="real-bandwidth-toggle" ${isChecked ? 'checked' : ''} disabled>
              <span>Show Real Bandwidths</span>
            </label>
          </div>
          
          <div style="display: flex; gap: 12px; align-items: center; margin-top: 8px;">
            <select id="path-select" style="min-width: 250px;">
              <option value="">Select path...</option>
            </select>
          </div>
        `;
        controlsContainer.innerHTML = controlsHTML;

        const pathSelect = controlsContainer.querySelector('#path-select');
        const realBandwidthToggle = controlsContainer.querySelector('#real-bandwidth-toggle');
        const realBandwidthLabel = controlsContainer.querySelector('#real-bandwidth-label');

        // Populate single select with prefixed options
        Object.entries(pathsByCategory).forEach(([category, paths]) => {
          const categoryLabel = category.charAt(0).toUpperCase() + category.slice(1);

          paths.forEach(path => {
            const option = document.createElement('option');
            option.value = path.id;
            option.textContent = `${categoryLabel}: ${path.label}`;
            pathSelect.appendChild(option);
          });
        });

        // Helper function to enable/disable real bandwidth toggle
        const updateRealBandwidthToggleState = (enabled) => {
          if (enabled) {
            realBandwidthToggle.disabled = false;
            realBandwidthLabel.style.opacity = '1';
            realBandwidthLabel.style.cursor = 'pointer';
          } else {
            realBandwidthToggle.disabled = true;
            realBandwidthLabel.style.opacity = '0.3';
            realBandwidthLabel.style.cursor = 'default';
          }
        };

        // Real bandwidth toggle handler
        realBandwidthToggle.addEventListener('change', (e) => {
          showRealBandwidthsOverride = e.target.checked;

          // Re-apply highlight if a path is active
          if (currentActivePathId) {
            const path = CONFIG.paths[currentActivePathId];
            if (path) {
              highlightPath(path, path.label, currentActivePathId);
            }
          } else {
            // If no path active, just reset to clear any displayed values
            resetHighlight();
          }
        });

        // Function to activate a path
        const activatePath = (pathId) => {
          if (!pathId) {
            // Reset to default
            currentActivePathId = null;
            updateRealBandwidthToggleState(false); // Disable toggle when no path selected
            const needsRedraw = currentEnsembleCount !== 2 || currentSystemCount !== 1;

            if (needsRedraw) {
              const container = getElement('aws-topology-container');
              container.style.opacity = '0';

              setTimeout(() => {
                drawTopology(2, 1);
                resetHighlight();

                requestAnimationFrame(() => {
                  container.style.opacity = '1';
                });
              }, 150);
            } else {
              resetHighlight();
            }
            return;
          }

          const path = CONFIG.paths[pathId];
          if (!path) return;

          currentActivePathId = pathId;
          updateRealBandwidthToggleState(true); // Enable toggle when path is selected

          // Check if we need to redraw
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            pathId === 'gpu-gpu-efa-intranode' ||
            pathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            const container = getElement('aws-topology-container');
            container.style.opacity = '0';

            setTimeout(() => {
              currentActivePathId = pathId;
              drawTopology(path.requiredEnsembles, path.requiredSystems);
              highlightPath(path, path.label, pathId);

              requestAnimationFrame(() => {
                container.style.opacity = '1';
              });
            }, 150);
          } else {
            currentActivePathId = pathId;
            highlightPath(path, path.label, pathId);
          }
        };

        // Path select change handler
        pathSelect.addEventListener('change', (e) => {
          const pathId = e.target.value;
          activatePath(pathId);
        });
      }

      // Apply initial filter from embedConfig if provided
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          currentActivePathId = initialPathId;

          // Draw topology with correct requirements
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            initialPathId === 'gpu-gpu-efa-intranode' ||
            initialPathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            drawTopology(path.requiredEnsembles, path.requiredSystems);
          }
        }
      }

      // Create SVG legend
      const legendContainer = getElement('aws-topology-legend');
      const legendSvg = SVG().addTo(legendContainer).size('100%', '100%');

      const lineLength = 36;  // 30 * 1.2
      const itemSpacing = 30;  // 25 * 1.2
      const startX = 96;  // 80 * 1.2
      const startY = 42;  // 35 * 1.2
      const textOffset = 24;  // 20 * 1.2

      // Calculate actual legend width based on content
      const legendWidth = startX + lineLength + textOffset + 168;  // 140 * 1.2
      const legendHeight = 144;  // 120 * 1.2
      legendSvg.viewbox(0, 0, legendWidth, legendHeight);

      [...CONFIG.bandwidths].reverse().forEach((bw, index) => {
        const y = startY + (index * itemSpacing);
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const width = bw.width;

        // Create a group for each legend item with a data attribute for bandwidth
        const legendItemGroup = legendSvg.group();
        legendItemGroup.attr('data-legend-bandwidth', bw.speed);

        // Dessiner la ligne
        legendItemGroup.line(startX, y, startX + lineLength, y)
          .stroke({ color, width });

        // Dessiner les cercles aux extrémités
        const r = width * 0.8;
        const startCircle = legendItemGroup.circle(r * 2).move(startX - r, y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        const endCircle = legendItemGroup.circle(r * 2).move(startX + lineLength - r, y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        // Ajouter le texte (aligné à droite, valeur en gras)
        const textX = legendWidth - 5;
        const value = bw.speed.replace('GB/s', '').trim();

        // Format: "Label - 900 GB/s" avec 900 en gras
        const textEl = legendItemGroup.text(function (add) {
          add.tspan(bw.label + ' - ').font({ weight: 'normal' });
          add.tspan(value).font({ weight: 'bold' });
          add.tspan(' GB/s').font({ weight: 'normal' });
        })
          .move(textX, y)
          .font({
            family: 'system-ui, -apple-system, sans-serif',
            size: 14,  // 12 * 1.2 ≈ 14
            anchor: 'end',
            fill: CONFIG.colors.nodeText
          })
          .dy(-7);  // -6 * 1.2 ≈ -7
      });
    }

    // Initialize only if wrapper is found
    if (findWrapper()) {
      initialize();

      // Apply initial filter highlight after legend is created
      const embedConfig = readEmbedConfig();
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          // Apply highlight to both topology and legend
          highlightPath(path, path.label, initialPathId);
        }
      }

      // Add resize handler for responsive width changes (mobile/desktop)
      const handleResize = () => {
        const container = getElement('aws-topology-container');
        if (!container) return;

        // Recalculate fixed height based on new width (for responsive design)
        const containerWidth = container.clientWidth || 800;

        // Use max viewbox dimensions for consistent aspect ratio
        const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
        const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
          CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
          CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
          CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
          CONFIG.gaps.bottomMargin;
        const maxViewboxHeight = maxSingleSystemHeight * 1.15;
        const maxViewboxWidth = maxEnsembleWidth + 200;

        const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
        const baseHeight = containerWidth * maxAspectRatio;
        const legendHeight = embedConfig.initialFilter ? 150 : 200;

        // Update height based on current width (responsive)
        container.style.height = `${baseHeight + legendHeight}px`;
      };

      // Use ResizeObserver for better performance (only for window resize, not content changes)
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => handleResize());
        ro.observe(findWrapper());
      } else {
        window.addEventListener('resize', handleResize);
      }
    } else {
      console.warn('AWS topology: wrapper not found, skipping initialization');
    }
  })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">GPU-to-GPU communication path through Libfabric EFA. Note that this is less efficient for intranode communications compared to using NVLink.</figcaption></figure> </div>
<p>While GPUDirect RDMA over EFA provides significant improvements over CPU-mediated transfers, achieving around  <strong>50 GB/s</strong>  with 4 EFA cards per GPU, can we do even better? This is where NVLink comes into play.</p>
<h4 id="through-nvlink"><a href="#through-nvlink">Through NVLink</a></h4>
<p><strong>NVLink</strong>  is NVIDIA’s high-speed, direct GPU-to-GPU interconnect technology that enables fast multi-GPU communication within servers. The H100 employs fourth-generation NVLink (NVLink 4.0), providing 900 GB/s bidirectional bandwidth per GPU through 18 links, each operating at 50 GB/s bidirectional (<a href="https://resources.nvidia.com/en-us-hopper-architecture/nvidia-h100-tensor-c">NVIDIA H100 Tensor Core GPU Datasheet</a>). In the DGX H100 architecture, 4 third-generation NVSwitches connect the 8 GPUs using a layered topology where each GPU connects with 5+4+4+5 links across the switches. This configuration ensures multiple direct paths between any GPU pair with a constant hop count of just 1 NVSwitch, resulting in 3.6 TB/s total bidirectional NVLink network bandwidth.</p>

















<div class="table-scroll"><table><thead><tr><th>NVLink 2.0 (Volta)</th><th>NVLink 3.0 (Ampere)</th><th>NVLink 4.0 (Hopper)</th><th>NVLink 5.0 (Blackwell)</th></tr></thead><tbody><tr><td>Bandwidth</td><td>300 GB/s</td><td>600 GB/s</td><td>900 GB/s</td></tr></tbody></table></div>
<p><em>Table: NVLink bandwidth comparison across generations, showing theoretical specifications</em></p>
<p>By default, NCCL prioritizes NVLink for intra-node GPU communication when available, as it provides the lowest latency and highest bandwidth path between GPUs on the same machine. However, if you did not set your flags properly, you could be preventing the use of NVLink! 😱</p>
<p>NVLink enables direct GPU-to-GPU memory access without involving the CPU or system memory. When NVLink is unavailable, NCCL falls back to GPUDirect P2P over PCIe, or uses Shared Memory (SHM) transport when inter-socket PCIe transfers would be suboptimal.</p>
<p>To verify that NVLink is being used, set  <code>NCCL_DEBUG=INFO</code>  and look for messages like:</p>
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>NCCL INFO Channel 00/1 : 0[0] -&gt; 1[1] via P2P/CUMEM</span></span>
<span class="line"><span></span></span></code></pre></div>
<p>The following diagram illustrates the direct path that data takes when using NVLink:</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-pmi31f896bk" data-config="{&#34;initialFilter&#34;:&#34;gpu-gpu-nvswitch&#34;}"><!--
  AWS Bandwidth Bottleneck Visualization
  
  Usage:
  
  Basic:
    <HtmlEmbed src="/embeds/aws-bandwidth-bottleneck.html" />
  
  With initial filter:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ initialFilter: 'cpu-gpu' }} 
    />
  
  With real bandwidths display:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ showRealBandwidths: true }} 
    />
  
  Available filters:
    - cpu-gpu (Intranode: CPU ⟷ GPU)
    - gpu-gpu-cpu (Intranode: GPU ⟷ GPU via CPU)
    - gpu-gpu-nvswitch (Intranode: GPU ⟷ GPU via NVSwitch)
    - gpu-gpu-efa-intranode (Intranode: GPU ⟷ GPU via EFA)
    - gpu-gpu-efa-internode (Internode: GPU ⟷ GPU via EFA)
    - gpu-storage (Storage: GPU ⟷ Storage)
    - cpu-storage (Storage: CPU ⟷ Storage)
    - gpu-cpu-storage (Storage: GPU ⟷ Storage via CPU)
-->
<div class="aws-topology-wrapper">
  <div class="aws-topology-container"></div>
  <div class="aws-topology-controls"></div>
  <div class="aws-topology-legend"></div>
  <div class="aws-topology-tooltip"></div>
  <div class="aws-topology-bottleneck">
    <div class="bottleneck-label">Bandwidth Max</div>
    <div class="bottleneck-path">for CPU → GPU</div>
    <div class="bottleneck-value">-</div>
    <div class="bottleneck-unit">GB/s</div>
    <div class="bottleneck-efficiency" style="display: none;">
      <div class="efficiency-value">-</div>
      <div class="efficiency-label">Efficiency</div>
    </div>
    <div class="real-bandwidths" style="display: none;">
      <div class="real-bandwidths-title">Real Bandwidths</div>
      <div class="real-bandwidths-content"></div>
    </div>
  </div>
</div>

<style>
  .aws-topology-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .aws-topology-container {
    width: 100%;
    height: auto;
    min-height: 400px;
    position: relative;
    transition: opacity 0.15s ease;
  }

  .aws-topology-container.fixed-height {
    height: 850px;
  }

  .aws-topology-container svg {
    width: 100%;
    height: 100%;
  }

  .aws-topology-container svg g {
    transition: opacity 0.2s ease;
  }

  /* Add drop shadow to all links */
  .aws-topology-container svg g[data-link-type] line,
  .aws-topology-container svg g[data-link-type] path {
    filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
  }

  .aws-topology-controls {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 800px;
  }

  .aws-topology-controls-section {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .aws-topology-controls-row {
    display: flex;
    flex-direction: row;
    gap: 16px;
    align-items: flex-start;
  }

  .aws-topology-controls-label {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0.7;
  }

  .aws-topology-controls-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }

  .aws-topology-controls-buttons .button {
    flex-shrink: 0;
  }

  /* Hide controls on mobile */
  @media (max-width: 768px) {
    .aws-topology-controls {
      display: none;
    }
  }

  .aws-topology-legend {
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 264px;
    /* 220 * 1.2 */
    height: 120px;
    /* 100 * 1.2 */
  }

  .aws-topology-tooltip {
    position: absolute;
    padding: 8px 12px;
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 12px;
    color: var(--text-color);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .aws-topology-tooltip.visible {
    opacity: 1;
  }

  .tooltip-label {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-color);
  }

  .tooltip-bandwidth {
    font-size: 11px;
    color: var(--text-secondary);
  }

  .aws-topology-bottleneck {
    position: absolute;
    top: 10px;
    right: 10px;
    text-align: right;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .aws-topology-bottleneck.visible {
    opacity: 1;
  }

  .bottleneck-label {
    font-size: 11px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-value {
    font-size: 24px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    margin-bottom: 2px;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .bottleneck-unit {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-path {
    font-size: 10px;
    color: var(--text-secondary);
    font-style: italic;
    margin-bottom: 6px;
    opacity: 0.8;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-efficiency {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    margin-top: 12px;
    margin-bottom: 4px;
  }

  .efficiency-label {
    font-size: 9px;
    color: var(--text-secondary);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 2px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .efficiency-value {
    font-size: 20px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .real-bandwidths {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
    opacity: 0.9;
  }

  .real-bandwidths-title {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content {
    font-size: 11px;
    color: var(--text-color);
    line-height: 1.4;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content .bandwidth-item {
    margin-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .real-bandwidths-content .bandwidth-label {
    font-size: 10px;
    color: var(--text-secondary);
    opacity: 0.8;
  }

  .real-bandwidths-content .bandwidth-value {
    font-size: 11px;
    font-weight: 600;
    color: var(--primary-color);
  }

  /* Checkbox styling for the bandwidth toggle */
  #real-bandwidth-toggle {
    appearance: none;
    width: 16px;
    height: 16px;
    border: 2px solid var(--border-color);
    border-radius: 3px;
    background-color: var(--page-bg);
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    margin-right: 8px;
  }

  #real-bandwidth-toggle:hover {
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(from var(--primary-color) r g b / 0.1);
  }

  #real-bandwidth-toggle:checked {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:checked::before {
    content: '';
    position: absolute;
    top: 1px;
    left: 4px;
    width: 4px;
    height: 8px;
    border: solid var(--on-primary);
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }

  #real-bandwidth-toggle:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.5/svg.min.js"></script>
<script>
  (function () {
    // Generate unique ID for this instance
    const instanceId = 'aws-topology-' + Math.random().toString(36).substr(2, 9);

    // Store reference to current script to find wrapper later
    const scriptEl = document.currentScript;

    // Function to find wrapper (will be called after DOM is ready)
    let wrapperEl = null;
    const findWrapper = () => {
      if (!wrapperEl) {
        wrapperEl = scriptEl.previousElementSibling;
        if (!wrapperEl || !wrapperEl.classList.contains('aws-topology-wrapper')) {
          // Fallback: search for unmounted wrappers
          const allWrappers = document.querySelectorAll('.aws-topology-wrapper');
          for (const wrapper of allWrappers) {
            if (!wrapper.dataset.mounted) {
              wrapperEl = wrapper;
              break;
            }
          }
        }
        if (wrapperEl && !wrapperEl.dataset.mounted) {
          wrapperEl.dataset.mounted = 'true';
        }
      }
      return wrapperEl;
    };

    // Get all child elements for this instance
    const getElement = (className) => {
      const wrapper = findWrapper();
      return wrapper ? wrapper.querySelector('.' + className) : null;
    };

    // ============================================================================
    // CONFIGURATION - All settings in one place
    // ============================================================================
    const CONFIG = {
      // Canvas settings
      viewbox: {
        width: 2400,  // Width for 2 ensembles side by side
        get height() {
          // Calculate height based on vertical elements × systemCount
          const singleSystemHeight = this.parent.gaps.topMargin +
            this.parent.sizes.cpu +
            this.parent.gaps.cpuToPcie +
            this.parent.sizes.pcie.height +
            this.parent.gaps.pcieToGpu +
            this.parent.sizes.gpu.height +
            this.parent.gaps.gpuToNvswitch +
            this.parent.sizes.nvswitch.height +
            this.parent.gaps.bottomMargin;

          return singleSystemHeight * this.parent.systemCount +
            this.parent.gaps.systemGap * (this.parent.systemCount - 1);
        },
        parent: null  // Will be set to CONFIG
      },

      // System replication
      systemCount: 2,      // Number of complete systems (each has 2 ensembles)
      ensembleCount: 2,    // Number of ensembles per system (each ensemble = CPU + 4 groups + 2 NVSwitches)
      groupCount: 4,       // Groups per ensemble
      nvswitchCount: 2,    // NVSwitches per ensemble

      // Node sizes (all based on CPU size)
      sizes: {
        cpu: 80,
        get pcie() { return { width: this.cpu * 0.75, height: this.cpu * 0.625 * 3 }; },
        get gpu() { return { width: this.cpu, height: this.cpu }; },
        get efa() { return { width: 60, height: 30 }; },
        get nvme() { return { width: 60, height: 30 }; },
        get nvswitch() { return { width: 100, height: 60 }; }
      },

      // Gaps and spacing
      gaps: {
        topMargin: 0,        // Margin from top to CPU
        cpuToPcie: 80,        // Vertical gap CPU → PCIe
        pcieToGpu: 80,        // Vertical gap PCIe → GPU
        gpuToNvswitch: 200,    // Vertical gap GPU → NVSwitch
        bottomMargin: 40,     // Margin from NVSwitch to bottom
        horizontal: 230,      // Horizontal gap between groups
        ensembleGap: 50,     // Horizontal gap between ensembles (within a system)
        systemGap: 30,       // Horizontal gap between complete systems
        connectionOffset: 15  // Gap between node edge and arrow anchor
      },

      // Group layout offsets (all relative positions within a group)
      layout: {
        pcieOffsetX: -40,      // PCIe X offset from group center (to the left)
        efaNvmeOffsetX: 60,    // EFA/NVMe X offset from group center (to the right)
        efaOffsetY: -30,       // EFA Y offset from PCIe Y (above)
        nvmeOffsetY: 30,       // NVMe Y offset from PCIe Y (below)
        groupPadding: 20       // Padding around group bounding box
      },

      // Debug mode
      debug: {
        showPhantoms: false    // Set to true to visualize phantom nodes
      },

      // Highlight paths (for interactive buttons)
      paths: {
        'cpu-gpu': {
          label: 'CPU ⟷ GPU',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'gpu'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' }
          ]
        },
        'gpu-gpu-cpu': {
          label: 'GPU ⟷ GPU via CPU',
          requiredEnsembles: 1,  // Need only 1 ensemble (2 groups within)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'cpu', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'pcie', to: 'cpu' },
            { from: 'cpu', to: 'pcie' },
            { from: 'cpu', to: 'pcie-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-nvswitch': {
          label: 'GPU ⟷ GPU via NVSwitch',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'nvswitch-0', 'gpu-1'],
          links: [
            { from: 'gpu', to: 'nvswitch-0' },
            { from: 'gpu-1', to: 'nvswitch-0' }
          ]
        },
        'gpu-gpu-efa': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-1', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-1', to: 'efa-external-1' },
            { from: 'efa-1', to: 'pcie-efa-phantom-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-efa-intranode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles (same system)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-4', 'pcie-4', 'gpu-4'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-4' },  // EFA cross-link between ensembles (12.5GB/s)
            { from: 'efa-4', to: 'efa-external-4' },
            { from: 'efa-4', to: 'pcie-efa-phantom-4' },
            { from: 'pcie-4', to: 'gpu-4' }
          ]
        },
        'gpu-gpu-efa-internode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles per system
          requiredSystems: 2,    // Need 2 systems
          nodes: ['gpu', 'pcie', 'efa', 'efa-8', 'pcie-8', 'gpu-8'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-8' },  // EFA cross-link between systems
            { from: 'efa-8', to: 'efa-external-8' },
            { from: 'efa-8', to: 'pcie-efa-phantom-8' },
            { from: 'pcie-8', to: 'gpu-8' }
          ]
        },
        'gpu-storage': {
          label: 'GPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'nvme'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'cpu-storage': {
          label: 'CPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'gpu-cpu-storage': {
          label: 'GPU ⟷ Storage via CPU',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'gpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        }
      },


      // Bandwidth levels
      bandwidths: [
        { speed: '900GB/s', label: 'NVLink 4.0', width: 9 },
        { speed: '64GB/s', label: 'PCIe Gen5', width: 6 },
        { speed: '16GB/s', label: 'PCIe Gen4', width: 3 },
        { speed: '12.5GB/s', label: 'EFA Link', width: 1.25 }
      ],

      // Link definitions for groups
      groupLinks: [
        { from: 'cpu', to: 'pcie', bandwidth: '16GB/s', type: 'cpu', fromSide: 'bottom', toSide: 'top', multiLink: true },
        { from: 'efa', to: 'pcie-efa-phantom', bandwidth: '16GB/s', type: 'network', fromSide: 'left', toSide: 'right', stacked: 4 },
        { from: 'nvme', to: 'pcie-nvme-phantom', bandwidth: '16GB/s', type: 'storage', fromSide: 'left', toSide: 'right' },
        { from: 'pcie', to: 'gpu', bandwidth: '64GB/s', type: 'gpu', fromSide: 'bottom', toSide: 'top' },
        { from: 'efa', to: 'efa-external', bandwidth: '12.5GB/s', type: 'network', fromSide: 'right', toSide: 'left', stacked: 4 }
      ],

      // GPU to NVSwitch links (full mesh)
      gpuNvswitchLink: {
        bandwidth: '900GB/s',
        type: 'gpu',
        fromSide: 'bottom',
        toSide: 'top'
      },

      // Colors (using CSS variables for dark mode compatibility)
      colors: {
        // Node colors
        nodeFill: 'var(--page-bg)',
        nodeStroke: 'var(--muted-color)',     // More contrast than border-color
        nodeText: 'var(--text-color)',
        nodePins: 'var(--muted-color)',
        nodeCoreFill: 'rgba(0, 0, 0, 0.05)',  // Very light gray for cores
        nodeCoreStroke: 'rgba(0, 0, 0, 0.2)', // More visible border for cores

        // Link colors
        linkColor: 'var(--primary-color)',
        linkCircleBorder: 'rgba(0, 0, 0, 0.1)', // Border for link circles

        // Group border
        groupBorder: 'var(--border-color)',

        // Phantom debug
        phantomFill: 'rgba(255, 0, 255, 0.2)',
        phantomStroke: 'magenta'
      },

      // Real bandwidth data for display
      realBandwidths: {
        'cpu-gpu': '14.2GB/s',
        'gpu-gpu-same-node': '786GB/s',
        'gpu-gpu-efa-intranode': '40GB/s',
        'gpu-gpu-efa-internode': '40GB/s',
        'allreduce-same-node': '480GB/s',
        'all2all-same-node': '340GB/s',
        'allreduce-internode': '320GB/s',
        'alltoall-internode': '45GB/s',
        'gpu-storage': '14.2GB/s'
      }
    };

    // Initialize viewbox parent reference
    CONFIG.viewbox.parent = CONFIG;

    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================
    function getBandwidth(speed) {
      const bw = CONFIG.bandwidths.find(b => b.speed === speed);
      if (bw) {
        // Add numericValue for comparison
        bw.numericValue = parseFloat(bw.speed.replace('GB/s', ''));
      }
      return bw;
    }

    // Calculate connection offset proportional to link width
    function getLinkOffset(linkWidth) {
      const minOffset = 5;   // Minimum offset for thin links
      const maxOffset = 20;  // Maximum offset for thick links

      // Proportional offset: thinner links = smaller offset
      const proportionalOffset = minOffset + (linkWidth / 10) * (maxOffset - minOffset);
      return Math.min(Math.max(proportionalOffset, minOffset), maxOffset);
    }

    // ============================================================================
    // EFA CROSS-LINKS HELPER
    // ============================================================================
    function drawEfaCrossLinks(renderer, fromId, toId, linkType = 'efa-crosslink') {
      const phantom0 = renderer.nodes.get(fromId);
      const phantom1 = renderer.nodes.get(toId);

      if (!phantom0 || !phantom1) return;

      const efaBw = getBandwidth('12.5GB/s');
      const efaColor = CONFIG.colors.linkColor;

      // Draw 4 stacked links manually (EFA has 4 connections) - randomized order
      const stackCount = 4;
      const spacing = 6; // Fixed spacing between stacked links
      const verticalShift = -95; // Shift up to align with EFA nodes
      const horizontalShift = -40; // Shift left to better position the arrows
      const horizontalExtension = 20; // Extend arrows horizontally on each side

      // Create array of indices and randomize
      const linkIndices = Array.from({ length: stackCount }, (_, i) => i);
      const shuffledIndices = linkIndices.sort(() => Math.random() - 0.5);

      // Draw horizontal lines with vertical offset for stacking
      shuffledIndices.forEach(i => {
        const offsetY = (i - (stackCount - 1) / 2) * spacing;

        const efaCrossGroup = renderer.crossLinksGroup.group();
        efaCrossGroup.attr('data-link-type', linkType);
        efaCrossGroup.attr('data-from', fromId);
        efaCrossGroup.attr('data-to', toId);
        efaCrossGroup.attr('data-bandwidth', '12.5GB/s');
        efaCrossGroup.attr('data-label', 'EFA Link');

        // Draw line with vertical offset for stacking + shifts + horizontal extension
        const x0 = phantom0.x + horizontalShift;
        const x1 = phantom1.x + horizontalShift + horizontalExtension;
        const y0 = phantom0.y + offsetY + verticalShift;
        const y1 = phantom1.y + offsetY + verticalShift;

        // Draw border
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: efaColor, width: efaBw.width, opacity: 1 });

        // Draw circles at both ends
        const r = efaBw.width * 0.8;
        const startCircle = efaCrossGroup.circle(r * 2).move(x0 - r, y0 - r);
        startCircle.fill(efaColor);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = efaCrossGroup.circle(r * 2).move(x1 - r, y1 - r);
        endCircle.fill(efaColor);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');
      });

      // Add vertical bars at both ends (connect horizontal arrows to EFA phantoms)
      const barColor = CONFIG.colors.linkColor;

      shuffledIndices.forEach(i => {
        const offsetX = (i - (stackCount - 1) / 2) * spacing + 12; // Horizontal offset for vertical bars
        const yHorizontal = phantom0.y + verticalShift + 10;
        const yPhantom = phantom0.y + 8; // End a bit higher (5px above phantom center)

        // Left vertical bar (one per horizontal arrow)
        const leftBarGroup = renderer.crossLinksGroup.group();
        leftBarGroup.attr('data-link-type', linkType);
        leftBarGroup.attr('data-from', fromId);
        leftBarGroup.attr('data-to', toId);
        leftBarGroup.attr('data-bandwidth', '12.5GB/s');
        leftBarGroup.attr('data-label', 'EFA Link');

        const x0 = phantom0.x + horizontalShift + offsetX;

        // Draw border
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const r = efaBw.width * 0.8;
        const bottomCircle0 = leftBarGroup.circle(r * 2).move(x0 - r, yPhantom - r);
        bottomCircle0.fill(barColor);
        bottomCircle0.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle0.attr('data-link-circle', 'true');

        // Right vertical bar (one per horizontal arrow)
        const rightBarGroup = renderer.crossLinksGroup.group();
        rightBarGroup.attr('data-link-type', linkType);
        rightBarGroup.attr('data-from', fromId);
        rightBarGroup.attr('data-to', toId);
        rightBarGroup.attr('data-bandwidth', '12.5GB/s');
        rightBarGroup.attr('data-label', 'EFA Link');

        const x1 = phantom1.x + horizontalShift + offsetX;

        // Draw border
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const bottomCircle1 = rightBarGroup.circle(r * 2).move(x1 - r, yPhantom - r);
        bottomCircle1.fill(barColor);
        bottomCircle1.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle1.attr('data-link-circle', 'true');
      });
    }

    // ============================================================================
    // SVG HELPERS
    // ============================================================================
    class TopologyRenderer {
      constructor(draw) {
        this.draw = draw;
        this.nodes = new Map();
        this.structuralGroup = draw.group();  // Structural elements (Node/NUMA borders, never ghosted)
        this.structuralGroup.attr('data-group', 'structural');
        this.baseLinksGroup = draw.group();   // Base links layer (will be ghosted)
        this.baseLinksGroup.attr('data-group', 'base-links');
        this.linksGroup = this.baseLinksGroup; // Alias for compatibility
        this.nodesGroup = draw.group();   // Nodes layer (middle)
        this.phantomsGroup = draw.group(); // Phantoms layer (for debug)
        this.baseCrossLinksGroup = draw.group(); // Base EFA cross-links layer
        this.baseCrossLinksGroup.attr('data-group', 'base-cross-links');
        this.crossLinksGroup = this.baseCrossLinksGroup; // Alias for compatibility
        this.activeLinksGroup = draw.group(); // Active (duplicated) links layer (top, non-ghosted)
        this.activeLinksGroup.attr('data-group', 'active-links');
      }

      // Draw a simple rectangular node
      // Helper: Draw text with consistent styling
      drawText(x, y, label, group = this.nodesGroup) {
        if (!label) return;

        const lines = label.split('\n');
        lines.forEach((line, i) => {
          group.text(line)
            .font({ family: 'Inter, sans-serif', size: 12, weight: '600', anchor: 'middle' })
            .fill(CONFIG.colors.nodeText)
            .cx(x)
            .cy(y + (i - (lines.length - 1) / 2) * 14);
        });
      }

      // Helper: Draw pins around a node
      drawPins(x, y, width, height, pinConfig = {}, targetGroup = null) {
        const group = targetGroup || this.nodesGroup;

        const defaultConfig = {
          pinsPerSide: width >= 80 ? 18 : 15,
          pinLength: 3,
          pinOffset: width / 2 + 1.5,
          pinPadding: 12
        };

        const config = { ...defaultConfig, ...pinConfig };
        const pinStartOffset = -width / 2 + config.pinPadding;
        const pinEndOffset = width / 2 - config.pinPadding;
        const pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);

        const sides = [
          { side: 'left', xOffset: -config.pinOffset, yOffset: 0 },
          { side: 'right', xOffset: config.pinOffset, yOffset: 0 },
          { side: 'top', xOffset: 0, yOffset: -config.pinOffset },
          { side: 'bottom', xOffset: 0, yOffset: config.pinOffset }
        ];

        sides.forEach(({ side, xOffset, yOffset }) => {
          for (let i = 0; i < config.pinsPerSide; i++) {
            const pinX = x + xOffset + (side === 'left' || side === 'right' ? 0 : pinStartOffset + (i * pinSpacing));
            const pinY = y + yOffset + (side === 'top' || side === 'bottom' ? 0 : pinStartOffset + (i * pinSpacing));

            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      drawNode(id, x, y, width, height, label, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      drawNodeWithPins(id, x, y, width, height, label, pinConfig = {}, nodeType = '') {
        const node = this.drawNode(id, x, y, width, height, label, nodeType);
        this.drawPins(x, y, width, height, pinConfig);
        return node;
      }

      drawNodeWithCores(id, x, y, width, height, label, coreConfig = {}, nodeType = '') {
        // Draw main node
        const node = this.drawNode(id, x, y, width, height, label, nodeType);

        // Default core configuration
        const defaultCoreConfig = {
          coresX: 2,              // 2x2 for CPU, 8x8 for GPU
          coresY: 2,
          coreSpacing: 2,         // Space between cores
          coreMargin: 8           // Margin from node edges
        };

        const config = { ...defaultCoreConfig, ...coreConfig };

        // Calculate core size
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coreSpacing * (config.coresX - 1))) / config.coresX;
        const coreHeight = (availableHeight - (config.coreSpacing * (config.coresY - 1))) / config.coresY;

        // Draw cores
        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            this.nodesGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        return node;
      }

      drawProcessorNode(id, x, y, width, height, label, type = 'cpu') {
        // Create main group for the node
        const nodeGroup = this.nodesGroup.group();
        nodeGroup.attr('id', id);
        nodeGroup.attr('data-node-type', type);

        // Draw node background
        nodeGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Draw cores
        const coreConfig = type === 'gpu' ? { coresX: 8, coresY: 8 } : { coresX: 2, coresY: 2 };
        const config = { coreSpacing: 2, coreMargin: 8, ...coreConfig };
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coresX - 1) * config.coreSpacing) / config.coresX;
        const coreHeight = (availableHeight - (config.coresY - 1) * config.coreSpacing) / config.coresY;

        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            nodeGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        // Draw pins in the same group
        this.drawPins(x, y, width, height, {}, nodeGroup);

        // Draw text on top
        this.drawText(x, y, label, nodeGroup);

        // Store node position
        this.nodes.set(id, { x, y, width, height });

        return nodeGroup;
      }

      // Add pins to an existing node (without changing the node design)
      addPinsToNode(nodeId, pinConfig = {}) {
        const node = this.nodes.get(nodeId);
        if (!node) return;

        // Find the node's SVG group
        const svg = getElement('aws-topology-container').querySelector('svg');
        if (!svg) return;
        const nodeGroup = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeGroup) return;

        // Use SVG.js to manipulate the group
        const group = this.draw.findOne(`#${nodeId}`);
        if (!group) return;

        // Default pin configuration
        const defaultPinConfig = {
          pinsPerSide: node.width >= 80 ? 18 : 15,
          sides: ['left', 'right', 'top', 'bottom'],
          pinLength: 3,
          pinPadding: 12
        };

        const config = { ...defaultPinConfig, ...pinConfig };

        // Generate pins on specified sides only
        config.sides.forEach(side => {
          let pinSpacing, pinStartOffset, pinEndOffset;

          if (side === 'left' || side === 'right') {
            pinStartOffset = -node.height / 2 + config.pinPadding;
            pinEndOffset = node.height / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          } else {
            pinStartOffset = -node.width / 2 + config.pinPadding;
            pinEndOffset = node.width / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          }

          for (let i = 0; i < config.pinsPerSide; i++) {
            let pinX, pinY;

            if (side === 'left') {
              pinX = node.x - node.width / 2 - 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'right') {
              pinX = node.x + node.width / 2 + 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'top') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y - node.height / 2 - 1.5;
            } else if (side === 'bottom') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y + node.height / 2 + 1.5;
            }

            // Draw pin in the node's group
            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      // Draw a stacked node (visual stack effect)
      drawStackedNode(id, x, y, width, height, label, stackCount, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        for (let i = stackCount - 1; i >= 0; i--) {
          const offsetY = i * 3;
          group.rect(width, height)
            .move(x - width / 2, y - height / 2 + offsetY)
            .fill(CONFIG.colors.nodeFill)
            .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
            .radius(4)
            .opacity(1);
        }

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw a storage node (NVMe) with internal rectangle
      drawStorageNode(id, x, y, width, height, label, nodeType = 'storage') {
        const group = this.nodesGroup.group();
        group.attr('id', id);
        if (nodeType) group.attr('data-node-type', nodeType);

        // Main node background
        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Internal rectangle on the left side (flush with edge)
        const internalRectWidth = 5;
        const internalRectHeight = height * .6; // Full height
        const internalRectX = x - width / 2; // Flush with left edge
        const internalRectY = y - height / 2 + height * .20;

        group.rect(internalRectWidth, internalRectHeight)
          .move(internalRectX, internalRectY)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: '#ffffff', width: 1 })
          .opacity(.4)
          .radius(0); // No radius

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw background rectangle
      drawBackground(id, x, y, width, height) {
        const bg = this.linksGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 2,
            dasharray: '5,5'
          })
          .radius(8);

        this.nodes.set(id, { x, y, width, height });
        return bg;
      }

      // Get connection point on a node's side with configurable offset and multi-link spacing
      getPoint(nodeId, side, offset = CONFIG.gaps.connectionOffset, linkIndex = 0, totalLinks = 1) {
        const node = this.nodes.get(nodeId);
        if (!node) return { x: 0, y: 0 };

        const points = {
          top: { x: node.x, y: node.y - node.height / 2 - offset },
          right: { x: node.x + node.width / 2 + offset, y: node.y },
          bottom: { x: node.x, y: node.y + node.height / 2 + offset },
          left: { x: node.x - node.width / 2 - offset, y: node.y }
        };

        let basePoint = points[side] || { x: node.x, y: node.y };

        // Apply spacing for multiple links to the same anchor
        if (totalLinks > 1) {
          const isVerticalAnchor = (side === 'top' || side === 'bottom');

          // Vertical anchors (top/bottom) space horizontally, horizontal anchors (left/right) space vertically
          const spacing = isVerticalAnchor ? node.width / (totalLinks + 1) : node.height / (totalLinks + 1);
          const linkOffset = (linkIndex - (totalLinks - 1) / 2) * spacing;

          // Apply offset in the perpendicular direction to the anchor
          if (isVerticalAnchor) {
            basePoint.x += linkOffset;  // Horizontal offset for vertical anchors
          } else {
            basePoint.y += linkOffset;  // Vertical offset for horizontal anchors
          }
        }

        return basePoint;
      }

      // Draw single link with optional multi-link spacing
      drawLink(fromId, toId, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, fromLinkIndex = 0, fromTotalLinks = 1, toLinkIndex = 0, toTotalLinks = 1, linkType = '', bandwidth = '') {
        const start = this.getPoint(fromId, fromSide, offset, fromLinkIndex, fromTotalLinks);
        const end = this.getPoint(toId, toSide, offset, toLinkIndex, toTotalLinks);

        const group = this.linksGroup.group();
        if (linkType) group.attr('data-link-type', linkType);
        if (bandwidth) {
          group.attr('data-bandwidth', bandwidth);
          // Find label from bandwidth config
          const bwConfig = getBandwidth(bandwidth);
          if (bwConfig && bwConfig.label) {
            group.attr('data-label', bwConfig.label);
          }
        }
        group.attr('data-from', fromId);
        group.attr('data-to', toId);

        // Check if this is a vertical connection (GPU-NVSwitch or CPU-PCIe)
        const isVerticalConnection = fromSide === 'bottom' && toSide === 'top';

        if (isVerticalConnection) {
          // Use curved paths for vertical connections
          const curvature = 45; // Fixed curvature value for consistent curve strength

          // Create a smooth cubic bezier curve with vertical control points
          const pathData = `M ${start.x} ${start.y} C ${start.x} ${start.y + curvature}, ${end.x} ${end.y - curvature}, ${end.x} ${end.y}`;

          // Draw border (wider path behind)
          group.path(pathData)
            .fill('none')
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main path on top
          group.path(pathData)
            .fill('none')
            .stroke({ color, width, opacity: 1 });
        } else {
          // Draw straight lines for other connections
          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });
        }

        const r = width * 0.8;
        const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');

        return group;
      }

      // Draw stacked links
      drawStackedLinks(fromId, toId, count, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, linkType = '', bandwidth = '') {
        const fromNode = this.nodes.get(fromId);
        const toNode = this.nodes.get(toId);
        if (!fromNode || !toNode) return [];

        const isHorizontal = (fromSide === 'left' || fromSide === 'right') &&
          (toSide === 'left' || toSide === 'right');
        const spacing = isHorizontal
          ? Math.min(fromNode.height, toNode.height) / (count + 1)
          : Math.min(fromNode.width, toNode.width) / (count + 1);

        const arrows = [];
        for (let i = 0; i < count; i++) {
          const stackOffset = (i - (count - 1) / 2) * spacing;
          let start = this.getPoint(fromId, fromSide, offset);
          let end = this.getPoint(toId, toSide, offset);

          if (isHorizontal) {
            start.y += stackOffset;
            end.y += stackOffset;
          } else {
            start.x += stackOffset;
            end.x += stackOffset;
          }

          const group = this.linksGroup.group();
          if (linkType) group.attr('data-link-type', linkType);
          if (bandwidth) {
            group.attr('data-bandwidth', bandwidth);
            // Find label from bandwidth config
            const bwConfig = getBandwidth(bandwidth);
            if (bwConfig && bwConfig.label) {
              group.attr('data-label', bwConfig.label);
            }
          }
          group.attr('data-from', fromId);
          group.attr('data-to', toId);

          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });

          const r = width * 0.8;
          const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
          startCircle.fill(color);
          startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          startCircle.attr('data-link-circle', 'true');

          const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
          endCircle.fill(color);
          endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          endCircle.attr('data-link-circle', 'true');

          arrows.push(group);
        }
        return arrows;
      }

      // Add phantom node (invisible connection point)
      addPhantom(id, x, y, width = 30, height = 30) {
        this.nodes.set(id, { x, y, width, height });

        // Draw phantom for debug visualization
        if (CONFIG.debug.showPhantoms) {
          this.phantomsGroup.rect(width, height)
            .move(x - width / 2, y - height / 2)
            .fill('rgba(255, 0, 255, 0.2)')  // Semi-transparent magenta
            .stroke({ color: 'magenta', width: 2, dasharray: '4,4' })
            .radius(4);

          // Add label
          this.phantomsGroup.text(id)
            .move(x, y)
            .font({
              family: 'system-ui, -apple-system, sans-serif',
              size: 10,
              anchor: 'middle',
              fill: 'magenta',
              weight: 'bold'
            })
            .dy(-height / 2 - 5);
        }
      }
    }

    // ============================================================================
    // DRAW SINGLE GROUP
    // ============================================================================
    function drawGroup(renderer, globalIndex, localIndex, x, cpuY, nvswitchY, cpuId = 'cpu') {
      const s = CONFIG.sizes;
      const g = CONFIG.gaps;
      const l = CONFIG.layout;
      const suffix = globalIndex > 0 ? `-${globalIndex}` : '';

      // Calculate Y positions
      const pcieY = cpuY + s.cpu / 2 + g.cpuToPcie + s.pcie.height / 2;
      const gpuY = pcieY + s.pcie.height / 2 + g.pcieToGpu + s.gpu.height / 2;

      // Calculate node positions
      const pcieX = x + l.pcieOffsetX;
      const efaX = x + l.efaNvmeOffsetX;
      const nvmeX = x + l.efaNvmeOffsetX;
      const efaY = pcieY + l.efaOffsetY;
      const nvmeY = pcieY + l.nvmeOffsetY;

      // Calculate bounding box BEFORE creating nodes
      const nodeBounds = [
        { x: pcieX, y: pcieY, width: s.pcie.width, height: s.pcie.height },
        { x: efaX, y: efaY, width: s.efa.width, height: s.efa.height },
        { x: nvmeX, y: nvmeY, width: s.nvme.width, height: s.nvme.height },
        { x: pcieX, y: gpuY, width: s.gpu.width, height: s.gpu.height }
      ];

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      nodeBounds.forEach(node => {
        minX = Math.min(minX, node.x - node.width / 2);
        maxX = Math.max(maxX, node.x + node.width / 2);
        minY = Math.min(minY, node.y - node.height / 2);
        maxY = Math.max(maxY, node.y + node.height / 2);
      });

      const bgWidth = maxX - minX + l.groupPadding * 2;
      const bgHeight = maxY - minY + l.groupPadding * 2;
      const bgCenterX = (minX + maxX) / 2;
      const bgCenterY = (minY + maxY) / 2;

      // Draw background FIRST (will be behind nodes)
      renderer.drawBackground(`group${suffix}`, bgCenterX, bgCenterY, bgWidth, bgHeight);

      // Nodes
      renderer.drawNode(`pcie${suffix}`, pcieX, pcieY, s.pcie.width, s.pcie.height, 'PCIe\nSwitch', 'network');
      renderer.addPinsToNode(`pcie${suffix}`, {
        pinsPerSide: 6,
        sides: ['left', 'right'],
        pinLength: 3,
        pinPadding: 8
      });
      renderer.drawStackedNode(`efa${suffix}`, efaX, efaY, s.efa.width, s.efa.height, 'EFA', 4, 'network');
      renderer.drawStorageNode(`nvme${suffix}`, nvmeX, nvmeY, s.nvme.width, s.nvme.height, 'NVMe', 'storage');
      renderer.drawProcessorNode(`gpu${suffix}`, pcieX, gpuY, s.gpu.width, s.gpu.height, 'GPU', 'gpu');

      // Phantom nodes for routing
      // PCIe phantoms: bord gauche aligné avec PCIe, largeur du PCIe
      const pcieLeftEdge = pcieX;
      const pciePhantomX = pcieLeftEdge;
      renderer.addPhantom(`pcie-efa-phantom${suffix}`, pciePhantomX, efaY, s.pcie.width, s.efa.height);
      renderer.addPhantom(`pcie-nvme-phantom${suffix}`, pciePhantomX, nvmeY, s.pcie.width, s.nvme.height);

      // EFA external phantom: à droite de EFA
      const efaRightEdge = efaX + s.efa.width / 2;
      const efaPhantomX = efaRightEdge + g.connectionOffset + s.efa.width / 2 + 20;  // Centre du phantom + décalage réduit
      renderer.addPhantom(`efa-external${suffix}`, efaPhantomX, efaY, s.efa.width, s.efa.height);

      // Create links from configuration
      CONFIG.groupLinks.forEach(linkDef => {
        const bw = getBandwidth(linkDef.bandwidth);
        const fromId = linkDef.from === 'cpu' ? cpuId : `${linkDef.from}${suffix}`;  // Use cpuId from parameter
        const toId = `${linkDef.to}${suffix}`;
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const offset = getLinkOffset(bw.width);  // Proportional offset based on link width

        if (linkDef.stacked) {
          renderer.drawStackedLinks(fromId, toId, linkDef.stacked, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, linkDef.type, linkDef.bandwidth);
        } else if (linkDef.multiLink) {
          // Use localIndex for multi-link spacing (0-3 within ensemble)
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, localIndex, CONFIG.groupCount, 0, 1, linkDef.type, linkDef.bandwidth);
        } else {
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, 0, 1, 0, 1, linkDef.type, linkDef.bandwidth);
        }
      });
    }

    // ============================================================================
    // DRAW SINGLE ENSEMBLE (CPU + 4 groups + 2 NVSwitches)
    // ============================================================================
    function drawEnsemble(renderer, ensembleGlobalIndex, centerX, cpuY, nvswitchY) {
      const cpuId = ensembleGlobalIndex === 0 ? 'cpu' : `cpu-${ensembleGlobalIndex}`;

      // CPU for this ensemble
      renderer.drawProcessorNode(cpuId, centerX, cpuY, CONFIG.sizes.cpu, CONFIG.sizes.cpu, 'CPU', 'cpu');

      // Groups for this ensemble
      for (let i = 0; i < CONFIG.groupCount; i++) {
        const groupGlobalIndex = ensembleGlobalIndex * CONFIG.groupCount + i;
        const offsetX = (i - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal;
        drawGroup(renderer, groupGlobalIndex, i, centerX + offsetX, cpuY, nvswitchY, cpuId);  // Pass i as localIndex
      }

      // NVSwitches: positioned between pairs of groups
      for (let i = 0; i < CONFIG.nvswitchCount; i++) {
        const nvswitchGlobalIndex = ensembleGlobalIndex * CONFIG.nvswitchCount + i;
        const groupPairStart = i * 2;
        const groupPairEnd = groupPairStart + 1;

        const group1X = centerX + ((groupPairStart - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const group2X = centerX + ((groupPairEnd - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const nvswitchX = (group1X + group2X) / 2;

        renderer.drawNode(`nvswitch-${nvswitchGlobalIndex}`, nvswitchX, nvswitchY,
          CONFIG.sizes.nvswitch.width, CONFIG.sizes.nvswitch.height, 'NVSwitch', 'network');

        // Add pins to NVSwitch (like PCIe Switch)
        renderer.addPinsToNode(`nvswitch-${nvswitchGlobalIndex}`, {
          pinsPerSide: 6,
          sides: ['left', 'right'],
          pinLength: 3,
          pinPadding: 8
        });
      }

    }


    // ============================================================================
    // DRAW SINGLE SYSTEM (variable number of ensembles)
    // ============================================================================
    function drawSystem(renderer, systemIndex, systemCenterX, cpuY, nvswitchY, ensembleCount = 1, systemCount = 1, shouldDrawEfaCrossLinks = false) {
      // For internode (2 systems), only show 1 ensemble per system for clarity
      const ensemblesToShow = (systemCount === 2) ? 1 : ensembleCount;

      // Calculate ensemble width (4 groups)
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;

      // Calculate system bounding box based on actual ensembles shown
      const systemWidth = ensemblesToShow * ensembleWidth + (ensemblesToShow - 1) * CONFIG.gaps.ensembleGap;
      const systemHeight = CONFIG.sizes.cpu + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height;

      const systemBgCenterY = cpuY + (nvswitchY - cpuY) / 2;
      const systemPadding = 30;

      // In internode mode, extend the rectangle slightly to the right
      const isInternode = systemCount === 2;
      const extraWidth = isInternode && ensembleCount === 2 ? 210 : 0;

      // Draw system background ONLY if 2 ensembles (intra-node vs inter-node distinction)
      if (ensembleCount === 2) {
        // Adjust rectX to center the extended rectangle
        const totalWidth = systemWidth + systemPadding * 2 + extraWidth;
        const rectX = systemCenterX - totalWidth / 2;
        const rectY = systemBgCenterY - (systemHeight + systemPadding * 2) / 2;
        const rectWidth = totalWidth;
        const rectHeight = systemHeight + systemPadding * 2;

        renderer.structuralGroup.rect(rectWidth, rectHeight)
          .move(rectX, rectY)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 3,
            opacity: 1
          })
          .radius(12)
          .attr('data-group-border', 'node');

        // Add "Node" label at top left of the system box
        renderer.nodesGroup.text('Node')
          .move(rectX + 35, rectY + 40)
          .font({
            size: 32,
            family: 'var(--font-family)',
            weight: 900,
            fill: CONFIG.colors.textSecondary
          })
          .opacity(0.8);

        // Add NUMA 1 group with "..." in the extended area for internode mode
        if (isInternode) {
          const numaPadding = 15;
          const numaWidth = extraWidth - 15; // Margin for spacing
          const numaHeight = systemHeight;

          const numaX = rectX + rectWidth - extraWidth; // Left margin
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth;
          const numaRectHeight = numaHeight + numaPadding * 2;

          // Draw NUMA 1 border
          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA 1" label at top right
          renderer.nodesGroup.text('NUMA 1')
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);

          // Add "..." centered in NUMA 1
          renderer.nodesGroup.text('...')
            .move(numaX + numaRectWidth / 2, numaY + numaRectHeight / 2)
            .font({
              size: 40,
              family: 'var(--font-family)',
              weight: 900,
              fill: CONFIG.colors.textSecondary,
              anchor: 'middle'
            })
            .opacity(0.6);
        }
      }

      // Draw each ensemble in the system
      for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
        const ensembleGlobalIndex = systemIndex * CONFIG.ensembleCount + ensIndex;

        // Position ensemble within system
        let ensembleCenterX;
        if (isInternode) {
          // In internode mode, align NUMA 0 to the left of the Node rectangle
          const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
          ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
        } else {
          // Normal centered positioning
          const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
          ensembleCenterX = systemCenterX + ensembleOffsetX;
        }

        drawEnsemble(renderer, ensembleGlobalIndex, ensembleCenterX, cpuY, nvswitchY);
      }

      // Draw NUMA node borders (one per ensemble) if 2 ensembles
      if (ensembleCount === 2) {
        for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
          let ensembleCenterX;
          if (isInternode) {
            // In internode mode, align NUMA 0 to the left
            const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
            ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
          } else {
            // Normal centered positioning
            const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
            ensembleCenterX = systemCenterX + ensembleOffsetX;
          }

          // Calculate NUMA node bounding box (same as system but for single ensemble)
          const numaWidth = ensembleWidth;
          const numaHeight = systemHeight;
          const numaPadding = 15;

          const numaX = ensembleCenterX - (numaWidth + numaPadding * 2) / 2;
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth + numaPadding * 2;
          const numaRectHeight = numaHeight + numaPadding * 2;

          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA" label at top right
          renderer.nodesGroup.text(`NUMA ${ensIndex}`)
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);
        }
      }

      // GPU to NVSwitch connections (full mesh - all GPUs to all NVSwitches in system)
      const linkDef = CONFIG.gpuNvswitchLink;
      const bw = getBandwidth(linkDef.bandwidth);
      const color = CONFIG.colors.linkColor;
      const offset = getLinkOffset(bw.width);

      // Connect all GPUs in the system to all NVSwitches in the system
      const totalGpusInSystem = ensemblesToShow * CONFIG.groupCount;
      const totalNVSwitchesInSystem = ensemblesToShow * CONFIG.nvswitchCount;

      // Collect all GPU-NVSwitch connections for randomized drawing
      const gpuNvswitchConnections = [];
      for (let gpuIndex = 0; gpuIndex < totalGpusInSystem; gpuIndex++) {
        const gpuGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + gpuIndex;
        const gpuId = gpuGlobalIndex === 0 ? 'gpu' : `gpu-${gpuGlobalIndex}`;

        for (let nvIndex = 0; nvIndex < totalNVSwitchesInSystem; nvIndex++) {
          const nvswitchGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.nvswitchCount + nvIndex;
          gpuNvswitchConnections.push({
            fromId: gpuId,
            toId: `nvswitch-${nvswitchGlobalIndex}`,
            color: color,
            width: bw.width,
            fromSide: linkDef.fromSide,
            toSide: linkDef.toSide,
            offset: offset,
            type: linkDef.type,
            bandwidth: linkDef.bandwidth
          });
        }
      }

      // Randomize and draw GPU-NVSwitch connections
      const shuffledGpuNvswitchConnections = gpuNvswitchConnections.sort(() => Math.random() - 0.5);
      shuffledGpuNvswitchConnections.forEach(conn => {
        renderer.drawLink(conn.fromId, conn.toId, conn.color, conn.width, conn.fromSide, conn.toSide, conn.offset, 0, 1, 0, 1, conn.type, conn.bandwidth);
      });

      // Draw CPU-to-CPU link between ensembles (only if 2 ensembles visible)
      if (ensemblesToShow === 2) {
        const cpu0Id = systemIndex * CONFIG.ensembleCount === 0 ? 'cpu' : `cpu-${systemIndex * CONFIG.ensembleCount}`;
        const cpu1Id = `cpu-${systemIndex * CONFIG.ensembleCount + 1}`;

        // Use a bandwidth for CPU-CPU connection (assuming similar to CPU-PCIe)
        const bw = getBandwidth('16GB/s');
        const color = CONFIG.colors.linkColor;
        const offset = getLinkOffset(bw.width);

        renderer.drawLink(cpu0Id, cpu1Id, color, bw.width, 'right', 'left', offset, 0, 1, 0, 1, 'cpu', '16GB/s');

        // Draw EFA-to-EFA link between ensembles (only if 2 ensembles visible and explicitly requested)
        if (ensemblesToShow === 2 && shouldDrawEfaCrossLinks) {
          const efaExt0Id = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount === 0 ? 'efa-external' : `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount}`;
          const efaExt1Id = `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + CONFIG.groupCount}`;

          // Use unified EFA cross-links function
          drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
        }
      }
    }

    // ============================================================================
    // DRAW COMPLETE TOPOLOGY
    // ============================================================================
    let currentEnsembleCount = 2;  // Start with 2 ensembles (1 complete node)
    let currentSystemCount = 1;    // Start with 1 system
    let currentActivePathId = null; // Track active path for conditional rendering
    let showRealBandwidthsOverride = null; // User override via checkbox (null = use config)

    function drawTopology(ensembleCount = currentEnsembleCount, systemCount = currentSystemCount) {
      // Clear existing
      const container = getElement('aws-topology-container');
      container.innerHTML = '';

      // Use FIXED viewbox size for consistent zoom across all modes
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;
      const isInternodeLayout = systemCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode';

      // Calculate single system height (used in both layouts)
      const singleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;

      // Always use max viewbox dimensions for consistent zoom level
      const maxEnsembleWidthForViewbox = 2 * ensembleWidth;
      let viewboxWidth = maxEnsembleWidthForViewbox + CONFIG.gaps.ensembleGap + 200;
      let viewboxHeight = singleSystemHeight;

      // For single ensemble (CPU-GPU, GPU-GPU via CPU, storage paths), zoom in more
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxWidth *= 0.65;  // Zoom in by reducing viewbox width (increased from 0.75)
        viewboxHeight *= 0.65; // Zoom in by reducing viewbox height (increased from 0.75)
      }

      // For 2 systems in vertical layout, use scaled dimensions
      if (systemCount === 2 && !isInternodeLayout) {
        viewboxHeight = singleSystemHeight * 2 + CONFIG.gaps.systemGap;
        viewboxWidth *= 1.15;
        viewboxHeight *= 1.15;
      }

      // For internode horizontal layout, extend viewbox width to accommodate both extended systems
      if (isInternodeLayout) {
        const extraWidth = 210; // Extension per system for NUMA 1
        const systemPadding = 30;
        const singleEnsembleWidth = ensembleWidth;
        const totalSystemWidth = singleEnsembleWidth + systemPadding * 2 + extraWidth;
        const gap = 80;
        viewboxWidth = totalSystemWidth * 2 + gap + 200; // Extra margin for comfort
      }

      // Fixed height based on screen width for better consistency
      const embedConfig = readEmbedConfig();
      const containerWidth = container.clientWidth || 800;

      // Calculate fixed height: use max viewbox dimensions to determine aspect ratio
      // Max viewbox is for 2 ensembles, 2 systems (vertical layout)
      const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
      const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;
      const maxViewboxHeight = maxSingleSystemHeight * 1.15; // Account for 2-system scaling
      const maxViewboxWidth = maxEnsembleWidth + 200;

      const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
      const baseHeight = containerWidth * maxAspectRatio;
      const legendHeight = embedConfig.initialFilter ? 150 : 200;

      // Set fixed height once, won't change on filter change
      if (!container.dataset.heightSet) {
        container.style.height = `${baseHeight + legendHeight}px`;
        container.dataset.heightSet = 'true';
      }

      // Viewbox will auto-center/zoom content
      let viewboxY = 0;
      let paddedViewboxHeight = viewboxHeight;
      const verticalPadding = 0;
      viewboxY = -verticalPadding / 2 + 100;
      paddedViewboxHeight = viewboxHeight + verticalPadding;

      // For single ensemble, shift content up slightly
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxY += 150;  // Shift up by reducing viewboxY (reduced from 80)
      }

      // For single node mode (no Node/NUMA groups), shift content down by 80px
      // BUT only if: 1) not an EFA filter, 2) a filter is active
      const isEfaFilter = currentActivePathId === 'gpu-gpu-efa-intranode' || currentActivePathId === 'gpu-gpu-efa-internode';
      const hasActiveFilter = currentActivePathId && currentActivePathId !== '';
      if (!isInternodeLayout && hasActiveFilter && !isEfaFilter) {
        viewboxY -= 80;  // Shift down by decreasing viewboxY (increased from 50px)
      }

      const draw = SVG().addTo(container).size('100%', '100%').viewbox(0, viewboxY, viewboxWidth, paddedViewboxHeight);
      const renderer = new TopologyRenderer(draw);

      const centerX = viewboxWidth / 2;

      // Draw each system - horizontally for internode, vertically for others
      const isInternodeHorizontalLayout = isInternodeLayout;

      for (let sysIndex = 0; sysIndex < systemCount; sysIndex++) {
        let systemCenterX, cpuY, nvswitchY;

        if (isInternodeHorizontalLayout) {
          // Horizontal layout for internode: systems side by side (rapprochés mais sans overlap)
          // Pour internode, on affiche 1 seul ensemble (NUMA) par système, donc largeur réelle = 50%
          const fullSystemWidth = ensembleCount * ensembleWidth + (ensembleCount - 1) * CONFIG.gaps.ensembleGap;
          const actualSystemWidth = fullSystemWidth * 0.5; // On n'affiche qu'1 ensemble sur 2
          const extraWidth = 210; // Extension pour le groupe NUMA 1
          const systemPadding = 10;
          const totalSystemWidth = actualSystemWidth + systemPadding * 2 + extraWidth; // Largeur totale incluant l'extension
          const gap = 80; // Gap visible entre les systèmes

          // Positionner les systèmes avec le gap (en prenant en compte la largeur totale)
          if (sysIndex === 0) {
            systemCenterX = centerX - (totalSystemWidth / 2 + gap / 2); // Premier système à gauche
          } else {
            systemCenterX = centerX + (totalSystemWidth / 2 + gap / 2); // Deuxième système à droite
          }
          cpuY = CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        } else {
          // Vertical layout for other cases: systems stacked vertically
          const systemOffsetY = sysIndex * (singleSystemHeight + CONFIG.gaps.systemGap);
          systemCenterX = centerX;
          cpuY = systemOffsetY + CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        }

        // Only draw EFA cross-links for intranode EFA path
        const shouldDrawEfaCrossLinks = currentActivePathId === 'gpu-gpu-efa-intranode';
        drawSystem(renderer, sysIndex, systemCenterX, cpuY, nvswitchY, ensembleCount, systemCount, shouldDrawEfaCrossLinks);
      }

      // Draw EFA cross-link between systems (for internode)
      if (systemCount === 2 && ensembleCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode') {
        const efaExt0Id = 'efa-external';  // System 0, ensemble 0, group 0
        const efaExt1Id = 'efa-external-8';  // System 1, ensemble 0, group 0 (4 groups per ensemble, 2 ensembles per system = group 8)

        // Use unified EFA cross-links function
        drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
      }

      currentEnsembleCount = ensembleCount;
      currentSystemCount = systemCount;
    }

    // ============================================================================
    // REAL BANDWIDTH HELPERS
    // ============================================================================
    function getRealBandwidthForPath(pathId) {
      const pathToRealBandwidth = {
        'cpu-gpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-cpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-nvswitch': { value: '786', unit: 'GB/s' },
        'gpu-gpu-efa-intranode': { value: '40', unit: 'GB/s' },
        'gpu-gpu-efa-internode': { value: '40', unit: 'GB/s' },
        'gpu-storage': { value: '14.2', unit: 'GB/s' },
        'cpu-storage': { value: '14.2', unit: 'GB/s' },
        'gpu-cpu-storage': { value: '14.2', unit: 'GB/s' }
      };

      const bandwidth = pathToRealBandwidth[pathId];
      if (bandwidth) {
        return {
          value: bandwidth.value,
          unit: bandwidth.unit
        };
      }
      return null;
    }

    // ============================================================================
    // HIGHLIGHT HELPERS
    // ============================================================================
    function highlightPath(path, pathLabel = '', pathId = '') {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear previous active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Ghost all base links and cross-links groups at once
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '0.35';

        // Increase stroke width of group borders to make them more visible when ghosted
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '5');
          // border.setAttribute('stroke-opacity', '0.8');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '0.25';
      }

      // Dim nodes individually (they're not in a group)
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '0.6';
        // Dim text labels
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '0.25';
        });
      });

      // Highlight path nodes
      path.nodes.forEach(nodeId => {
        let nodeEl = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeEl) {
          const candidates = svg.querySelectorAll(`g[id^="${nodeId}"]`);
          nodeEl = candidates[0];
        }
        if (nodeEl) {
          nodeEl.style.opacity = '1';
          // Restore text opacity
          nodeEl.querySelectorAll('text').forEach(text => {
            text.style.opacity = '1';
          });
        }
      });

      // Duplicate active links into activeLinksGroup
      if (activeLinksGroup) {
        path.links.forEach(linkSpec => {
          // Find matching links in base groups
          const allBaseLinks = [
            ...svg.querySelectorAll('g[data-group="base-links"] > g[data-link-type]'),
            ...svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type]')
          ];

          allBaseLinks.forEach(linkGroup => {
            const linkFrom = linkGroup.getAttribute('data-from');
            const linkTo = linkGroup.getAttribute('data-to');

            const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
            const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

            if (matchesFrom && matchesTo) {
              // Clone the link and append to active group
              const clonedLink = linkGroup.cloneNode(true);
              activeLinksGroup.appendChild(clonedLink);
            }
          });
        });

        // Duplicate EFA cross-links if they match the current path
        const currentPathId = currentActivePathId;
        if (currentPathId === 'gpu-gpu-efa-intranode' || currentPathId === 'gpu-gpu-efa-internode') {
          const efaCrossLinks = svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type="efa-crosslink"]');
          efaCrossLinks.forEach(linkGroup => {
            const clonedLink = linkGroup.cloneNode(true);
            activeLinksGroup.appendChild(clonedLink);
          });
        }
      }

      // Calculate and show bottleneck (minimum bandwidth in the path)
      let minBandwidth = Infinity;
      let minBandwidthValue = null;
      const usedBandwidths = new Set();

      path.links.forEach(linkSpec => {
        svg.querySelectorAll('g[data-link-type]').forEach(linkGroup => {
          const linkFrom = linkGroup.getAttribute('data-from');
          const linkTo = linkGroup.getAttribute('data-to');

          const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
          const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

          if (matchesFrom && matchesTo) {
            const bandwidth = linkGroup.getAttribute('data-bandwidth');
            if (bandwidth) {
              const bw = getBandwidth(bandwidth);
              if (bw && bw.numericValue < minBandwidth) {
                minBandwidth = bw.numericValue;
                minBandwidthValue = bw.speed;
              }
              if (bw) {
                usedBandwidths.add(bw.speed);
              }
            }
          }
        });
      });

      // Highlight all used bandwidths in the legend
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          const bandwidth = legendItem.getAttribute('data-legend-bandwidth');
          if (usedBandwidths.has(bandwidth)) {
            // Used in the path - active
            legendItem.style.opacity = '1';
          } else {
            // Not used - ghosted
            legendItem.style.opacity = '0.4';
          }
        });
      }

      // Show bottleneck info
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      const efficiencyValueEl = bottleneckEl.querySelector('.efficiency-value');

      // Check if real bandwidths are enabled
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (showRealBandwidths) {
        // When real bandwidths are shown, display real bandwidth value directly
        const realBandwidth = getRealBandwidthForPath(pathId);
        if (realBandwidth) {
          bottleneckValueEl.textContent = realBandwidth.value;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');

          // Calculate and display efficiency
          if (minBandwidthValue && efficiencyEl && efficiencyValueEl) {
            const theoreticalBandwidth = parseFloat(minBandwidthValue.replace('GB/s', ''));
            const realBandwidthNum = parseFloat(realBandwidth.value);

            // For EFA (12.5GB/s), multiply by 4 to get total theoretical bandwidth
            const adjustedTheoretical = minBandwidthValue === '12.5GB/s' ? theoreticalBandwidth * 4 : theoreticalBandwidth;

            const efficiency = (realBandwidthNum / adjustedTheoretical) * 100;
            efficiencyValueEl.textContent = `${efficiency.toFixed(1)}%`;
            efficiencyEl.style.display = 'block';
          }
        } else {
          // Fallback if no real bandwidth found
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');
          if (efficiencyEl) {
            efficiencyEl.style.display = 'none';
          }
        }
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      } else {
        // Normal bottleneck display
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        if (minBandwidthValue) {
          const value = minBandwidthValue.replace('GB/s', '');
          // For EFA (12.5GB/s), display as 50 (4 links × 12.5)
          const displayValue = value === '12.5' ? '50' : value;
          bottleneckValueEl.textContent = displayValue;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        } else {
          // Debug: show the module even without bandwidth data
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        }
        // Hide efficiency in normal mode
        if (efficiencyEl) {
          efficiencyEl.style.display = 'none';
        }
      }
    }

    function resetHighlight() {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Restore opacity to base links groups
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '1';

        // Restore original stroke width for group borders
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '3');
          border.setAttribute('stroke-opacity', '1');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '1';
      }

      // Reset nodes opacity
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '1';
        // Reset text opacity
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '1';
        });
      });

      // Clear current active path to ensure EFA cross-links are not drawn
      currentActivePathId = null;

      // Reset legend opacity
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          legendItem.style.opacity = '1';
        });
      }

      // Hide bottleneck (unless real bandwidths are enabled)
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (!showRealBandwidths) {
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        bottleneckEl.classList.remove('visible');
      } else {
        // When real bandwidths are enabled, hide the module when no path is active
        bottleneckLabelEl.textContent = 'Real Bandwidth';
        bottleneckEl.classList.remove('visible');
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      }

      // Hide efficiency display
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      if (efficiencyEl) {
        efficiencyEl.style.display = 'none';
      }
    }

    // ============================================================================
    // CONFIG READING (from HtmlEmbed props)
    // ============================================================================
    function readEmbedConfig() {
      // Find the closest ancestor that carries the data-config attribute
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let providedConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      const config = providedConfig || {};

      // Apply user override from checkbox if set
      if (showRealBandwidthsOverride !== null) {
        config.showRealBandwidths = showRealBandwidthsOverride;
      }

      return config;
    }

    // ============================================================================
    // REAL BANDWIDTHS DISPLAY
    // ============================================================================
    function displayContextualRealBandwidths(pathId, pathLabel) {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Map path IDs to relevant real bandwidths
      const pathToBandwidths = {
        'cpu-gpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-cpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-GPU (via CPU)', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-nvswitch': [
          { label: 'GPU-GPU (NVSwitch)', value: CONFIG.realBandwidths['gpu-gpu-same-node'] }
        ],
        'gpu-gpu-efa-intranode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-intranode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
          { label: 'All2All', value: CONFIG.realBandwidths['all2all-same-node'] }
        ],
        'gpu-gpu-efa-internode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-internode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
          { label: 'All2All', value: CONFIG.realBandwidths['alltoall-internode'] }
        ],
        'gpu-storage': [
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'cpu-storage': [
          { label: 'CPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'gpu-cpu-storage': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ]
      };

      const relevantBandwidths = pathToBandwidths[pathId] || [];

      if (relevantBandwidths.length > 0) {
        // Clear normal bottleneck display
        bottleneckValueEl.textContent = '';
        bottleneckPathEl.textContent = '';

        // Create HTML for relevant bandwidths
        const html = relevantBandwidths.map(item => `
          <div class="bandwidth-item">
            <span class="bandwidth-label">${item.label}</span>
            <span class="bandwidth-value">${item.value}</span>
          </div>
        `).join('');

        realBandwidthsContentEl.innerHTML = html;
      } else {
        // Fallback: show all bandwidths if path not found
        setupRealBandwidthsDisplay();
      }
    }

    function setupRealBandwidthsDisplay() {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Create the bandwidth items HTML
      const bandwidthItems = [
        { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
        { label: 'Same Node', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-same-node'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
        { label: '  All2All', value: CONFIG.realBandwidths['all2all-same-node'] },
        { label: 'Internode', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-internode'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
        { label: '  All2All', value: CONFIG.realBandwidths['alltoall-internode'] },
        { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
      ];

      const html = bandwidthItems.map(item => {
        if (item.value === '') {
          // Section header
          return `<div class="bandwidth-section-header" style="font-weight: 600; margin: 6px 0 4px 0; color: var(--text-secondary);">${item.label}</div>`;
        } else {
          // Bandwidth item
          return `
            <div class="bandwidth-item">
              <span class="bandwidth-label">${item.label}</span>
              <span class="bandwidth-value">${item.value}</span>
            </div>
          `;
        }
      }).join('');

      realBandwidthsContentEl.innerHTML = html;
    }

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    function initialize() {
      const container = getElement('aws-topology-container');
      const tooltip = getElement('aws-topology-tooltip');

      // Read initial config from HtmlEmbed props (before any override)
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let initialConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          initialConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      // Initialize override with initial config value (so checkbox is in sync)
      if (initialConfig && initialConfig.showRealBandwidths !== undefined) {
        showRealBandwidthsOverride = initialConfig.showRealBandwidths;
      }

      // Now read config (which will use override if set)
      const embedConfig = readEmbedConfig();

      // Setup real bandwidths display if enabled
      if (embedConfig.showRealBandwidths) {
        const bottleneckEl = getElement('aws-topology-bottleneck');
        const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');

        // Change label to "Real Bandwidth"
        bottleneckLabelEl.textContent = 'Real Bandwidth';

        // Hide the detailed real bandwidths list initially
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
        // Don't show the module initially - only when a path is selected
        bottleneckEl.classList.remove('visible');
      }

      drawTopology();

      // Initial fade in
      requestAnimationFrame(() => {
        container.style.opacity = '1';
      });

      // Setup tooltip

      container.addEventListener('mouseover', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          const bandwidth = target.getAttribute('data-bandwidth');
          const label = target.getAttribute('data-label');

          // Clear and rebuild tooltip content
          tooltip.innerHTML = '';

          if (label) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'tooltip-label';
            labelDiv.textContent = label;
            tooltip.appendChild(labelDiv);
          }

          const bandwidthDiv = document.createElement('div');
          bandwidthDiv.className = 'tooltip-bandwidth';
          bandwidthDiv.textContent = bandwidth;
          tooltip.appendChild(bandwidthDiv);

          tooltip.classList.add('visible');
        }
      });

      container.addEventListener('mousemove', (e) => {
        if (tooltip.classList.contains('visible')) {
          const rect = container.getBoundingClientRect();
          tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
          tooltip.style.top = (e.clientY - rect.top + 10) + 'px';
        }
      });

      container.addEventListener('mouseout', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          tooltip.classList.remove('visible');
        }
      });

      // Create control buttons organized by category
      const controlsContainer = getElement('aws-topology-controls');

      // Hide controls if an initial filter is provided
      if (embedConfig.initialFilter) {
        controlsContainer.style.display = 'none';
      } else {
        // Categorize paths
        const pathsByCategory = {
          intranode: [
            { id: 'cpu-gpu', label: CONFIG.paths['cpu-gpu'].label },
            { id: 'gpu-gpu-cpu', label: CONFIG.paths['gpu-gpu-cpu'].label },
            { id: 'gpu-gpu-nvswitch', label: CONFIG.paths['gpu-gpu-nvswitch'].label },
            { id: 'gpu-gpu-efa-intranode', label: CONFIG.paths['gpu-gpu-efa-intranode'].label }
          ],
          internode: [
            { id: 'gpu-gpu-efa-internode', label: CONFIG.paths['gpu-gpu-efa-internode'].label }
          ],
          storage: [
            { id: 'gpu-storage', label: CONFIG.paths['gpu-storage'].label },
            { id: 'cpu-storage', label: CONFIG.paths['cpu-storage'].label },
            { id: 'gpu-cpu-storage', label: CONFIG.paths['gpu-cpu-storage'].label }
          ]
        };

        // Create single select with prefixed options and checkbox
        const isChecked = showRealBandwidthsOverride === true || (showRealBandwidthsOverride === null && embedConfig.showRealBandwidths);
        const controlsHTML = `
          <div>
            <label id="real-bandwidth-label" style="display: flex; align-items: center; gap: 0px; font-size: 14px; color: var(--text-color); cursor: pointer; opacity: 0.3; transition: opacity 0.2s;">
              <input type="checkbox" id="real-bandwidth-toggle" ${isChecked ? 'checked' : ''} disabled>
              <span>Show Real Bandwidths</span>
            </label>
          </div>
          
          <div style="display: flex; gap: 12px; align-items: center; margin-top: 8px;">
            <select id="path-select" style="min-width: 250px;">
              <option value="">Select path...</option>
            </select>
          </div>
        `;
        controlsContainer.innerHTML = controlsHTML;

        const pathSelect = controlsContainer.querySelector('#path-select');
        const realBandwidthToggle = controlsContainer.querySelector('#real-bandwidth-toggle');
        const realBandwidthLabel = controlsContainer.querySelector('#real-bandwidth-label');

        // Populate single select with prefixed options
        Object.entries(pathsByCategory).forEach(([category, paths]) => {
          const categoryLabel = category.charAt(0).toUpperCase() + category.slice(1);

          paths.forEach(path => {
            const option = document.createElement('option');
            option.value = path.id;
            option.textContent = `${categoryLabel}: ${path.label}`;
            pathSelect.appendChild(option);
          });
        });

        // Helper function to enable/disable real bandwidth toggle
        const updateRealBandwidthToggleState = (enabled) => {
          if (enabled) {
            realBandwidthToggle.disabled = false;
            realBandwidthLabel.style.opacity = '1';
            realBandwidthLabel.style.cursor = 'pointer';
          } else {
            realBandwidthToggle.disabled = true;
            realBandwidthLabel.style.opacity = '0.3';
            realBandwidthLabel.style.cursor = 'default';
          }
        };

        // Real bandwidth toggle handler
        realBandwidthToggle.addEventListener('change', (e) => {
          showRealBandwidthsOverride = e.target.checked;

          // Re-apply highlight if a path is active
          if (currentActivePathId) {
            const path = CONFIG.paths[currentActivePathId];
            if (path) {
              highlightPath(path, path.label, currentActivePathId);
            }
          } else {
            // If no path active, just reset to clear any displayed values
            resetHighlight();
          }
        });

        // Function to activate a path
        const activatePath = (pathId) => {
          if (!pathId) {
            // Reset to default
            currentActivePathId = null;
            updateRealBandwidthToggleState(false); // Disable toggle when no path selected
            const needsRedraw = currentEnsembleCount !== 2 || currentSystemCount !== 1;

            if (needsRedraw) {
              const container = getElement('aws-topology-container');
              container.style.opacity = '0';

              setTimeout(() => {
                drawTopology(2, 1);
                resetHighlight();

                requestAnimationFrame(() => {
                  container.style.opacity = '1';
                });
              }, 150);
            } else {
              resetHighlight();
            }
            return;
          }

          const path = CONFIG.paths[pathId];
          if (!path) return;

          currentActivePathId = pathId;
          updateRealBandwidthToggleState(true); // Enable toggle when path is selected

          // Check if we need to redraw
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            pathId === 'gpu-gpu-efa-intranode' ||
            pathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            const container = getElement('aws-topology-container');
            container.style.opacity = '0';

            setTimeout(() => {
              currentActivePathId = pathId;
              drawTopology(path.requiredEnsembles, path.requiredSystems);
              highlightPath(path, path.label, pathId);

              requestAnimationFrame(() => {
                container.style.opacity = '1';
              });
            }, 150);
          } else {
            currentActivePathId = pathId;
            highlightPath(path, path.label, pathId);
          }
        };

        // Path select change handler
        pathSelect.addEventListener('change', (e) => {
          const pathId = e.target.value;
          activatePath(pathId);
        });
      }

      // Apply initial filter from embedConfig if provided
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          currentActivePathId = initialPathId;

          // Draw topology with correct requirements
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            initialPathId === 'gpu-gpu-efa-intranode' ||
            initialPathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            drawTopology(path.requiredEnsembles, path.requiredSystems);
          }
        }
      }

      // Create SVG legend
      const legendContainer = getElement('aws-topology-legend');
      const legendSvg = SVG().addTo(legendContainer).size('100%', '100%');

      const lineLength = 36;  // 30 * 1.2
      const itemSpacing = 30;  // 25 * 1.2
      const startX = 96;  // 80 * 1.2
      const startY = 42;  // 35 * 1.2
      const textOffset = 24;  // 20 * 1.2

      // Calculate actual legend width based on content
      const legendWidth = startX + lineLength + textOffset + 168;  // 140 * 1.2
      const legendHeight = 144;  // 120 * 1.2
      legendSvg.viewbox(0, 0, legendWidth, legendHeight);

      [...CONFIG.bandwidths].reverse().forEach((bw, index) => {
        const y = startY + (index * itemSpacing);
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const width = bw.width;

        // Create a group for each legend item with a data attribute for bandwidth
        const legendItemGroup = legendSvg.group();
        legendItemGroup.attr('data-legend-bandwidth', bw.speed);

        // Dessiner la ligne
        legendItemGroup.line(startX, y, startX + lineLength, y)
          .stroke({ color, width });

        // Dessiner les cercles aux extrémités
        const r = width * 0.8;
        const startCircle = legendItemGroup.circle(r * 2).move(startX - r, y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        const endCircle = legendItemGroup.circle(r * 2).move(startX + lineLength - r, y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        // Ajouter le texte (aligné à droite, valeur en gras)
        const textX = legendWidth - 5;
        const value = bw.speed.replace('GB/s', '').trim();

        // Format: "Label - 900 GB/s" avec 900 en gras
        const textEl = legendItemGroup.text(function (add) {
          add.tspan(bw.label + ' - ').font({ weight: 'normal' });
          add.tspan(value).font({ weight: 'bold' });
          add.tspan(' GB/s').font({ weight: 'normal' });
        })
          .move(textX, y)
          .font({
            family: 'system-ui, -apple-system, sans-serif',
            size: 14,  // 12 * 1.2 ≈ 14
            anchor: 'end',
            fill: CONFIG.colors.nodeText
          })
          .dy(-7);  // -6 * 1.2 ≈ -7
      });
    }

    // Initialize only if wrapper is found
    if (findWrapper()) {
      initialize();

      // Apply initial filter highlight after legend is created
      const embedConfig = readEmbedConfig();
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          // Apply highlight to both topology and legend
          highlightPath(path, path.label, initialPathId);
        }
      }

      // Add resize handler for responsive width changes (mobile/desktop)
      const handleResize = () => {
        const container = getElement('aws-topology-container');
        if (!container) return;

        // Recalculate fixed height based on new width (for responsive design)
        const containerWidth = container.clientWidth || 800;

        // Use max viewbox dimensions for consistent aspect ratio
        const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
        const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
          CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
          CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
          CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
          CONFIG.gaps.bottomMargin;
        const maxViewboxHeight = maxSingleSystemHeight * 1.15;
        const maxViewboxWidth = maxEnsembleWidth + 200;

        const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
        const baseHeight = containerWidth * maxAspectRatio;
        const legendHeight = embedConfig.initialFilter ? 150 : 200;

        // Update height based on current width (responsive)
        container.style.height = `${baseHeight + legendHeight}px`;
      };

      // Use ResizeObserver for better performance (only for window resize, not content changes)
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => handleResize());
        ro.observe(findWrapper());
      } else {
        window.addEventListener('resize', handleResize);
      }
    } else {
      console.warn('AWS topology: wrapper not found, skipping initialization');
    }
  })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">GPU-to-GPU communication path through NVLink.</figcaption></figure>
<p>With NVLink 4.0’s theoretical bandwidth of 900 GB/s compared to EFA’s ~50 GB/s, we expect an 18x advantage for intra-node communication. To validate this in practice, we ran <a href="https://github.com/NVIDIA/nccl-tests/blob/master/src/sendrecv.cu">NCCL’s SendRecv performance test</a> to measure actual bandwidth across different communication paths:</p>
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="markdown"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8">$ FI_PROVIDER=XXX NCCL_P2P_DISABLE=X sendrecv_perf -b 8 -e 8G -f 2 -g 1 -c 1 -n 100</span></span>
<span class="line"></span></code></pre></div>
<figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">GPU-&gt;

GPU measured bandwidth with NCCL&#39;s SendRecv test (H100 GPUs, 1 Node, 2 GPUs)</figcaption><div class="html-embed__card"><div id="frag-vngsk6rxdr" data-config="{&#34;dataUrl&#34;:&#34;./data/nccl_sendrecv_p2p_comparison.csv&#34;,&#34;xColumn&#34;:&#34;message_size&#34;,&#34;yColumn&#34;:&#34;bandwidth&#34;,&#34;runColumn&#34;:&#34;run_name&#34;,&#34;xScaleType&#34;:&#34;log&#34;,&#34;xAxisLabel&#34;:&#34;Message Size (bytes)&#34;,&#34;yAxisLabel&#34;:&#34;Bandwidth (GB/s)&#34;}"><!-- 
  Line Chart with Smoothing
  
  A configurable multi-line chart with zoom/pan, smoothing, and hover tooltips.
  
  Configuration via data-config attribute (optional):
  {
    "dataUrl": "./assets/data/your_data.csv",       // Custom CSV path
    "xDomain": [0, 45e9],                           // X-axis range
    "yDomain": [2.1, 2.7],                          // Y-axis range
    "smoothingWindow": 15,                          // Moving average window size
    "smoothingCurve": "monotoneX",                  // D3 curve: "linear", "monotoneX", "catmullRom", "basis"
    "title": "My Chart",                            // Chart title for tooltip
    "xFormatAsFileSize": true                       // Format X axis as file sizes (B, kB, MB, GB)
  }
  
  CSV format: run_name, tokens, loss (or custom x/y columns)
  
  Example usage in MDX:
  <HtmlEmbed 
    src="embeds/line-chart-smooth.html" 
    config={{ 
      dataUrl: "./assets/data/attention_loss.csv",
      xDomain: [0, 30e9],
      yDomain: [2.0, 2.8],
      smoothingWindow: 20,
      title: "Attention Loss"
    }} 
  />
  
  Example with file size formatting:
  <HtmlEmbed 
    src="embeds/d3-line-chart.html" 
    config={{ 
      dataUrl: "./data/device_local_copy_bandwidth.csv",
      xColumn: "message_size",
      yColumn: "bandwidth",
      runColumn: "run_name",
      xScaleType: "log",
      xFormatAsFileSize: true,
      xAxisLabel: "Message Size",
      yAxisLabel: "Bandwidth (GB/s)"
    }} 
  />
-->
<div class="d3-line-chart"></div>
<style>
  .d3-line-chart {
    position: relative;
  }

  .d3-line-chart .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 300;
    opacity: 0.7;
    stroke: var(--page-bg, white);
    background-color: var(--surface-bg) !important;
    stroke-width: 6px;
    paint-order: stroke fill;
  }

  .d3-line-chart .axes path {
    display: none;
  }

  .d3-line-chart .axes line {
    stroke: var(--axis-color);
  }

  .d3-line-chart .axes text {
    fill: var(--tick-color);
  }

  .d3-line-chart .grid line {
    stroke: var(--grid-color);
  }


  .d3-line-chart .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 6px;
  }

  .d3-line-chart .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .d3-line-chart .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .d3-line-chart .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
    cursor: pointer;
  }

  .d3-line-chart .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .d3-line-chart path.main-line {
    transition: opacity 0.2s ease;
  }

  .d3-line-chart path.ghost-line {
    transition: opacity 0.6s ease;
  }

  /* Ghosting on hover */
  .d3-line-chart.hovering .legend-bottom .item.ghost {
    opacity: .35;
  }

  .d3-line-chart.hovering path.main-line.ghost {
    opacity: .25;
  }

  .d3-line-chart.hovering path.ghost-line.ghost {
    opacity: .05;
  }

  /* Tooltip */
  .d3-line-chart .d3-tooltip {
    z-index: 20;
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .d3-line-chart .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .d3-line-chart .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .d3-line-chart .d3-tooltip__inner>div:nth-child(n+3) {
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
  }

  .d3-line-chart .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  /* Reference line */
  .d3-line-chart .reference-line {
    stroke: #e15759;
    stroke-width: 2;
    stroke-dasharray: 3, 3;
  }

  .d3-line-chart .reference-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  /* Chart card */
  .d3-line-chart .chart-card {
    padding: 0;
  }

  .d3-line-chart .chart-header {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 12px;
    margin: 12px 0 0 0;
    flex-wrap: wrap;
  }

  /* Trackio footer removed */
</style>
<script>
  (() => {
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;

      // If the previous sibling is not a d3-line-chart, look for the closest one
      if (!(container && container.classList && container.classList.contains('d3-line-chart'))) {
        // First, try to find the closest d3-line-chart element by traversing up the DOM
        let currentEl = scriptEl;
        while (currentEl && currentEl.parentNode) {
          currentEl = currentEl.parentNode;
          const found = currentEl.querySelector && currentEl.querySelector('.d3-line-chart:not([data-mounted="true"])');
          if (found) {
            container = found;
            break;
          }
        }

        // If still not found, get the first unmounted d3-line-chart
        if (!container) {
          const cs = Array.from(document.querySelectorAll('.d3-line-chart')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
          container = cs[0] || null; // Use first instead of last
        }
      }

      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
          padding: '10px 12px', borderRadius: '12px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 8px 32px rgba(0,0,0,.28), 0 2px 8px rgba(0,0,0,.12)', opacity: '0', transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign = 'left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend)
      const header = document.createElement('div');
      header.className = 'chart-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);

      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.style.position = 'relative';

      // Reset button (absolute positioned in chart)
      const resetBtn = document.createElement('button');
      resetBtn.className = 'reset-button';
      resetBtn.textContent = 'Reset View';
      Object.assign(resetBtn.style, {
        position: 'absolute',
        top: '12px',
        right: '12px',
        zIndex: '10',
        display: 'none',
        opacity: '0',
        transition: 'opacity 0.2s ease',
        fontSize: '12px',
        padding: '4px 8px',
        borderRadius: '6px',
        background: 'var(--surface-bg)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      });
      chartCard.appendChild(resetBtn);

      container.appendChild(chartCard);
      container.appendChild(header);

      // Footer removed

      const d3 = window.d3;

      // Read config from HtmlEmbed props
      function readEmbedConfig() {
        let mountEl = container;
        while (mountEl && !mountEl.getAttribute?.('data-config')) {
          mountEl = mountEl.parentElement;
        }

        let providedConfig = null;
        try {
          const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
          if (cfg && cfg.trim()) {
            providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
          }
        } catch (e) {
          // Failed to parse data-config
        }
        return providedConfig || {};
      }

      const embedConfig = readEmbedConfig();

      // Configuration (with overrides from embed config)
      const CONFIG = {
        width: 800,
        height: 320,
        margin: { top: 20, right: 10, bottom: 52, left: 52 },
        xDomain: embedConfig.xDomain || null,  // Auto-calculated if null
        yDomain: embedConfig.yDomain || null,  // Auto-calculated if null
        zoomExtent: [1.0, 8],
        smoothing: embedConfig.smoothing !== undefined ? embedConfig.smoothing : false,
        smoothingWindow: embedConfig.smoothingWindow || 15,
        smoothingCurve: embedConfig.smoothingCurve || 'monotoneX',
        transitionDuration: 600,
        dataUrl: embedConfig.dataUrl || null,
        title: embedConfig.title || 'Chart',
        xAxisLabel: embedConfig.xAxisLabel || 'Consumed tokens',
        yAxisLabel: embedConfig.yAxisLabel || 'Loss',
        xColumn: embedConfig.xColumn || 'tokens',
        yColumn: embedConfig.yColumn || 'loss',
        runColumn: embedConfig.runColumn || 'run_name',
        xScaleType: embedConfig.xScaleType || 'linear',  // 'linear' or 'log'
        yScaleType: embedConfig.yScaleType || 'linear',  // 'linear' or 'log'
        referenceLine: embedConfig.referenceLine || null,  // { value: number, label?: string, color?: string, dashArray?: string }
        xFormatAsFileSize: embedConfig.xFormatAsFileSize || false  // Format X axis as file sizes (B, kB, MB, GB)
      };

      let width = CONFIG.width;
      let height = CONFIG.height;
      const margin = CONFIG.margin;
      let smoothEnabled = CONFIG.smoothing;
      let hasMoved = false;

      // Create SVG
      const svg = d3.select(chartCard)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block');

      // Clip path for constraining plot area
      const clipId = 'clip-' + Math.random().toString(36).slice(2);
      const clipPath = svg.append('defs')
        .append('clipPath')
        .attr('id', clipId);
      const clipRect = clipPath.append('rect');

      // Main group (with margins)
      const g = svg.append('g');

      // Grid and axes (not affected by zoom)
      const gGrid = g.append('g').attr('class', 'grid');
      const gAxes = g.append('g').attr('class', 'axes');
      const gReference = g.append('g').attr('class', 'reference');

      // Zoomable content layer (with clip-path)
      const gPlot = g.append('g')
        .attr('class', 'plot')
        .attr('clip-path', `url(#${clipId})`);

      // Hover layer (on top, for tooltips)
      const gHover = g.append('g').attr('class', 'hover-layer');

      // Overlay rect for capturing zoom events (on top, transparent)
      const overlay = g.append('rect')
        .attr('class', 'overlay')
        .attr('fill', 'none')
        .attr('pointer-events', 'all')
        .style('cursor', 'grab')
        .on('mousedown', function () {
          d3.select(this).style('cursor', 'grabbing');
          // Hide tooltip during zoom/pan
          if (tip) tip.style.opacity = '0';
          if (hoverLine) hoverLine.style('display', 'none');
        })
        .on('mouseup', function () { d3.select(this).style('cursor', 'grab'); });

      // Scales
      const xScale = (CONFIG.xScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.xDomain || [0.1, 1]);
      const yScale = (CONFIG.yScaleType === 'log' ? d3.scaleLog() : d3.scaleLinear()).domain(CONFIG.yDomain || [0.1, 1]);

      // Data
      let data = [];
      let runList = [];
      let runColorMap = {};

      // Hover state
      let hoverLine = null;
      let tokens = [];
      let hideTipTimer = null;

      // Smoothing
      const getCurve = (smooth) => {
        if (!smooth) return d3.curveLinear;
        switch (CONFIG.smoothingCurve) {
          case 'catmullRom': return d3.curveCatmullRom.alpha(0.5);
          case 'monotoneX': return d3.curveMonotoneX;
          case 'basis': return d3.curveBasis;
          default: return d3.curveLinear;
        }
      };

      function movingAverage(values, windowSize) {
        if (!Array.isArray(values) || values.length === 0 || windowSize <= 1) return values;
        const half = Math.floor(windowSize / 2);
        const out = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          let sum = 0; let count = 0;
          const start = Math.max(0, i - half);
          const end = Math.min(values.length - 1, i + half);
          for (let j = start; j <= end; j++) { if (!Number.isNaN(values[j].loss)) { sum += values[j].loss; count++; } }
          const avg = count ? (sum / count) : values[i].loss;
          out[i] = { tokens: values[i].tokens, loss: avg };
        }
        return out;
      }

      function applySmoothing(values, smooth) {
        if (!smooth) return values;
        return movingAverage(values, CONFIG.smoothingWindow);
      }

      // Smart formatters (will be set after data loading)
      let formatX = (v) => v;
      let formatY = (v) => v;
      const MAX_TICKS = 10;

      function limitTicks(ticks, maxCount, domain) {
        if (!Array.isArray(ticks)) return ticks;
        if (ticks.length <= maxCount) return ticks;
        const first = ticks[0];
        const last = ticks[ticks.length - 1];
        const step = Math.ceil(ticks.length / maxCount);
        const sampled = ticks.filter((_, i) => i % step === 0);
        if (sampled[0] !== first && first >= domain[0]) sampled.unshift(first);
        if (sampled[sampled.length - 1] !== last && last <= domain[1]) sampled.push(last);
        return sampled.slice(0, maxCount);
      }

      // Function to determine smart format based on data values
      function createSmartFormatter(values, isFileSize = false) {
        if (!values || values.length === 0) return (v) => v;

        const min = d3.min(values);
        const max = d3.max(values);
        const range = max - min;

        // Check if all values are effectively integers (within 0.001 tolerance)
        const allIntegers = values.every(v => Math.abs(v - Math.round(v)) < 0.001);

        // File size formatting (binary units: B, KiB, MiB, GiB)
        if (isFileSize) {
          const KiB = 1024;
          const MiB = KiB * 1024;
          const GiB = MiB * 1024;
          return (v) => {
            if (v >= GiB) {
              const gib = v / GiB;
              return (gib % 1 === 0 ? d3.format('d')(gib) : d3.format('.2f')(gib)) + ' GiB';
            } else if (v >= MiB) {
              const mib = v / MiB;
              return (mib % 1 === 0 ? d3.format('d')(mib) : d3.format('.2f')(mib)) + ' MiB';
            } else if (v >= KiB) {
              const kib = v / KiB;
              return (kib % 1 === 0 ? d3.format('d')(kib) : d3.format('.1f')(kib)) + ' KiB';
            } else {
              return d3.format('d')(Math.round(v)) + ' B';
            }
          };
        }

        // Large numbers (billions): format as "X.XXB"
        if (max >= 1e9) {
          return (v) => {
            const billions = v / 1e9;
            return allIntegers && billions === Math.round(billions)
              ? d3.format('d')(Math.round(billions)) + 'B'
              : d3.format('.2f')(billions) + 'B';
          };
        }

        // Millions: format as "X.XXM" or "XM"
        if (max >= 1e6) {
          return (v) => {
            const millions = v / 1e6;
            return allIntegers && millions === Math.round(millions)
              ? d3.format('d')(Math.round(millions)) + 'M'
              : d3.format('.2f')(millions) + 'M';
          };
        }

        // Thousands: format as "X.Xk" or "Xk"
        if (max >= 1000 && range >= 100) {
          return (v) => {
            const thousands = v / 1000;
            return allIntegers && thousands === Math.round(thousands)
              ? d3.format('d')(Math.round(thousands)) + 'k'
              : d3.format('.1f')(thousands) + 'k';
          };
        }

        // Regular numbers
        if (allIntegers) {
          return (v) => d3.format('d')(Math.round(v));
        }

        // Small decimals: use appropriate precision
        if (range < 1) {
          return (v) => d3.format('.3f')(v);
        } else if (range < 10) {
          return (v) => d3.format('.2f')(v);
        } else {
          return (v) => d3.format('.1f')(v);
        }
      }

      // Colors
      const getRunColors = (n) => {
        try { if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') return window.ColorPalettes.getColors('categorical', n); } catch (_) { }
        const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#E889AB';
        return [primary, '#4EA5B7', '#E38A42', '#CEC0FA', '#9B59B6', '#16A085', ...(d3.schemeTableau10 || [])].slice(0, n);
      };

      // Zoom behavior
      const zoom = d3.zoom()
        .scaleExtent(CONFIG.zoomExtent)
        .on('zoom', zoomed);

      // Apply zoom to overlay (not svg) so it respects the margins
      overlay.call(zoom);

      function zoomed(event) {
        const transform = event.transform;
        hasMoved = transform.k !== 1 || transform.x !== 0 || transform.y !== 0;
        updateResetButton();

        // DON'T transform the group - instead redraw paths with rescaled domains
        const newXScale = transform.rescaleX(xScale);
        const newYScale = transform.rescaleY(yScale);

        // Get current inner dimensions
        const innerWidth = xScale.range()[1];

        // Smart grid ticks (same as axis ticks)

        const getGridTicks = (scale, scaleType) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(4, Math.ceil(logRange * 2)));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        // Update grid lines
        const gridTicks = getGridTicks(newYScale, CONFIG.yScaleType);
        gGrid.selectAll('line')
          .data(gridTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => newYScale(d))
          .attr('y2', d => newYScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Redraw lines with transformed scales
        const line = d3.line()
          .x(d => newXScale(d.tokens))
          .y(d => newYScale(d.loss))
          .curve(getCurve(smoothEnabled));

        // Update ghost lines (raw data)
        gPlot.selectAll('path.ghost-line')
          .attr('d', d => {
            const rawLine = d3.line()
              .x(d => newXScale(d.tokens))
              .y(d => newYScale(d.loss))
              .curve(d3.curveLinear);
            return rawLine(d.values);
          });

        // Update main lines
        gPlot.selectAll('path.main-line')
          .attr('d', d => line(applySmoothing(d.values, smoothEnabled)));

        // Smart tick generation for zoomed view
        const getSmartTicksZoom = (scale, scaleType, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(6, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const newXTicks = getSmartTicksZoom(newXScale, CONFIG.xScaleType, !!CONFIG.xFormatAsFileSize);
        const newYTicks = getSmartTicksZoom(newYScale, CONFIG.yScaleType);

        // Update axes with rescaled domains
        gAxes.select('.x-axis').call(d3.axisBottom(newXScale).tickValues(newXTicks).tickSizeOuter(0).tickFormat(formatX));
        gAxes.select('.y-axis').call(d3.axisLeft(newYScale).tickValues(newYTicks).tickSizeOuter(0).tickFormat(formatY));

        // Update reference line
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          gReference.select('.reference-line')
            .attr('y1', newYScale(refValue))
            .attr('y2', newYScale(refValue));

          gReference.select('.reference-label')
            .attr('y', newYScale(refValue) - 5);
        }
      }

      function updateResetButton() {
        if (hasMoved) {
          resetBtn.style.display = 'block';
          requestAnimationFrame(() => { resetBtn.style.opacity = '1'; });
        } else {
          resetBtn.style.opacity = '0';
          setTimeout(() => { if (!hasMoved) resetBtn.style.display = 'none'; }, 200);
        }
      }

      function render() {
        if (!data.length) return;

        // Update dimensions
        const rect = container.getBoundingClientRect();
        width = Math.max(1, Math.round(rect && rect.width ? rect.width : (container.clientWidth || 800)));
        height = Math.max(CONFIG.height, Math.round(width / 2.2));
        svg.attr('width', width).attr('height', height);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Position main group
        g.attr('transform', `translate(${margin.left},${margin.top})`);

        // Update scales ranges
        xScale.range([0, innerWidth]);
        yScale.range([innerHeight, 0]);

        // Update clip rect - positioned relative to g (which is already translated)
        clipRect
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update overlay (positioned at 0,0 within the g group)
        overlay
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', innerWidth)
          .attr('height', innerHeight);

        // Update zoom extent and translateExtent
        zoom
          .extent([[0, 0], [innerWidth, innerHeight]])
          .translateExtent([[0, 0], [innerWidth, innerHeight]]);

        // Smart tick generation for log scales
        const getSmartTicks = (scale, scaleType, targetCount = 6, useBinary = false) => {
          if (scaleType !== 'log') {
            return scale.ticks(Math.min(targetCount, MAX_TICKS));
          }

          const domain = scale.domain();
          if (useBinary) {
            const minPow2 = Math.ceil(Math.log2(domain[0]));
            const maxPow2 = Math.floor(Math.log2(domain[1]));
            const ticks = [];
            for (let p = minPow2; p <= maxPow2; p++) ticks.push(Math.pow(2, p));
            const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
            return limitTicks(within, MAX_TICKS, domain);
          }

          // For log scale, use custom tick logic to avoid crowding (powers of 10)
          const minLog = Math.log10(domain[0]);
          const maxLog = Math.log10(domain[1]);
          const logRange = maxLog - minLog;

          if (logRange < 2) {
            return scale.ticks(Math.min(MAX_TICKS, Math.min(4, Math.ceil(logRange * 2))));
          }

          const ticks = [];
          const minPower = Math.ceil(minLog);
          const maxPower = Math.floor(maxLog);

          for (let power = minPower; power <= maxPower; power++) {
            ticks.push(Math.pow(10, power));
          }

          if (ticks.length < 4 && logRange < 3) {
            const intermediateTicks = [];
            for (let power = minPower; power < maxPower; power++) {
              intermediateTicks.push(5 * Math.pow(10, power));
            }
            ticks.push(...intermediateTicks);
            ticks.sort((a, b) => a - b);
          }

          const within = ticks.filter(t => t >= domain[0] && t <= domain[1]);
          return limitTicks(within, MAX_TICKS, domain);
        };

        const xTicks = getSmartTicks(xScale, CONFIG.xScaleType, 6, !!CONFIG.xFormatAsFileSize);
        const yTicks = getSmartTicks(yScale, CONFIG.yScaleType, 6);

        // Grid (use smart ticks)
        gGrid.selectAll('line').data(yTicks)
          .join('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d))
          .attr('stroke', 'var(--grid-color)');

        // Axes
        gAxes.selectAll('*').remove();

        gAxes.append('g')
          .attr('class', 'x-axis')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(xTicks).tickSizeOuter(0).tickFormat(formatX))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.append('g')
          .attr('class', 'y-axis')
          .call(d3.axisLeft(yScale).tickValues(yTicks).tickSizeOuter(0).tickFormat(formatY))
          .selectAll('text').attr('fill', 'var(--tick-color)');

        gAxes.selectAll('.domain, .tick line').attr('stroke', 'var(--axis-color)');

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 38)
          .attr('text-anchor', 'middle')
          .text(CONFIG.xAxisLabel);

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('transform', 'rotate(-90)')
          .attr('x', -innerHeight / 2)
          .attr('y', -43)
          .attr('text-anchor', 'middle')
          .text(CONFIG.yAxisLabel);

        // Reference line (optional horizontal line at a specific Y value)
        gReference.selectAll('*').remove();
        if (CONFIG.referenceLine) {
          const refValue = CONFIG.referenceLine.value;
          const refLabel = CONFIG.referenceLine.label || null;
          const refColor = CONFIG.referenceLine.color || '#e15759';
          const refDashArray = CONFIG.referenceLine.dashArray || '3,3';

          gReference.append('line')
            .attr('class', 'reference-line')
            .attr('x1', 0)
            .attr('x2', innerWidth)
            .attr('y1', yScale(refValue))
            .attr('y2', yScale(refValue))
            .style('stroke', refColor)
            .style('stroke-dasharray', refDashArray);

          if (refLabel) {
            gReference.append('text')
              .attr('class', 'reference-label')
              .attr('x', innerWidth - 5)
              .attr('y', yScale(refValue) - 5)
              .attr('text-anchor', 'end')
              .text(refLabel);
          }
        }

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });

        // Draw lines
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Ghost lines (raw data, always linear)
        const ghostLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(d3.curveLinear);

        gPlot.selectAll('path.ghost-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'ghost-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', smoothEnabled ? 0.15 : 0)
          .attr('pointer-events', 'none')
          .attr('d', d => ghostLine(d.values));

        // Main lines (smooth or raw depending on toggle)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(smoothEnabled));

        gPlot.selectAll('path.main-line').data(series, d => d.run)
          .join('path')
          .attr('class', 'main-line')
          .attr('fill', 'none')
          .attr('stroke', d => d.color)
          .attr('stroke-width', 2)
          .attr('opacity', 0.85)
          .attr('d', d => mainLine(applySmoothing(d.values, smoothEnabled)));

        // Hover interactions
        setupHover(series, innerWidth, innerHeight);
      }

      // Setup hover tooltip
      function setupHover(series, innerWidth, innerHeight) {
        gHover.selectAll('*').remove();

        hoverLine = gHover.append('line')
          .style('stroke', 'var(--text-color)')
          .attr('stroke-opacity', 0.25)
          .attr('stroke-width', 1)
          .attr('y1', 0)
          .attr('y2', innerHeight)
          .style('display', 'none')
          .attr('pointer-events', 'none');

        // Build a set of all unique token values
        const tokenSet = new Set();
        series.forEach(s => s.values.forEach(v => tokenSet.add(v.tokens)));
        tokens = Array.from(tokenSet).sort((a, b) => a - b);

        // Attach hover handlers to the overlay (which also handles zoom)
        overlay.on('mousemove', function (ev) {
          // Show tooltip on mouse move (will be hidden during zoom/pan by mousedown handler)
          onHoverMove(ev, series);
        }).on('mouseleave', onHoverLeave);
      }

      function onHoverMove(ev, series) {
        if (hideTipTimer) {
          clearTimeout(hideTipTimer);
          hideTipTimer = null;
        }

        const [mx, my] = d3.pointer(ev, overlay.node());
        const targetTokens = xScale.invert(mx);

        // Find nearest actual data point for snapping the hover line
        const nearest = tokens.reduce((best, t) =>
          Math.abs(t - targetTokens) < Math.abs(best - targetTokens) ? t : best,
          tokens[0]
        );

        const xpx = xScale(nearest);
        hoverLine.attr('x1', xpx).attr('x2', xpx).style('display', null);

        // Build tooltip HTML
        let html = `<div><strong>${CONFIG.title}</strong></div>`;
        html += `<div>${formatX(nearest)}</div>`;

        // Interpolate values for all series
        const entries = series.map(s => {
          const values = s.values;

          // Find the two points to interpolate between
          let before = null, after = null;
          for (let i = 0; i < values.length; i++) {
            if (values[i].tokens <= nearest) {
              before = values[i];
            }
            if (values[i].tokens >= nearest && !after) {
              after = values[i];
              break;
            }
          }

          let interpolatedLoss = null;

          if (before && after && before.tokens !== after.tokens) {
            // Linear interpolation
            const t = (nearest - before.tokens) / (after.tokens - before.tokens);
            interpolatedLoss = before.loss + t * (after.loss - before.loss);
          } else if (before && before.tokens === nearest) {
            // Exact match
            interpolatedLoss = before.loss;
          } else if (after && after.tokens === nearest) {
            // Exact match
            interpolatedLoss = after.loss;
          } else if (before) {
            // Use last known value
            interpolatedLoss = before.loss;
          } else if (after) {
            // Use first value
            interpolatedLoss = after.loss;
          }

          return {
            run: s.run,
            color: s.color,
            loss: interpolatedLoss
          };
        }).filter(e => e.loss != null);

        entries.sort((a, b) => a.loss - b.loss);

        entries.forEach(e => {
          html += `<div style="display:flex;align-items:center;gap:8px;"><span class="d3-tooltip__color-dot" style="background:${e.color}"></span><span>${e.run}</span><span style="margin-left:auto;font-weight:normal;">${e.loss.toFixed(4)}</span></div>`;
        });

        tipInner.innerHTML = html;
        const offsetX = 12, offsetY = 12;
        tip.style.opacity = '1';
        tip.style.transform = `translate(${Math.round(mx + offsetX + margin.left)}px, ${Math.round(my + offsetY + margin.top)}px)`;
      }

      function onHoverLeave() {
        hideTipTimer = setTimeout(() => {
          tip.style.opacity = '0';
          tip.style.transform = 'translate(-9999px, -9999px)';
          if (hoverLine) hoverLine.style('display', 'none');
        }, 100);
      }

      // Toggle smoothing
      function toggleSmoothing(enabled) {
        smoothEnabled = enabled;

        // Group data by run
        const dataByRun = {};
        runList.forEach(run => { dataByRun[run] = []; });
        data.forEach(d => { if (dataByRun[d.run]) dataByRun[d.run].push(d); });
        runList.forEach(run => { dataByRun[run].sort((a, b) => a.tokens - b.tokens); });
        const series = runList.map(run => ({ run, color: runColorMap[run], values: dataByRun[run] }));

        // Animate ghost lines opacity
        gPlot.selectAll('path.ghost-line')
          .transition()
          .duration(CONFIG.transitionDuration)
          .attr('opacity', enabled ? 0.15 : 0);

        // Update main lines instantly (no animation on path shape)
        const mainLine = d3.line()
          .x(d => xScale(d.tokens))
          .y(d => yScale(d.loss))
          .curve(getCurve(enabled));

        gPlot.selectAll('path.main-line')
          .data(series, d => d.run)
          .attr('d', d => mainLine(applySmoothing(d.values, enabled)));
      }

      // Load data
      async function load() {
        try {
          // Build CSV paths, prioritizing CONFIG.dataUrl if provided
          const csvPaths = CONFIG.dataUrl
            ? [CONFIG.dataUrl]
            : [
              '/data/attention_loss.csv',
              './assets/data/attention_loss.csv',
              '../assets/data/attention_loss.csv',
              '../../assets/data/attention_loss.csv'
            ];

          let csvText = null;
          for (const path of csvPaths) {
            try {
              const response = await fetch(path, { cache: 'no-cache' });
              if (response.ok) {
                csvText = await response.text();
                break;
              }
            } catch (_) { }
          }

          if (!csvText) throw new Error('CSV file not found');

          const rows = d3.csvParse(csvText, d => ({
            run: (d[CONFIG.runColumn] || '').trim(),
            tokens: +d[CONFIG.xColumn],
            loss: +d[CONFIG.yColumn]
          }));

          data = rows.filter(d => !isNaN(d.tokens) && !isNaN(d.loss));
          runList = Array.from(new Set(data.map(d => d.run))).sort();

          // Auto-calculate domains if not provided
          if (!CONFIG.xDomain) {
            const xValues = data.map(d => d.tokens);
            const xMin = d3.min(xValues);
            const xMax = d3.max(xValues);

            if (CONFIG.xScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(xMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = xMax * 1.1; // 10% above max
              CONFIG.xDomain = [minVal, maxVal];
            } else {
              const xPadding = (xMax - xMin) * 0.02; // 2% padding
              CONFIG.xDomain = [Math.max(0, xMin - xPadding), xMax + xPadding];
            }
          }

          if (!CONFIG.yDomain) {
            const yValues = data.map(d => d.loss);
            const yMin = d3.min(yValues);
            const yMax = d3.max(yValues);

            if (CONFIG.yScaleType === 'log') {
              // For log scale: use ratio-based padding and ensure min > 0
              const minVal = Math.max(yMin / 1.1, 0.1); // 10% below min, but > 0
              const maxVal = yMax * 1.1; // 10% above max
              CONFIG.yDomain = [minVal, maxVal];
            } else {
              const yPadding = (yMax - yMin) * 0.05; // 5% padding
              CONFIG.yDomain = [yMin - yPadding, yMax + yPadding];
            }
          }

          // Update scales with calculated/provided domains
          xScale.domain(CONFIG.xDomain);
          yScale.domain(CONFIG.yDomain);

          // Create smart formatters based on actual data
          const xValues = data.map(d => d.tokens);
          const yValues = data.map(d => d.loss);

          // Force file size formatting if xColumn contains "size" or "message"
          const shouldFormatAsFileSize = CONFIG.xFormatAsFileSize ||
            CONFIG.xColumn.toLowerCase().includes('size') ||
            CONFIG.xColumn.toLowerCase().includes('message');

          // Ensure CONFIG flag reflects detection for consistent tick logic
          CONFIG.xFormatAsFileSize = shouldFormatAsFileSize;

          formatX = createSmartFormatter(xValues, shouldFormatAsFileSize);
          formatY = createSmartFormatter(yValues);

          const colors = getRunColors(runList.length);
          runList.forEach((run, i) => {
            runColorMap[run] = colors[i % colors.length];
          });

          // Build legend (only if more than one run)
          if (runList.length > 1) {
            const legendItemsHost = header.querySelector('.legend-bottom .items');
            if (legendItemsHost) {
              legendItemsHost.innerHTML = runList.map(run => {
                const color = runColorMap[run];
                return `<span class="item" data-run="${run}"><span class="swatch" style="background:${color}"></span><span>${run}</span></span>`;
              }).join('');

              legendItemsHost.querySelectorAll('.item').forEach(el => {
                el.addEventListener('mouseenter', () => {
                  const run = el.getAttribute('data-run');
                  container.classList.add('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  gPlot.selectAll('path.ghost-line').classed('ghost', function () { return d3.select(this).datum().run !== run; });
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.toggle('ghost', it.getAttribute('data-run') !== run));
                });
                el.addEventListener('mouseleave', () => {
                  container.classList.remove('hovering');
                  gPlot.selectAll('path.main-line').classed('ghost', false);
                  gPlot.selectAll('path.ghost-line').classed('ghost', false);
                  legendItemsHost.querySelectorAll('.item').forEach(it => it.classList.remove('ghost'));
                });
              });
            }
          } else {
            // Hide header if only one run
            header.style.display = 'none';
          }

          // Reset button event listener
          resetBtn.addEventListener('click', () => {
            overlay.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          });

          render();
          const ro = window.ResizeObserver ? new ResizeObserver(() => render()) : null;
          if (ro) ro.observe(container);
        } catch (e) {
          const pre = document.createElement('pre');
          pre.textContent = 'CSV load error: ' + (e && e.message ? e.message : e);
          pre.style.color = 'var(--danger, #b00020)';
          pre.style.fontSize = '12px';
          container.appendChild(pre);
        }
      }

      load();
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true }); } else { ensureD3(bootstrap); }
  })();
</script></div></div></figure>
<p>This shows without a doubt how much more efficient NVLink is: it achieves 364.93 GB/s compared to EFA’s 38.16 GB/s (9x faster, or 18x bidirectional) and the CPU baseline’s 3.24 GB/s (112.6x faster). These measurements confirm why NCCL prioritizes NVLink for intra-node GPU communication, but to further check NVLink’s performance, let’s use  <code>nvbandwidth</code>  to measure bidirectional bandwidth between all GPU pairs using simultaneous copies in both directions:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>./nvbandwidth -t device_to_device_bidirectional_memcpy_write_ce -b &lt;message_size&gt; -i 5</span></span>
<span class="line"><span>memcpy CE GPU(row) &lt;-&gt; GPU(column) Total bandwidth (GB/s)</span></span>
<span class="line"><span>           0         1         2         3         4         5         6         7</span></span>
<span class="line"><span> 0       N/A    785.81    785.92    785.90    785.92    785.78    785.92    785.90</span></span>
<span class="line"><span> 1    785.83       N/A    785.87    785.83    785.98    785.90    786.05    785.94</span></span>
<span class="line"><span> 2    785.87    785.89       N/A    785.83    785.96    785.83    785.96    786.03</span></span>
<span class="line"><span> 3    785.89    785.85    785.90       N/A    785.96    785.89    785.90    785.96</span></span>
<span class="line"><span> 4    785.87    785.96    785.92    786.01       N/A    785.98    786.14    786.08</span></span>
<span class="line"><span> 5    785.81    785.92    785.85    785.89    785.89       N/A    786.10    786.03</span></span>
<span class="line"><span> 6    785.94    785.92    785.99    785.99    786.10    786.05       N/A    786.07</span></span>
<span class="line"><span> 7    785.94    786.07    785.99    786.01    786.05    786.05    786.14       N/A</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SUM device_to_device_bidirectional_memcpy_write_ce_total 44013.06</span></span>
<span class="line"><span></span></span></code></pre></div>
<p>The measured bidirectional bandwidth of  <strong>786 GB/s</strong>  represents 85% of  <strong>NVLink 4.0</strong> ‘s theoretical 900 GB/s specification. Using NVLink has bypassed the CPU bottleneck entirely (for gpu-to-gpu communication)!</p>
<p>But how does this translate to collective communication patterns? Let’s measure  <code>allreduce</code>  performance within a single node with the  <code>all_reduce_perf</code>  <a href="https://github.com/NVIDIA/nccl-tests/blob/master/src/all_reduce.cu">benchmark from NCCL tests.</a></p>
<div class="sidenote-container"> <aside class="sidenote"> <p>For comprehensive benchmarking scripts and configurations, see the excellent collection at <a href="https://github.com/aws-samples/awsome-distributed-training/tree/main/micro-benchmarks/nccl-tests">AWS Distributed Training Samples</a>. For a quick refresher on collective communication patterns, see the <a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook?section=ring_allreduce">UltraScale Playbook Appendix</a>.</p> </aside> </div>  
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>$ ./all_reduce_perf -b 8 -e 16G -f 2 -g 1 -c 1 -n 100</span></span>
<span class="line"><span></span></span></code></pre></div>
<figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">NCCL&#39;s All-Reduce performance test intranode</figcaption><div class="html-embed__card"><div id="frag-8sglv2iq90c"><div class="nccl-all-reduce-singlenode"></div>
<style>
  .nccl-all-reduce-singlenode { position: relative; }
  .nccl-all-reduce-singlenode .axis-label { fill: var(--text-color); font-size: 12px; font-weight: 700; }
  .nccl-all-reduce-singlenode .axes path, .nccl-all-reduce-singlenode .axes line { stroke: var(--axis-color); }
  .nccl-all-reduce-singlenode .axes text { fill: var(--tick-color); }
  .nccl-all-reduce-singlenode .grid line { stroke: var(--grid-color); }
  .nccl-all-reduce-singlenode .chart-card { background: var(--page-bg); border: 1px solid var(--border-color); border-radius: 10px; padding: 16px; }
  .nccl-all-reduce-singlenode .chart-header { display:flex; align-items:flex-start; justify-content:flex-start; gap:12px; margin: 8px 0 0 0; flex-wrap: wrap; }
  .nccl-all-reduce-singlenode .legend-bottom { display:flex; align-items:flex-start; justify-content:flex-start; font-size:12px; color: var(--text-color); flex-direction: column; gap: 4px; }
  .nccl-all-reduce-singlenode .legend-bottom .items { display:flex; flex-wrap:wrap; gap:8px 14px; }
  .nccl-all-reduce-singlenode .legend-bottom .item { display:inline-flex; align-items:center; gap:6px; white-space:nowrap; }
  .nccl-all-reduce-singlenode .legend-bottom .swatch { width:14px; height:14px; border-radius:3px; border:1px solid var(--border-color); display:inline-block; }
  .nccl-all-reduce-singlenode .legend-bottom .legend-label { font-size: 11px; font-weight: 600; color: var(--muted-color); text-transform: uppercase; letter-spacing: 0.5px; }
  .nccl-all-reduce-singlenode .lines path.active { stroke-width: 3; }
  .nccl-all-reduce-singlenode .d3-tooltip { z-index: var(--z-elevated); backdrop-filter: saturate(1.12) blur(8px); }
  .nccl-all-reduce-singlenode .d3-tooltip__inner { display:flex; flex-direction:column; gap:6px; min-width: 220px; }
  .nccl-all-reduce-singlenode .d3-tooltip__inner > div:first-child { font-weight: 800; letter-spacing: 0.1px; margin-bottom: 0; }
  .nccl-all-reduce-singlenode .d3-tooltip__inner > div:nth-child(2) { font-size: 11px; color: var(--muted-color); display: block; margin-top: -4px; margin-bottom: 2px; letter-spacing: 0.1px; }
  .nccl-all-reduce-singlenode .d3-tooltip__color-dot { display:inline-block; width: 12px; height: 12px; border-radius: 3px; border: 1px solid var(--border-color); }
  /* Ghosting on hover */
  .nccl-all-reduce-singlenode.hovering .legend-bottom .item.ghost { opacity: .35; }
  .nccl-all-reduce-singlenode.hovering .lines path.ghost { opacity: .25; }
  .nccl-all-reduce-singlenode.hovering .points circle.ghost { opacity: .25; }
</style>
<script> 
  (() => {
    // Prevent multiple executions
    if (window.ncclAllReduceInitialized) return;
    window.ncclAllReduceInitialized = true;
    
    // Completely scoped IIFE to avoid variable conflicts
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrapAllReduce = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('nccl-all-reduce-singlenode'))){
        const cs = Array.from(document.querySelectorAll('.nccl-all-reduce-singlenode')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position:'absolute', top:'0px', left:'0px', transform:'translate(-9999px, -9999px)', pointerEvents:'none',
          padding:'8px 10px', borderRadius:'8px', fontSize:'12px', lineHeight:'1.35', border:'1px solid var(--border-color)',
          background:'var(--surface-bg)', color:'var(--text-color)', boxShadow:'0 4px 24px rgba(0,0,0,.18)', opacity:'0', transition:'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign='left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend) placed after the chart
      const header = document.createElement('div'); header.className = 'chart-header';
      const legendBottom = document.createElement('div'); legendBottom.className = 'legend-bottom'; header.appendChild(legendBottom);

      // Chart card (SVG)
      const card = document.createElement('div'); card.className = 'chart-card'; container.appendChild(card);
      container.appendChild(header);
      
      // SVG
      const svg = d3.select(card).append('svg').attr('width','100%').style('display','block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class','grid');
      const gAxes = gRoot.append('g').attr('class','axes');
      const gLines = gRoot.append('g').attr('class','lines');
      const gPoints = gRoot.append('g').attr('class','points');
      const overlay = gRoot.append('rect').attr('fill','transparent').style('cursor','crosshair');
      const hoverLine = gRoot.append('line').attr('stroke-width',1).style('display','none');

      // State/data
      let width = 800, height = 480; const margin = { top: 16, right: 32, bottom: 60, left: 80 };
      const xScale = d3.scaleLog();
      const yScale = d3.scaleLinear();
      const lineGen = d3.line().x(d => xScale(d.messageSize)).y(d => yScale(d.bandwidth));
      let data = [];

      // Colors - following guidelines to use ColorPalettes
      let currentColors = ['#d62728']; // Red color for single line
      
      function refreshPalette(){
        try { 
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            const colors = window.ColorPalettes.getColors('categorical', 1);
            if (colors && colors.length >= 1) {
              currentColors = colors;
              // Re-render with new colors
              if (data.length > 0) render();
              return;
            }
          }
        } catch(_){}
        // Fallback to CSS variable or default
        currentColors = ['#d62728'];
        // Re-render with fallback colors
        if (data.length > 0) render();
      }
      
      function getColors(){
        return currentColors;
      }
      
      // Format helper for bytes
      function formatBytes(bytes){
        if (bytes >= 1024 * 1024 * 1024) {
          return Math.round(bytes / (1024 * 1024 * 1024)) + ' GB';
        } else if (bytes >= 1024 * 1024) {
          return Math.round(bytes / (1024 * 1024)) + ' MB';
        } else if (bytes >= 1024) {
          return Math.round(bytes / 1024) + ' KB';
        } else {
          return bytes + ' B';
        }
      }

      // Format helper for bandwidth values
      function formatBandwidth(v){
        return Math.round(v);
      }

      function updateLayout(){
        const axisColor = getComputedStyle(container).getPropertyValue('--axis-color').trim() || 'rgba(0,0,0,0.25)';
        width = container.clientWidth || 800;
        height = Math.max(280, Math.round(width / 3));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        overlay.attr('x',0).attr('y',0).attr('width', innerWidth).attr('height', innerHeight);
        hoverLine.attr('y1',0).attr('y2', innerHeight).attr('stroke', axisColor);
        return { innerWidth, innerHeight };
      }

      function render(){
        if (data.length === 0) return;
        
        const { innerWidth, innerHeight } = updateLayout();
        
        // Sort data by message size
        const sortedData = data.slice().sort((a, b) => a.messageSize - b.messageSize);
        
        // Prepare series data
        const series = [{
          name: 'Bus Bandwidth',
          values: sortedData.map(d => ({ messageSize: d.messageSize, bandwidth: d.bandwidth }))
        }];
        
        // domains
        const minSize = d3.min(sortedData, d => d.messageSize);
        const maxSize = d3.max(sortedData, d => d.messageSize);
        const minBandwidth = 0;
        const maxBandwidth = d3.max(sortedData, d => d.bandwidth);
        
        xScale.domain([minSize, maxSize]).range([0, innerWidth]);
        yScale.domain([minBandwidth, 500]).range([innerHeight, 0]);

        // grid
        gGrid.selectAll('*').remove();
        gGrid.selectAll('line').data(yScale.ticks(7)).join('line')
          .attr('x1',0).attr('x2', innerWidth).attr('y1', d=>yScale(d)).attr('y2', d=>yScale(d))
          .attr('stroke','var(--grid-color)').attr('stroke-width',1).attr('shape-rendering','crispEdges');

        // axes
        gAxes.selectAll('*').remove();
        
        // Create custom ticks for X axis (powers of 2, every other tick)
        const xTicks = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592];
        const filteredXTicks = xTicks.filter(tick => tick >= minSize && tick <= maxSize);
        
        gAxes.append('g').attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(filteredXTicks).tickFormat(formatBytes))
          .call(g=>{ 
            g.selectAll('path, line').attr('stroke','var(--axis-color)'); 
            g.selectAll('text')
              .attr('fill','var(--tick-color)')
              .style('font-size','10px')
              .attr('transform', 'rotate(-45)')
              .style('text-anchor', 'end')
              .attr('dx', '-8px');
          });
        
        gAxes.append('g').call(d3.axisLeft(yScale).tickFormat(formatBandwidth)).call(g=>{ g.selectAll('path, line').attr('stroke','var(--axis-color)'); g.selectAll('text').attr('fill','var(--tick-color)').style('font-size','12px'); });
        gAxes.append('text').attr('class','axis-label').attr('text-anchor','middle').attr('x', innerWidth/2).attr('y', innerHeight + 50).text('Message Size (bytes)');
        gAxes.append('text').attr('class','axis-label').attr('text-anchor','middle').attr('transform', `translate(${-60}, ${innerHeight/2}) rotate(-90)`).text('Bus Bandwidth (GB/s)');

        // lines
        const colors = getColors();
        gLines.selectAll('*').remove();
        series.forEach((s, i) => {
          gLines.append('path')
            .attr('class', `line line-${i}`)
            .attr('data-series', s.name)
            .attr('fill','none')
            .attr('stroke', colors[i % colors.length])
            .attr('stroke-width', 2)
            .attr('d', lineGen(s.values));
        });

        // point markers
        gPoints.selectAll('*').remove();
        series.forEach((s, i) => {
          gPoints.selectAll(`g.point-group-${i}`).data(s.values).join('g')
            .attr('class', `point-group point-group-${i}`)
            .attr('data-series', s.name)
            .attr('transform', d => `translate(${xScale(d.messageSize)}, ${yScale(d.bandwidth)})`)
            .append('circle')
            .attr('r', 3)
            .attr('fill', colors[i % colors.length])
            .attr('fill-opacity', 0.8)
            .attr('stroke', 'white')
            .attr('stroke-width', 1);
        });

        // Add max bandwidth reference line
        gAxes.append('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', yScale(maxBandwidth))
          .attr('y2', yScale(maxBandwidth))
          .attr('stroke', colors[0])
          .attr('stroke-dasharray', '5,5')
          .attr('stroke-width', 1)
          .attr('opacity', 0.7);

        // No legend needed for single line chart

        // hover
        function onMove(ev){
          const [mx, my] = d3.pointer(ev, overlay.node());
          const sx = xScale.invert(mx);
          
          // Find nearest message size
          const sizes = Array.from(new Set(sortedData.map(d => d.messageSize))).sort((a,b) => a - b);
          const nearest = sizes.reduce((best, s) => Math.abs(s - sx) < Math.abs(best - sx) ? s : best, sizes[0]);
          const xpx = xScale(nearest);
          hoverLine.style('display', null).attr('x1', xpx).attr('x2', xpx);
          
          // Find data point for this message size
          const dataPoint = sortedData.find(d => d.messageSize === nearest);
          if (!dataPoint) return;
          
          // tooltip content
          let html = `<div style="font-weight:800;letter-spacing:.1px;">NCCL All-Reduce Bus Bandwidth</div><div style="font-size:11px;color:var(--muted-color);margin-top:-4px;margin-bottom:2px;">${formatBytes(nearest)}</div>`;
          html += `<div style="display:flex;align-items:center;gap:6px;white-space:nowrap;"><span class="d3-tooltip__color-dot" style="background:${colors[0]}"></span><strong>Bus Bandwidth</strong><span style="margin-left:auto;">${formatBandwidth(dataPoint.bandwidth)} GB/s</span></div>`;
          
          tipInner.innerHTML = html; 
          tip.style.opacity = '1'; 
          tip.style.transform = `translate(${Math.round(mx + margin.left + 12)}px, ${Math.round(my + margin.top + 12)}px)`;
        }
        
        function onLeave(){ 
          tip.style.opacity='0'; 
          tip.style.transform='translate(-9999px, -9999px)'; 
          hoverLine.style('display','none'); 
        }
        
        overlay.on('mousemove', onMove).on('mouseleave', onLeave);
      }

      // Load real data from JSON
      async function loadData() {
        try {
          const response = await fetch('./data/nccl-all-reduce-singlenode-bandwidth.json');
          const jsonData = await response.json();
          
          data = jsonData;
          render();
        } catch (error) {
          console.error('Error loading NCCL All-Reduce data:', error);
        }
      }

      // Initialize palette and listen for changes
      refreshPalette();
      document.addEventListener('palettes:updated', refreshPalette);
      
      // Initialize data by loading from JSON
      loadData();
      
      const rerender = () => render();
      if (window.ResizeObserver) { 
        const ro = new ResizeObserver(() => rerender()); 
        ro.observe(container); 
      } else { 
        window.addEventListener('resize', rerender); 
      }
    };

    if (document.readyState === 'loading') { 
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrapAllReduce), { once: true }); 
    } else { 
      ensureD3(bootstrapAllReduce); 
    }
  })();
</script>
</div></div></figure>
<p>But wait… We are achieving 480 GB/s, which exceeds the theoretical unidirectional bandwidth of 450 GB/s for NVLink 4.0 😮 What is this sorcery, and how is this possible?</p>
<p>Diving a bit in the docs, it seems like the answer lies in NVLink SHARP (NVLS), NVIDIA’s hardware-accelerated collective operations technology. They provide approximately 1.3x speedup for allreduce operations on a single node with H100 GPUs!</p>
<div class="ri-root" data-ri-root="ri_ujiw7mm915g" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/image_2891384e-bcac-80e2-9cc5-c2c46c7ab39b.B9LkpQ-__ZcdxHc.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/image_2891384e-bcac-80e2-9cc5-c2c46c7ab39b.B9LkpQ-_.png" data-astro-cid-6kov3kig width="1800" height="1004" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script> 
<p>For technical details on how NVSwitch enables these hardware-accelerated collective operations, see the <a href="https://hc34.hotchips.org/assets/program/conference/day2/Network%20and%20Switches/NVSwitch%20HotChips%202022%20r5.pdf">NVSwitch architecture presentation</a>.</p>
<p>Can they help in other places too? Let’s examine <a href="https://github.com/NVIDIA/nccl-tests/blob/master/src/alltoall.cu">alltoall performance</a>:</p>
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>$ ./all_to_all_perf -b 8 -e 16G -f 2 -g 1 -c 1 -n 100</span></span>
<span class="line"><span></span></span></code></pre></div>
<figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">NCCL&#39;s All-to-All performance test intranode</figcaption><div class="html-embed__card"><div id="frag-7a4cprdz48m"><div class="nccl-alltoall-singlenode"></div>
<style>
  .nccl-alltoall-singlenode { position: relative; }
  .nccl-alltoall-singlenode .axis-label { fill: var(--text-color); font-size: 12px; font-weight: 700; }
  .nccl-alltoall-singlenode .axes path, .nccl-alltoall-singlenode .axes line { stroke: var(--axis-color); }
  .nccl-alltoall-singlenode .axes text { fill: var(--tick-color); }
  .nccl-alltoall-singlenode .grid line { stroke: var(--grid-color); }
  .nccl-alltoall-singlenode .chart-card { background: var(--page-bg); border: 1px solid var(--border-color); border-radius: 10px; padding: 16px; }
  .nccl-alltoall-singlenode .chart-header { display:flex; align-items:flex-start; justify-content:flex-start; gap:12px; margin: 8px 0 0 0; flex-wrap: wrap; }
  .nccl-alltoall-singlenode .legend-bottom { display:flex; align-items:flex-start; justify-content:flex-start; font-size:12px; color: var(--text-color); flex-direction: column; gap: 4px; }
  .nccl-alltoall-singlenode .legend-bottom .items { display:flex; flex-wrap:wrap; gap:8px 14px; }
  .nccl-alltoall-singlenode .legend-bottom .item { display:inline-flex; align-items:center; gap:6px; white-space:nowrap; }
  .nccl-alltoall-singlenode .legend-bottom .swatch { width:14px; height:14px; border-radius:3px; border:1px solid var(--border-color); display:inline-block; }
  .nccl-alltoall-singlenode .legend-bottom .legend-label { font-size: 11px; font-weight: 600; color: var(--muted-color); text-transform: uppercase; letter-spacing: 0.5px; }
  .nccl-alltoall-singlenode .lines path.active { stroke-width: 3; }
  .nccl-alltoall-singlenode .d3-tooltip { z-index: var(--z-elevated); backdrop-filter: saturate(1.12) blur(8px); }
  .nccl-alltoall-singlenode .d3-tooltip__inner { display:flex; flex-direction:column; gap:6px; min-width: 220px; }
  .nccl-alltoall-singlenode .d3-tooltip__inner > div:first-child { font-weight: 800; letter-spacing: 0.1px; margin-bottom: 0; }
  .nccl-alltoall-singlenode .d3-tooltip__inner > div:nth-child(2) { font-size: 11px; color: var(--muted-color); display: block; margin-top: -4px; margin-bottom: 2px; letter-spacing: 0.1px; }
  .nccl-alltoall-singlenode .d3-tooltip__color-dot { display:inline-block; width: 12px; height: 12px; border-radius: 3px; border: 1px solid var(--border-color); }
  /* Ghosting on hover */
  .nccl-alltoall-singlenode.hovering .legend-bottom .item.ghost { opacity: .35; }
  .nccl-alltoall-singlenode.hovering .lines path.ghost { opacity: .25; }
  .nccl-alltoall-singlenode.hovering .points circle.ghost { opacity: .25; }
</style>
<script> 
  (() => {
    // Prevent multiple executions
    if (window.ncclAllToAllInitialized) return;
    window.ncclAllToAllInitialized = true;
    
    // Completely scoped IIFE to avoid variable conflicts
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrapAllToAll = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('nccl-alltoall-singlenode'))){
        const cs = Array.from(document.querySelectorAll('.nccl-alltoall-singlenode')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip'); let tipInner;
      if (!tip) {
        tip = document.createElement('div'); tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position:'absolute', top:'0px', left:'0px', transform:'translate(-9999px, -9999px)', pointerEvents:'none',
          padding:'8px 10px', borderRadius:'8px', fontSize:'12px', lineHeight:'1.35', border:'1px solid var(--border-color)',
          background:'var(--surface-bg)', color:'var(--text-color)', boxShadow:'0 4px 24px rgba(0,0,0,.18)', opacity:'0', transition:'opacity .12s ease'
        });
        tipInner = document.createElement('div'); tipInner.className = 'd3-tooltip__inner'; tipInner.style.textAlign='left'; tip.appendChild(tipInner); container.appendChild(tip);
      } else { tipInner = tip.querySelector('.d3-tooltip__inner') || tip; }

      // Header (legend) placed after the chart
      const header = document.createElement('div'); header.className = 'chart-header';
      const legendBottom = document.createElement('div'); legendBottom.className = 'legend-bottom'; header.appendChild(legendBottom);

      // Chart card (SVG)
      const card = document.createElement('div'); card.className = 'chart-card'; container.appendChild(card);
      container.appendChild(header);
      
      // SVG
      const svg = d3.select(card).append('svg').attr('width','100%').style('display','block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g').attr('class','grid');
      const gAxes = gRoot.append('g').attr('class','axes');
      const gLines = gRoot.append('g').attr('class','lines');
      const gPoints = gRoot.append('g').attr('class','points');
      const overlay = gRoot.append('rect').attr('fill','transparent').style('cursor','crosshair');
      const hoverLine = gRoot.append('line').attr('stroke-width',1).style('display','none');

      // State/data
      let width = 800, height = 480; const margin = { top: 16, right: 32, bottom: 60, left: 80 };
      const xScale = d3.scaleLog();
      const yScale = d3.scaleLinear();
      const lineGen = d3.line().x(d => xScale(d.messageSize)).y(d => yScale(d.bandwidth));
      let data = [];
      let maxBandwidth = 0;

      // Colors - following guidelines to use ColorPalettes
      let currentColors = ['#d62728']; // Red color for single line
      
      function refreshPalette(){
        try { 
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            const colors = window.ColorPalettes.getColors('categorical', 1);
            if (colors && colors.length >= 1) {
              currentColors = colors;
              // Re-render with new colors
              if (data.length > 0) render();
              return;
            }
          }
        } catch(_){}
        // Fallback to CSS variable or default
        currentColors = ['#d62728'];
        // Re-render with fallback colors
        if (data.length > 0) render();
      }
      
      function getColors(){
        return currentColors;
      }
      
      // Format helper for bytes
      function formatBytes(bytes){
        if (bytes >= 1024 * 1024 * 1024) {
          return Math.round(bytes / (1024 * 1024 * 1024)) + ' GB';
        } else if (bytes >= 1024 * 1024) {
          return Math.round(bytes / (1024 * 1024)) + ' MB';
        } else if (bytes >= 1024) {
          return Math.round(bytes / 1024) + ' KB';
        } else {
          return bytes + ' B';
        }
      }

      // Format helper for bandwidth values
      function formatBandwidth(v){
        return Math.round(v);
      }

      function updateLayout(){
        const axisColor = getComputedStyle(container).getPropertyValue('--axis-color').trim() || 'rgba(0,0,0,0.25)';
        width = container.clientWidth || 800;
        height = Math.max(280, Math.round(width / 3));
        svg.attr('width', width).attr('height', height);
        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        overlay.attr('x',0).attr('y',0).attr('width', innerWidth).attr('height', innerHeight);
        hoverLine.attr('y1',0).attr('y2', innerHeight).attr('stroke', axisColor);
        return { innerWidth, innerHeight };
      }

      function render(){
        if (data.length === 0) return;
        
        const { innerWidth, innerHeight } = updateLayout();
        
        // Sort data by message size
        const sortedData = data.slice().sort((a, b) => a.messageSize - b.messageSize);
        
        // Prepare series data
        const series = [{
          name: 'Bus Bandwidth',
          values: sortedData.map(d => ({ messageSize: d.messageSize, bandwidth: d.bandwidth }))
        }];
        
        // domains
        const minSize = d3.min(sortedData, d => d.messageSize);
        const maxSize = d3.max(sortedData, d => d.messageSize);
        const minBandwidth = 0;
        maxBandwidth = d3.max(sortedData, d => d.bandwidth);
        
        xScale.domain([minSize, maxSize]).range([0, innerWidth]);
        yScale.domain([minBandwidth, 350]).range([innerHeight, 0]);

        // grid
        gGrid.selectAll('*').remove();
        gGrid.selectAll('line').data(yScale.ticks(7)).join('line')
          .attr('x1',0).attr('x2', innerWidth).attr('y1', d=>yScale(d)).attr('y2', d=>yScale(d))
          .attr('stroke','var(--grid-color)').attr('stroke-width',1).attr('shape-rendering','crispEdges');

        // axes
        gAxes.selectAll('*').remove();
        
        // Create custom ticks for X axis (powers of 2, every other tick)
        const xTicks = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592];
        const filteredXTicks = xTicks.filter(tick => tick >= minSize && tick <= maxSize);
        
        gAxes.append('g').attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale).tickValues(filteredXTicks).tickFormat(formatBytes))
          .call(g=>{ 
            g.selectAll('path, line').attr('stroke','var(--axis-color)'); 
            g.selectAll('text')
              .attr('fill','var(--tick-color)')
              .style('font-size','10px')
              .attr('transform', 'rotate(-45)')
              .style('text-anchor', 'end')
              .attr('dx', '-8px');
          });
        
        gAxes.append('g').call(d3.axisLeft(yScale).tickFormat(formatBandwidth)).call(g=>{ g.selectAll('path, line').attr('stroke','var(--axis-color)'); g.selectAll('text').attr('fill','var(--tick-color)').style('font-size','12px'); });
        gAxes.append('text').attr('class','axis-label').attr('text-anchor','middle').attr('x', innerWidth/2).attr('y', innerHeight + 50).text('Message Size (bytes)');
        gAxes.append('text').attr('class','axis-label').attr('text-anchor','middle').attr('transform', `translate(${-60}, ${innerHeight/2}) rotate(-90)`).text('Bus Bandwidth (GB/s)');

        // lines
        const colors = getColors();
        gLines.selectAll('*').remove();
        series.forEach((s, i) => {
          gLines.append('path')
            .attr('class', `line line-${i}`)
            .attr('data-series', s.name)
            .attr('fill','none')
            .attr('stroke', colors[i % colors.length])
            .attr('stroke-width', 2)
            .attr('d', lineGen(s.values));
        });

        // point markers
        gPoints.selectAll('*').remove();
        series.forEach((s, i) => {
          gPoints.selectAll(`g.point-group-${i}`).data(s.values).join('g')
            .attr('class', `point-group point-group-${i}`)
            .attr('data-series', s.name)
            .attr('transform', d => `translate(${xScale(d.messageSize)}, ${yScale(d.bandwidth)})`)
            .append('circle')
            .attr('r', 3)
            .attr('fill', colors[i % colors.length])
            .attr('fill-opacity', 0.8)
            .attr('stroke', 'white')
            .attr('stroke-width', 1);
        });

        // Add max bandwidth reference line
        gAxes.append('line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', yScale(maxBandwidth))
          .attr('y2', yScale(maxBandwidth))
          .attr('stroke', colors[0])
          .attr('stroke-dasharray', '5,5')
          .attr('stroke-width', 1)
          .attr('opacity', 0.7);

        // No legend needed for single line chart

        // hover
        function onMove(ev){
          const [mx, my] = d3.pointer(ev, overlay.node());
          const sx = xScale.invert(mx);
          
          // Find nearest message size
          const sizes = Array.from(new Set(sortedData.map(d => d.messageSize))).sort((a,b) => a - b);
          const nearest = sizes.reduce((best, s) => Math.abs(s - sx) < Math.abs(best - sx) ? s : best, sizes[0]);
          const xpx = xScale(nearest);
          hoverLine.style('display', null).attr('x1', xpx).attr('x2', xpx);
          
          // Find data point for this message size
          const dataPoint = sortedData.find(d => d.messageSize === nearest);
          if (!dataPoint) return;
          
          // tooltip content
          let html = `<div style="font-weight:800;letter-spacing:.1px;">NCCL AllToAll Bus Bandwidth</div><div style="font-size:11px;color:var(--muted-color);margin-top:-4px;margin-bottom:2px;">${formatBytes(nearest)}</div>`;
          html += `<div style="display:flex;align-items:center;gap:6px;white-space:nowrap;"><span class="d3-tooltip__color-dot" style="background:${colors[0]}"></span><strong>Bus Bandwidth</strong><span style="margin-left:auto;">${formatBandwidth(dataPoint.bandwidth)} GB/s</span></div>`;
          
          tipInner.innerHTML = html; 
          tip.style.opacity = '1'; 
          tip.style.transform = `translate(${Math.round(mx + margin.left + 12)}px, ${Math.round(my + margin.top + 12)}px)`;
        }
        
        function onLeave(){ 
          tip.style.opacity='0'; 
          tip.style.transform='translate(-9999px, -9999px)'; 
          hoverLine.style('display','none'); 
        }
        
        overlay.on('mousemove', onMove).on('mouseleave', onLeave);
      }

      // Load real data from JSON
      async function loadData() {
        try {
          const response = await fetch('./data/nccl-alltoall-singlenode-bandwidth.json');
          const jsonData = await response.json();
          
          data = jsonData;
          render();
        } catch (error) {
          console.error('Error loading NCCL AllToAll data:', error);
        }
      }

      // Initialize palette and listen for changes
      refreshPalette();
      document.addEventListener('palettes:updated', refreshPalette);
      
      // Initialize data by loading from JSON
      loadData();
      
      const rerender = () => render();
      if (window.ResizeObserver) { 
        const ro = new ResizeObserver(() => rerender()); 
        ro.observe(container); 
      } else { 
        window.addEventListener('resize', rerender); 
      }
    };

    if (document.readyState === 'loading') { 
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrapAllToAll), { once: true }); 
    } else { 
      ensureD3(bootstrapAllToAll); 
    }
  })();
</script>
</div></div></figure>
<p>We achieve  <strong>340 GB/s</strong>  for alltoall operations, which aligns with published benchmarks showing similar performance characteristics for H100 systems with NVLink 4.0 (<a href="https://juser.fz-juelich.de/record/1019178/files/02-NCCL_NVSHMEM.pdf#page=20.00">source</a>). Unlike allreduce, alltoall operations don’t benefit from NVLS hardware acceleration, which explains why we see 340 GB/s here compared to the 480 GB/s achieved with allreduce. The alltoall pattern requires more complex point-to-point data exchanges between all GPU pairs, relying purely on NVLink’s base bandwidth rather than NVSwitch’s collective acceleration features.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>⚡</span> <div class="note__title" data-astro-cid-qg6lmfty>Advanced Kernel Optimization</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Some optimized kernels separate NVLink communication from compute by assigning dedicated warps to handle transfers. For example, ThunderKittens uses a warp-level design where specific warps issue NVLink transfers and wait for completion, while other warps continue compute operations. This fine-grained overlap of SM compute and NVLink communication can hide most inter-GPU communication latency. For implementation details, see the <a href="https://hazyresearch.stanford.edu/blog/2025-09-22-pgl#fine-grained-overlap-of-sm-compute-and-nvlink-communication-with-thunderkittens" target="_blank">ThunderKittens blog post on multi-GPU kernels</a>.</p> </div> </div> </div> 
<p>While NVLink provides exceptional bandwidth within a single node, training frontier models requires scaling across multiple nodes.</p>
<p>This introduces a new potential bottleneck: the inter-node network interconnect, which operates at significantly lower bandwidths than NVLink.</p>
<h4 id="gpu-to-gpu-internode"><a href="#gpu-to-gpu-internode">GPU-to-GPU Internode</a></h4>
<div class="note note--neutral" data-astro-cid-qg6lmfty> <!-- When there's no title, emoji is above content -->
    <div class="note__layout" data-astro-cid-qg6lmfty>  <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__content" data-astro-cid-qg6lmfty> <p><b>TL;DR</b> Multi-node GPU communication uses high-speed networks like InfiniBand (400 Gbps) or RoCE (100 Gbps). Allreduce scales well (320-350 GB/s stable across nodes), enabling massive training clusters. Alltoall degrades more sharply due to algorithm complexity. Latency jumps from ~13μs intra-node to 55μs+ inter-node. For MoE workloads requiring frequent all-to-all operations, NVSHMEM offers asynchronous GPU-initiated communication with significantly better performance than CPU-orchestrated transfers.</p> </div> </div> </div> </div> 
<p>As models scale beyond what a single node can accommodate, training requires distributing computation across multiple nodes connected via high-speed networks. Before diving into the benchmarks, let’s look at the 3 key networking technologies connecting nodes you’ll encounter in multi-node GPU clusters:</p>
<ul>
<li><strong>Ethernet</strong>  has evolved from 1 Gbps to 100+ Gbps speeds and remains widely used in HPC and data center clusters.</li>
<li><strong>RoCE (RDMA over Converged Ethernet)</strong>  brings RDMA capabilities to Ethernet networks, using ECN for congestion control instead of traditional TCP mechanisms.</li>
<li><strong>InfiniBand</strong>  is NVIDIA’s industry-standard switch fabric, providing up to 400 Gbps bandwidth and sub-microsecond latency with RDMA support that enables direct GPU-to-GPU memory access while bypassing the host CPU through GPUDirect RDMA.</li>
</ul>
<p>As a summary:</p>








































<div class="table-scroll"><table><thead><tr><th>Name</th><th>Ethernet (25–100 Gbps)</th><th>Ethernet (200–400 Gbps)</th><th>RoCE</th><th>Infiniband</th></tr></thead><tbody><tr><td>Manufacturer</td><td>Many</td><td>Many</td><td>Many</td><td>NVIDIA/Mellanox</td></tr><tr><td>Unidirectional Bandwidth (Gbps)</td><td>25–100</td><td>200–400</td><td>100</td><td>400</td></tr><tr><td>End to End Latency (μs)</td><td>10-30</td><td>N/A</td><td>~1</td><td>&lt;1</td></tr><tr><td>RDMA</td><td>No</td><td>No</td><td>Yes</td><td>Yes</td></tr></tbody></table></div>
<p>Table: Comparison of Interconnects. Source: <a href="https://www.sciencedirect.com/science/article/pii/S2772485922000618">https://www.sciencedirect.com/science/article/pii/S2772485922000618</a></p>
<p>For AWS p5 instances we have <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html">Elastic Fabric Adapter (</a><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html"> <strong>EFA</strong> </a><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html">)</a> as the  <strong>NIC</strong>  (Network Interface Card), where each GPU connects to four 100 Gbps EFA network cards through PCIe Gen5 x16 lanes, as we’ve seen before.</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-8ms8tporji7" data-config="{&#34;initialFilter&#34;:&#34;gpu-gpu-efa-internode&#34;}"><!--
  AWS Bandwidth Bottleneck Visualization
  
  Usage:
  
  Basic:
    <HtmlEmbed src="/embeds/aws-bandwidth-bottleneck.html" />
  
  With initial filter:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ initialFilter: 'cpu-gpu' }} 
    />
  
  With real bandwidths display:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ showRealBandwidths: true }} 
    />
  
  Available filters:
    - cpu-gpu (Intranode: CPU ⟷ GPU)
    - gpu-gpu-cpu (Intranode: GPU ⟷ GPU via CPU)
    - gpu-gpu-nvswitch (Intranode: GPU ⟷ GPU via NVSwitch)
    - gpu-gpu-efa-intranode (Intranode: GPU ⟷ GPU via EFA)
    - gpu-gpu-efa-internode (Internode: GPU ⟷ GPU via EFA)
    - gpu-storage (Storage: GPU ⟷ Storage)
    - cpu-storage (Storage: CPU ⟷ Storage)
    - gpu-cpu-storage (Storage: GPU ⟷ Storage via CPU)
-->
<div class="aws-topology-wrapper">
  <div class="aws-topology-container"></div>
  <div class="aws-topology-controls"></div>
  <div class="aws-topology-legend"></div>
  <div class="aws-topology-tooltip"></div>
  <div class="aws-topology-bottleneck">
    <div class="bottleneck-label">Bandwidth Max</div>
    <div class="bottleneck-path">for CPU → GPU</div>
    <div class="bottleneck-value">-</div>
    <div class="bottleneck-unit">GB/s</div>
    <div class="bottleneck-efficiency" style="display: none;">
      <div class="efficiency-value">-</div>
      <div class="efficiency-label">Efficiency</div>
    </div>
    <div class="real-bandwidths" style="display: none;">
      <div class="real-bandwidths-title">Real Bandwidths</div>
      <div class="real-bandwidths-content"></div>
    </div>
  </div>
</div>

<style>
  .aws-topology-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .aws-topology-container {
    width: 100%;
    height: auto;
    min-height: 400px;
    position: relative;
    transition: opacity 0.15s ease;
  }

  .aws-topology-container.fixed-height {
    height: 850px;
  }

  .aws-topology-container svg {
    width: 100%;
    height: 100%;
  }

  .aws-topology-container svg g {
    transition: opacity 0.2s ease;
  }

  /* Add drop shadow to all links */
  .aws-topology-container svg g[data-link-type] line,
  .aws-topology-container svg g[data-link-type] path {
    filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
  }

  .aws-topology-controls {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 800px;
  }

  .aws-topology-controls-section {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .aws-topology-controls-row {
    display: flex;
    flex-direction: row;
    gap: 16px;
    align-items: flex-start;
  }

  .aws-topology-controls-label {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0.7;
  }

  .aws-topology-controls-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }

  .aws-topology-controls-buttons .button {
    flex-shrink: 0;
  }

  /* Hide controls on mobile */
  @media (max-width: 768px) {
    .aws-topology-controls {
      display: none;
    }
  }

  .aws-topology-legend {
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 264px;
    /* 220 * 1.2 */
    height: 120px;
    /* 100 * 1.2 */
  }

  .aws-topology-tooltip {
    position: absolute;
    padding: 8px 12px;
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 12px;
    color: var(--text-color);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .aws-topology-tooltip.visible {
    opacity: 1;
  }

  .tooltip-label {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-color);
  }

  .tooltip-bandwidth {
    font-size: 11px;
    color: var(--text-secondary);
  }

  .aws-topology-bottleneck {
    position: absolute;
    top: 10px;
    right: 10px;
    text-align: right;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .aws-topology-bottleneck.visible {
    opacity: 1;
  }

  .bottleneck-label {
    font-size: 11px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-value {
    font-size: 24px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    margin-bottom: 2px;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .bottleneck-unit {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-path {
    font-size: 10px;
    color: var(--text-secondary);
    font-style: italic;
    margin-bottom: 6px;
    opacity: 0.8;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-efficiency {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    margin-top: 12px;
    margin-bottom: 4px;
  }

  .efficiency-label {
    font-size: 9px;
    color: var(--text-secondary);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 2px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .efficiency-value {
    font-size: 20px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .real-bandwidths {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
    opacity: 0.9;
  }

  .real-bandwidths-title {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content {
    font-size: 11px;
    color: var(--text-color);
    line-height: 1.4;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content .bandwidth-item {
    margin-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .real-bandwidths-content .bandwidth-label {
    font-size: 10px;
    color: var(--text-secondary);
    opacity: 0.8;
  }

  .real-bandwidths-content .bandwidth-value {
    font-size: 11px;
    font-weight: 600;
    color: var(--primary-color);
  }

  /* Checkbox styling for the bandwidth toggle */
  #real-bandwidth-toggle {
    appearance: none;
    width: 16px;
    height: 16px;
    border: 2px solid var(--border-color);
    border-radius: 3px;
    background-color: var(--page-bg);
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    margin-right: 8px;
  }

  #real-bandwidth-toggle:hover {
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(from var(--primary-color) r g b / 0.1);
  }

  #real-bandwidth-toggle:checked {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:checked::before {
    content: '';
    position: absolute;
    top: 1px;
    left: 4px;
    width: 4px;
    height: 8px;
    border: solid var(--on-primary);
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }

  #real-bandwidth-toggle:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.5/svg.min.js"></script>
<script>
  (function () {
    // Generate unique ID for this instance
    const instanceId = 'aws-topology-' + Math.random().toString(36).substr(2, 9);

    // Store reference to current script to find wrapper later
    const scriptEl = document.currentScript;

    // Function to find wrapper (will be called after DOM is ready)
    let wrapperEl = null;
    const findWrapper = () => {
      if (!wrapperEl) {
        wrapperEl = scriptEl.previousElementSibling;
        if (!wrapperEl || !wrapperEl.classList.contains('aws-topology-wrapper')) {
          // Fallback: search for unmounted wrappers
          const allWrappers = document.querySelectorAll('.aws-topology-wrapper');
          for (const wrapper of allWrappers) {
            if (!wrapper.dataset.mounted) {
              wrapperEl = wrapper;
              break;
            }
          }
        }
        if (wrapperEl && !wrapperEl.dataset.mounted) {
          wrapperEl.dataset.mounted = 'true';
        }
      }
      return wrapperEl;
    };

    // Get all child elements for this instance
    const getElement = (className) => {
      const wrapper = findWrapper();
      return wrapper ? wrapper.querySelector('.' + className) : null;
    };

    // ============================================================================
    // CONFIGURATION - All settings in one place
    // ============================================================================
    const CONFIG = {
      // Canvas settings
      viewbox: {
        width: 2400,  // Width for 2 ensembles side by side
        get height() {
          // Calculate height based on vertical elements × systemCount
          const singleSystemHeight = this.parent.gaps.topMargin +
            this.parent.sizes.cpu +
            this.parent.gaps.cpuToPcie +
            this.parent.sizes.pcie.height +
            this.parent.gaps.pcieToGpu +
            this.parent.sizes.gpu.height +
            this.parent.gaps.gpuToNvswitch +
            this.parent.sizes.nvswitch.height +
            this.parent.gaps.bottomMargin;

          return singleSystemHeight * this.parent.systemCount +
            this.parent.gaps.systemGap * (this.parent.systemCount - 1);
        },
        parent: null  // Will be set to CONFIG
      },

      // System replication
      systemCount: 2,      // Number of complete systems (each has 2 ensembles)
      ensembleCount: 2,    // Number of ensembles per system (each ensemble = CPU + 4 groups + 2 NVSwitches)
      groupCount: 4,       // Groups per ensemble
      nvswitchCount: 2,    // NVSwitches per ensemble

      // Node sizes (all based on CPU size)
      sizes: {
        cpu: 80,
        get pcie() { return { width: this.cpu * 0.75, height: this.cpu * 0.625 * 3 }; },
        get gpu() { return { width: this.cpu, height: this.cpu }; },
        get efa() { return { width: 60, height: 30 }; },
        get nvme() { return { width: 60, height: 30 }; },
        get nvswitch() { return { width: 100, height: 60 }; }
      },

      // Gaps and spacing
      gaps: {
        topMargin: 0,        // Margin from top to CPU
        cpuToPcie: 80,        // Vertical gap CPU → PCIe
        pcieToGpu: 80,        // Vertical gap PCIe → GPU
        gpuToNvswitch: 200,    // Vertical gap GPU → NVSwitch
        bottomMargin: 40,     // Margin from NVSwitch to bottom
        horizontal: 230,      // Horizontal gap between groups
        ensembleGap: 50,     // Horizontal gap between ensembles (within a system)
        systemGap: 30,       // Horizontal gap between complete systems
        connectionOffset: 15  // Gap between node edge and arrow anchor
      },

      // Group layout offsets (all relative positions within a group)
      layout: {
        pcieOffsetX: -40,      // PCIe X offset from group center (to the left)
        efaNvmeOffsetX: 60,    // EFA/NVMe X offset from group center (to the right)
        efaOffsetY: -30,       // EFA Y offset from PCIe Y (above)
        nvmeOffsetY: 30,       // NVMe Y offset from PCIe Y (below)
        groupPadding: 20       // Padding around group bounding box
      },

      // Debug mode
      debug: {
        showPhantoms: false    // Set to true to visualize phantom nodes
      },

      // Highlight paths (for interactive buttons)
      paths: {
        'cpu-gpu': {
          label: 'CPU ⟷ GPU',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'gpu'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' }
          ]
        },
        'gpu-gpu-cpu': {
          label: 'GPU ⟷ GPU via CPU',
          requiredEnsembles: 1,  // Need only 1 ensemble (2 groups within)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'cpu', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'pcie', to: 'cpu' },
            { from: 'cpu', to: 'pcie' },
            { from: 'cpu', to: 'pcie-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-nvswitch': {
          label: 'GPU ⟷ GPU via NVSwitch',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'nvswitch-0', 'gpu-1'],
          links: [
            { from: 'gpu', to: 'nvswitch-0' },
            { from: 'gpu-1', to: 'nvswitch-0' }
          ]
        },
        'gpu-gpu-efa': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-1', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-1', to: 'efa-external-1' },
            { from: 'efa-1', to: 'pcie-efa-phantom-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-efa-intranode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles (same system)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-4', 'pcie-4', 'gpu-4'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-4' },  // EFA cross-link between ensembles (12.5GB/s)
            { from: 'efa-4', to: 'efa-external-4' },
            { from: 'efa-4', to: 'pcie-efa-phantom-4' },
            { from: 'pcie-4', to: 'gpu-4' }
          ]
        },
        'gpu-gpu-efa-internode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles per system
          requiredSystems: 2,    // Need 2 systems
          nodes: ['gpu', 'pcie', 'efa', 'efa-8', 'pcie-8', 'gpu-8'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-8' },  // EFA cross-link between systems
            { from: 'efa-8', to: 'efa-external-8' },
            { from: 'efa-8', to: 'pcie-efa-phantom-8' },
            { from: 'pcie-8', to: 'gpu-8' }
          ]
        },
        'gpu-storage': {
          label: 'GPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'nvme'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'cpu-storage': {
          label: 'CPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'gpu-cpu-storage': {
          label: 'GPU ⟷ Storage via CPU',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'gpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        }
      },


      // Bandwidth levels
      bandwidths: [
        { speed: '900GB/s', label: 'NVLink 4.0', width: 9 },
        { speed: '64GB/s', label: 'PCIe Gen5', width: 6 },
        { speed: '16GB/s', label: 'PCIe Gen4', width: 3 },
        { speed: '12.5GB/s', label: 'EFA Link', width: 1.25 }
      ],

      // Link definitions for groups
      groupLinks: [
        { from: 'cpu', to: 'pcie', bandwidth: '16GB/s', type: 'cpu', fromSide: 'bottom', toSide: 'top', multiLink: true },
        { from: 'efa', to: 'pcie-efa-phantom', bandwidth: '16GB/s', type: 'network', fromSide: 'left', toSide: 'right', stacked: 4 },
        { from: 'nvme', to: 'pcie-nvme-phantom', bandwidth: '16GB/s', type: 'storage', fromSide: 'left', toSide: 'right' },
        { from: 'pcie', to: 'gpu', bandwidth: '64GB/s', type: 'gpu', fromSide: 'bottom', toSide: 'top' },
        { from: 'efa', to: 'efa-external', bandwidth: '12.5GB/s', type: 'network', fromSide: 'right', toSide: 'left', stacked: 4 }
      ],

      // GPU to NVSwitch links (full mesh)
      gpuNvswitchLink: {
        bandwidth: '900GB/s',
        type: 'gpu',
        fromSide: 'bottom',
        toSide: 'top'
      },

      // Colors (using CSS variables for dark mode compatibility)
      colors: {
        // Node colors
        nodeFill: 'var(--page-bg)',
        nodeStroke: 'var(--muted-color)',     // More contrast than border-color
        nodeText: 'var(--text-color)',
        nodePins: 'var(--muted-color)',
        nodeCoreFill: 'rgba(0, 0, 0, 0.05)',  // Very light gray for cores
        nodeCoreStroke: 'rgba(0, 0, 0, 0.2)', // More visible border for cores

        // Link colors
        linkColor: 'var(--primary-color)',
        linkCircleBorder: 'rgba(0, 0, 0, 0.1)', // Border for link circles

        // Group border
        groupBorder: 'var(--border-color)',

        // Phantom debug
        phantomFill: 'rgba(255, 0, 255, 0.2)',
        phantomStroke: 'magenta'
      },

      // Real bandwidth data for display
      realBandwidths: {
        'cpu-gpu': '14.2GB/s',
        'gpu-gpu-same-node': '786GB/s',
        'gpu-gpu-efa-intranode': '40GB/s',
        'gpu-gpu-efa-internode': '40GB/s',
        'allreduce-same-node': '480GB/s',
        'all2all-same-node': '340GB/s',
        'allreduce-internode': '320GB/s',
        'alltoall-internode': '45GB/s',
        'gpu-storage': '14.2GB/s'
      }
    };

    // Initialize viewbox parent reference
    CONFIG.viewbox.parent = CONFIG;

    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================
    function getBandwidth(speed) {
      const bw = CONFIG.bandwidths.find(b => b.speed === speed);
      if (bw) {
        // Add numericValue for comparison
        bw.numericValue = parseFloat(bw.speed.replace('GB/s', ''));
      }
      return bw;
    }

    // Calculate connection offset proportional to link width
    function getLinkOffset(linkWidth) {
      const minOffset = 5;   // Minimum offset for thin links
      const maxOffset = 20;  // Maximum offset for thick links

      // Proportional offset: thinner links = smaller offset
      const proportionalOffset = minOffset + (linkWidth / 10) * (maxOffset - minOffset);
      return Math.min(Math.max(proportionalOffset, minOffset), maxOffset);
    }

    // ============================================================================
    // EFA CROSS-LINKS HELPER
    // ============================================================================
    function drawEfaCrossLinks(renderer, fromId, toId, linkType = 'efa-crosslink') {
      const phantom0 = renderer.nodes.get(fromId);
      const phantom1 = renderer.nodes.get(toId);

      if (!phantom0 || !phantom1) return;

      const efaBw = getBandwidth('12.5GB/s');
      const efaColor = CONFIG.colors.linkColor;

      // Draw 4 stacked links manually (EFA has 4 connections) - randomized order
      const stackCount = 4;
      const spacing = 6; // Fixed spacing between stacked links
      const verticalShift = -95; // Shift up to align with EFA nodes
      const horizontalShift = -40; // Shift left to better position the arrows
      const horizontalExtension = 20; // Extend arrows horizontally on each side

      // Create array of indices and randomize
      const linkIndices = Array.from({ length: stackCount }, (_, i) => i);
      const shuffledIndices = linkIndices.sort(() => Math.random() - 0.5);

      // Draw horizontal lines with vertical offset for stacking
      shuffledIndices.forEach(i => {
        const offsetY = (i - (stackCount - 1) / 2) * spacing;

        const efaCrossGroup = renderer.crossLinksGroup.group();
        efaCrossGroup.attr('data-link-type', linkType);
        efaCrossGroup.attr('data-from', fromId);
        efaCrossGroup.attr('data-to', toId);
        efaCrossGroup.attr('data-bandwidth', '12.5GB/s');
        efaCrossGroup.attr('data-label', 'EFA Link');

        // Draw line with vertical offset for stacking + shifts + horizontal extension
        const x0 = phantom0.x + horizontalShift;
        const x1 = phantom1.x + horizontalShift + horizontalExtension;
        const y0 = phantom0.y + offsetY + verticalShift;
        const y1 = phantom1.y + offsetY + verticalShift;

        // Draw border
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: efaColor, width: efaBw.width, opacity: 1 });

        // Draw circles at both ends
        const r = efaBw.width * 0.8;
        const startCircle = efaCrossGroup.circle(r * 2).move(x0 - r, y0 - r);
        startCircle.fill(efaColor);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = efaCrossGroup.circle(r * 2).move(x1 - r, y1 - r);
        endCircle.fill(efaColor);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');
      });

      // Add vertical bars at both ends (connect horizontal arrows to EFA phantoms)
      const barColor = CONFIG.colors.linkColor;

      shuffledIndices.forEach(i => {
        const offsetX = (i - (stackCount - 1) / 2) * spacing + 12; // Horizontal offset for vertical bars
        const yHorizontal = phantom0.y + verticalShift + 10;
        const yPhantom = phantom0.y + 8; // End a bit higher (5px above phantom center)

        // Left vertical bar (one per horizontal arrow)
        const leftBarGroup = renderer.crossLinksGroup.group();
        leftBarGroup.attr('data-link-type', linkType);
        leftBarGroup.attr('data-from', fromId);
        leftBarGroup.attr('data-to', toId);
        leftBarGroup.attr('data-bandwidth', '12.5GB/s');
        leftBarGroup.attr('data-label', 'EFA Link');

        const x0 = phantom0.x + horizontalShift + offsetX;

        // Draw border
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const r = efaBw.width * 0.8;
        const bottomCircle0 = leftBarGroup.circle(r * 2).move(x0 - r, yPhantom - r);
        bottomCircle0.fill(barColor);
        bottomCircle0.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle0.attr('data-link-circle', 'true');

        // Right vertical bar (one per horizontal arrow)
        const rightBarGroup = renderer.crossLinksGroup.group();
        rightBarGroup.attr('data-link-type', linkType);
        rightBarGroup.attr('data-from', fromId);
        rightBarGroup.attr('data-to', toId);
        rightBarGroup.attr('data-bandwidth', '12.5GB/s');
        rightBarGroup.attr('data-label', 'EFA Link');

        const x1 = phantom1.x + horizontalShift + offsetX;

        // Draw border
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const bottomCircle1 = rightBarGroup.circle(r * 2).move(x1 - r, yPhantom - r);
        bottomCircle1.fill(barColor);
        bottomCircle1.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle1.attr('data-link-circle', 'true');
      });
    }

    // ============================================================================
    // SVG HELPERS
    // ============================================================================
    class TopologyRenderer {
      constructor(draw) {
        this.draw = draw;
        this.nodes = new Map();
        this.structuralGroup = draw.group();  // Structural elements (Node/NUMA borders, never ghosted)
        this.structuralGroup.attr('data-group', 'structural');
        this.baseLinksGroup = draw.group();   // Base links layer (will be ghosted)
        this.baseLinksGroup.attr('data-group', 'base-links');
        this.linksGroup = this.baseLinksGroup; // Alias for compatibility
        this.nodesGroup = draw.group();   // Nodes layer (middle)
        this.phantomsGroup = draw.group(); // Phantoms layer (for debug)
        this.baseCrossLinksGroup = draw.group(); // Base EFA cross-links layer
        this.baseCrossLinksGroup.attr('data-group', 'base-cross-links');
        this.crossLinksGroup = this.baseCrossLinksGroup; // Alias for compatibility
        this.activeLinksGroup = draw.group(); // Active (duplicated) links layer (top, non-ghosted)
        this.activeLinksGroup.attr('data-group', 'active-links');
      }

      // Draw a simple rectangular node
      // Helper: Draw text with consistent styling
      drawText(x, y, label, group = this.nodesGroup) {
        if (!label) return;

        const lines = label.split('\n');
        lines.forEach((line, i) => {
          group.text(line)
            .font({ family: 'Inter, sans-serif', size: 12, weight: '600', anchor: 'middle' })
            .fill(CONFIG.colors.nodeText)
            .cx(x)
            .cy(y + (i - (lines.length - 1) / 2) * 14);
        });
      }

      // Helper: Draw pins around a node
      drawPins(x, y, width, height, pinConfig = {}, targetGroup = null) {
        const group = targetGroup || this.nodesGroup;

        const defaultConfig = {
          pinsPerSide: width >= 80 ? 18 : 15,
          pinLength: 3,
          pinOffset: width / 2 + 1.5,
          pinPadding: 12
        };

        const config = { ...defaultConfig, ...pinConfig };
        const pinStartOffset = -width / 2 + config.pinPadding;
        const pinEndOffset = width / 2 - config.pinPadding;
        const pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);

        const sides = [
          { side: 'left', xOffset: -config.pinOffset, yOffset: 0 },
          { side: 'right', xOffset: config.pinOffset, yOffset: 0 },
          { side: 'top', xOffset: 0, yOffset: -config.pinOffset },
          { side: 'bottom', xOffset: 0, yOffset: config.pinOffset }
        ];

        sides.forEach(({ side, xOffset, yOffset }) => {
          for (let i = 0; i < config.pinsPerSide; i++) {
            const pinX = x + xOffset + (side === 'left' || side === 'right' ? 0 : pinStartOffset + (i * pinSpacing));
            const pinY = y + yOffset + (side === 'top' || side === 'bottom' ? 0 : pinStartOffset + (i * pinSpacing));

            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      drawNode(id, x, y, width, height, label, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      drawNodeWithPins(id, x, y, width, height, label, pinConfig = {}, nodeType = '') {
        const node = this.drawNode(id, x, y, width, height, label, nodeType);
        this.drawPins(x, y, width, height, pinConfig);
        return node;
      }

      drawNodeWithCores(id, x, y, width, height, label, coreConfig = {}, nodeType = '') {
        // Draw main node
        const node = this.drawNode(id, x, y, width, height, label, nodeType);

        // Default core configuration
        const defaultCoreConfig = {
          coresX: 2,              // 2x2 for CPU, 8x8 for GPU
          coresY: 2,
          coreSpacing: 2,         // Space between cores
          coreMargin: 8           // Margin from node edges
        };

        const config = { ...defaultCoreConfig, ...coreConfig };

        // Calculate core size
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coreSpacing * (config.coresX - 1))) / config.coresX;
        const coreHeight = (availableHeight - (config.coreSpacing * (config.coresY - 1))) / config.coresY;

        // Draw cores
        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            this.nodesGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        return node;
      }

      drawProcessorNode(id, x, y, width, height, label, type = 'cpu') {
        // Create main group for the node
        const nodeGroup = this.nodesGroup.group();
        nodeGroup.attr('id', id);
        nodeGroup.attr('data-node-type', type);

        // Draw node background
        nodeGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Draw cores
        const coreConfig = type === 'gpu' ? { coresX: 8, coresY: 8 } : { coresX: 2, coresY: 2 };
        const config = { coreSpacing: 2, coreMargin: 8, ...coreConfig };
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coresX - 1) * config.coreSpacing) / config.coresX;
        const coreHeight = (availableHeight - (config.coresY - 1) * config.coreSpacing) / config.coresY;

        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            nodeGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        // Draw pins in the same group
        this.drawPins(x, y, width, height, {}, nodeGroup);

        // Draw text on top
        this.drawText(x, y, label, nodeGroup);

        // Store node position
        this.nodes.set(id, { x, y, width, height });

        return nodeGroup;
      }

      // Add pins to an existing node (without changing the node design)
      addPinsToNode(nodeId, pinConfig = {}) {
        const node = this.nodes.get(nodeId);
        if (!node) return;

        // Find the node's SVG group
        const svg = getElement('aws-topology-container').querySelector('svg');
        if (!svg) return;
        const nodeGroup = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeGroup) return;

        // Use SVG.js to manipulate the group
        const group = this.draw.findOne(`#${nodeId}`);
        if (!group) return;

        // Default pin configuration
        const defaultPinConfig = {
          pinsPerSide: node.width >= 80 ? 18 : 15,
          sides: ['left', 'right', 'top', 'bottom'],
          pinLength: 3,
          pinPadding: 12
        };

        const config = { ...defaultPinConfig, ...pinConfig };

        // Generate pins on specified sides only
        config.sides.forEach(side => {
          let pinSpacing, pinStartOffset, pinEndOffset;

          if (side === 'left' || side === 'right') {
            pinStartOffset = -node.height / 2 + config.pinPadding;
            pinEndOffset = node.height / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          } else {
            pinStartOffset = -node.width / 2 + config.pinPadding;
            pinEndOffset = node.width / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          }

          for (let i = 0; i < config.pinsPerSide; i++) {
            let pinX, pinY;

            if (side === 'left') {
              pinX = node.x - node.width / 2 - 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'right') {
              pinX = node.x + node.width / 2 + 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'top') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y - node.height / 2 - 1.5;
            } else if (side === 'bottom') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y + node.height / 2 + 1.5;
            }

            // Draw pin in the node's group
            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      // Draw a stacked node (visual stack effect)
      drawStackedNode(id, x, y, width, height, label, stackCount, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        for (let i = stackCount - 1; i >= 0; i--) {
          const offsetY = i * 3;
          group.rect(width, height)
            .move(x - width / 2, y - height / 2 + offsetY)
            .fill(CONFIG.colors.nodeFill)
            .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
            .radius(4)
            .opacity(1);
        }

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw a storage node (NVMe) with internal rectangle
      drawStorageNode(id, x, y, width, height, label, nodeType = 'storage') {
        const group = this.nodesGroup.group();
        group.attr('id', id);
        if (nodeType) group.attr('data-node-type', nodeType);

        // Main node background
        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Internal rectangle on the left side (flush with edge)
        const internalRectWidth = 5;
        const internalRectHeight = height * .6; // Full height
        const internalRectX = x - width / 2; // Flush with left edge
        const internalRectY = y - height / 2 + height * .20;

        group.rect(internalRectWidth, internalRectHeight)
          .move(internalRectX, internalRectY)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: '#ffffff', width: 1 })
          .opacity(.4)
          .radius(0); // No radius

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw background rectangle
      drawBackground(id, x, y, width, height) {
        const bg = this.linksGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 2,
            dasharray: '5,5'
          })
          .radius(8);

        this.nodes.set(id, { x, y, width, height });
        return bg;
      }

      // Get connection point on a node's side with configurable offset and multi-link spacing
      getPoint(nodeId, side, offset = CONFIG.gaps.connectionOffset, linkIndex = 0, totalLinks = 1) {
        const node = this.nodes.get(nodeId);
        if (!node) return { x: 0, y: 0 };

        const points = {
          top: { x: node.x, y: node.y - node.height / 2 - offset },
          right: { x: node.x + node.width / 2 + offset, y: node.y },
          bottom: { x: node.x, y: node.y + node.height / 2 + offset },
          left: { x: node.x - node.width / 2 - offset, y: node.y }
        };

        let basePoint = points[side] || { x: node.x, y: node.y };

        // Apply spacing for multiple links to the same anchor
        if (totalLinks > 1) {
          const isVerticalAnchor = (side === 'top' || side === 'bottom');

          // Vertical anchors (top/bottom) space horizontally, horizontal anchors (left/right) space vertically
          const spacing = isVerticalAnchor ? node.width / (totalLinks + 1) : node.height / (totalLinks + 1);
          const linkOffset = (linkIndex - (totalLinks - 1) / 2) * spacing;

          // Apply offset in the perpendicular direction to the anchor
          if (isVerticalAnchor) {
            basePoint.x += linkOffset;  // Horizontal offset for vertical anchors
          } else {
            basePoint.y += linkOffset;  // Vertical offset for horizontal anchors
          }
        }

        return basePoint;
      }

      // Draw single link with optional multi-link spacing
      drawLink(fromId, toId, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, fromLinkIndex = 0, fromTotalLinks = 1, toLinkIndex = 0, toTotalLinks = 1, linkType = '', bandwidth = '') {
        const start = this.getPoint(fromId, fromSide, offset, fromLinkIndex, fromTotalLinks);
        const end = this.getPoint(toId, toSide, offset, toLinkIndex, toTotalLinks);

        const group = this.linksGroup.group();
        if (linkType) group.attr('data-link-type', linkType);
        if (bandwidth) {
          group.attr('data-bandwidth', bandwidth);
          // Find label from bandwidth config
          const bwConfig = getBandwidth(bandwidth);
          if (bwConfig && bwConfig.label) {
            group.attr('data-label', bwConfig.label);
          }
        }
        group.attr('data-from', fromId);
        group.attr('data-to', toId);

        // Check if this is a vertical connection (GPU-NVSwitch or CPU-PCIe)
        const isVerticalConnection = fromSide === 'bottom' && toSide === 'top';

        if (isVerticalConnection) {
          // Use curved paths for vertical connections
          const curvature = 45; // Fixed curvature value for consistent curve strength

          // Create a smooth cubic bezier curve with vertical control points
          const pathData = `M ${start.x} ${start.y} C ${start.x} ${start.y + curvature}, ${end.x} ${end.y - curvature}, ${end.x} ${end.y}`;

          // Draw border (wider path behind)
          group.path(pathData)
            .fill('none')
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main path on top
          group.path(pathData)
            .fill('none')
            .stroke({ color, width, opacity: 1 });
        } else {
          // Draw straight lines for other connections
          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });
        }

        const r = width * 0.8;
        const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');

        return group;
      }

      // Draw stacked links
      drawStackedLinks(fromId, toId, count, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, linkType = '', bandwidth = '') {
        const fromNode = this.nodes.get(fromId);
        const toNode = this.nodes.get(toId);
        if (!fromNode || !toNode) return [];

        const isHorizontal = (fromSide === 'left' || fromSide === 'right') &&
          (toSide === 'left' || toSide === 'right');
        const spacing = isHorizontal
          ? Math.min(fromNode.height, toNode.height) / (count + 1)
          : Math.min(fromNode.width, toNode.width) / (count + 1);

        const arrows = [];
        for (let i = 0; i < count; i++) {
          const stackOffset = (i - (count - 1) / 2) * spacing;
          let start = this.getPoint(fromId, fromSide, offset);
          let end = this.getPoint(toId, toSide, offset);

          if (isHorizontal) {
            start.y += stackOffset;
            end.y += stackOffset;
          } else {
            start.x += stackOffset;
            end.x += stackOffset;
          }

          const group = this.linksGroup.group();
          if (linkType) group.attr('data-link-type', linkType);
          if (bandwidth) {
            group.attr('data-bandwidth', bandwidth);
            // Find label from bandwidth config
            const bwConfig = getBandwidth(bandwidth);
            if (bwConfig && bwConfig.label) {
              group.attr('data-label', bwConfig.label);
            }
          }
          group.attr('data-from', fromId);
          group.attr('data-to', toId);

          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });

          const r = width * 0.8;
          const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
          startCircle.fill(color);
          startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          startCircle.attr('data-link-circle', 'true');

          const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
          endCircle.fill(color);
          endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          endCircle.attr('data-link-circle', 'true');

          arrows.push(group);
        }
        return arrows;
      }

      // Add phantom node (invisible connection point)
      addPhantom(id, x, y, width = 30, height = 30) {
        this.nodes.set(id, { x, y, width, height });

        // Draw phantom for debug visualization
        if (CONFIG.debug.showPhantoms) {
          this.phantomsGroup.rect(width, height)
            .move(x - width / 2, y - height / 2)
            .fill('rgba(255, 0, 255, 0.2)')  // Semi-transparent magenta
            .stroke({ color: 'magenta', width: 2, dasharray: '4,4' })
            .radius(4);

          // Add label
          this.phantomsGroup.text(id)
            .move(x, y)
            .font({
              family: 'system-ui, -apple-system, sans-serif',
              size: 10,
              anchor: 'middle',
              fill: 'magenta',
              weight: 'bold'
            })
            .dy(-height / 2 - 5);
        }
      }
    }

    // ============================================================================
    // DRAW SINGLE GROUP
    // ============================================================================
    function drawGroup(renderer, globalIndex, localIndex, x, cpuY, nvswitchY, cpuId = 'cpu') {
      const s = CONFIG.sizes;
      const g = CONFIG.gaps;
      const l = CONFIG.layout;
      const suffix = globalIndex > 0 ? `-${globalIndex}` : '';

      // Calculate Y positions
      const pcieY = cpuY + s.cpu / 2 + g.cpuToPcie + s.pcie.height / 2;
      const gpuY = pcieY + s.pcie.height / 2 + g.pcieToGpu + s.gpu.height / 2;

      // Calculate node positions
      const pcieX = x + l.pcieOffsetX;
      const efaX = x + l.efaNvmeOffsetX;
      const nvmeX = x + l.efaNvmeOffsetX;
      const efaY = pcieY + l.efaOffsetY;
      const nvmeY = pcieY + l.nvmeOffsetY;

      // Calculate bounding box BEFORE creating nodes
      const nodeBounds = [
        { x: pcieX, y: pcieY, width: s.pcie.width, height: s.pcie.height },
        { x: efaX, y: efaY, width: s.efa.width, height: s.efa.height },
        { x: nvmeX, y: nvmeY, width: s.nvme.width, height: s.nvme.height },
        { x: pcieX, y: gpuY, width: s.gpu.width, height: s.gpu.height }
      ];

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      nodeBounds.forEach(node => {
        minX = Math.min(minX, node.x - node.width / 2);
        maxX = Math.max(maxX, node.x + node.width / 2);
        minY = Math.min(minY, node.y - node.height / 2);
        maxY = Math.max(maxY, node.y + node.height / 2);
      });

      const bgWidth = maxX - minX + l.groupPadding * 2;
      const bgHeight = maxY - minY + l.groupPadding * 2;
      const bgCenterX = (minX + maxX) / 2;
      const bgCenterY = (minY + maxY) / 2;

      // Draw background FIRST (will be behind nodes)
      renderer.drawBackground(`group${suffix}`, bgCenterX, bgCenterY, bgWidth, bgHeight);

      // Nodes
      renderer.drawNode(`pcie${suffix}`, pcieX, pcieY, s.pcie.width, s.pcie.height, 'PCIe\nSwitch', 'network');
      renderer.addPinsToNode(`pcie${suffix}`, {
        pinsPerSide: 6,
        sides: ['left', 'right'],
        pinLength: 3,
        pinPadding: 8
      });
      renderer.drawStackedNode(`efa${suffix}`, efaX, efaY, s.efa.width, s.efa.height, 'EFA', 4, 'network');
      renderer.drawStorageNode(`nvme${suffix}`, nvmeX, nvmeY, s.nvme.width, s.nvme.height, 'NVMe', 'storage');
      renderer.drawProcessorNode(`gpu${suffix}`, pcieX, gpuY, s.gpu.width, s.gpu.height, 'GPU', 'gpu');

      // Phantom nodes for routing
      // PCIe phantoms: bord gauche aligné avec PCIe, largeur du PCIe
      const pcieLeftEdge = pcieX;
      const pciePhantomX = pcieLeftEdge;
      renderer.addPhantom(`pcie-efa-phantom${suffix}`, pciePhantomX, efaY, s.pcie.width, s.efa.height);
      renderer.addPhantom(`pcie-nvme-phantom${suffix}`, pciePhantomX, nvmeY, s.pcie.width, s.nvme.height);

      // EFA external phantom: à droite de EFA
      const efaRightEdge = efaX + s.efa.width / 2;
      const efaPhantomX = efaRightEdge + g.connectionOffset + s.efa.width / 2 + 20;  // Centre du phantom + décalage réduit
      renderer.addPhantom(`efa-external${suffix}`, efaPhantomX, efaY, s.efa.width, s.efa.height);

      // Create links from configuration
      CONFIG.groupLinks.forEach(linkDef => {
        const bw = getBandwidth(linkDef.bandwidth);
        const fromId = linkDef.from === 'cpu' ? cpuId : `${linkDef.from}${suffix}`;  // Use cpuId from parameter
        const toId = `${linkDef.to}${suffix}`;
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const offset = getLinkOffset(bw.width);  // Proportional offset based on link width

        if (linkDef.stacked) {
          renderer.drawStackedLinks(fromId, toId, linkDef.stacked, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, linkDef.type, linkDef.bandwidth);
        } else if (linkDef.multiLink) {
          // Use localIndex for multi-link spacing (0-3 within ensemble)
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, localIndex, CONFIG.groupCount, 0, 1, linkDef.type, linkDef.bandwidth);
        } else {
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, 0, 1, 0, 1, linkDef.type, linkDef.bandwidth);
        }
      });
    }

    // ============================================================================
    // DRAW SINGLE ENSEMBLE (CPU + 4 groups + 2 NVSwitches)
    // ============================================================================
    function drawEnsemble(renderer, ensembleGlobalIndex, centerX, cpuY, nvswitchY) {
      const cpuId = ensembleGlobalIndex === 0 ? 'cpu' : `cpu-${ensembleGlobalIndex}`;

      // CPU for this ensemble
      renderer.drawProcessorNode(cpuId, centerX, cpuY, CONFIG.sizes.cpu, CONFIG.sizes.cpu, 'CPU', 'cpu');

      // Groups for this ensemble
      for (let i = 0; i < CONFIG.groupCount; i++) {
        const groupGlobalIndex = ensembleGlobalIndex * CONFIG.groupCount + i;
        const offsetX = (i - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal;
        drawGroup(renderer, groupGlobalIndex, i, centerX + offsetX, cpuY, nvswitchY, cpuId);  // Pass i as localIndex
      }

      // NVSwitches: positioned between pairs of groups
      for (let i = 0; i < CONFIG.nvswitchCount; i++) {
        const nvswitchGlobalIndex = ensembleGlobalIndex * CONFIG.nvswitchCount + i;
        const groupPairStart = i * 2;
        const groupPairEnd = groupPairStart + 1;

        const group1X = centerX + ((groupPairStart - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const group2X = centerX + ((groupPairEnd - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const nvswitchX = (group1X + group2X) / 2;

        renderer.drawNode(`nvswitch-${nvswitchGlobalIndex}`, nvswitchX, nvswitchY,
          CONFIG.sizes.nvswitch.width, CONFIG.sizes.nvswitch.height, 'NVSwitch', 'network');

        // Add pins to NVSwitch (like PCIe Switch)
        renderer.addPinsToNode(`nvswitch-${nvswitchGlobalIndex}`, {
          pinsPerSide: 6,
          sides: ['left', 'right'],
          pinLength: 3,
          pinPadding: 8
        });
      }

    }


    // ============================================================================
    // DRAW SINGLE SYSTEM (variable number of ensembles)
    // ============================================================================
    function drawSystem(renderer, systemIndex, systemCenterX, cpuY, nvswitchY, ensembleCount = 1, systemCount = 1, shouldDrawEfaCrossLinks = false) {
      // For internode (2 systems), only show 1 ensemble per system for clarity
      const ensemblesToShow = (systemCount === 2) ? 1 : ensembleCount;

      // Calculate ensemble width (4 groups)
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;

      // Calculate system bounding box based on actual ensembles shown
      const systemWidth = ensemblesToShow * ensembleWidth + (ensemblesToShow - 1) * CONFIG.gaps.ensembleGap;
      const systemHeight = CONFIG.sizes.cpu + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height;

      const systemBgCenterY = cpuY + (nvswitchY - cpuY) / 2;
      const systemPadding = 30;

      // In internode mode, extend the rectangle slightly to the right
      const isInternode = systemCount === 2;
      const extraWidth = isInternode && ensembleCount === 2 ? 210 : 0;

      // Draw system background ONLY if 2 ensembles (intra-node vs inter-node distinction)
      if (ensembleCount === 2) {
        // Adjust rectX to center the extended rectangle
        const totalWidth = systemWidth + systemPadding * 2 + extraWidth;
        const rectX = systemCenterX - totalWidth / 2;
        const rectY = systemBgCenterY - (systemHeight + systemPadding * 2) / 2;
        const rectWidth = totalWidth;
        const rectHeight = systemHeight + systemPadding * 2;

        renderer.structuralGroup.rect(rectWidth, rectHeight)
          .move(rectX, rectY)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 3,
            opacity: 1
          })
          .radius(12)
          .attr('data-group-border', 'node');

        // Add "Node" label at top left of the system box
        renderer.nodesGroup.text('Node')
          .move(rectX + 35, rectY + 40)
          .font({
            size: 32,
            family: 'var(--font-family)',
            weight: 900,
            fill: CONFIG.colors.textSecondary
          })
          .opacity(0.8);

        // Add NUMA 1 group with "..." in the extended area for internode mode
        if (isInternode) {
          const numaPadding = 15;
          const numaWidth = extraWidth - 15; // Margin for spacing
          const numaHeight = systemHeight;

          const numaX = rectX + rectWidth - extraWidth; // Left margin
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth;
          const numaRectHeight = numaHeight + numaPadding * 2;

          // Draw NUMA 1 border
          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA 1" label at top right
          renderer.nodesGroup.text('NUMA 1')
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);

          // Add "..." centered in NUMA 1
          renderer.nodesGroup.text('...')
            .move(numaX + numaRectWidth / 2, numaY + numaRectHeight / 2)
            .font({
              size: 40,
              family: 'var(--font-family)',
              weight: 900,
              fill: CONFIG.colors.textSecondary,
              anchor: 'middle'
            })
            .opacity(0.6);
        }
      }

      // Draw each ensemble in the system
      for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
        const ensembleGlobalIndex = systemIndex * CONFIG.ensembleCount + ensIndex;

        // Position ensemble within system
        let ensembleCenterX;
        if (isInternode) {
          // In internode mode, align NUMA 0 to the left of the Node rectangle
          const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
          ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
        } else {
          // Normal centered positioning
          const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
          ensembleCenterX = systemCenterX + ensembleOffsetX;
        }

        drawEnsemble(renderer, ensembleGlobalIndex, ensembleCenterX, cpuY, nvswitchY);
      }

      // Draw NUMA node borders (one per ensemble) if 2 ensembles
      if (ensembleCount === 2) {
        for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
          let ensembleCenterX;
          if (isInternode) {
            // In internode mode, align NUMA 0 to the left
            const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
            ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
          } else {
            // Normal centered positioning
            const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
            ensembleCenterX = systemCenterX + ensembleOffsetX;
          }

          // Calculate NUMA node bounding box (same as system but for single ensemble)
          const numaWidth = ensembleWidth;
          const numaHeight = systemHeight;
          const numaPadding = 15;

          const numaX = ensembleCenterX - (numaWidth + numaPadding * 2) / 2;
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth + numaPadding * 2;
          const numaRectHeight = numaHeight + numaPadding * 2;

          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA" label at top right
          renderer.nodesGroup.text(`NUMA ${ensIndex}`)
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);
        }
      }

      // GPU to NVSwitch connections (full mesh - all GPUs to all NVSwitches in system)
      const linkDef = CONFIG.gpuNvswitchLink;
      const bw = getBandwidth(linkDef.bandwidth);
      const color = CONFIG.colors.linkColor;
      const offset = getLinkOffset(bw.width);

      // Connect all GPUs in the system to all NVSwitches in the system
      const totalGpusInSystem = ensemblesToShow * CONFIG.groupCount;
      const totalNVSwitchesInSystem = ensemblesToShow * CONFIG.nvswitchCount;

      // Collect all GPU-NVSwitch connections for randomized drawing
      const gpuNvswitchConnections = [];
      for (let gpuIndex = 0; gpuIndex < totalGpusInSystem; gpuIndex++) {
        const gpuGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + gpuIndex;
        const gpuId = gpuGlobalIndex === 0 ? 'gpu' : `gpu-${gpuGlobalIndex}`;

        for (let nvIndex = 0; nvIndex < totalNVSwitchesInSystem; nvIndex++) {
          const nvswitchGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.nvswitchCount + nvIndex;
          gpuNvswitchConnections.push({
            fromId: gpuId,
            toId: `nvswitch-${nvswitchGlobalIndex}`,
            color: color,
            width: bw.width,
            fromSide: linkDef.fromSide,
            toSide: linkDef.toSide,
            offset: offset,
            type: linkDef.type,
            bandwidth: linkDef.bandwidth
          });
        }
      }

      // Randomize and draw GPU-NVSwitch connections
      const shuffledGpuNvswitchConnections = gpuNvswitchConnections.sort(() => Math.random() - 0.5);
      shuffledGpuNvswitchConnections.forEach(conn => {
        renderer.drawLink(conn.fromId, conn.toId, conn.color, conn.width, conn.fromSide, conn.toSide, conn.offset, 0, 1, 0, 1, conn.type, conn.bandwidth);
      });

      // Draw CPU-to-CPU link between ensembles (only if 2 ensembles visible)
      if (ensemblesToShow === 2) {
        const cpu0Id = systemIndex * CONFIG.ensembleCount === 0 ? 'cpu' : `cpu-${systemIndex * CONFIG.ensembleCount}`;
        const cpu1Id = `cpu-${systemIndex * CONFIG.ensembleCount + 1}`;

        // Use a bandwidth for CPU-CPU connection (assuming similar to CPU-PCIe)
        const bw = getBandwidth('16GB/s');
        const color = CONFIG.colors.linkColor;
        const offset = getLinkOffset(bw.width);

        renderer.drawLink(cpu0Id, cpu1Id, color, bw.width, 'right', 'left', offset, 0, 1, 0, 1, 'cpu', '16GB/s');

        // Draw EFA-to-EFA link between ensembles (only if 2 ensembles visible and explicitly requested)
        if (ensemblesToShow === 2 && shouldDrawEfaCrossLinks) {
          const efaExt0Id = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount === 0 ? 'efa-external' : `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount}`;
          const efaExt1Id = `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + CONFIG.groupCount}`;

          // Use unified EFA cross-links function
          drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
        }
      }
    }

    // ============================================================================
    // DRAW COMPLETE TOPOLOGY
    // ============================================================================
    let currentEnsembleCount = 2;  // Start with 2 ensembles (1 complete node)
    let currentSystemCount = 1;    // Start with 1 system
    let currentActivePathId = null; // Track active path for conditional rendering
    let showRealBandwidthsOverride = null; // User override via checkbox (null = use config)

    function drawTopology(ensembleCount = currentEnsembleCount, systemCount = currentSystemCount) {
      // Clear existing
      const container = getElement('aws-topology-container');
      container.innerHTML = '';

      // Use FIXED viewbox size for consistent zoom across all modes
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;
      const isInternodeLayout = systemCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode';

      // Calculate single system height (used in both layouts)
      const singleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;

      // Always use max viewbox dimensions for consistent zoom level
      const maxEnsembleWidthForViewbox = 2 * ensembleWidth;
      let viewboxWidth = maxEnsembleWidthForViewbox + CONFIG.gaps.ensembleGap + 200;
      let viewboxHeight = singleSystemHeight;

      // For single ensemble (CPU-GPU, GPU-GPU via CPU, storage paths), zoom in more
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxWidth *= 0.65;  // Zoom in by reducing viewbox width (increased from 0.75)
        viewboxHeight *= 0.65; // Zoom in by reducing viewbox height (increased from 0.75)
      }

      // For 2 systems in vertical layout, use scaled dimensions
      if (systemCount === 2 && !isInternodeLayout) {
        viewboxHeight = singleSystemHeight * 2 + CONFIG.gaps.systemGap;
        viewboxWidth *= 1.15;
        viewboxHeight *= 1.15;
      }

      // For internode horizontal layout, extend viewbox width to accommodate both extended systems
      if (isInternodeLayout) {
        const extraWidth = 210; // Extension per system for NUMA 1
        const systemPadding = 30;
        const singleEnsembleWidth = ensembleWidth;
        const totalSystemWidth = singleEnsembleWidth + systemPadding * 2 + extraWidth;
        const gap = 80;
        viewboxWidth = totalSystemWidth * 2 + gap + 200; // Extra margin for comfort
      }

      // Fixed height based on screen width for better consistency
      const embedConfig = readEmbedConfig();
      const containerWidth = container.clientWidth || 800;

      // Calculate fixed height: use max viewbox dimensions to determine aspect ratio
      // Max viewbox is for 2 ensembles, 2 systems (vertical layout)
      const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
      const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;
      const maxViewboxHeight = maxSingleSystemHeight * 1.15; // Account for 2-system scaling
      const maxViewboxWidth = maxEnsembleWidth + 200;

      const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
      const baseHeight = containerWidth * maxAspectRatio;
      const legendHeight = embedConfig.initialFilter ? 150 : 200;

      // Set fixed height once, won't change on filter change
      if (!container.dataset.heightSet) {
        container.style.height = `${baseHeight + legendHeight}px`;
        container.dataset.heightSet = 'true';
      }

      // Viewbox will auto-center/zoom content
      let viewboxY = 0;
      let paddedViewboxHeight = viewboxHeight;
      const verticalPadding = 0;
      viewboxY = -verticalPadding / 2 + 100;
      paddedViewboxHeight = viewboxHeight + verticalPadding;

      // For single ensemble, shift content up slightly
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxY += 150;  // Shift up by reducing viewboxY (reduced from 80)
      }

      // For single node mode (no Node/NUMA groups), shift content down by 80px
      // BUT only if: 1) not an EFA filter, 2) a filter is active
      const isEfaFilter = currentActivePathId === 'gpu-gpu-efa-intranode' || currentActivePathId === 'gpu-gpu-efa-internode';
      const hasActiveFilter = currentActivePathId && currentActivePathId !== '';
      if (!isInternodeLayout && hasActiveFilter && !isEfaFilter) {
        viewboxY -= 80;  // Shift down by decreasing viewboxY (increased from 50px)
      }

      const draw = SVG().addTo(container).size('100%', '100%').viewbox(0, viewboxY, viewboxWidth, paddedViewboxHeight);
      const renderer = new TopologyRenderer(draw);

      const centerX = viewboxWidth / 2;

      // Draw each system - horizontally for internode, vertically for others
      const isInternodeHorizontalLayout = isInternodeLayout;

      for (let sysIndex = 0; sysIndex < systemCount; sysIndex++) {
        let systemCenterX, cpuY, nvswitchY;

        if (isInternodeHorizontalLayout) {
          // Horizontal layout for internode: systems side by side (rapprochés mais sans overlap)
          // Pour internode, on affiche 1 seul ensemble (NUMA) par système, donc largeur réelle = 50%
          const fullSystemWidth = ensembleCount * ensembleWidth + (ensembleCount - 1) * CONFIG.gaps.ensembleGap;
          const actualSystemWidth = fullSystemWidth * 0.5; // On n'affiche qu'1 ensemble sur 2
          const extraWidth = 210; // Extension pour le groupe NUMA 1
          const systemPadding = 10;
          const totalSystemWidth = actualSystemWidth + systemPadding * 2 + extraWidth; // Largeur totale incluant l'extension
          const gap = 80; // Gap visible entre les systèmes

          // Positionner les systèmes avec le gap (en prenant en compte la largeur totale)
          if (sysIndex === 0) {
            systemCenterX = centerX - (totalSystemWidth / 2 + gap / 2); // Premier système à gauche
          } else {
            systemCenterX = centerX + (totalSystemWidth / 2 + gap / 2); // Deuxième système à droite
          }
          cpuY = CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        } else {
          // Vertical layout for other cases: systems stacked vertically
          const systemOffsetY = sysIndex * (singleSystemHeight + CONFIG.gaps.systemGap);
          systemCenterX = centerX;
          cpuY = systemOffsetY + CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        }

        // Only draw EFA cross-links for intranode EFA path
        const shouldDrawEfaCrossLinks = currentActivePathId === 'gpu-gpu-efa-intranode';
        drawSystem(renderer, sysIndex, systemCenterX, cpuY, nvswitchY, ensembleCount, systemCount, shouldDrawEfaCrossLinks);
      }

      // Draw EFA cross-link between systems (for internode)
      if (systemCount === 2 && ensembleCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode') {
        const efaExt0Id = 'efa-external';  // System 0, ensemble 0, group 0
        const efaExt1Id = 'efa-external-8';  // System 1, ensemble 0, group 0 (4 groups per ensemble, 2 ensembles per system = group 8)

        // Use unified EFA cross-links function
        drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
      }

      currentEnsembleCount = ensembleCount;
      currentSystemCount = systemCount;
    }

    // ============================================================================
    // REAL BANDWIDTH HELPERS
    // ============================================================================
    function getRealBandwidthForPath(pathId) {
      const pathToRealBandwidth = {
        'cpu-gpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-cpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-nvswitch': { value: '786', unit: 'GB/s' },
        'gpu-gpu-efa-intranode': { value: '40', unit: 'GB/s' },
        'gpu-gpu-efa-internode': { value: '40', unit: 'GB/s' },
        'gpu-storage': { value: '14.2', unit: 'GB/s' },
        'cpu-storage': { value: '14.2', unit: 'GB/s' },
        'gpu-cpu-storage': { value: '14.2', unit: 'GB/s' }
      };

      const bandwidth = pathToRealBandwidth[pathId];
      if (bandwidth) {
        return {
          value: bandwidth.value,
          unit: bandwidth.unit
        };
      }
      return null;
    }

    // ============================================================================
    // HIGHLIGHT HELPERS
    // ============================================================================
    function highlightPath(path, pathLabel = '', pathId = '') {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear previous active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Ghost all base links and cross-links groups at once
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '0.35';

        // Increase stroke width of group borders to make them more visible when ghosted
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '5');
          // border.setAttribute('stroke-opacity', '0.8');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '0.25';
      }

      // Dim nodes individually (they're not in a group)
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '0.6';
        // Dim text labels
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '0.25';
        });
      });

      // Highlight path nodes
      path.nodes.forEach(nodeId => {
        let nodeEl = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeEl) {
          const candidates = svg.querySelectorAll(`g[id^="${nodeId}"]`);
          nodeEl = candidates[0];
        }
        if (nodeEl) {
          nodeEl.style.opacity = '1';
          // Restore text opacity
          nodeEl.querySelectorAll('text').forEach(text => {
            text.style.opacity = '1';
          });
        }
      });

      // Duplicate active links into activeLinksGroup
      if (activeLinksGroup) {
        path.links.forEach(linkSpec => {
          // Find matching links in base groups
          const allBaseLinks = [
            ...svg.querySelectorAll('g[data-group="base-links"] > g[data-link-type]'),
            ...svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type]')
          ];

          allBaseLinks.forEach(linkGroup => {
            const linkFrom = linkGroup.getAttribute('data-from');
            const linkTo = linkGroup.getAttribute('data-to');

            const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
            const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

            if (matchesFrom && matchesTo) {
              // Clone the link and append to active group
              const clonedLink = linkGroup.cloneNode(true);
              activeLinksGroup.appendChild(clonedLink);
            }
          });
        });

        // Duplicate EFA cross-links if they match the current path
        const currentPathId = currentActivePathId;
        if (currentPathId === 'gpu-gpu-efa-intranode' || currentPathId === 'gpu-gpu-efa-internode') {
          const efaCrossLinks = svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type="efa-crosslink"]');
          efaCrossLinks.forEach(linkGroup => {
            const clonedLink = linkGroup.cloneNode(true);
            activeLinksGroup.appendChild(clonedLink);
          });
        }
      }

      // Calculate and show bottleneck (minimum bandwidth in the path)
      let minBandwidth = Infinity;
      let minBandwidthValue = null;
      const usedBandwidths = new Set();

      path.links.forEach(linkSpec => {
        svg.querySelectorAll('g[data-link-type]').forEach(linkGroup => {
          const linkFrom = linkGroup.getAttribute('data-from');
          const linkTo = linkGroup.getAttribute('data-to');

          const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
          const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

          if (matchesFrom && matchesTo) {
            const bandwidth = linkGroup.getAttribute('data-bandwidth');
            if (bandwidth) {
              const bw = getBandwidth(bandwidth);
              if (bw && bw.numericValue < minBandwidth) {
                minBandwidth = bw.numericValue;
                minBandwidthValue = bw.speed;
              }
              if (bw) {
                usedBandwidths.add(bw.speed);
              }
            }
          }
        });
      });

      // Highlight all used bandwidths in the legend
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          const bandwidth = legendItem.getAttribute('data-legend-bandwidth');
          if (usedBandwidths.has(bandwidth)) {
            // Used in the path - active
            legendItem.style.opacity = '1';
          } else {
            // Not used - ghosted
            legendItem.style.opacity = '0.4';
          }
        });
      }

      // Show bottleneck info
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      const efficiencyValueEl = bottleneckEl.querySelector('.efficiency-value');

      // Check if real bandwidths are enabled
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (showRealBandwidths) {
        // When real bandwidths are shown, display real bandwidth value directly
        const realBandwidth = getRealBandwidthForPath(pathId);
        if (realBandwidth) {
          bottleneckValueEl.textContent = realBandwidth.value;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');

          // Calculate and display efficiency
          if (minBandwidthValue && efficiencyEl && efficiencyValueEl) {
            const theoreticalBandwidth = parseFloat(minBandwidthValue.replace('GB/s', ''));
            const realBandwidthNum = parseFloat(realBandwidth.value);

            // For EFA (12.5GB/s), multiply by 4 to get total theoretical bandwidth
            const adjustedTheoretical = minBandwidthValue === '12.5GB/s' ? theoreticalBandwidth * 4 : theoreticalBandwidth;

            const efficiency = (realBandwidthNum / adjustedTheoretical) * 100;
            efficiencyValueEl.textContent = `${efficiency.toFixed(1)}%`;
            efficiencyEl.style.display = 'block';
          }
        } else {
          // Fallback if no real bandwidth found
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');
          if (efficiencyEl) {
            efficiencyEl.style.display = 'none';
          }
        }
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      } else {
        // Normal bottleneck display
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        if (minBandwidthValue) {
          const value = minBandwidthValue.replace('GB/s', '');
          // For EFA (12.5GB/s), display as 50 (4 links × 12.5)
          const displayValue = value === '12.5' ? '50' : value;
          bottleneckValueEl.textContent = displayValue;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        } else {
          // Debug: show the module even without bandwidth data
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        }
        // Hide efficiency in normal mode
        if (efficiencyEl) {
          efficiencyEl.style.display = 'none';
        }
      }
    }

    function resetHighlight() {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Restore opacity to base links groups
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '1';

        // Restore original stroke width for group borders
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '3');
          border.setAttribute('stroke-opacity', '1');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '1';
      }

      // Reset nodes opacity
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '1';
        // Reset text opacity
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '1';
        });
      });

      // Clear current active path to ensure EFA cross-links are not drawn
      currentActivePathId = null;

      // Reset legend opacity
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          legendItem.style.opacity = '1';
        });
      }

      // Hide bottleneck (unless real bandwidths are enabled)
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (!showRealBandwidths) {
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        bottleneckEl.classList.remove('visible');
      } else {
        // When real bandwidths are enabled, hide the module when no path is active
        bottleneckLabelEl.textContent = 'Real Bandwidth';
        bottleneckEl.classList.remove('visible');
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      }

      // Hide efficiency display
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      if (efficiencyEl) {
        efficiencyEl.style.display = 'none';
      }
    }

    // ============================================================================
    // CONFIG READING (from HtmlEmbed props)
    // ============================================================================
    function readEmbedConfig() {
      // Find the closest ancestor that carries the data-config attribute
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let providedConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      const config = providedConfig || {};

      // Apply user override from checkbox if set
      if (showRealBandwidthsOverride !== null) {
        config.showRealBandwidths = showRealBandwidthsOverride;
      }

      return config;
    }

    // ============================================================================
    // REAL BANDWIDTHS DISPLAY
    // ============================================================================
    function displayContextualRealBandwidths(pathId, pathLabel) {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Map path IDs to relevant real bandwidths
      const pathToBandwidths = {
        'cpu-gpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-cpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-GPU (via CPU)', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-nvswitch': [
          { label: 'GPU-GPU (NVSwitch)', value: CONFIG.realBandwidths['gpu-gpu-same-node'] }
        ],
        'gpu-gpu-efa-intranode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-intranode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
          { label: 'All2All', value: CONFIG.realBandwidths['all2all-same-node'] }
        ],
        'gpu-gpu-efa-internode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-internode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
          { label: 'All2All', value: CONFIG.realBandwidths['alltoall-internode'] }
        ],
        'gpu-storage': [
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'cpu-storage': [
          { label: 'CPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'gpu-cpu-storage': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ]
      };

      const relevantBandwidths = pathToBandwidths[pathId] || [];

      if (relevantBandwidths.length > 0) {
        // Clear normal bottleneck display
        bottleneckValueEl.textContent = '';
        bottleneckPathEl.textContent = '';

        // Create HTML for relevant bandwidths
        const html = relevantBandwidths.map(item => `
          <div class="bandwidth-item">
            <span class="bandwidth-label">${item.label}</span>
            <span class="bandwidth-value">${item.value}</span>
          </div>
        `).join('');

        realBandwidthsContentEl.innerHTML = html;
      } else {
        // Fallback: show all bandwidths if path not found
        setupRealBandwidthsDisplay();
      }
    }

    function setupRealBandwidthsDisplay() {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Create the bandwidth items HTML
      const bandwidthItems = [
        { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
        { label: 'Same Node', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-same-node'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
        { label: '  All2All', value: CONFIG.realBandwidths['all2all-same-node'] },
        { label: 'Internode', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-internode'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
        { label: '  All2All', value: CONFIG.realBandwidths['alltoall-internode'] },
        { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
      ];

      const html = bandwidthItems.map(item => {
        if (item.value === '') {
          // Section header
          return `<div class="bandwidth-section-header" style="font-weight: 600; margin: 6px 0 4px 0; color: var(--text-secondary);">${item.label}</div>`;
        } else {
          // Bandwidth item
          return `
            <div class="bandwidth-item">
              <span class="bandwidth-label">${item.label}</span>
              <span class="bandwidth-value">${item.value}</span>
            </div>
          `;
        }
      }).join('');

      realBandwidthsContentEl.innerHTML = html;
    }

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    function initialize() {
      const container = getElement('aws-topology-container');
      const tooltip = getElement('aws-topology-tooltip');

      // Read initial config from HtmlEmbed props (before any override)
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let initialConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          initialConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      // Initialize override with initial config value (so checkbox is in sync)
      if (initialConfig && initialConfig.showRealBandwidths !== undefined) {
        showRealBandwidthsOverride = initialConfig.showRealBandwidths;
      }

      // Now read config (which will use override if set)
      const embedConfig = readEmbedConfig();

      // Setup real bandwidths display if enabled
      if (embedConfig.showRealBandwidths) {
        const bottleneckEl = getElement('aws-topology-bottleneck');
        const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');

        // Change label to "Real Bandwidth"
        bottleneckLabelEl.textContent = 'Real Bandwidth';

        // Hide the detailed real bandwidths list initially
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
        // Don't show the module initially - only when a path is selected
        bottleneckEl.classList.remove('visible');
      }

      drawTopology();

      // Initial fade in
      requestAnimationFrame(() => {
        container.style.opacity = '1';
      });

      // Setup tooltip

      container.addEventListener('mouseover', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          const bandwidth = target.getAttribute('data-bandwidth');
          const label = target.getAttribute('data-label');

          // Clear and rebuild tooltip content
          tooltip.innerHTML = '';

          if (label) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'tooltip-label';
            labelDiv.textContent = label;
            tooltip.appendChild(labelDiv);
          }

          const bandwidthDiv = document.createElement('div');
          bandwidthDiv.className = 'tooltip-bandwidth';
          bandwidthDiv.textContent = bandwidth;
          tooltip.appendChild(bandwidthDiv);

          tooltip.classList.add('visible');
        }
      });

      container.addEventListener('mousemove', (e) => {
        if (tooltip.classList.contains('visible')) {
          const rect = container.getBoundingClientRect();
          tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
          tooltip.style.top = (e.clientY - rect.top + 10) + 'px';
        }
      });

      container.addEventListener('mouseout', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          tooltip.classList.remove('visible');
        }
      });

      // Create control buttons organized by category
      const controlsContainer = getElement('aws-topology-controls');

      // Hide controls if an initial filter is provided
      if (embedConfig.initialFilter) {
        controlsContainer.style.display = 'none';
      } else {
        // Categorize paths
        const pathsByCategory = {
          intranode: [
            { id: 'cpu-gpu', label: CONFIG.paths['cpu-gpu'].label },
            { id: 'gpu-gpu-cpu', label: CONFIG.paths['gpu-gpu-cpu'].label },
            { id: 'gpu-gpu-nvswitch', label: CONFIG.paths['gpu-gpu-nvswitch'].label },
            { id: 'gpu-gpu-efa-intranode', label: CONFIG.paths['gpu-gpu-efa-intranode'].label }
          ],
          internode: [
            { id: 'gpu-gpu-efa-internode', label: CONFIG.paths['gpu-gpu-efa-internode'].label }
          ],
          storage: [
            { id: 'gpu-storage', label: CONFIG.paths['gpu-storage'].label },
            { id: 'cpu-storage', label: CONFIG.paths['cpu-storage'].label },
            { id: 'gpu-cpu-storage', label: CONFIG.paths['gpu-cpu-storage'].label }
          ]
        };

        // Create single select with prefixed options and checkbox
        const isChecked = showRealBandwidthsOverride === true || (showRealBandwidthsOverride === null && embedConfig.showRealBandwidths);
        const controlsHTML = `
          <div>
            <label id="real-bandwidth-label" style="display: flex; align-items: center; gap: 0px; font-size: 14px; color: var(--text-color); cursor: pointer; opacity: 0.3; transition: opacity 0.2s;">
              <input type="checkbox" id="real-bandwidth-toggle" ${isChecked ? 'checked' : ''} disabled>
              <span>Show Real Bandwidths</span>
            </label>
          </div>
          
          <div style="display: flex; gap: 12px; align-items: center; margin-top: 8px;">
            <select id="path-select" style="min-width: 250px;">
              <option value="">Select path...</option>
            </select>
          </div>
        `;
        controlsContainer.innerHTML = controlsHTML;

        const pathSelect = controlsContainer.querySelector('#path-select');
        const realBandwidthToggle = controlsContainer.querySelector('#real-bandwidth-toggle');
        const realBandwidthLabel = controlsContainer.querySelector('#real-bandwidth-label');

        // Populate single select with prefixed options
        Object.entries(pathsByCategory).forEach(([category, paths]) => {
          const categoryLabel = category.charAt(0).toUpperCase() + category.slice(1);

          paths.forEach(path => {
            const option = document.createElement('option');
            option.value = path.id;
            option.textContent = `${categoryLabel}: ${path.label}`;
            pathSelect.appendChild(option);
          });
        });

        // Helper function to enable/disable real bandwidth toggle
        const updateRealBandwidthToggleState = (enabled) => {
          if (enabled) {
            realBandwidthToggle.disabled = false;
            realBandwidthLabel.style.opacity = '1';
            realBandwidthLabel.style.cursor = 'pointer';
          } else {
            realBandwidthToggle.disabled = true;
            realBandwidthLabel.style.opacity = '0.3';
            realBandwidthLabel.style.cursor = 'default';
          }
        };

        // Real bandwidth toggle handler
        realBandwidthToggle.addEventListener('change', (e) => {
          showRealBandwidthsOverride = e.target.checked;

          // Re-apply highlight if a path is active
          if (currentActivePathId) {
            const path = CONFIG.paths[currentActivePathId];
            if (path) {
              highlightPath(path, path.label, currentActivePathId);
            }
          } else {
            // If no path active, just reset to clear any displayed values
            resetHighlight();
          }
        });

        // Function to activate a path
        const activatePath = (pathId) => {
          if (!pathId) {
            // Reset to default
            currentActivePathId = null;
            updateRealBandwidthToggleState(false); // Disable toggle when no path selected
            const needsRedraw = currentEnsembleCount !== 2 || currentSystemCount !== 1;

            if (needsRedraw) {
              const container = getElement('aws-topology-container');
              container.style.opacity = '0';

              setTimeout(() => {
                drawTopology(2, 1);
                resetHighlight();

                requestAnimationFrame(() => {
                  container.style.opacity = '1';
                });
              }, 150);
            } else {
              resetHighlight();
            }
            return;
          }

          const path = CONFIG.paths[pathId];
          if (!path) return;

          currentActivePathId = pathId;
          updateRealBandwidthToggleState(true); // Enable toggle when path is selected

          // Check if we need to redraw
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            pathId === 'gpu-gpu-efa-intranode' ||
            pathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            const container = getElement('aws-topology-container');
            container.style.opacity = '0';

            setTimeout(() => {
              currentActivePathId = pathId;
              drawTopology(path.requiredEnsembles, path.requiredSystems);
              highlightPath(path, path.label, pathId);

              requestAnimationFrame(() => {
                container.style.opacity = '1';
              });
            }, 150);
          } else {
            currentActivePathId = pathId;
            highlightPath(path, path.label, pathId);
          }
        };

        // Path select change handler
        pathSelect.addEventListener('change', (e) => {
          const pathId = e.target.value;
          activatePath(pathId);
        });
      }

      // Apply initial filter from embedConfig if provided
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          currentActivePathId = initialPathId;

          // Draw topology with correct requirements
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            initialPathId === 'gpu-gpu-efa-intranode' ||
            initialPathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            drawTopology(path.requiredEnsembles, path.requiredSystems);
          }
        }
      }

      // Create SVG legend
      const legendContainer = getElement('aws-topology-legend');
      const legendSvg = SVG().addTo(legendContainer).size('100%', '100%');

      const lineLength = 36;  // 30 * 1.2
      const itemSpacing = 30;  // 25 * 1.2
      const startX = 96;  // 80 * 1.2
      const startY = 42;  // 35 * 1.2
      const textOffset = 24;  // 20 * 1.2

      // Calculate actual legend width based on content
      const legendWidth = startX + lineLength + textOffset + 168;  // 140 * 1.2
      const legendHeight = 144;  // 120 * 1.2
      legendSvg.viewbox(0, 0, legendWidth, legendHeight);

      [...CONFIG.bandwidths].reverse().forEach((bw, index) => {
        const y = startY + (index * itemSpacing);
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const width = bw.width;

        // Create a group for each legend item with a data attribute for bandwidth
        const legendItemGroup = legendSvg.group();
        legendItemGroup.attr('data-legend-bandwidth', bw.speed);

        // Dessiner la ligne
        legendItemGroup.line(startX, y, startX + lineLength, y)
          .stroke({ color, width });

        // Dessiner les cercles aux extrémités
        const r = width * 0.8;
        const startCircle = legendItemGroup.circle(r * 2).move(startX - r, y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        const endCircle = legendItemGroup.circle(r * 2).move(startX + lineLength - r, y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        // Ajouter le texte (aligné à droite, valeur en gras)
        const textX = legendWidth - 5;
        const value = bw.speed.replace('GB/s', '').trim();

        // Format: "Label - 900 GB/s" avec 900 en gras
        const textEl = legendItemGroup.text(function (add) {
          add.tspan(bw.label + ' - ').font({ weight: 'normal' });
          add.tspan(value).font({ weight: 'bold' });
          add.tspan(' GB/s').font({ weight: 'normal' });
        })
          .move(textX, y)
          .font({
            family: 'system-ui, -apple-system, sans-serif',
            size: 14,  // 12 * 1.2 ≈ 14
            anchor: 'end',
            fill: CONFIG.colors.nodeText
          })
          .dy(-7);  // -6 * 1.2 ≈ -7
      });
    }

    // Initialize only if wrapper is found
    if (findWrapper()) {
      initialize();

      // Apply initial filter highlight after legend is created
      const embedConfig = readEmbedConfig();
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          // Apply highlight to both topology and legend
          highlightPath(path, path.label, initialPathId);
        }
      }

      // Add resize handler for responsive width changes (mobile/desktop)
      const handleResize = () => {
        const container = getElement('aws-topology-container');
        if (!container) return;

        // Recalculate fixed height based on new width (for responsive design)
        const containerWidth = container.clientWidth || 800;

        // Use max viewbox dimensions for consistent aspect ratio
        const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
        const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
          CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
          CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
          CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
          CONFIG.gaps.bottomMargin;
        const maxViewboxHeight = maxSingleSystemHeight * 1.15;
        const maxViewboxWidth = maxEnsembleWidth + 200;

        const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
        const baseHeight = containerWidth * maxAspectRatio;
        const legendHeight = embedConfig.initialFilter ? 150 : 200;

        // Update height based on current width (responsive)
        container.style.height = `${baseHeight + legendHeight}px`;
      };

      // Use ResizeObserver for better performance (only for window resize, not content changes)
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => handleResize());
        ro.observe(findWrapper());
      } else {
        window.addEventListener('resize', handleResize);
      }
    } else {
      console.warn('AWS topology: wrapper not found, skipping initialization');
    }
  })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">Internode GPU-to-GPU communication path through Libfabric EFA</figcaption></figure> </div>
<p>As illustrated above, when GPUs and network cards are connected to the same PCIe switch, GPUDirect RDMA enables their communication to occur solely through that switch. This setup allows for full utilization of the PCIe Gen5 x16 bandwidth and avoids involving other PCIe switches or the CPU memory bus.
Theoretically, 8 PCIe Switches per node x 4 EFA NICs per switch x 100 Gbps each EFA NIC gives 3200 Gbps (400GB/s) of bandwidth which is the bandwidth we find in <a href="https://aws.amazon.com/ec2/instance-types/p5/">AWS p5’s specs).</a> So how does it hold in practice? Let’s find out by running the same benchmarks as before but across different nodes!</p>
<p><strong>Bandwidth Analysis</strong></p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-091yd8jnngo2"><div class="nccl-bandwidth-comparison">
  <div class="nccl-bandwidth-comparison__grid">
    <div class="nccl-chart-cell" data-benchmark="sendrecv"
      data-title="NCCL's Sendrecv performance test"></div>
    <div class="nccl-chart-cell" data-benchmark="all_reduce" data-title="NCCL's All-Reduce performance test">
    </div>
    <div class="nccl-chart-cell" data-benchmark="alltoall"
      data-title="NCCL's Alltoall performance test"></div>
  </div>
  <div class="nccl-bandwidth-comparison__legend"></div>
  <noscript>JavaScript is required to render these charts.</noscript>
</div>
<style>
  .nccl-bandwidth-comparison {
    position: relative;
  }

  .nccl-bandwidth-comparison .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 700;
  }

  .nccl-bandwidth-comparison .axes path,
  .nccl-bandwidth-comparison .axes line {
    stroke: var(--axis-color);
  }

  .nccl-bandwidth-comparison .axes text {
    fill: var(--tick-color);
  }

  .nccl-bandwidth-comparison .grid line {
    stroke: var(--grid-color);
  }

  .nccl-bandwidth-comparison__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }

  @media (max-width: 1100px) {
    .nccl-bandwidth-comparison__grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @media (max-width: 700px) {
    .nccl-bandwidth-comparison__grid {
      grid-template-columns: 1fr;
    }
  }

  .nccl-chart-cell {
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background: var(--page-bg);
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
  }

  .nccl-chart-cell .cell-header {
    padding: 8px 10px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }

  .nccl-chart-cell .cell-title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
  }

  .nccl-chart-cell .cell-subtitle {
    font-size: 11px;
    color: var(--muted-color);
  }

  .nccl-chart-cell .cell-body {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .nccl-chart-cell .cell-body svg {
    max-width: 100%;
    height: auto;
  }

  .nccl-chart-cell .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 4px;
    margin-top: 8px;
  }

  .nccl-chart-cell .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .nccl-chart-cell .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
  }

  .nccl-chart-cell .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .nccl-chart-cell .legend-bottom .legend-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--muted-color);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .nccl-chart-cell .lines path.active {
    stroke-width: 3;
  }

  .nccl-chart-cell .d3-tooltip {
    z-index: var(--z-elevated);
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .nccl-chart-cell .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .nccl-chart-cell .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .nccl-chart-cell .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .nccl-chart-cell .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .nccl-bandwidth-comparison__legend {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .nccl-bandwidth-comparison__legend .legend-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--muted-color);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .nccl-bandwidth-comparison__legend .legend-items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 16px;
  }

  .nccl-bandwidth-comparison__legend .legend-item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
  }

  .nccl-bandwidth-comparison__legend .legend-swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }
</style>
<script>
  (() => {
    // Prevent multiple executions
    if (window.ncclBandwidthComparisonInitialized) return;
    window.ncclBandwidthComparisonInitialized = true;

    // Completely scoped IIFE to avoid variable conflicts
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrapBandwidthComparison = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('nccl-bandwidth-comparison'))) {
        const cs = Array.from(document.querySelectorAll('.nccl-bandwidth-comparison')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) { if (container.dataset.mounted === 'true') return; container.dataset.mounted = 'true'; }

      let data = {};

      // Colors - following guidelines to use ColorPalettes
      let currentColors = ['#d62728', '#1f77b4', '#2ca02c', '#ff7f0e', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94'];

      function refreshPalette() {
        try {
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            const colors = window.ColorPalettes.getColors('categorical', 12);
            if (colors && colors.length > 0) {
              currentColors = colors;
              // Re-render with new colors
              if (Object.keys(data).length > 0) renderAllCharts();
              return;
            }
          }
        } catch (_) { }
        // Fallback to CSS variable or default
        currentColors = ['#d62728', '#1f77b4', '#2ca02c', '#ff7f0e', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5', '#c49c94'];
        // Re-render with fallback colors
        if (Object.keys(data).length > 0) renderAllCharts();
      }

      function getColors() {
        return currentColors;
      }

      // Format helper for bytes
      function formatBytes(bytes) {
        if (bytes >= 1024 * 1024 * 1024) {
          return Math.round(bytes / (1024 * 1024 * 1024)) + ' GB';
        } else if (bytes >= 1024 * 1024) {
          return Math.round(bytes / (1024 * 1024)) + ' MB';
        } else if (bytes >= 1024) {
          return Math.round(bytes / 1024) + ' KB';
        } else {
          return bytes + ' B';
        }
      }

      // Format helper for bandwidth values
      function formatBandwidth(v) {
        return Math.round(v);
      }

      function createChart(cell, benchmark) {
        // Create header if it doesn't exist
        let header = cell.querySelector('.cell-header');
        if (!header) {
          header = document.createElement('div');
          header.className = 'cell-header';
          const title = document.createElement('div');
          title.className = 'cell-title';
          title.textContent = cell.dataset.title;
          header.appendChild(title);
          cell.appendChild(header);
        }

        // Create body if it doesn't exist
        let body = cell.querySelector('.cell-body');
        if (!body) {
          body = document.createElement('div');
          body.className = 'cell-body';
          cell.appendChild(body);
        }

        // Legend removed - no longer needed

        // Create tooltip if it doesn't exist
        let tip = cell.querySelector('.d3-tooltip');
        let tipInner;
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'd3-tooltip';
          Object.assign(tip.style, {
            position: 'absolute', top: '0px', left: '0px', transform: 'translate(-9999px, -9999px)', pointerEvents: 'none',
            padding: '8px 10px', borderRadius: '8px', fontSize: '12px', lineHeight: '1.35', border: '1px solid var(--border-color)',
            background: 'var(--surface-bg)', color: 'var(--text-color)', boxShadow: '0 4px 24px rgba(0,0,0,.18)', opacity: '0', transition: 'opacity .12s ease'
          });
          tipInner = document.createElement('div');
          tipInner.className = 'd3-tooltip__inner';
          tipInner.style.textAlign = 'left';
          tip.appendChild(tipInner);
          cell.appendChild(tip);
        } else {
          tipInner = tip.querySelector('.d3-tooltip__inner');
        }

        // SVG - create only if it doesn't exist
        let svg = d3.select(body).select('svg');
        let gRoot, gGrid, gAxes, gLines;

        if (svg.empty()) {
          svg = d3.select(body).append('svg').attr('width', '100%').style('display', 'block');
          gRoot = svg.append('g');
          gGrid = gRoot.append('g').attr('class', 'grid');
          gAxes = gRoot.append('g').attr('class', 'axes');
          gLines = gRoot.append('g').attr('class', 'lines');
        } else {
          gRoot = svg.select('g');
          gGrid = gRoot.select('.grid');
          gAxes = gRoot.select('.axes');
          gLines = gRoot.select('.lines');
        }

        // State
        let width = 400, height = 250;
        const margin = { top: 16, right: 32, bottom: 70, left: 80 };
        const xScale = d3.scaleLog();
        const yScale = d3.scaleLinear();
        const lineGen = d3.line().x(d => xScale(d.messageSize)).y(d => yScale(d.bandwidth));

        function updateLayout() {
          const axisColor = getComputedStyle(cell).getPropertyValue('--axis-color').trim() || 'rgba(0,0,0,0.25)';
          width = cell.clientWidth || 400;
          height = Math.max(250, Math.round(width * 0.75));
          svg.attr('width', width).attr('height', height);
          gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;
          return { innerWidth, innerHeight };
        }

        function render() {
          if (!data[benchmark]) return;

          const { innerWidth, innerHeight } = updateLayout();

          // Prepare series data - one line per node count
          const series = [];
          const colors = getColors();

          Object.keys(data[benchmark]).forEach(nodeKey => {
            const nodeData = data[benchmark][nodeKey];
            if (nodeData && nodeData.length > 0) {
              const nodeCount = parseInt(nodeKey.split('_')[0]);
              series.push({
                name: `${nodeCount} nodes`,
                nodeCount: nodeCount,
                values: nodeData.map(d => ({ messageSize: d.messageSize, bandwidth: d.bandwidth })),
                color: colors[(nodeCount - 1) % colors.length]
              });
            }
          });

          if (series.length === 0) return;

          // Sort by node count
          series.sort((a, b) => a.nodeCount - b.nodeCount);

          // Get all data points for domain calculation
          const allData = series.flatMap(s => s.values);
          const sortedData = allData.slice().sort((a, b) => a.messageSize - b.messageSize);

          // domains
          const minSize = d3.min(sortedData, d => d.messageSize);
          const maxSize = d3.max(sortedData, d => d.messageSize);
          const minBandwidth = 0;
          const maxBandwidth = d3.max(sortedData, d => d.bandwidth);

          // Set Y domain based on benchmark with individual caps
          let yMax;
          if (benchmark === 'alltoall') {
            yMax = 350;
          } else if (benchmark === 'all_reduce') {
            yMax = 500;
          } else if (benchmark === 'sendrecv') {
            yMax = Math.ceil(maxBandwidth * 1.1); // Cap au max des données
          } else {
            yMax = maxBandwidth * 1.1;
          }

          xScale.domain([minSize, maxSize]).range([0, innerWidth]);
          yScale.domain([minBandwidth, yMax]).range([innerHeight, 0]);

          // grid
          gGrid.selectAll('*').remove();
          gGrid.selectAll('line').data(yScale.ticks(7)).join('line')
            .attr('x1', 0).attr('x2', innerWidth).attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
            .attr('stroke', 'var(--grid-color)').attr('stroke-width', 1).attr('shape-rendering', 'crispEdges');

          // axes
          gAxes.selectAll('*').remove();

          // Create custom ticks for X axis (powers of 2, every 4th tick)
          const xTicks = [8, 128, 2048, 32768, 524288, 8388608, 134217728, 2147483648, 8589934592];
          const filteredXTicks = xTicks.filter(tick => tick >= minSize && tick <= maxSize);

          gAxes.append('g').attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale).tickValues(filteredXTicks).tickFormat(formatBytes))
            .call(g => {
              g.selectAll('path, line').attr('stroke', 'var(--axis-color)');
              g.selectAll('text')
                .attr('fill', 'var(--tick-color)')
                .style('font-size', '10px')
                .attr('transform', 'rotate(-45)')
                .style('text-anchor', 'end')
                .attr('dx', '-8px');
            });

          gAxes.append('g').call(d3.axisLeft(yScale).tickFormat(formatBandwidth)).call(g => { g.selectAll('path, line').attr('stroke', 'var(--axis-color)'); g.selectAll('text').attr('fill', 'var(--tick-color)').style('font-size', '12px'); });
          gAxes.append('text').attr('class', 'axis-label').attr('text-anchor', 'middle').attr('x', innerWidth / 2).attr('y', innerHeight + 50).text('Message Size (bytes)');
          gAxes.append('text').attr('class', 'axis-label').attr('text-anchor', 'middle').attr('transform', `translate(${-60}, ${innerHeight / 2}) rotate(-90)`).text('Bus Bandwidth (GB/s)');

          // lines
          gLines.selectAll('*').remove();
          series.forEach((s, i) => {
            if (s.values.length > 0) {
              gLines.append('path')
                .attr('class', `line line-${i}`)
                .attr('data-series', s.name)
                .attr('fill', 'none')
                .attr('stroke', s.color)
                .attr('stroke-width', 2)
                .attr('d', lineGen(s.values));
            }
          });

          // Point markers removed - no longer needed

        }

        return { render };
      }

      function renderAllCharts() {
        const cells = container.querySelectorAll('.nccl-chart-cell');
        cells.forEach(cell => {
          const benchmark = cell.dataset.benchmark;

          // Check if chart is already initialized
          if (!cell.dataset.chartInitialized) {
            const chart = createChart(cell, benchmark);
            cell.chartInstance = chart;
            cell.dataset.chartInitialized = 'true';
          }

          // Render the existing chart
          if (cell.chartInstance) {
            cell.chartInstance.render();
          }
        });

        // Render common legend
        renderCommonLegend();
      }

      function renderCommonLegend() {
        const legendContainer = container.querySelector('.nccl-bandwidth-comparison__legend');
        if (!legendContainer || !data) return;

        // Collect all unique node counts from all benchmarks
        const nodeCounts = new Set();
        Object.keys(data).forEach(benchmark => {
          Object.keys(data[benchmark]).forEach(nodeKey => {
            // nodeKey format is "nodes_X" where X is the node count
            const nodeCount = parseInt(nodeKey.replace('nodes_', ''));
            if (!isNaN(nodeCount)) {
              nodeCounts.add(nodeCount);
            }
          });
        });

        // Sort node counts
        const sortedNodeCounts = Array.from(nodeCounts).sort((a, b) => a - b);

        // Get colors
        const colors = getColors();

        // Create legend with individual colored lines
        const legendWidth = Math.min(container.clientWidth * 0.8, 600);
        const legendHeight = 30;
        const lineHeight = 5; // Height of each colored line
        const lineY = 0; // Y position of the lines

        // Calculate spacing between items
        const numItems = sortedNodeCounts.length;
        const itemWidth = legendWidth / numItems;

        legendContainer.innerHTML = `
          <div style="font-size: 12px; font-weight: 600; color: var(--text-color); margin-bottom: 12px;">Number of Nodes</div>
          <svg width="${legendWidth}" height="${legendHeight}" style="display: block; overflow:visible!important;">
            <!-- Individual colored lines and labels -->
            ${sortedNodeCounts.map((nodeCount, i) => {
          const x = (i + 0.5) * itemWidth;
          const lineWidth = itemWidth * 0.5; // 50% of available space for each line
          const lineX = i * itemWidth + (itemWidth - lineWidth) / 2;
          const label = nodeCount === 1 ? '1' : `${nodeCount}`;
          const color = colors[(nodeCount - 1) % colors.length];

          return `
                <!-- Colored line -->
                <line x1="${lineX}" y1="${lineY}" x2="${lineX + lineWidth}" y2="${lineY}" 
                      stroke="${color}" stroke-width="${lineHeight}" stroke-linecap="round" />
                
                <!-- Label -->
                <text x="${x}" y="${lineY + 20}" 
                      text-anchor="middle" 
                      font-size="11px" 
                      font-weight="600"
                      fill="var(--text-color)">${label}</text>
              `;
        }).join('')}
          </svg>
        `;
      }

      // Load real data from JSON
      async function loadData() {
        try {
          const response = await fetch('./data/nccl-multinode-bandwidth.json');
          const jsonData = await response.json();

          data = jsonData;
          renderAllCharts();
        } catch (error) {
          console.error('Error loading NCCL multinode bandwidth data:', error);
        }
      }

      // Initialize palette and listen for changes
      refreshPalette();
      document.addEventListener('palettes:updated', refreshPalette);

      // Initialize data by loading from JSON
      loadData();

      const rerender = () => renderAllCharts();
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => rerender());
        ro.observe(container);
      } else {
        window.addEventListener('resize', rerender);
      }
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrapBandwidthComparison), { once: true });
    } else {
      ensureD3(bootstrapBandwidthComparison);
    }
  })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">Bandwidth scaling of collective operations across different number of nodes on our AWS p5 instances, using recommendations from <a href='https://github.com/aws-samples/awsome-distributed-training/blob/main/micro-benchmarks/nccl-tests/slurm/nccl-tests-container.sbatch'>

aws-samples/awsome-distributed-training.</a></figcaption></figure> </div>
<p>Point-to-point send/receive operations achieve around  <strong>42-43 GB/s</strong>  for 2-4 nodes but drop to approximately 21 GB/s for 5+ nodes. This performance degradation occurs because NCCL automatically reduces the number of point-to-point channels per peer from 2 to 1 when scaling beyond 4 nodes, effectively halving the available bandwidth utilization, while theoretical maximum remains ~50 GB/s (4 EFA NICs × 12.5 GB/s each). We successfully managed to restore the full throughput for this test on 5+ nodes by setting  <code>NCCL_NCHANNELS_PER_NET_PEER=2</code> , though this flag should be used with caution as it may degrade all-to-all performance for example (see <a href="https://github.com/NVIDIA/nccl/issues/1272">GitHub issue #1272</a> for details).</p>
<p>The all-reduce operation demonstrates excellent scaling within a single node, achieving  <strong>480 GB/s</strong>  of bus bandwidth. When scaling to 2 nodes, bandwidth remains nearly identical at 479 GB/s, after which it stabilizes at around 320-350 GB/s for 3-16 nodes. This pattern reveals an important characteristic: while there’s an initial drop when crossing node boundaries due to the transition from NVLink to the inter-node network fabric, the bandwidth then scales almost constantly as we add more nodes.</p>
<div class="note note--tip" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>💡</span> <div class="note__title" data-astro-cid-qg6lmfty>Scaling All-Reduce Across Nodes</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p><p>This near-constant scaling behavior beyond 2 nodes is actually quite encouraging for large-scale training. The relatively stable 320-350 GB/s across 3-16 nodes suggests that parallelism strategies relying on all-reduce operations (for example, in data parallelism) can scale to hundreds or even thousands of GPUs without significant per-GPU bandwidth degradation. This logarithmic scaling characteristic is typical of well-designed multi-tier network topologies using 8-rail optimized fat trees, where each of the 8 GPUs connects to a separate switch rail to maximize bisection bandwidth. Modern frontier training clusters routinely operate at 100,000+ GPUs, and this stable scaling behavior is what makes such massive deployments feasible.</p></p><p><p>When working with different bandwidth links (NVLink within nodes vs. inter-node network), consider adapting your parallelism strategy to each bandwidth tier to fully utilize all available bandwidths. See the <a href="[https://huggingface.co/spaces/nanotron/ultrascale-playbook](https://huggingface.co/spaces/nanotron/ultrascale-playbook)">Ultrascale playbook</a> for detailed guidance on optimizing parallelism configurations for heterogeneous network topologies.</p></p> </div> </div> </div> 
<p>The all-to-all operation shows more dramatic scaling challenges: starting at 344 GB/s for a single node, bandwidth drops to 81 GB/s at 2 nodes and continues declining to approximately 45-58 GB/s for larger clusters. This steeper degradation reflects the all-to-all pattern’s intensive network demands, where each GPU must communicate with every other GPU across nodes, creating significantly more network congestion than all-reduce operations.</p>
<p><strong>Latency Analysis</strong></p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-lkvspzm8g9"><div class="nccl-latency-comparison">
  <div class="nccl-latency-comparison__grid">
    <div class="nccl-chart-cell" data-benchmark="sendrecv"
      data-title="NCCL's Sendrecv performance test"></div>
    <div class="nccl-chart-cell" data-benchmark="all_reduce" data-title="NCCL's All-Reduce performance test"></div>
    <div class="nccl-chart-cell" data-benchmark="alltoall"
      data-title="NCCL's Alltoall performance test"></div>
  </div>
  <div class="nccl-latency-comparison__legend"></div>
  <noscript>JavaScript is required to render these charts.</noscript>
</div>
<style>
  .nccl-latency-comparison {
    position: relative;
  }

  .nccl-latency-comparison .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 700;
  }

  .nccl-latency-comparison .axes path,
  .nccl-latency-comparison .axes line {
    stroke: var(--axis-color);
  }

  .nccl-latency-comparison .axes text {
    fill: var(--tick-color);
  }

  .nccl-latency-comparison .grid line {
    stroke: var(--grid-color);
  }

  .nccl-latency-comparison__grid {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }

  @media (max-width: 1100px) {
    .nccl-latency-comparison__grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }

  @media (max-width: 700px) {
    .nccl-latency-comparison__grid {
      grid-template-columns: 1fr;
    }
  }

  .nccl-chart-cell {
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background: var(--page-bg);
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
  }

  .nccl-chart-cell .cell-header {
    min-height: 58px;
    padding: 8px 10px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }

  .nccl-chart-cell .cell-title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
  }

  .nccl-chart-cell .cell-subtitle {
    font-size: 11px;
    color: var(--muted-color);
  }

  .nccl-chart-cell .cell-body {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .nccl-chart-cell .cell-body svg {
    max-width: 100%;
    height: auto;
  }

  .nccl-chart-cell .legend-bottom {
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: 12px;
    color: var(--text-color);
    flex-direction: column;
    gap: 4px;
    margin-top: 8px;
  }

  .nccl-chart-cell .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .nccl-chart-cell .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
  }

  .nccl-chart-cell .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .nccl-chart-cell .legend-bottom .legend-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--muted-color);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .nccl-chart-cell .lines path.active {
    stroke-width: 3;
  }

  .nccl-chart-cell .d3-tooltip {
    z-index: var(--z-elevated);
    backdrop-filter: saturate(1.12) blur(8px);
  }

  .nccl-chart-cell .d3-tooltip__inner {
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-width: 220px;
  }

  .nccl-chart-cell .d3-tooltip__inner>div:first-child {
    font-weight: 800;
    letter-spacing: 0.1px;
    margin-bottom: 0;
  }

  .nccl-chart-cell .d3-tooltip__inner>div:nth-child(2) {
    font-size: 11px;
    color: var(--muted-color);
    display: block;
    margin-top: -4px;
    margin-bottom: 2px;
    letter-spacing: 0.1px;
  }

  .nccl-chart-cell .d3-tooltip__color-dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }

  .nccl-latency-comparison__legend {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .nccl-latency-comparison__legend .legend-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--muted-color);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .nccl-latency-comparison__legend .legend-items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 16px;
  }

  .nccl-latency-comparison__legend .legend-item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
  }

  .nccl-latency-comparison__legend .legend-swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
  }
</style>
<script>
  (() => {
    // Prevent multiple executions
    if (window.ncclLatencyComparisonInitialized) return;
    window.ncclLatencyComparisonInitialized = true;

    // Completely scoped IIFE to avoid variable conflicts
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) { s = document.createElement('script'); s.id = 'd3-cdn-script'; s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js'; document.head.appendChild(s); }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true }); if (window.d3) onReady();
    };

    const bootstrapLatencyComparison = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('nccl-latency-comparison'))) {
        const cs = Array.from(document.querySelectorAll('.nccl-latency-comparison')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      container.dataset.mounted = 'true';
      let data = {};
      let currentColors = [];

      function getColors() {
        return currentColors.length > 0 ? currentColors : [
          '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
          '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
          '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5',
          '#c49c94', '#f7b6d3', '#c7c7c7', '#dbdb8d', '#9edae5'
        ];
      }

      function refreshPalette() {
        try {
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            const colors = window.ColorPalettes.getColors('categorical', 12);
            if (colors && colors.length > 0) {
              currentColors = colors;
              // Re-render with new colors
              if (Object.keys(data).length > 0) {
                renderAllCharts();
              }
            }
          }
        } catch (e) {
          console.warn('ColorPalettes not available:', e);
        }
      }

      function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
      }

      function formatLatency(latency) {
        if (latency < 1000) {
          return Math.round(latency) + ' μs';
        } else if (latency < 1000000) {
          return (latency / 1000).toFixed(1) + ' ms';
        } else {
          return (latency / 1000000).toFixed(1) + ' s';
        }
      }

      function createChart(cell, benchmark) {
        // Create tooltip if it doesn't exist
        let tip = cell.querySelector('.d3-tooltip');
        let tipInner = cell.querySelector('.d3-tooltip__inner');
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'd3-tooltip';
          tip.style.cssText = 'position:absolute;pointer-events:none;opacity:0;transform:translate(-9999px,-9999px);background:var(--surface-bg);border:1px solid var(--border-color);border-radius:6px;padding:8px 12px;font-size:12px;box-shadow:0 4px 12px rgba(0,0,0,0.15);backdrop-filter:blur(8px);';
          tipInner = document.createElement('div');
          tipInner.className = 'd3-tooltip__inner';
          tip.appendChild(tipInner);
          cell.appendChild(tip);
        }

        // Create header if it doesn't exist
        let header = cell.querySelector('.cell-header');
        if (!header) {
          header = document.createElement('div');
          header.className = 'cell-header';
          const title = document.createElement('div');
          title.className = 'cell-title';
          title.textContent = cell.dataset.title;
          header.appendChild(title);
          cell.appendChild(header);
        }

        // Create body if it doesn't exist
        let body = cell.querySelector('.cell-body');
        if (!body) {
          body = document.createElement('div');
          body.className = 'cell-body';
          cell.appendChild(body);
        }

        // SVG - create only if it doesn't exist
        let svg = d3.select(body).select('svg');
        let gRoot, gGrid, gAxes, gLines;

        if (svg.empty()) {
          svg = d3.select(body).append('svg').attr('width', '100%').style('display', 'block');
          gRoot = svg.append('g');
          gGrid = gRoot.append('g').attr('class', 'grid');
          gAxes = gRoot.append('g').attr('class', 'axes');
          gLines = gRoot.append('g').attr('class', 'lines');
        } else {
          gRoot = svg.select('g');
          gGrid = gRoot.select('.grid');
          gAxes = gRoot.select('.axes');
          gLines = gRoot.select('.lines');
        }

        // State
        let width = 400, height = 250;
        const margin = { top: 16, right: 32, bottom: 70, left: 80 };
        const xScale = d3.scaleLog();
        const yScale = d3.scaleLog();
        const lineGen = d3.line().x(d => xScale(d.messageSize)).y(d => yScale(d.latency));

        function updateLayout() {
          const axisColor = getComputedStyle(cell).getPropertyValue('--axis-color').trim() || 'rgba(0,0,0,0.25)';
          width = cell.clientWidth || 400;
          height = Math.max(250, Math.round(width * 0.65));
          svg.attr('width', width).attr('height', height);
          gRoot.attr('transform', `translate(${margin.left},${margin.top})`);
          const innerWidth = width - margin.left - margin.right;
          const innerHeight = height - margin.top - margin.bottom;
          return { innerWidth, innerHeight };
        }

        function render() {
          console.log('Rendering chart for benchmark:', benchmark, 'Data:', data[benchmark]);
          if (!data[benchmark]) {
            console.log('No data for benchmark:', benchmark);
            return;
          }

          const { innerWidth, innerHeight } = updateLayout();

          // Prepare series data - one line per node count
          const series = [];
          const colors = getColors();

          Object.keys(data[benchmark]).forEach(nodeKey => {
            const nodeData = data[benchmark][nodeKey];
            if (nodeData && nodeData.length > 0) {
              const nodeCount = parseInt(nodeKey.replace('nodes_', ''));
              series.push({
                name: `${nodeCount} nodes`,
                nodeCount: nodeCount,
                values: nodeData.map(d => ({ messageSize: d.messageSize, latency: d.latency })),
                color: colors[(nodeCount - 1) % colors.length]
              });
            }
          });

          if (series.length === 0) return;

          // Sort by node count
          series.sort((a, b) => a.nodeCount - b.nodeCount);

          // Get all data points for domain calculation
          const allData = series.flatMap(s => s.values);
          const sortedData = allData.slice().sort((a, b) => a.messageSize - b.messageSize);

          // domains
          const minSize = d3.min(sortedData, d => d.messageSize);
          const maxSize = d3.max(sortedData, d => d.messageSize);
          const minLatency = d3.min(sortedData, d => d.latency);
          const maxLatency = d3.max(sortedData, d => d.latency);

          // Set Y domain based on benchmark with individual caps
          let yMax;
          if (benchmark === 'alltoall') {
            yMax = 200000; // 200ms
          } else if (benchmark === 'all_reduce') {
            yMax = 60000; // 60ms
          } else if (benchmark === 'sendrecv') {
            yMax = 500000; // 500ms
          } else {
            yMax = maxLatency * 1.1;
          }

          xScale.domain([minSize, maxSize]).range([0, innerWidth]);
          yScale.domain([minLatency, yMax]).range([innerHeight, 0]);

          // grid - horizontal lines for Y ticks
          gGrid.selectAll('*').remove();
          const gridBaseTicks = [50, 100, 200, 500, 1000];
          const gridExtendedTicks = [10, 20, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000];
          const allGridTicks = [...gridBaseTicks, ...gridExtendedTicks];
          const gridTicks = allGridTicks.filter(tick => tick >= minLatency && tick <= yMax);

          gGrid.selectAll('line').data(gridTicks).join('line')
            .attr('x1', 0).attr('x2', innerWidth).attr('y1', d => yScale(d)).attr('y2', d => yScale(d))
            .attr('stroke', 'var(--grid-color)').attr('stroke-width', 1).attr('shape-rendering', 'crispEdges');

          // axes
          gAxes.selectAll('*').remove();

          // Create custom ticks for X axis (powers of 2, every 4th tick)
          const xTicks = [8, 128, 2048, 32768, 524288, 8388608, 134217728, 2147483648, 8589934592];
          const filteredXTicks = xTicks.filter(tick => tick >= minSize && tick <= maxSize);

          gAxes.append('g').attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale).tickValues(filteredXTicks).tickFormat(formatBytes))
            .call(g => {
              g.selectAll('path, line').attr('stroke', 'var(--axis-color)');
              g.selectAll('text').attr('fill', 'var(--tick-color)').style('font-size', '11px').attr('transform', 'rotate(-45)').style('text-anchor', 'end');
            });

          // Create custom ticks for Y axis: base range + extended range
          const baseTicks = [50, 100, 200, 500, 1000]; // 50μs, 100μs, 200μs, 500μs, 1ms
          const extendedTicks = [10, 20, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000]; // Extended range
          const yTicks = [...baseTicks, ...extendedTicks];
          const filteredYTicks = yTicks.filter(tick => tick >= minLatency && tick <= yMax);

          gAxes.append('g')
            .call(d3.axisLeft(yScale).tickValues(filteredYTicks).tickFormat(formatLatency))
            .call(g => {
              g.selectAll('path, line').attr('stroke', 'var(--axis-color)');
              g.selectAll('text').attr('fill', 'var(--tick-color)').style('font-size', '11px');
            });

          // axis labels
          gAxes.selectAll('.axis-label').remove();
          gAxes.append('text').attr('class', 'axis-label').attr('transform', 'rotate(-90)').attr('y', 0 - margin.left).attr('x', 0 - (innerHeight / 2)).attr('dy', '1em').style('text-anchor', 'middle').text('Latency (μs)');
          gAxes.append('text').attr('class', 'axis-label').attr('text-anchor', 'middle').attr('x', innerWidth / 2).attr('y', innerHeight + 45).text('Message Size (bytes)');

          // lines
          gLines.selectAll('*').remove();
          gLines.selectAll('path').data(series).join('path')
            .attr('d', d => lineGen(d.values))
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('stroke-linecap', 'round')
            .attr('stroke-linejoin', 'round');

          // Point markers removed - no longer needed

        }

        return { render };
      }

      function renderAllCharts() {
        const cells = container.querySelectorAll('.nccl-chart-cell');
        cells.forEach(cell => {
          const benchmark = cell.dataset.benchmark;

          // Check if chart is already initialized
          if (!cell.dataset.chartInitialized) {
            const chart = createChart(cell, benchmark);
            cell.chartInstance = chart;
            cell.dataset.chartInitialized = 'true';
          }

          // Render the existing chart
          if (cell.chartInstance) {
            cell.chartInstance.render();
          }
        });

        // Render common legend
        renderCommonLegend();
      }

      function renderCommonLegend() {
        const legendContainer = container.querySelector('.nccl-latency-comparison__legend');
        if (!legendContainer || !data) return;

        // Collect all unique node counts from all benchmarks
        const nodeCounts = new Set();
        Object.keys(data).forEach(benchmark => {
          Object.keys(data[benchmark]).forEach(nodeKey => {
            // nodeKey format is "nodes_X" where X is the node count
            const nodeCount = parseInt(nodeKey.replace('nodes_', ''));
            if (!isNaN(nodeCount)) {
              nodeCounts.add(nodeCount);
            }
          });
        });

        // Sort node counts
        const sortedNodeCounts = Array.from(nodeCounts).sort((a, b) => a - b);

        // Get colors
        const colors = getColors();

        // Create legend with individual colored lines
        const legendWidth = Math.min(container.clientWidth * 0.8, 600);
        const legendHeight = 30;
        const lineHeight = 5; // Height of each colored line
        const lineY = 0; // Y position of the lines

        // Calculate spacing between items
        const numItems = sortedNodeCounts.length;
        const itemWidth = legendWidth / numItems;

        legendContainer.innerHTML = `
        <div style="font-size: 12px; font-weight: 600; color: var(--text-color); margin-bottom: 12px;">Number of Nodes</div>
        <svg width="${legendWidth}" height="${legendHeight}" style="display: block; overflow:visible!important;">
          <!-- Individual colored lines and labels -->
          ${sortedNodeCounts.map((nodeCount, i) => {
          const x = (i + 0.5) * itemWidth;
          const lineWidth = itemWidth * 0.5; // 50% of available space for each line
          const lineX = i * itemWidth + (itemWidth - lineWidth) / 2;
          const label = nodeCount === 1 ? '1' : `${nodeCount}`;
          const color = colors[(nodeCount - 1) % colors.length];

          return `
              <!-- Colored line -->
              <line x1="${lineX}" y1="${lineY}" x2="${lineX + lineWidth}" y2="${lineY}" 
                    stroke="${color}" stroke-width="${lineHeight}" stroke-linecap="round" />
              
              <!-- Label -->
              <text x="${x}" y="${lineY + 20}" 
                    text-anchor="middle" 
                    font-size="11px" 
                    font-weight="600"
                    fill="var(--text-color)">${label}</text>
            `;
        }).join('')}
        </svg>
      `;
      }

      // Load real data from JSON
      async function loadData() {
        try {
          console.log('Loading NCCL latency data...');
          const response = await fetch('./data/nccl-multinode-latency.json');
          const jsonData = await response.json();

          console.log('Loaded data:', jsonData);
          data = jsonData;
          renderAllCharts();
        } catch (error) {
          console.error('Error loading NCCL multinode latency data:', error);
        }
      }

      // Initialize palette and listen for changes
      refreshPalette();
      document.addEventListener('palettes:updated', refreshPalette);

      // Initialize data by loading from JSON
      loadData();

      const rerender = () => renderAllCharts();
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => rerender());
        ro.observe(container);
      } else {
        window.addEventListener('resize', rerender);
      }
    };

    ensureD3(bootstrapLatencyComparison);
  })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">Latency scaling of collective operations across different number of nodes on our AWS p5 instances, using recommendations from <a href='https://github.com/aws-samples/awsome-distributed-training/blob/main/micro-benchmarks/nccl-tests/slurm/nccl-tests-container.sbatch'>

[aws-samples/awsome-distributed-training](https://github.com/aws-samples/awsome-distributed-training/blob/main/micro-benchmarks/nccl-tests/slurm/nccl-tests-container.sbatch)</a>.</figcaption></figure> </div>
<p>Latency measurements reveal the fundamental cost of crossing node boundaries. Send/receive operations maintain relatively stable latencies of 40-53 μs across all multi-node configurations, demonstrating that point-to-point communication latency is primarily determined by the base network round-trip time rather than cluster size, though some variation suggests network topology and routing effects still play a role.</p>
<p>All-reduce operations show minimal latency of 12.9 μs within a single node, but this jumps to 55.5 μs for 2 nodes and continues increasing nearly linearly with cluster size, reaching 235 μs at 16 nodes. This progression reflects both the increased communication distance and the growing complexity of the reduction tree across more nodes.</p>
<p>All-to-all operations exhibit similar trends, starting at 7.6 μs for single-node communication but climbing to 60 μs at 2 nodes and reaching 621 μs at 16 nodes. The superlinear growth in latency for all-to-all operations indicates that network congestion and coordination overhead compound as more nodes participate in the collective.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>🚀</span> <div class="note__title" data-astro-cid-qg6lmfty>NVSHMEM for Optimized GPU Communication</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p><p>With the rise of Mixture of Experts (MoE) architectures, which require frequent all-to-all communication patterns for expert routing, optimized GPU communication libraries have become increasingly critical.</p></p><p><p><a href="https://developer.nvidia.com/nvshmem" target="_blank">NVSHMEM</a> is gaining significant traction as a high-performance communication library that combines the memory of multiple GPUs into a partitioned global address space (PGAS). Unlike traditional MPI-based approaches that rely on CPU-orchestrated data transfers, NVSHMEM enables asynchronous, GPU-initiated operations that eliminate CPU-GPU synchronization overhead.</p></p><p><p>NVSHMEM offers several key advantages for GPU communication: Through technologies like GPUDirect Async, GPUs can bypass the CPU entirely when issuing internode communication, achieving up to 9.5x higher throughput for small messages (&lt;1 KiB). This is particularly beneficial for collective operations that require intensive network communication patterns.</p></p><p><p>The library currently supports InfiniBand/RoCE with Mellanox adapters (CX-4 or later), Slingshot-11 (Libfabric CXI), and Amazon EFA (Libfabric EFA). For applications requiring strong scaling with fine-grain communication, NVSHMEM’s low-overhead, one-sided communication primitives can significantly improve performance compared to traditional CPU-proxy methods.</p></p><p><p>Learn more in the <a href="https://developer.nvidia.com/nvshmem" target="_blank">NVSHMEM documentation</a> and this detailed <a href="https://developer.nvidia.com/blog/improving-network-performance-of-hpc-systems-using-nvidia-magnum-io-nvshmem-and-gpudirect-async/" target="_blank">blog post on GPUDirect Async</a>.</p></p> </div> </div> </div> 
<p>When bandwidth measurements fall short of expectations, several factors could be limiting performance. Understanding these potential bottlenecks is essential for achieving optimal interconnect utilization.</p>
<h4 id="troubleshooting-interconnect"><a href="#troubleshooting-interconnect">Troubleshooting Interconnect</a></h4>
<p>If you’re experiencing lower than expected bandwidth, systematically check the following areas:</p>
<p><strong>Library Versions</strong></p>
<p>Outdated NCCL, EFA, or CUDA libraries may lack critical performance optimizations or bug fixes. Always verify you’re running recent, compatible versions of all communication libraries. e.g. AWS regularly updates their Deep Learning AMIs with optimized library versions for their hardware. It’s also recommended to log these library versions for important experiments.</p>
<p><strong>CPU Affinity Configuration</strong></p>
<p>Improper CPU affinity settings can significantly impact NCCL performance by causing unnecessary cross-NUMA traffic. Each GPU should be bound to CPUs on the same NUMA node to minimize memory access latency. In practice, <a href="https://github.com/NVIDIA/nccl/issues/1017#issuecomment-1751385723">this Github issue</a> demonstrates how using  <code>NCCL_IGNORE_CPU_AFFINITY=1</code>  and  <code>--cpu-bind none</code>  helped reduce container latency significantly. <a href="https://enterprise-support.nvidia.com/s/article/understanding-numa-node-for-performance-benchmarks#Mapping-between-PCI-device-driver-port-and-NUMA">You can read more about it here.</a></p>
<p><strong>Network Topology and Placement</strong></p>
<p>Understanding your network topology is crucial for diagnosing performance issues. Cloud placement groups, while helpful, don’t guarantee minimal network hops between instances. In modern datacenter fat-tree topologies, instances placed under different top-level switches will experience higher latency and potentially lower bandwidth due to additional network hops in the routing path.</p>
<p>For AWS EC2 users, the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-ec2-instance-topology-works.html">Instance Topology API</a> provides valuable visibility into network node placement. Instances sharing t”he same network node at the bottom layer (directly connected to the instance) are physically closest and will achieve the lowest latency communication.</p>
<div class="full-width"> <div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <pre class="mermaid">graph TD
    %% Single Level 1 node
    L1[&quot;Level 1<br/>nn-4aed5...&quot;]:::level1

    %% Single Level 2 node
    L2[&quot;Level 2<br/>nn-48b0a...&quot;]:::level2

    %% 12 nodes of Level 3
    L3_1[&quot;Level 3<br/>nn-d2ad4...&quot;]:::level3
    L3_2[&quot;Level 3<br/>nn-2d36a...&quot;]:::level3
    L3_3[&quot;Level 3<br/>nn-65fc9...&quot;]:::level3
    L3_4[&quot;Level 3<br/>nn-fbb73...&quot;]:::level3
    L3_5[&quot;Level 3<br/>nn-65290...&quot;]:::level3
    L3_6[&quot;Level 3<br/>nn-27373...&quot;]:::level3
    L3_7[&quot;Level 3<br/>nn-5adeb...&quot;]:::level3
    L3_8[&quot;Level 3<br/>nn-dbe4f...&quot;]:::level3
    L3_9[&quot;Level 3<br/>nn-fde84...&quot;]:::level3
    L3_10[&quot;Level 3<br/>nn-3c5c0...&quot;]:::level3
    L3_11[&quot;Level 3<br/>nn-94247...&quot;]:::level3
    L3_12[&quot;Level 3<br/>nn-8f3c1...&quot;]:::level3

    %% L1 -&gt; L2
    L1 --&gt; L2

    %% L2 -&gt; L3 (12 arrows)
    L2 --&gt; L3_1
    L2 --&gt; L3_2
    L2 --&gt; L3_3
    L2 --&gt; L3_4
    L2 --&gt; L3_5
    L2 --&gt; L3_6
    L2 --&gt; L3_7
    L2 --&gt; L3_8
    L2 --&gt; L3_9
    L2 --&gt; L3_10
    L2 --&gt; L3_11
    L2 --&gt; L3_12

    %% Distribution Level 3 -&gt; Leaf nodes (instance info)
    %% 1st Level 3 has 2 leaves
    L3_1 --&gt; L4_1[&quot;ID: 02e1b4f9<br/>ip-26-0-171-102<br/>p5.48xlarge&quot;]:::level4
    L3_1 --&gt; L4_2[&quot;ID: 05388ebf<br/>ip-26-0-171-230<br/>p5.48xlarge&quot;]:::level4

    %% 2nd, 3rd, 4th have 1 each
    L3_2 --&gt; L4_3[&quot;ID: 03bfac00<br/>ip-26-0-168-30<br/>p5.48xlarge&quot;]:::level4
    L3_3 --&gt; L4_4[&quot;ID: d92bab46<br/>ip-26-0-168-95<br/>p5.48xlarge&quot;]:::level4
    L3_4 --&gt; L4_5[&quot;ID: 97a542e4<br/>ip-26-0-163-158<br/>p5.48xlarge&quot;]:::level4

    %% 5th has 3
    L3_5 --&gt; L4_6[&quot;ID: e2c87e43<br/>ip-26-0-167-9<br/>p5.48xlarge&quot;]:::level4
    L3_5 --&gt; L4_7[&quot;ID: afa887ea<br/>ip-26-0-168-120<br/>p5.48xlarge&quot;]:::level4
    L3_5 --&gt; L4_8[&quot;ID: 66c12e70<br/>ip-26-0-167-177<br/>p5.48xlarge&quot;]:::level4

    %% 6th, 7th, 8th have 1 each
    L3_6 --&gt; L4_9[&quot;ID: 9412bdf3<br/>ip-26-0-168-52<br/>p5.48xlarge&quot;]:::level4
    L3_7 --&gt; L4_10[&quot;ID: 87bd4dc8<br/>ip-26-0-167-111<br/>p5.48xlarge&quot;]:::level4
    L3_8 --&gt; L4_11[&quot;ID: b001549b<br/>ip-26-0-166-244<br/>p5.48xlarge&quot;]:::level4

    %% 9th has 2
    L3_9 --&gt; L4_12[&quot;ID: 10ed8172<br/>ip-26-0-107-245<br/>p5.48xlarge&quot;]:::level4
    L3_9 --&gt; L4_13[&quot;ID: 7c1d0a09<br/>ip-26-0-168-238<br/>p5.48xlarge&quot;]:::level4

    %% 10th, 11th, 12th have 1 each
    L3_10 --&gt; L4_14[&quot;ID: 925ce932<br/>ip-26-0-167-217<br/>p5.48xlarge&quot;]:::level4
    L3_11 --&gt; L4_15[&quot;ID: c9bc34db<br/>ip-26-0-171-168<br/>p5.48xlarge&quot;]:::level4
    L3_12 --&gt; L4_16[&quot;ID: 328d5d04<br/>ip-26-0-167-127<br/>p5.48xlarge&quot;]:::level4

    %% Styles
    classDef level1 fill:#c8e6c9
    classDef level2 fill:#e1f5fe
    classDef level3 fill:#fff9c4
    classDef level4 fill:#ffcdd2</pre> </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Network topology visualization showing instance placement. Minimizing hops between nodes improves interconnect performance, particularly for smaller cluster configurations.</figcaption> </figure> </div>  </div>
<p>Minimizing network hops between communicating nodes directly translates to better interconnect performance. For small-scale experiments and ablations, ensuring your instances are co-located on the same network switch can make a measurable difference in both latency and bandwidth utilization.</p>
<p><strong>Correct Environment Variables</strong></p>
<p>Missing or incorrect environment variables for your network adapter can severely limit bandwidth utilization. Communication libraries like NCCL rely on specific configuration flags to enable optimal performance features such as adaptive routing, GPU-initiated transfers, and proper buffer sizing.</p>
<p>For example, when using AWS EFA (Elastic Fabric Adapter), ensure you’re setting the recommended NCCL and EFA environment variables for your instance type. The <a href="https://github.com/aws-samples/awsome-distributed-training/blob/main/1.architectures/efa-cheatsheet.md">AWS EFA cheatsheet</a> provides comprehensive guidance on optimal flag configurations for different scenarios.</p>
<p><strong>Container-specific Considerations</strong></p>
<p>When using containers (Docker/Enroot), several configuration steps are critical for optimal NCCL performance:</p>
<ul>
<li><strong>Shared and Pinned Memory</strong> : Docker containers default to limited shared and pinned memory resources. Launch containers with  <code>-shm-size=1g --ulimit memlock=-1</code>  to prevent initialization failures.</li>
<li><strong>NUMA Support</strong> : Docker disables NUMA support by default, which can prevent cuMem host allocations from working correctly. Enable NUMA support by invoking Docker with  <code>-cap-add SYS_NICE</code> .</li>
<li><strong>PCI Topology Discovery</strong> : Ensure  <code>/sys</code>  is properly mounted to allow NCCL to discover the PCI topology of GPUs and network cards. Having  <code>/sys</code>  expose a virtual PCI topology can result in sub-optimal performance.</li>
</ul>
<div class="note note--tip" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>🤗</span> <div class="note__title" data-astro-cid-qg6lmfty>Community Troubleshooting</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>We’re gathering troubleshooting findings here as a community effort. If you’ve encountered performance issues or discovered effective debugging methods, please jump to the Discussion Tab and share your experience to help others optimize their interconnect utilization.</p> </div> </div> </div> 
<p>Now that you know how to debug bottlenecks in GPU-CPU and GPU-GPU communication let’s have a look at a GPU communication part that typically gets less attention, namely communication with the storage layer!</p>
<h4 id="gpu-to-storage"><a href="#gpu-to-storage">GPU-to-Storage</a></h4>
<p>The connection between GPUs and storage systems is often overlooked but can significantly impact training efficiency. During training, GPUs need to continuously read data from storage (data loading, especially for multimodal data with large image/video files) and periodically write model states back to storage (aka checkpointing). For modern large-scale training runs, these I/O operations can become bottlenecks if not properly optimized.</p>
<div class="note note--neutral" data-astro-cid-qg6lmfty> <!-- When there's no title, emoji is above content -->
    <div class="note__layout" data-astro-cid-qg6lmfty>  <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__content" data-astro-cid-qg6lmfty> <p><b>TL;DR:</b> GPU-storage I/O impacts training through data loading and checkpointing. GPUDirect Storage (GDS) enables direct GPU-to-storage transfers, bypassing CPU for better performance. Even without GDS enabled in our cluster, local NVMe RAID (8×3.5TB drives in RAID 0) delivers 26.59 GiB/s and 337K IOPS (6.3x faster than network storage), making it ideal for checkpoints.</p> </div> </div> </div> </div> 
<p><strong>Understanding Storage Topology</strong></p>
<p>The physical connection between GPUs and storage devices follows a similar hierarchical structure to GPU interconnects. Storage devices connect through PCIe bridges, and understanding this topology helps explain performance characteristics and potential bottlenecks.</p>
<p>Looking at the system topology from  <code>lstopo</code> , we can see how NVMe drives connect to the system. In our p5 instance, we have 1 NVMe SSD per GPU:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>PCIBridge L#13 (busid=0000:46:01.5 id=1d0f:0200 class=0604(PCIBridge) link=15.75GB/s buses=0000:[54-54] PCIVendor=&quot;Amazon.com, Inc.&quot;)</span></span>
<span class="line"><span>PCI L#11 (busid=0000:54:00.0 id=1d0f:cd01 class=0108(NVMExp) link=15.75GB/s PCISlot=87-1 PCIVendor=&quot;Amazon.com, Inc.&quot; PCIDevice=&quot;NVMe SSD Controller&quot;)</span></span>
<span class="line"><span>    Block(Disk) L#9 (Size=3710937500 SectorSize=512 LinuxDeviceID=259:2 Model=&quot;Amazon EC2 NVMe Instance Storage&quot; Revision=0 SerialNumber=AWS110C9F44F9A530351) &quot;nvme1n1&quot;</span></span>
<span class="line"><span></span></span></code></pre></div>
<p>A natural question would be whether GPUs can directly access NVMe drives without involving the CPU. The answer is yes, through  <strong>GPUDirect Storage (GDS)</strong> .</p>
<p><strong>GPUDirect Storage</strong>  is part of NVIDIA’s <a href="https://developer.nvidia.com/gpudirect">GPUDirect</a> family of technologies that enables a direct data path between storage (local NVMe or remote NVMe-oF) and GPU memory. It eliminates unnecessary memory copies through CPU bounce buffers by allowing the DMA engine near the storage controller to move data directly into or out of GPU memory. This reduces CPU overhead, decreases latency, and significantly improves I/O performance for data-intensive workloads like training on large multimodal datasets.</p>
<p>To verify if GPUDirect Storage is properly configured on your system, you can check the GDS configuration file and use the provided diagnostic tools:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>$ /usr/local/cuda/gds/tools/gdscheck.py -p</span></span>
<span class="line"><span> =====================</span></span>
<span class="line"><span> DRIVER CONFIGURATION:</span></span>
<span class="line"><span> =====================</span></span>
<span class="line"><span> NVMe               : Supported   </span></span>
<span class="line"><span> NVMeOF             : Unsupported</span></span>
<span class="line"><span> SCSI               : Unsupported</span></span>
<span class="line"><span> ScaleFlux CSD      : Unsupported</span></span>
<span class="line"><span> NVMesh             : Unsupported</span></span>
<span class="line"><span> DDN EXAScaler      : Unsupported</span></span>
<span class="line"><span> IBM Spectrum Scale : Unsupported</span></span>
<span class="line"><span> NFS                : Unsupported</span></span>
<span class="line"><span> BeeGFS             : Unsupported</span></span>
<span class="line"><span> WekaFS             : Unsupported</span></span>
<span class="line"><span> Userspace RDMA     : Unsupported</span></span>
<span class="line"><span> --Mellanox PeerDirect : Enabled</span></span>
<span class="line"><span> --rdma library        : Not Loaded (libcufile_rdma.so)</span></span>
<span class="line"><span> --rdma devices        : Not configured</span></span>
<span class="line"><span> --rdma_device_status  : Up: 0 Down: 0</span></span>
<span class="line"><span> =====================</span></span>
<span class="line"><span></span></span></code></pre></div>
<p>We see  <code>NVMe: Supported</code>  which informs that GDS is currently configured to work for NVMe drives, and all other storage types are not properly configured as apparent from the Unsupported flag. If GDS is not properly configured for your storage type, refer to the <a href="https://docs.nvidia.com/gpudirect-storage/configuration-guide/index.html">NVIDIA GPUDirect Storage Configuration Guide</a> for instructions on modifying the configuration file at  <code>/etc/cufile.json</code> .</p>
<p><strong>Block Storage Devices</strong></p>
<p>To understand the storage devices available on your system, you can use  <code>lsblk</code>  to display the block device hierarchy:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>$ lsblk --fs -M</span></span>
<span class="line"><span>    NAME        FSTYPE            LABEL                   UUID                                 FSAVAIL FSUSE% MOUNTPOINT</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>    nvme0n1</span></span>
<span class="line"><span>    └─nvme0n1p1 ext4              cloudimg-rootfs         24ec7991-cb5c-4fab-99e5-52c45690ba30  189.7G    35% /</span></span>
<span class="line"><span>┌┈▶ nvme1n1     linux_raid_member ip-26-0-164-236:MY_RAID d0795631-71f0-37e5-133b-e748befec126</span></span>
<span class="line"><span>├┈▶ nvme2n1     linux_raid_member ip-26-0-164-236:MY_RAID d0795631-71f0-37e5-133b-e748befec126</span></span>
<span class="line"><span>├┈▶ nvme3n1     linux_raid_member ip-26-0-164-236:MY_RAID d0795631-71f0-37e5-133b-e748befec126</span></span>
<span class="line"><span>├┈▶ nvme8n1     linux_raid_member ip-26-0-164-236:MY_RAID d0795631-71f0-37e5-133b-e748befec126</span></span>
<span class="line"><span>├┈▶ nvme5n1     linux_raid_member ip-26-0-164-236:MY_RAID d0795631-71f0-37e5-133b-e748befec126</span></span>
<span class="line"><span>├┈▶ nvme4n1     linux_raid_member ip-26-0-164-236:MY_RAID d0795631-71f0-37e5-133b-e748befec126</span></span>
<span class="line"><span>├┈▶ nvme6n1     linux_raid_member ip-26-0-164-236:MY_RAID d0795631-71f0-37e5-133b-e748befec126</span></span>
<span class="line"><span>└┬▶ nvme7n1     linux_raid_member ip-26-0-164-236:MY_RAID d0795631-71f0-37e5-133b-e748befec126</span></span>
<span class="line"><span> └┈┈md0         xfs                                       dddb6849-e5b5-4828-9034-96da65da27f0   27.5T     1% /scratch</span></span>
<span class="line"><span></span></span></code></pre></div>
<p>This output shows the block device hierarchy on the system. The key observations:</p>
<ul>
<li><code>nvme0n1p1</code>  is the root filesystem mounted at  <code>/</code> , using 35% of its ~190GB capacity</li>
<li>Eight NVMe drives ( <code>nvme1n1</code>  through  <code>nvme8n1</code> ) are configured as a RAID array named  <code>MY_RAID</code></li>
<li>The RAID array is exposed as  <code>/dev/md0</code> , formatted with XFS, and mounted at  <code>/scratch</code>  with 28TB available (8x3.5TB)</li>
</ul>
<p>The arrows (┈▶) indicate that multiple NVMe devices are members of the same RAID array, which then combines into the single  <code>md0</code>  device.</p>
<p><strong>Network Storage</strong></p>
<p>In addition to local NVMe storage, the system has access to network-attached storage systems:</p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>$ df -h</span></span>
<span class="line"><span>Filesystem                                         Size  Used Avail Use% Mounted on</span></span>
<span class="line"><span>/dev/root                                          291G  101G  190G  35% /</span></span>
<span class="line"><span>weka-hopper.hpc.internal.huggingface.tech/default  393T  263T  131T  67% /fsx</span></span>
<span class="line"><span>10.53.83.155@tcp:/fg7ntbev                         4.5T  2.9T  1.7T  63% /admin</span></span>
<span class="line"><span>/dev/md0                                            28T  206G   28T   1% /scratch</span></span>
<span class="line"><span></span></span></code></pre></div>
<p>This output shows:</p>
<ul>
<li><code>/dev/root</code>  (291GB) is the root filesystem at 35% capacity</li>
<li><code>/fsx</code>  (393TB WekaFS) is 67% full with 131TB available</li>
<li><code>/admin</code>  (4.5TB Lustre) is 63% full with 1.7TB available</li>
<li><code>/dev/md0</code>  (28TB local RAID) is only 1% full with 28TB available at  <code>/scratch</code> . This is our 8×3.5TB NVMe instance store drives in RAID.</li>
</ul>
<p>The local NVMe RAID array ( <code>/scratch</code> ) provides the fastest I/O performance, while the network filesystems offer larger capacity for shared data storage.</p>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>💾</span> <div class="note__title" data-astro-cid-qg6lmfty>Storage Technologies</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p><p><b>RAID (Redundant Array of Independent Disks)</b>: Combines multiple drives
to improve performance and/or reliability through data striping, parity, or
mirroring.</p></p><p><p><b>NVMe (Non-Volatile Memory Express)</b>: High-performance storage protocol
for SSDs that connects directly to PCIe, delivering higher throughput and
lower latency than SATA/SAS.</p></p><p><p><b>WekaFS</b>: A high-performance parallel file system designed for AI/ML
workloads, providing low-latency access and high throughput across multiple
nodes.</p></p><p><p><b>Lustre</b>: A parallel file system designed for HPC that separates
metadata and data services across different servers to enable parallel
access. While effective for large files, it can struggle with
metadata-intensive AI/ML workloads involving many small files.</p></p> </div> </div> </div> 
<p><strong>Benchmarking Storage Bandwidth</strong></p>
<p>To understand the performance characteristics of each storage system, we can benchmark their read/write speeds using GPUDirect Storage (GDS). Here’s a comprehensive parametric benchmark script that tests various configurations:</p>
<div class="code-card no-copy"><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>gdsio -f /&lt;disk_path&gt;/gds_test.dat -d 0 -w &lt;n_threads&gt; -s 10G -i &lt;io_size&gt; -x 1 -I 1 -T 10</span></span>
<span class="line"><span></span></span></code></pre></div>
<p>The benchmark evaluates storage system performance across Throughput, Latency, IOPS but also:</p>
<p><strong>Scalability</strong> : How performance changes with different thread counts and I/O sizes. This reveals optimal configurations for different workload patterns:</p>
<ul>
<li>Small I/O sizes (64K to 256K) typically maximize IOPS but may not saturate bandwidth</li>
<li>Large I/O sizes (2M to 8M) typically maximize throughput but reduce IOPS</li>
<li>Thread count affects both: more threads can increase total IOPS and throughput up to hardware limits</li>
</ul>
<p><strong>Transfer Method Efficiency</strong> : Comparing GPU_DIRECT vs CPU_GPU vs CPUONLY shows the benefit of bypassing CPU memory:</p>
<ul>
<li><strong>GPU_DIRECT</strong> : Uses RDMA to transfer data directly to GPU memory, bypassing CPU entirely (lowest latency, highest efficiency, best IOPS for small operations)</li>
<li><strong>CPU_GPU</strong> : Traditional path where data goes to CPU memory first, then copied to GPU (adds CPU overhead and memory bandwidth contention, reduces effective IOPS)</li>
<li><strong>CPUONLY</strong> : Baseline CPU-only I/O without GPU involvement</li>
</ul>
<div class="note note--info" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>📊</span> <div class="note__title" data-astro-cid-qg6lmfty>IOPS (I/O Operations Per Second)</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p><p>IOPS is the number of individual I/O operations completed per second.
Calculated as <code>ops / total_time</code> from the gdsio output. IOPS is
particularly important for:</p></p><ul><li>Random access patterns with small I/O sizes</li><li>Workloads with many small files or scattered data access</li><li><p>Database-like operations where latency per operation matters more than raw
bandwidth</p></li><li><p>Higher IOPS indicates better ability to handle concurrent, fine-grained
data access</p></li></ul> </div> </div> </div> 
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-nlzcw4rh13q"><div class="gds-interactive-heatmaps"></div>
<style>
  .gds-interactive-heatmaps {
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .gds-interactive-heatmaps .controls {
    display: flex;
    gap: 20px;
    margin-top: 20px;
    align-items: center;
    flex-wrap: wrap;
  }

  .gds-interactive-heatmaps .control-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  .gds-interactive-heatmaps .control-label {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-color);
  }

  .gds-interactive-heatmaps select {
    min-width: 160px;
  }

  .gds-interactive-heatmaps .grid-2x2 {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 16px;
    min-height: 600px;
  }

  .gds-interactive-heatmaps .heatmap-panel {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 12px;
    position: relative;
    min-height: 280px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .gds-interactive-heatmaps .panel-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-color);
    margin-bottom: 8px;
    text-align: center;
  }

  .gds-interactive-heatmaps .axis-label {
    fill: var(--text-color);
    font-size: 11px;
    font-weight: 600;
  }

  .gds-interactive-heatmaps .cell-border {
    stroke: var(--border-color);
    stroke-width: 1px;
    fill: none;
  }

  .gds-interactive-heatmaps .cell-text {
    fill: var(--muted-color);
    font-size: 9px;
    pointer-events: none;
  }

  .gds-interactive-heatmaps .colorbar {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    width: 16px;
    height: 120px;
  }

  .gds-interactive-heatmaps .colorbar-gradient {
    width: 100%;
    height: 100%;
    border-radius: 3px;
  }

  .gds-interactive-heatmaps .colorbar-labels {
    position: absolute;
    right: 22px;
    top: 0;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    font-size: 9px;
    color: var(--muted-color);
  }

  .gds-interactive-heatmaps .heatmap-panel svg {
    max-width: 100%;
  }

  @media (max-width: 800px) {
    .gds-interactive-heatmaps .grid-2x2 {
      grid-template-columns: 1fr;
      grid-template-rows: repeat(4, 1fr);
    }

    .gds-interactive-heatmaps .controls {
      flex-direction: column;
      align-items: flex-start;
    }

    .gds-interactive-heatmaps .heatmap-panel svg {
      width: 100%;
      max-width: 500px;
    }
  }
</style>
<script>
  (() => {
    // Prevent multiple executions
    if (window.gdsInteractiveHeatmapsInitialized) return;
    window.gdsInteractiveHeatmapsInitialized = true;

    // Load D3 from CDN once
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('gds-interactive-heatmaps'))) {
        const cs = Array.from(document.querySelectorAll('.gds-interactive-heatmaps')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease',
          zIndex: 'var(--z-tooltip)'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      let allData = {};
      let currentStorage = 'scratch';
      let currentXferType = 'CPUONLY';

      // Create controls
      const controls = document.createElement('div');
      controls.className = 'controls';

      const xferGroup = document.createElement('div');
      xferGroup.className = 'control-group';
      xferGroup.innerHTML = `
        <label class="control-label">Transfer Type</label>
        <select id="xfer-select">
          <option value="CPUONLY">CPU ONLY</option>
          <option value="GPUD">GPU DIRECT</option>
          <option value="CPU_GPU">CPU_GPU</option>
        </select>
      `;

      const metricGroup = document.createElement('div');
      metricGroup.className = 'control-group';
      metricGroup.innerHTML = `
        <label class="control-label">Metric</label>
        <select id="metric-select">
          <option value="throughput">Bandwidth</option>
          <option value="iops">IOPS</option>
        </select>
      `;

      controls.appendChild(xferGroup);
      controls.appendChild(metricGroup);

      // Create 2x2 grid
      const grid = document.createElement('div');
      grid.className = 'grid-2x2';
      container.appendChild(grid);

      // Add controls after the grid
      container.appendChild(controls);

      // Create 4 panels - one for each storage type
      const panelConfigs = [
        { id: 'panel-1', title: '/scratch', storage: 'scratch' },
        { id: 'panel-2', title: '/root', storage: 'root' },
        { id: 'panel-3', title: '/fsx', storage: 'fsx' },
        { id: 'panel-4', title: '/admin', storage: 'admin' }
      ];

      const panels = {};
      panelConfigs.forEach((config, i) => {
        const panel = document.createElement('div');
        panel.className = 'heatmap-panel';
        panel.id = config.id;

        const title = document.createElement('div');
        title.className = 'panel-title';
        title.textContent = `${config.title} - Bandwidth (GiB/s)`;
        panel.appendChild(title);

        const svg = d3.select(panel).append('svg').attr('width', '100%').style('display', 'block');
        const gRoot = svg.append('g');
        const gCells = gRoot.append('g');
        const gAxes = gRoot.append('g');

        grid.appendChild(panel);

        panels[config.id] = {
          panel,
          svg,
          gRoot,
          gCells,
          gAxes,
          config
        };
      });

      // Load data from multiple sources
      async function loadAllData() {
        const storageFiles = {
          scratch: '/data/scratch_seq_write.json',
          root: '/data/root_seq_write.json',
          fsx: '/data/fsx_seq_write.json',
          admin: '/data/admin_seq_write.json'
        };

        for (const [storage, filePath] of Object.entries(storageFiles)) {
          try {
            const response = await fetch(filePath);
            if (!response.ok) continue;
            allData[storage] = await response.json();
            console.log(`Loaded ${storage} data:`, allData[storage]);
          } catch (error) {
            console.warn(`Failed to load ${storage} data:`, error);
          }
        }

        renderAllHeatmaps();
      }


      function createHeatmap(panelData) {
        const { gRoot, gCells, gAxes, config } = panelData;

        function render() {
          const storageData = allData[config.storage];
          if (!storageData) return;

          const xferType = document.getElementById('xfer-select').value;
          const metric = document.getElementById('metric-select').value;

          if (!storageData.data[xferType]) return;

          const { innerWidth, innerHeight } = updateSize(panelData);
          const threadCounts = storageData.metadata.thread_counts;
          const ioSizeLabels = storageData.metadata.io_size_labels;
          const matrix = storageData.data[xferType][metric];

          if (!matrix) return;

          const nRows = threadCounts.length;
          const nCols = ioSizeLabels.length;
          const gridSize = Math.min(innerWidth, innerHeight);

          // Center the grid horizontally if it's smaller than innerWidth
          const gridOffsetX = (innerWidth - gridSize) / 2;
          gCells.attr('transform', `translate(${gridOffsetX}, 0)`);
          gAxes.attr('transform', `translate(${gridOffsetX}, 0)`);

          const x = d3.scaleBand().domain(d3.range(nCols)).range([0, gridSize]).paddingInner(0.06);
          const y = d3.scaleBand().domain(d3.range(nRows)).range([0, gridSize]).paddingInner(0.06);

          // Flatten matrix data
          const flatData = [];
          let minVal = Infinity, maxVal = -Infinity;

          for (let r = 0; r < nRows; r++) {
            for (let c = 0; c < nCols; c++) {
              const value = matrix[r][c];
              if (value < minVal) minVal = value;
              if (value > maxVal) maxVal = value;
              flatData.push({ r, c, value, threadCount: threadCounts[r], ioSize: ioSizeLabels[c] });
            }
          }

          // Color scale using ColorPalettes
          let colorScale;
          try {
            if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
              const colors = window.ColorPalettes.getColors('diverging', 10);
              if (colors && colors.length > 0) {
                colorScale = d3.scaleSequential()
                  .domain([maxVal, minVal])
                  .interpolator(d3.interpolateRgbBasis(colors));
              } else {
                throw new Error('No colors returned');
              }
            } else {
              throw new Error('ColorPalettes not available');
            }
          } catch (_) {
            // Fallback to D3 built-in scales
            if (metric === 'throughput') {
              colorScale = d3.scaleSequential(d3.interpolateViridis)
                .domain([maxVal, minVal]);
            } else {
              colorScale = d3.scaleSequential(d3.interpolatePlasma)
                .domain([maxVal, minVal]);
            }
          }

          // Clear previous content
          gCells.selectAll('*').remove();
          gAxes.selectAll('*').remove();

          // Background
          gCells.append('rect')
            .attr('class', 'cell-bg')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', gridSize)
            .attr('height', gridSize)
            .attr('fill', 'none')
            .attr('stroke', 'var(--border-color)')
            .attr('stroke-width', 1);

          // Cells
          const cells = gCells.selectAll('g.cell')
            .data(flatData, d => `${d.r}-${d.c}`);

          const cellsEnter = cells.enter()
            .append('g')
            .attr('class', 'cell');

          cellsEnter.append('rect')
            .attr('rx', 2)
            .attr('ry', 2)
            .on('mousemove', (event, d) => {
              const [px, py] = d3.pointer(event, container);
              const storageData = allData[config.storage];
              const iops = storageData.data[xferType].iops[d.r][d.c];
              const throughput = storageData.data[xferType].throughput[d.r][d.c];

              if (metric === 'throughput') {
                tipInner.innerHTML = `<strong>${config.storage.toUpperCase()} - ${xferType}</strong><br/>Threads: ${d.threadCount}<br/>IO Size: ${d.ioSize}<br/>Throughput: ${d.value.toFixed(2)} GiB/s<br/>IOPS: ${iops.toFixed(0)}`;
              } else {
                tipInner.innerHTML = `<strong>${config.storage.toUpperCase()} - ${xferType}</strong><br/>Threads: ${d.threadCount}<br/>IO Size: ${d.ioSize}<br/>IOPS: ${d.value.toFixed(0)}<br/>Throughput: ${throughput.toFixed(2)} GiB/s`;
              }
              tip.style.transform = `translate(${px + 10}px, ${py + 10}px)`;
              tip.style.opacity = '1';
            })
            .on('mouseleave', () => {
              tip.style.opacity = '0';
            });

          cellsEnter.append('text')
            .attr('class', 'cell-text')
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle');

          const cellsMerged = cellsEnter.merge(cells);

          cellsMerged.select('rect')
            .attr('x', d => x(d.c))
            .attr('y', d => y(d.r))
            .attr('width', Math.max(1, x.bandwidth()))
            .attr('height', Math.max(1, y.bandwidth()))
            .attr('fill', d => colorScale(d.value));

          cellsMerged.select('text')
            .attr('x', d => x(d.c) + x.bandwidth() / 2)
            .attr('y', d => y(d.r) + y.bandwidth() / 2)
            .text(d => {
              if (metric === 'throughput') {
                return d.value.toFixed(2);
              } else {
                return d.value.toFixed(0);
              }
            })
            .style('fill', function (d) {
              try {
                const rect = this && this.parentNode ? this.parentNode.querySelector('rect') : null;
                const bg = rect ? getComputedStyle(rect).fill : colorScale(d.value);
                return chooseReadableTextColor(bg);
              } catch (_) {
                return '#0e1116';
              }
            });

          cells.exit().remove();

          // Axes
          gAxes.append('g')
            .selectAll('text')
            .data(ioSizeLabels)
            .join('text')
            .attr('class', 'axis-label')
            .attr('text-anchor', 'middle')
            .attr('x', (_, i) => x(i) + x.bandwidth() / 2)
            .attr('y', -8)
            .text(d => d);

          gAxes.append('g')
            .selectAll('text')
            .data(threadCounts)
            .join('text')
            .attr('class', 'axis-label')
            .attr('text-anchor', 'end')
            .attr('x', -8)
            .attr('y', (_, i) => y(i) + y.bandwidth() / 2)
            .attr('dominant-baseline', 'middle')
            .text(d => d);

          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('text-anchor', 'middle')
            .attr('x', gridSize / 2)
            .attr('y', innerHeight + 20)
            .text('IO Size');

          gAxes.append('text')
            .attr('class', 'axis-label')
            .attr('text-anchor', 'middle')
            .attr('transform', `translate(${-40}, ${gridSize / 2}) rotate(-90)`)
            .text('Thread Count');
        }

        return { render };
      }

      function updateSize(panelData) {
        const { panel, svg, gRoot } = panelData;
        const width = panel.clientWidth || 400;
        const height = 280;
        const margin = { top: 30, right: 20, bottom: 20, left: 50 };

        svg
          .attr('viewBox', `0 0 ${width} ${height}`)
          .attr('preserveAspectRatio', 'xMidYMid meet')
          .style('width', '100%')
          .style('height', 'auto');

        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        return { innerWidth, innerHeight };
      }

      function chooseReadableTextColor(bgCss) {
        try {
          const m = String(bgCss || '').match(/rgba?\(([^)]+)\)/);
          if (!m) return '#0e1116';
          const parts = m[1].split(',').map(s => parseFloat(s.trim()));
          const [r, g, b] = parts;
          const srgb = [r, g, b].map(v => Math.max(0, Math.min(255, v)) / 255);
          const linear = srgb.map(c => (c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)));
          const L = 0.2126 * linear[0] + 0.7152 * linear[1] + 0.0722 * linear[2];
          return L < 0.5 ? '#ffffff' : '#0e1116';
        } catch (_) { return '#0e1116'; }
      }

      function renderAllHeatmaps() {
        Object.values(panels).forEach(panelData => {
          const chart = createHeatmap(panelData);
          chart.render();
        });
      }

      function updatePanelTitles() {
        const xferType = document.getElementById('xfer-select').value;
        const metric = document.getElementById('metric-select').value;
        const metricLabel = metric === 'throughput' ? 'Bandwidth (GiB/s)' : 'IOPS';

        // Update titles for all panels
        Object.values(panels).forEach(panelData => {
          const title = panelData.panel.querySelector('.panel-title');
          title.textContent = `${panelData.config.storage.toUpperCase()} - ${metricLabel}`;
        });

        renderAllHeatmaps();
      }

      // Event listeners
      document.getElementById('xfer-select').addEventListener('change', updatePanelTitles);
      document.getElementById('metric-select').addEventListener('change', updatePanelTitles);

      // Initial load
      loadAllData();

      // Resize handling
      const rerender = () => renderAllHeatmaps();
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => rerender());
        ro.observe(container);
      } else {
        window.addEventListener('resize', rerender);
      }
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script></div></div><figcaption class="html-embed__desc" style="text-align:left">Benchmark results comparing storage system performance across varying thread counts and I/O sizes. The heatmaps visualize throughput (GiB/s) and IOPS patterns, revealing optimal configurations for each storage tier. Note: GPUDirect Storage (GDS) is not currently supported in this cluster configuration.</figcaption></figure> </div>
<p>The benchmarks reveal dramatic performance differences across our four storage systems:</p>
<p><strong>Scratch (Local NVMe RAID)</strong>  dominates with  <strong>26.59 GiB/s</strong>  throughput and  <strong>337K IOPS</strong> , making it 6.3× faster than FSx for throughput and 6.6× better for IOPS. This local RAID array of 8×3.5TB NVMe drives delivers the lowest latency (190μs at peak IOPS) and scales exceptionally well with thread count, achieving peak performance at 64 threads with 1M I/O sizes for throughput.</p>
<p><strong>FSx (WekaFS)</strong>  provides solid network storage performance at  <strong>4.21 GiB/s</strong>  and  <strong>51K IOPS</strong> , making it the best choice for shared data that needs reasonable performance. FSx achieves its best throughput (4.21 GiB/s) using CPUONLY transfer, while its best IOPS (51K) uses GPUD transfer type.</p>
<p><strong>Admin (Lustre)</strong>  and  <strong>Root</strong>  filesystems show similar modest performance around  <strong>1.1 GiB/s</strong>  throughput, but differ significantly in IOPS capability. Admin achieves its peak throughput (1.13 GiB/s) with GPUD transfer and peaks at 17K IOPS with CPU_GPU transfer (24× better than Root), making it more suitable for workloads with many small operations. Root’s poor IOPS performance (730) confirms it’s best suited for large sequential operations only.</p>
<div class="note note--neutral" data-astro-cid-qg6lmfty> <!-- When there's no title, emoji is above content -->
    <div class="note__layout" data-astro-cid-qg6lmfty>  <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__content" data-astro-cid-qg6lmfty> <p><strong>Note on GPU_DIRECT Results:</strong>  GPUDirect Storage (GDS) is not currently enabled in our cluster, which explains why GPUD results for NVMe storage (Scratch and Root) underperform compared to CPUONLY transfers. With GDS properly configured, we would expect GPUD to show significant advantages for direct GPU-to-storage transfers, particularly for the high-performance NVMe arrays. The FSx and Admin results show better GPUD performance because WekaFS and Lustre have different optimization paths that don’t rely as heavily on the GDS kernel module.</p> </div> </div> </div> </div> 
<p><strong>Optimal Configuration Patterns</strong> : Across all storage types, maximum throughput occurs at 1M I/O sizes, while maximum IOPS occurs at the smallest tested size (64K). This classic tradeoff means choosing between raw bandwidth (large I/O) and operation concurrency (small I/O) based on workload characteristics. For ML training with large checkpoint files, the 1M-8M range on Scratch provides optimal performance.</p>
<h4 id="summary"><a href="#summary">Summary</a></h4>
<p>If you’ve made it this far, congratulations! You now have a comprehensive understanding of the storage hierarchy and how different components interact in our training infrastructure. But here’s the key insight we hope you take home:  <strong>identifying bottlenecks is what separates theoretical knowledge from practical optimization</strong> .</p>
<p>Throughout this guide, we’ve measured actual bandwidths at every level of the stack: HBM3’s 3TB/s within a single GPU, NVLink’s 786 GB/s between GPUs in a node, PCIe Gen4 x8’s 14.2 GB/s for CPU-GPU transfers, inter-node network’s 42 GB/s for point-to-point communication, and storage systems ranging from 26.59 GB/s (local NVMe) down to 1.1 GB/s (shared filesystems). These measurements reveal where your training pipeline will slow down and are essential for achieving high Model FLOPs Utilization (MFU).</p>
<p>However, raw bandwidth numbers alone don’t tell the complete story. Modern training systems can  <strong>overlap computation with communication</strong> , effectively hiding communication costs behind compute operations. This parallelization helps alleviate the bottleneck even when interconnects is slow. For detailed strategies on overlapping compute and communication to maximize throughput, see the Ultra-Scale Playbook.</p>
<p>The diagram below synthesizes all our benchmarked measurements into a single view, showing how bandwidth decreases dramatically as we move further from the GPU:</p>
<div class="wide"> <figure class="html-embed"><div class="html-embed__card"><div id="frag-3vh4pdfn07n" data-config="{&#34;showRealBandwidths&#34;:true}"><!--
  AWS Bandwidth Bottleneck Visualization
  
  Usage:
  
  Basic:
    <HtmlEmbed src="/embeds/aws-bandwidth-bottleneck.html" />
  
  With initial filter:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ initialFilter: 'cpu-gpu' }} 
    />
  
  With real bandwidths display:
    <HtmlEmbed 
      src="/embeds/aws-bandwidth-bottleneck.html" 
      config={{ showRealBandwidths: true }} 
    />
  
  Available filters:
    - cpu-gpu (Intranode: CPU ⟷ GPU)
    - gpu-gpu-cpu (Intranode: GPU ⟷ GPU via CPU)
    - gpu-gpu-nvswitch (Intranode: GPU ⟷ GPU via NVSwitch)
    - gpu-gpu-efa-intranode (Intranode: GPU ⟷ GPU via EFA)
    - gpu-gpu-efa-internode (Internode: GPU ⟷ GPU via EFA)
    - gpu-storage (Storage: GPU ⟷ Storage)
    - cpu-storage (Storage: CPU ⟷ Storage)
    - gpu-cpu-storage (Storage: GPU ⟷ Storage via CPU)
-->
<div class="aws-topology-wrapper">
  <div class="aws-topology-container"></div>
  <div class="aws-topology-controls"></div>
  <div class="aws-topology-legend"></div>
  <div class="aws-topology-tooltip"></div>
  <div class="aws-topology-bottleneck">
    <div class="bottleneck-label">Bandwidth Max</div>
    <div class="bottleneck-path">for CPU → GPU</div>
    <div class="bottleneck-value">-</div>
    <div class="bottleneck-unit">GB/s</div>
    <div class="bottleneck-efficiency" style="display: none;">
      <div class="efficiency-value">-</div>
      <div class="efficiency-label">Efficiency</div>
    </div>
    <div class="real-bandwidths" style="display: none;">
      <div class="real-bandwidths-title">Real Bandwidths</div>
      <div class="real-bandwidths-content"></div>
    </div>
  </div>
</div>

<style>
  .aws-topology-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .aws-topology-container {
    width: 100%;
    height: auto;
    min-height: 400px;
    position: relative;
    transition: opacity 0.15s ease;
  }

  .aws-topology-container.fixed-height {
    height: 850px;
  }

  .aws-topology-container svg {
    width: 100%;
    height: 100%;
  }

  .aws-topology-container svg g {
    transition: opacity 0.2s ease;
  }

  /* Add drop shadow to all links */
  .aws-topology-container svg g[data-link-type] line,
  .aws-topology-container svg g[data-link-type] path {
    filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
  }

  .aws-topology-controls {
    position: absolute;
    bottom: 10px;
    left: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 800px;
  }

  .aws-topology-controls-section {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .aws-topology-controls-row {
    display: flex;
    flex-direction: row;
    gap: 16px;
    align-items: flex-start;
  }

  .aws-topology-controls-label {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0.7;
  }

  .aws-topology-controls-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }

  .aws-topology-controls-buttons .button {
    flex-shrink: 0;
  }

  /* Hide controls on mobile */
  @media (max-width: 768px) {
    .aws-topology-controls {
      display: none;
    }
  }

  .aws-topology-legend {
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 264px;
    /* 220 * 1.2 */
    height: 120px;
    /* 100 * 1.2 */
  }

  .aws-topology-tooltip {
    position: absolute;
    padding: 8px 12px;
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 12px;
    color: var(--text-color);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .aws-topology-tooltip.visible {
    opacity: 1;
  }

  .tooltip-label {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-color);
  }

  .tooltip-bandwidth {
    font-size: 11px;
    color: var(--text-secondary);
  }

  .aws-topology-bottleneck {
    position: absolute;
    top: 10px;
    right: 10px;
    text-align: right;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .aws-topology-bottleneck.visible {
    opacity: 1;
  }

  .bottleneck-label {
    font-size: 11px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-value {
    font-size: 24px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    margin-bottom: 2px;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .bottleneck-unit {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-path {
    font-size: 10px;
    color: var(--text-secondary);
    font-style: italic;
    margin-bottom: 6px;
    opacity: 0.8;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .bottleneck-efficiency {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    margin-top: 12px;
    margin-bottom: 4px;
  }

  .efficiency-label {
    font-size: 9px;
    color: var(--text-secondary);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 2px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .efficiency-value {
    font-size: 20px;
    font-weight: 700;
    color: var(--primary-color);
    line-height: 1;
    text-shadow:
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg),
      0 0 10px var(--page-bg);
  }

  .real-bandwidths {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid var(--border-color);
    opacity: 0.9;
  }

  .real-bandwidths-title {
    font-size: 10px;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content {
    font-size: 11px;
    color: var(--text-color);
    line-height: 1.4;
    text-shadow:
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg),
      0 0 8px var(--page-bg);
  }

  .real-bandwidths-content .bandwidth-item {
    margin-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .real-bandwidths-content .bandwidth-label {
    font-size: 10px;
    color: var(--text-secondary);
    opacity: 0.8;
  }

  .real-bandwidths-content .bandwidth-value {
    font-size: 11px;
    font-weight: 600;
    color: var(--primary-color);
  }

  /* Checkbox styling for the bandwidth toggle */
  #real-bandwidth-toggle {
    appearance: none;
    width: 16px;
    height: 16px;
    border: 2px solid var(--border-color);
    border-radius: 3px;
    background-color: var(--page-bg);
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    margin-right: 8px;
  }

  #real-bandwidth-toggle:hover {
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(from var(--primary-color) r g b / 0.1);
  }

  #real-bandwidth-toggle:checked {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
  }

  #real-bandwidth-toggle:checked::before {
    content: '';
    position: absolute;
    top: 1px;
    left: 4px;
    width: 4px;
    height: 8px;
    border: solid var(--on-primary);
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }

  #real-bandwidth-toggle:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.5/svg.min.js"></script>
<script>
  (function () {
    // Generate unique ID for this instance
    const instanceId = 'aws-topology-' + Math.random().toString(36).substr(2, 9);

    // Store reference to current script to find wrapper later
    const scriptEl = document.currentScript;

    // Function to find wrapper (will be called after DOM is ready)
    let wrapperEl = null;
    const findWrapper = () => {
      if (!wrapperEl) {
        wrapperEl = scriptEl.previousElementSibling;
        if (!wrapperEl || !wrapperEl.classList.contains('aws-topology-wrapper')) {
          // Fallback: search for unmounted wrappers
          const allWrappers = document.querySelectorAll('.aws-topology-wrapper');
          for (const wrapper of allWrappers) {
            if (!wrapper.dataset.mounted) {
              wrapperEl = wrapper;
              break;
            }
          }
        }
        if (wrapperEl && !wrapperEl.dataset.mounted) {
          wrapperEl.dataset.mounted = 'true';
        }
      }
      return wrapperEl;
    };

    // Get all child elements for this instance
    const getElement = (className) => {
      const wrapper = findWrapper();
      return wrapper ? wrapper.querySelector('.' + className) : null;
    };

    // ============================================================================
    // CONFIGURATION - All settings in one place
    // ============================================================================
    const CONFIG = {
      // Canvas settings
      viewbox: {
        width: 2400,  // Width for 2 ensembles side by side
        get height() {
          // Calculate height based on vertical elements × systemCount
          const singleSystemHeight = this.parent.gaps.topMargin +
            this.parent.sizes.cpu +
            this.parent.gaps.cpuToPcie +
            this.parent.sizes.pcie.height +
            this.parent.gaps.pcieToGpu +
            this.parent.sizes.gpu.height +
            this.parent.gaps.gpuToNvswitch +
            this.parent.sizes.nvswitch.height +
            this.parent.gaps.bottomMargin;

          return singleSystemHeight * this.parent.systemCount +
            this.parent.gaps.systemGap * (this.parent.systemCount - 1);
        },
        parent: null  // Will be set to CONFIG
      },

      // System replication
      systemCount: 2,      // Number of complete systems (each has 2 ensembles)
      ensembleCount: 2,    // Number of ensembles per system (each ensemble = CPU + 4 groups + 2 NVSwitches)
      groupCount: 4,       // Groups per ensemble
      nvswitchCount: 2,    // NVSwitches per ensemble

      // Node sizes (all based on CPU size)
      sizes: {
        cpu: 80,
        get pcie() { return { width: this.cpu * 0.75, height: this.cpu * 0.625 * 3 }; },
        get gpu() { return { width: this.cpu, height: this.cpu }; },
        get efa() { return { width: 60, height: 30 }; },
        get nvme() { return { width: 60, height: 30 }; },
        get nvswitch() { return { width: 100, height: 60 }; }
      },

      // Gaps and spacing
      gaps: {
        topMargin: 0,        // Margin from top to CPU
        cpuToPcie: 80,        // Vertical gap CPU → PCIe
        pcieToGpu: 80,        // Vertical gap PCIe → GPU
        gpuToNvswitch: 200,    // Vertical gap GPU → NVSwitch
        bottomMargin: 40,     // Margin from NVSwitch to bottom
        horizontal: 230,      // Horizontal gap between groups
        ensembleGap: 50,     // Horizontal gap between ensembles (within a system)
        systemGap: 30,       // Horizontal gap between complete systems
        connectionOffset: 15  // Gap between node edge and arrow anchor
      },

      // Group layout offsets (all relative positions within a group)
      layout: {
        pcieOffsetX: -40,      // PCIe X offset from group center (to the left)
        efaNvmeOffsetX: 60,    // EFA/NVMe X offset from group center (to the right)
        efaOffsetY: -30,       // EFA Y offset from PCIe Y (above)
        nvmeOffsetY: 30,       // NVMe Y offset from PCIe Y (below)
        groupPadding: 20       // Padding around group bounding box
      },

      // Debug mode
      debug: {
        showPhantoms: false    // Set to true to visualize phantom nodes
      },

      // Highlight paths (for interactive buttons)
      paths: {
        'cpu-gpu': {
          label: 'CPU ⟷ GPU',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'gpu'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' }
          ]
        },
        'gpu-gpu-cpu': {
          label: 'GPU ⟷ GPU via CPU',
          requiredEnsembles: 1,  // Need only 1 ensemble (2 groups within)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'cpu', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'pcie', to: 'cpu' },
            { from: 'cpu', to: 'pcie' },
            { from: 'cpu', to: 'pcie-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-nvswitch': {
          label: 'GPU ⟷ GPU via NVSwitch',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'nvswitch-0', 'gpu-1'],
          links: [
            { from: 'gpu', to: 'nvswitch-0' },
            { from: 'gpu-1', to: 'nvswitch-0' }
          ]
        },
        'gpu-gpu-efa': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 1,  // Need only 1 ensemble
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-1', 'pcie-1', 'gpu-1'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-1', to: 'efa-external-1' },
            { from: 'efa-1', to: 'pcie-efa-phantom-1' },
            { from: 'pcie-1', to: 'gpu-1' }
          ]
        },
        'gpu-gpu-efa-intranode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles (same system)
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'efa', 'efa-4', 'pcie-4', 'gpu-4'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-4' },  // EFA cross-link between ensembles (12.5GB/s)
            { from: 'efa-4', to: 'efa-external-4' },
            { from: 'efa-4', to: 'pcie-efa-phantom-4' },
            { from: 'pcie-4', to: 'gpu-4' }
          ]
        },
        'gpu-gpu-efa-internode': {
          label: 'GPU ⟷ GPU via EFA',
          requiredEnsembles: 2,  // Need 2 ensembles per system
          requiredSystems: 2,    // Need 2 systems
          nodes: ['gpu', 'pcie', 'efa', 'efa-8', 'pcie-8', 'gpu-8'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'efa', to: 'pcie-efa-phantom' },
            { from: 'efa', to: 'efa-external' },
            { from: 'efa-external', to: 'efa-external-8' },  // EFA cross-link between systems
            { from: 'efa-8', to: 'efa-external-8' },
            { from: 'efa-8', to: 'pcie-efa-phantom-8' },
            { from: 'pcie-8', to: 'gpu-8' }
          ]
        },
        'gpu-storage': {
          label: 'GPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['gpu', 'pcie', 'nvme'],
          links: [
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'cpu-storage': {
          label: 'CPU ⟷ Storage',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        },
        'gpu-cpu-storage': {
          label: 'GPU ⟷ Storage via CPU',
          requiredEnsembles: 1,
          requiredSystems: 1,
          nodes: ['cpu', 'gpu', 'pcie', 'nvme'],
          links: [
            { from: 'cpu', to: 'pcie' },
            { from: 'pcie', to: 'gpu' },
            { from: 'nvme', to: 'pcie-nvme-phantom' },
            { from: 'pcie', to: 'pcie-nvme-phantom' }
          ]
        }
      },


      // Bandwidth levels
      bandwidths: [
        { speed: '900GB/s', label: 'NVLink 4.0', width: 9 },
        { speed: '64GB/s', label: 'PCIe Gen5', width: 6 },
        { speed: '16GB/s', label: 'PCIe Gen4', width: 3 },
        { speed: '12.5GB/s', label: 'EFA Link', width: 1.25 }
      ],

      // Link definitions for groups
      groupLinks: [
        { from: 'cpu', to: 'pcie', bandwidth: '16GB/s', type: 'cpu', fromSide: 'bottom', toSide: 'top', multiLink: true },
        { from: 'efa', to: 'pcie-efa-phantom', bandwidth: '16GB/s', type: 'network', fromSide: 'left', toSide: 'right', stacked: 4 },
        { from: 'nvme', to: 'pcie-nvme-phantom', bandwidth: '16GB/s', type: 'storage', fromSide: 'left', toSide: 'right' },
        { from: 'pcie', to: 'gpu', bandwidth: '64GB/s', type: 'gpu', fromSide: 'bottom', toSide: 'top' },
        { from: 'efa', to: 'efa-external', bandwidth: '12.5GB/s', type: 'network', fromSide: 'right', toSide: 'left', stacked: 4 }
      ],

      // GPU to NVSwitch links (full mesh)
      gpuNvswitchLink: {
        bandwidth: '900GB/s',
        type: 'gpu',
        fromSide: 'bottom',
        toSide: 'top'
      },

      // Colors (using CSS variables for dark mode compatibility)
      colors: {
        // Node colors
        nodeFill: 'var(--page-bg)',
        nodeStroke: 'var(--muted-color)',     // More contrast than border-color
        nodeText: 'var(--text-color)',
        nodePins: 'var(--muted-color)',
        nodeCoreFill: 'rgba(0, 0, 0, 0.05)',  // Very light gray for cores
        nodeCoreStroke: 'rgba(0, 0, 0, 0.2)', // More visible border for cores

        // Link colors
        linkColor: 'var(--primary-color)',
        linkCircleBorder: 'rgba(0, 0, 0, 0.1)', // Border for link circles

        // Group border
        groupBorder: 'var(--border-color)',

        // Phantom debug
        phantomFill: 'rgba(255, 0, 255, 0.2)',
        phantomStroke: 'magenta'
      },

      // Real bandwidth data for display
      realBandwidths: {
        'cpu-gpu': '14.2GB/s',
        'gpu-gpu-same-node': '786GB/s',
        'gpu-gpu-efa-intranode': '40GB/s',
        'gpu-gpu-efa-internode': '40GB/s',
        'allreduce-same-node': '480GB/s',
        'all2all-same-node': '340GB/s',
        'allreduce-internode': '320GB/s',
        'alltoall-internode': '45GB/s',
        'gpu-storage': '14.2GB/s'
      }
    };

    // Initialize viewbox parent reference
    CONFIG.viewbox.parent = CONFIG;

    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================
    function getBandwidth(speed) {
      const bw = CONFIG.bandwidths.find(b => b.speed === speed);
      if (bw) {
        // Add numericValue for comparison
        bw.numericValue = parseFloat(bw.speed.replace('GB/s', ''));
      }
      return bw;
    }

    // Calculate connection offset proportional to link width
    function getLinkOffset(linkWidth) {
      const minOffset = 5;   // Minimum offset for thin links
      const maxOffset = 20;  // Maximum offset for thick links

      // Proportional offset: thinner links = smaller offset
      const proportionalOffset = minOffset + (linkWidth / 10) * (maxOffset - minOffset);
      return Math.min(Math.max(proportionalOffset, minOffset), maxOffset);
    }

    // ============================================================================
    // EFA CROSS-LINKS HELPER
    // ============================================================================
    function drawEfaCrossLinks(renderer, fromId, toId, linkType = 'efa-crosslink') {
      const phantom0 = renderer.nodes.get(fromId);
      const phantom1 = renderer.nodes.get(toId);

      if (!phantom0 || !phantom1) return;

      const efaBw = getBandwidth('12.5GB/s');
      const efaColor = CONFIG.colors.linkColor;

      // Draw 4 stacked links manually (EFA has 4 connections) - randomized order
      const stackCount = 4;
      const spacing = 6; // Fixed spacing between stacked links
      const verticalShift = -95; // Shift up to align with EFA nodes
      const horizontalShift = -40; // Shift left to better position the arrows
      const horizontalExtension = 20; // Extend arrows horizontally on each side

      // Create array of indices and randomize
      const linkIndices = Array.from({ length: stackCount }, (_, i) => i);
      const shuffledIndices = linkIndices.sort(() => Math.random() - 0.5);

      // Draw horizontal lines with vertical offset for stacking
      shuffledIndices.forEach(i => {
        const offsetY = (i - (stackCount - 1) / 2) * spacing;

        const efaCrossGroup = renderer.crossLinksGroup.group();
        efaCrossGroup.attr('data-link-type', linkType);
        efaCrossGroup.attr('data-from', fromId);
        efaCrossGroup.attr('data-to', toId);
        efaCrossGroup.attr('data-bandwidth', '12.5GB/s');
        efaCrossGroup.attr('data-label', 'EFA Link');

        // Draw line with vertical offset for stacking + shifts + horizontal extension
        const x0 = phantom0.x + horizontalShift;
        const x1 = phantom1.x + horizontalShift + horizontalExtension;
        const y0 = phantom0.y + offsetY + verticalShift;
        const y1 = phantom1.y + offsetY + verticalShift;

        // Draw border
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        efaCrossGroup.line(x0, y0, x1, y1)
          .stroke({ color: efaColor, width: efaBw.width, opacity: 1 });

        // Draw circles at both ends
        const r = efaBw.width * 0.8;
        const startCircle = efaCrossGroup.circle(r * 2).move(x0 - r, y0 - r);
        startCircle.fill(efaColor);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = efaCrossGroup.circle(r * 2).move(x1 - r, y1 - r);
        endCircle.fill(efaColor);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');
      });

      // Add vertical bars at both ends (connect horizontal arrows to EFA phantoms)
      const barColor = CONFIG.colors.linkColor;

      shuffledIndices.forEach(i => {
        const offsetX = (i - (stackCount - 1) / 2) * spacing + 12; // Horizontal offset for vertical bars
        const yHorizontal = phantom0.y + verticalShift + 10;
        const yPhantom = phantom0.y + 8; // End a bit higher (5px above phantom center)

        // Left vertical bar (one per horizontal arrow)
        const leftBarGroup = renderer.crossLinksGroup.group();
        leftBarGroup.attr('data-link-type', linkType);
        leftBarGroup.attr('data-from', fromId);
        leftBarGroup.attr('data-to', toId);
        leftBarGroup.attr('data-bandwidth', '12.5GB/s');
        leftBarGroup.attr('data-label', 'EFA Link');

        const x0 = phantom0.x + horizontalShift + offsetX;

        // Draw border
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        leftBarGroup.line(x0, yHorizontal, x0, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const r = efaBw.width * 0.8;
        const bottomCircle0 = leftBarGroup.circle(r * 2).move(x0 - r, yPhantom - r);
        bottomCircle0.fill(barColor);
        bottomCircle0.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle0.attr('data-link-circle', 'true');

        // Right vertical bar (one per horizontal arrow)
        const rightBarGroup = renderer.crossLinksGroup.group();
        rightBarGroup.attr('data-link-type', linkType);
        rightBarGroup.attr('data-from', fromId);
        rightBarGroup.attr('data-to', toId);
        rightBarGroup.attr('data-bandwidth', '12.5GB/s');
        rightBarGroup.attr('data-label', 'EFA Link');

        const x1 = phantom1.x + horizontalShift + offsetX;

        // Draw border
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: efaBw.width + 1, opacity: 1 });

        // Draw main line
        rightBarGroup.line(x1, yHorizontal, x1, yPhantom)
          .stroke({ color: barColor, width: efaBw.width, opacity: 1 });

        const bottomCircle1 = rightBarGroup.circle(r * 2).move(x1 - r, yPhantom - r);
        bottomCircle1.fill(barColor);
        bottomCircle1.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        bottomCircle1.attr('data-link-circle', 'true');
      });
    }

    // ============================================================================
    // SVG HELPERS
    // ============================================================================
    class TopologyRenderer {
      constructor(draw) {
        this.draw = draw;
        this.nodes = new Map();
        this.structuralGroup = draw.group();  // Structural elements (Node/NUMA borders, never ghosted)
        this.structuralGroup.attr('data-group', 'structural');
        this.baseLinksGroup = draw.group();   // Base links layer (will be ghosted)
        this.baseLinksGroup.attr('data-group', 'base-links');
        this.linksGroup = this.baseLinksGroup; // Alias for compatibility
        this.nodesGroup = draw.group();   // Nodes layer (middle)
        this.phantomsGroup = draw.group(); // Phantoms layer (for debug)
        this.baseCrossLinksGroup = draw.group(); // Base EFA cross-links layer
        this.baseCrossLinksGroup.attr('data-group', 'base-cross-links');
        this.crossLinksGroup = this.baseCrossLinksGroup; // Alias for compatibility
        this.activeLinksGroup = draw.group(); // Active (duplicated) links layer (top, non-ghosted)
        this.activeLinksGroup.attr('data-group', 'active-links');
      }

      // Draw a simple rectangular node
      // Helper: Draw text with consistent styling
      drawText(x, y, label, group = this.nodesGroup) {
        if (!label) return;

        const lines = label.split('\n');
        lines.forEach((line, i) => {
          group.text(line)
            .font({ family: 'Inter, sans-serif', size: 12, weight: '600', anchor: 'middle' })
            .fill(CONFIG.colors.nodeText)
            .cx(x)
            .cy(y + (i - (lines.length - 1) / 2) * 14);
        });
      }

      // Helper: Draw pins around a node
      drawPins(x, y, width, height, pinConfig = {}, targetGroup = null) {
        const group = targetGroup || this.nodesGroup;

        const defaultConfig = {
          pinsPerSide: width >= 80 ? 18 : 15,
          pinLength: 3,
          pinOffset: width / 2 + 1.5,
          pinPadding: 12
        };

        const config = { ...defaultConfig, ...pinConfig };
        const pinStartOffset = -width / 2 + config.pinPadding;
        const pinEndOffset = width / 2 - config.pinPadding;
        const pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);

        const sides = [
          { side: 'left', xOffset: -config.pinOffset, yOffset: 0 },
          { side: 'right', xOffset: config.pinOffset, yOffset: 0 },
          { side: 'top', xOffset: 0, yOffset: -config.pinOffset },
          { side: 'bottom', xOffset: 0, yOffset: config.pinOffset }
        ];

        sides.forEach(({ side, xOffset, yOffset }) => {
          for (let i = 0; i < config.pinsPerSide; i++) {
            const pinX = x + xOffset + (side === 'left' || side === 'right' ? 0 : pinStartOffset + (i * pinSpacing));
            const pinY = y + yOffset + (side === 'top' || side === 'bottom' ? 0 : pinStartOffset + (i * pinSpacing));

            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      drawNode(id, x, y, width, height, label, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      drawNodeWithPins(id, x, y, width, height, label, pinConfig = {}, nodeType = '') {
        const node = this.drawNode(id, x, y, width, height, label, nodeType);
        this.drawPins(x, y, width, height, pinConfig);
        return node;
      }

      drawNodeWithCores(id, x, y, width, height, label, coreConfig = {}, nodeType = '') {
        // Draw main node
        const node = this.drawNode(id, x, y, width, height, label, nodeType);

        // Default core configuration
        const defaultCoreConfig = {
          coresX: 2,              // 2x2 for CPU, 8x8 for GPU
          coresY: 2,
          coreSpacing: 2,         // Space between cores
          coreMargin: 8           // Margin from node edges
        };

        const config = { ...defaultCoreConfig, ...coreConfig };

        // Calculate core size
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coreSpacing * (config.coresX - 1))) / config.coresX;
        const coreHeight = (availableHeight - (config.coreSpacing * (config.coresY - 1))) / config.coresY;

        // Draw cores
        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            this.nodesGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        return node;
      }

      drawProcessorNode(id, x, y, width, height, label, type = 'cpu') {
        // Create main group for the node
        const nodeGroup = this.nodesGroup.group();
        nodeGroup.attr('id', id);
        nodeGroup.attr('data-node-type', type);

        // Draw node background
        nodeGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Draw cores
        const coreConfig = type === 'gpu' ? { coresX: 8, coresY: 8 } : { coresX: 2, coresY: 2 };
        const config = { coreSpacing: 2, coreMargin: 8, ...coreConfig };
        const availableWidth = width - (config.coreMargin * 2);
        const availableHeight = height - (config.coreMargin * 2);
        const coreWidth = (availableWidth - (config.coresX - 1) * config.coreSpacing) / config.coresX;
        const coreHeight = (availableHeight - (config.coresY - 1) * config.coreSpacing) / config.coresY;

        for (let row = 0; row < config.coresY; row++) {
          for (let col = 0; col < config.coresX; col++) {
            const coreX = x - width / 2 + config.coreMargin + col * (coreWidth + config.coreSpacing);
            const coreY = y - height / 2 + config.coreMargin + row * (coreHeight + config.coreSpacing);

            nodeGroup.rect(coreWidth, coreHeight)
              .move(coreX, coreY)
              .fill(CONFIG.colors.nodeCoreFill)
              .stroke({ color: CONFIG.colors.nodeCoreStroke, width: 0.5 })
              .radius(1);
          }
        }

        // Draw pins in the same group
        this.drawPins(x, y, width, height, {}, nodeGroup);

        // Draw text on top
        this.drawText(x, y, label, nodeGroup);

        // Store node position
        this.nodes.set(id, { x, y, width, height });

        return nodeGroup;
      }

      // Add pins to an existing node (without changing the node design)
      addPinsToNode(nodeId, pinConfig = {}) {
        const node = this.nodes.get(nodeId);
        if (!node) return;

        // Find the node's SVG group
        const svg = getElement('aws-topology-container').querySelector('svg');
        if (!svg) return;
        const nodeGroup = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeGroup) return;

        // Use SVG.js to manipulate the group
        const group = this.draw.findOne(`#${nodeId}`);
        if (!group) return;

        // Default pin configuration
        const defaultPinConfig = {
          pinsPerSide: node.width >= 80 ? 18 : 15,
          sides: ['left', 'right', 'top', 'bottom'],
          pinLength: 3,
          pinPadding: 12
        };

        const config = { ...defaultPinConfig, ...pinConfig };

        // Generate pins on specified sides only
        config.sides.forEach(side => {
          let pinSpacing, pinStartOffset, pinEndOffset;

          if (side === 'left' || side === 'right') {
            pinStartOffset = -node.height / 2 + config.pinPadding;
            pinEndOffset = node.height / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          } else {
            pinStartOffset = -node.width / 2 + config.pinPadding;
            pinEndOffset = node.width / 2 - config.pinPadding;
            pinSpacing = (pinEndOffset - pinStartOffset) / (config.pinsPerSide - 1);
          }

          for (let i = 0; i < config.pinsPerSide; i++) {
            let pinX, pinY;

            if (side === 'left') {
              pinX = node.x - node.width / 2 - 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'right') {
              pinX = node.x + node.width / 2 + 1.5;
              pinY = node.y + pinStartOffset + (i * pinSpacing);
            } else if (side === 'top') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y - node.height / 2 - 1.5;
            } else if (side === 'bottom') {
              pinX = node.x + pinStartOffset + (i * pinSpacing);
              pinY = node.y + node.height / 2 + 1.5;
            }

            // Draw pin in the node's group
            group.rect(
              side === 'left' || side === 'right' ? config.pinLength : 1,
              side === 'top' || side === 'bottom' ? config.pinLength : 1
            )
              .move(
                pinX - (side === 'left' || side === 'right' ? config.pinLength : 1) / 2,
                pinY - (side === 'top' || side === 'bottom' ? config.pinLength : 1) / 2
              )
              .fill(CONFIG.colors.nodePins)
              .stroke('none');
          }
        });
      }

      // Draw a stacked node (visual stack effect)
      drawStackedNode(id, x, y, width, height, label, stackCount, nodeType = '') {
        const group = this.nodesGroup.group();
        group.attr('id', id);  // Set ID for selection
        if (nodeType) group.attr('data-node-type', nodeType);

        for (let i = stackCount - 1; i >= 0; i--) {
          const offsetY = i * 3;
          group.rect(width, height)
            .move(x - width / 2, y - height / 2 + offsetY)
            .fill(CONFIG.colors.nodeFill)
            .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
            .radius(4)
            .opacity(1);
        }

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw a storage node (NVMe) with internal rectangle
      drawStorageNode(id, x, y, width, height, label, nodeType = 'storage') {
        const group = this.nodesGroup.group();
        group.attr('id', id);
        if (nodeType) group.attr('data-node-type', nodeType);

        // Main node background
        group.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: CONFIG.colors.nodeStroke, width: 1 })
          .radius(4)
          .opacity(1);

        // Internal rectangle on the left side (flush with edge)
        const internalRectWidth = 5;
        const internalRectHeight = height * .6; // Full height
        const internalRectX = x - width / 2; // Flush with left edge
        const internalRectY = y - height / 2 + height * .20;

        group.rect(internalRectWidth, internalRectHeight)
          .move(internalRectX, internalRectY)
          .fill(CONFIG.colors.nodeFill)
          .stroke({ color: '#ffffff', width: 1 })
          .opacity(.4)
          .radius(0); // No radius

        this.drawText(x, y, label, group);

        this.nodes.set(id, { x, y, width, height });
        return group;
      }

      // Draw background rectangle
      drawBackground(id, x, y, width, height) {
        const bg = this.linksGroup.rect(width, height)
          .move(x - width / 2, y - height / 2)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 2,
            dasharray: '5,5'
          })
          .radius(8);

        this.nodes.set(id, { x, y, width, height });
        return bg;
      }

      // Get connection point on a node's side with configurable offset and multi-link spacing
      getPoint(nodeId, side, offset = CONFIG.gaps.connectionOffset, linkIndex = 0, totalLinks = 1) {
        const node = this.nodes.get(nodeId);
        if (!node) return { x: 0, y: 0 };

        const points = {
          top: { x: node.x, y: node.y - node.height / 2 - offset },
          right: { x: node.x + node.width / 2 + offset, y: node.y },
          bottom: { x: node.x, y: node.y + node.height / 2 + offset },
          left: { x: node.x - node.width / 2 - offset, y: node.y }
        };

        let basePoint = points[side] || { x: node.x, y: node.y };

        // Apply spacing for multiple links to the same anchor
        if (totalLinks > 1) {
          const isVerticalAnchor = (side === 'top' || side === 'bottom');

          // Vertical anchors (top/bottom) space horizontally, horizontal anchors (left/right) space vertically
          const spacing = isVerticalAnchor ? node.width / (totalLinks + 1) : node.height / (totalLinks + 1);
          const linkOffset = (linkIndex - (totalLinks - 1) / 2) * spacing;

          // Apply offset in the perpendicular direction to the anchor
          if (isVerticalAnchor) {
            basePoint.x += linkOffset;  // Horizontal offset for vertical anchors
          } else {
            basePoint.y += linkOffset;  // Vertical offset for horizontal anchors
          }
        }

        return basePoint;
      }

      // Draw single link with optional multi-link spacing
      drawLink(fromId, toId, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, fromLinkIndex = 0, fromTotalLinks = 1, toLinkIndex = 0, toTotalLinks = 1, linkType = '', bandwidth = '') {
        const start = this.getPoint(fromId, fromSide, offset, fromLinkIndex, fromTotalLinks);
        const end = this.getPoint(toId, toSide, offset, toLinkIndex, toTotalLinks);

        const group = this.linksGroup.group();
        if (linkType) group.attr('data-link-type', linkType);
        if (bandwidth) {
          group.attr('data-bandwidth', bandwidth);
          // Find label from bandwidth config
          const bwConfig = getBandwidth(bandwidth);
          if (bwConfig && bwConfig.label) {
            group.attr('data-label', bwConfig.label);
          }
        }
        group.attr('data-from', fromId);
        group.attr('data-to', toId);

        // Check if this is a vertical connection (GPU-NVSwitch or CPU-PCIe)
        const isVerticalConnection = fromSide === 'bottom' && toSide === 'top';

        if (isVerticalConnection) {
          // Use curved paths for vertical connections
          const curvature = 45; // Fixed curvature value for consistent curve strength

          // Create a smooth cubic bezier curve with vertical control points
          const pathData = `M ${start.x} ${start.y} C ${start.x} ${start.y + curvature}, ${end.x} ${end.y - curvature}, ${end.x} ${end.y}`;

          // Draw border (wider path behind)
          group.path(pathData)
            .fill('none')
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main path on top
          group.path(pathData)
            .fill('none')
            .stroke({ color, width, opacity: 1 });
        } else {
          // Draw straight lines for other connections
          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });
        }

        const r = width * 0.8;
        const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        startCircle.attr('data-link-circle', 'true');

        const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });
        endCircle.attr('data-link-circle', 'true');

        return group;
      }

      // Draw stacked links
      drawStackedLinks(fromId, toId, count, color, width, fromSide = 'right', toSide = 'left', offset = CONFIG.gaps.connectionOffset, linkType = '', bandwidth = '') {
        const fromNode = this.nodes.get(fromId);
        const toNode = this.nodes.get(toId);
        if (!fromNode || !toNode) return [];

        const isHorizontal = (fromSide === 'left' || fromSide === 'right') &&
          (toSide === 'left' || toSide === 'right');
        const spacing = isHorizontal
          ? Math.min(fromNode.height, toNode.height) / (count + 1)
          : Math.min(fromNode.width, toNode.width) / (count + 1);

        const arrows = [];
        for (let i = 0; i < count; i++) {
          const stackOffset = (i - (count - 1) / 2) * spacing;
          let start = this.getPoint(fromId, fromSide, offset);
          let end = this.getPoint(toId, toSide, offset);

          if (isHorizontal) {
            start.y += stackOffset;
            end.y += stackOffset;
          } else {
            start.x += stackOffset;
            end.x += stackOffset;
          }

          const group = this.linksGroup.group();
          if (linkType) group.attr('data-link-type', linkType);
          if (bandwidth) {
            group.attr('data-bandwidth', bandwidth);
            // Find label from bandwidth config
            const bwConfig = getBandwidth(bandwidth);
            if (bwConfig && bwConfig.label) {
              group.attr('data-label', bwConfig.label);
            }
          }
          group.attr('data-from', fromId);
          group.attr('data-to', toId);

          // Draw border (wider line behind)
          group.line(start.x, start.y, end.x, end.y)
            .stroke({ color: 'rgba(0, 0, 0, 0.15)', width: width + 1, opacity: 1 });

          // Draw main line on top
          group.line(start.x, start.y, end.x, end.y).stroke({ color, width, opacity: 1 });

          const r = width * 0.8;
          const startCircle = group.circle(r * 2).move(start.x - r, start.y - r);
          startCircle.fill(color);
          startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          startCircle.attr('data-link-circle', 'true');

          const endCircle = group.circle(r * 2).move(end.x - r, end.y - r);
          endCircle.fill(color);
          endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 1 });
          endCircle.attr('data-link-circle', 'true');

          arrows.push(group);
        }
        return arrows;
      }

      // Add phantom node (invisible connection point)
      addPhantom(id, x, y, width = 30, height = 30) {
        this.nodes.set(id, { x, y, width, height });

        // Draw phantom for debug visualization
        if (CONFIG.debug.showPhantoms) {
          this.phantomsGroup.rect(width, height)
            .move(x - width / 2, y - height / 2)
            .fill('rgba(255, 0, 255, 0.2)')  // Semi-transparent magenta
            .stroke({ color: 'magenta', width: 2, dasharray: '4,4' })
            .radius(4);

          // Add label
          this.phantomsGroup.text(id)
            .move(x, y)
            .font({
              family: 'system-ui, -apple-system, sans-serif',
              size: 10,
              anchor: 'middle',
              fill: 'magenta',
              weight: 'bold'
            })
            .dy(-height / 2 - 5);
        }
      }
    }

    // ============================================================================
    // DRAW SINGLE GROUP
    // ============================================================================
    function drawGroup(renderer, globalIndex, localIndex, x, cpuY, nvswitchY, cpuId = 'cpu') {
      const s = CONFIG.sizes;
      const g = CONFIG.gaps;
      const l = CONFIG.layout;
      const suffix = globalIndex > 0 ? `-${globalIndex}` : '';

      // Calculate Y positions
      const pcieY = cpuY + s.cpu / 2 + g.cpuToPcie + s.pcie.height / 2;
      const gpuY = pcieY + s.pcie.height / 2 + g.pcieToGpu + s.gpu.height / 2;

      // Calculate node positions
      const pcieX = x + l.pcieOffsetX;
      const efaX = x + l.efaNvmeOffsetX;
      const nvmeX = x + l.efaNvmeOffsetX;
      const efaY = pcieY + l.efaOffsetY;
      const nvmeY = pcieY + l.nvmeOffsetY;

      // Calculate bounding box BEFORE creating nodes
      const nodeBounds = [
        { x: pcieX, y: pcieY, width: s.pcie.width, height: s.pcie.height },
        { x: efaX, y: efaY, width: s.efa.width, height: s.efa.height },
        { x: nvmeX, y: nvmeY, width: s.nvme.width, height: s.nvme.height },
        { x: pcieX, y: gpuY, width: s.gpu.width, height: s.gpu.height }
      ];

      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      nodeBounds.forEach(node => {
        minX = Math.min(minX, node.x - node.width / 2);
        maxX = Math.max(maxX, node.x + node.width / 2);
        minY = Math.min(minY, node.y - node.height / 2);
        maxY = Math.max(maxY, node.y + node.height / 2);
      });

      const bgWidth = maxX - minX + l.groupPadding * 2;
      const bgHeight = maxY - minY + l.groupPadding * 2;
      const bgCenterX = (minX + maxX) / 2;
      const bgCenterY = (minY + maxY) / 2;

      // Draw background FIRST (will be behind nodes)
      renderer.drawBackground(`group${suffix}`, bgCenterX, bgCenterY, bgWidth, bgHeight);

      // Nodes
      renderer.drawNode(`pcie${suffix}`, pcieX, pcieY, s.pcie.width, s.pcie.height, 'PCIe\nSwitch', 'network');
      renderer.addPinsToNode(`pcie${suffix}`, {
        pinsPerSide: 6,
        sides: ['left', 'right'],
        pinLength: 3,
        pinPadding: 8
      });
      renderer.drawStackedNode(`efa${suffix}`, efaX, efaY, s.efa.width, s.efa.height, 'EFA', 4, 'network');
      renderer.drawStorageNode(`nvme${suffix}`, nvmeX, nvmeY, s.nvme.width, s.nvme.height, 'NVMe', 'storage');
      renderer.drawProcessorNode(`gpu${suffix}`, pcieX, gpuY, s.gpu.width, s.gpu.height, 'GPU', 'gpu');

      // Phantom nodes for routing
      // PCIe phantoms: bord gauche aligné avec PCIe, largeur du PCIe
      const pcieLeftEdge = pcieX;
      const pciePhantomX = pcieLeftEdge;
      renderer.addPhantom(`pcie-efa-phantom${suffix}`, pciePhantomX, efaY, s.pcie.width, s.efa.height);
      renderer.addPhantom(`pcie-nvme-phantom${suffix}`, pciePhantomX, nvmeY, s.pcie.width, s.nvme.height);

      // EFA external phantom: à droite de EFA
      const efaRightEdge = efaX + s.efa.width / 2;
      const efaPhantomX = efaRightEdge + g.connectionOffset + s.efa.width / 2 + 20;  // Centre du phantom + décalage réduit
      renderer.addPhantom(`efa-external${suffix}`, efaPhantomX, efaY, s.efa.width, s.efa.height);

      // Create links from configuration
      CONFIG.groupLinks.forEach(linkDef => {
        const bw = getBandwidth(linkDef.bandwidth);
        const fromId = linkDef.from === 'cpu' ? cpuId : `${linkDef.from}${suffix}`;  // Use cpuId from parameter
        const toId = `${linkDef.to}${suffix}`;
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const offset = getLinkOffset(bw.width);  // Proportional offset based on link width

        if (linkDef.stacked) {
          renderer.drawStackedLinks(fromId, toId, linkDef.stacked, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, linkDef.type, linkDef.bandwidth);
        } else if (linkDef.multiLink) {
          // Use localIndex for multi-link spacing (0-3 within ensemble)
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, localIndex, CONFIG.groupCount, 0, 1, linkDef.type, linkDef.bandwidth);
        } else {
          renderer.drawLink(fromId, toId, color, bw.width, linkDef.fromSide, linkDef.toSide, offset, 0, 1, 0, 1, linkDef.type, linkDef.bandwidth);
        }
      });
    }

    // ============================================================================
    // DRAW SINGLE ENSEMBLE (CPU + 4 groups + 2 NVSwitches)
    // ============================================================================
    function drawEnsemble(renderer, ensembleGlobalIndex, centerX, cpuY, nvswitchY) {
      const cpuId = ensembleGlobalIndex === 0 ? 'cpu' : `cpu-${ensembleGlobalIndex}`;

      // CPU for this ensemble
      renderer.drawProcessorNode(cpuId, centerX, cpuY, CONFIG.sizes.cpu, CONFIG.sizes.cpu, 'CPU', 'cpu');

      // Groups for this ensemble
      for (let i = 0; i < CONFIG.groupCount; i++) {
        const groupGlobalIndex = ensembleGlobalIndex * CONFIG.groupCount + i;
        const offsetX = (i - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal;
        drawGroup(renderer, groupGlobalIndex, i, centerX + offsetX, cpuY, nvswitchY, cpuId);  // Pass i as localIndex
      }

      // NVSwitches: positioned between pairs of groups
      for (let i = 0; i < CONFIG.nvswitchCount; i++) {
        const nvswitchGlobalIndex = ensembleGlobalIndex * CONFIG.nvswitchCount + i;
        const groupPairStart = i * 2;
        const groupPairEnd = groupPairStart + 1;

        const group1X = centerX + ((groupPairStart - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const group2X = centerX + ((groupPairEnd - (CONFIG.groupCount - 1) / 2) * CONFIG.gaps.horizontal);
        const nvswitchX = (group1X + group2X) / 2;

        renderer.drawNode(`nvswitch-${nvswitchGlobalIndex}`, nvswitchX, nvswitchY,
          CONFIG.sizes.nvswitch.width, CONFIG.sizes.nvswitch.height, 'NVSwitch', 'network');

        // Add pins to NVSwitch (like PCIe Switch)
        renderer.addPinsToNode(`nvswitch-${nvswitchGlobalIndex}`, {
          pinsPerSide: 6,
          sides: ['left', 'right'],
          pinLength: 3,
          pinPadding: 8
        });
      }

    }


    // ============================================================================
    // DRAW SINGLE SYSTEM (variable number of ensembles)
    // ============================================================================
    function drawSystem(renderer, systemIndex, systemCenterX, cpuY, nvswitchY, ensembleCount = 1, systemCount = 1, shouldDrawEfaCrossLinks = false) {
      // For internode (2 systems), only show 1 ensemble per system for clarity
      const ensemblesToShow = (systemCount === 2) ? 1 : ensembleCount;

      // Calculate ensemble width (4 groups)
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;

      // Calculate system bounding box based on actual ensembles shown
      const systemWidth = ensemblesToShow * ensembleWidth + (ensemblesToShow - 1) * CONFIG.gaps.ensembleGap;
      const systemHeight = CONFIG.sizes.cpu + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height;

      const systemBgCenterY = cpuY + (nvswitchY - cpuY) / 2;
      const systemPadding = 30;

      // In internode mode, extend the rectangle slightly to the right
      const isInternode = systemCount === 2;
      const extraWidth = isInternode && ensembleCount === 2 ? 210 : 0;

      // Draw system background ONLY if 2 ensembles (intra-node vs inter-node distinction)
      if (ensembleCount === 2) {
        // Adjust rectX to center the extended rectangle
        const totalWidth = systemWidth + systemPadding * 2 + extraWidth;
        const rectX = systemCenterX - totalWidth / 2;
        const rectY = systemBgCenterY - (systemHeight + systemPadding * 2) / 2;
        const rectWidth = totalWidth;
        const rectHeight = systemHeight + systemPadding * 2;

        renderer.structuralGroup.rect(rectWidth, rectHeight)
          .move(rectX, rectY)
          .fill('none')
          .stroke({
            color: CONFIG.colors.groupBorder,
            width: 3,
            opacity: 1
          })
          .radius(12)
          .attr('data-group-border', 'node');

        // Add "Node" label at top left of the system box
        renderer.nodesGroup.text('Node')
          .move(rectX + 35, rectY + 40)
          .font({
            size: 32,
            family: 'var(--font-family)',
            weight: 900,
            fill: CONFIG.colors.textSecondary
          })
          .opacity(0.8);

        // Add NUMA 1 group with "..." in the extended area for internode mode
        if (isInternode) {
          const numaPadding = 15;
          const numaWidth = extraWidth - 15; // Margin for spacing
          const numaHeight = systemHeight;

          const numaX = rectX + rectWidth - extraWidth; // Left margin
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth;
          const numaRectHeight = numaHeight + numaPadding * 2;

          // Draw NUMA 1 border
          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA 1" label at top right
          renderer.nodesGroup.text('NUMA 1')
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);

          // Add "..." centered in NUMA 1
          renderer.nodesGroup.text('...')
            .move(numaX + numaRectWidth / 2, numaY + numaRectHeight / 2)
            .font({
              size: 40,
              family: 'var(--font-family)',
              weight: 900,
              fill: CONFIG.colors.textSecondary,
              anchor: 'middle'
            })
            .opacity(0.6);
        }
      }

      // Draw each ensemble in the system
      for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
        const ensembleGlobalIndex = systemIndex * CONFIG.ensembleCount + ensIndex;

        // Position ensemble within system
        let ensembleCenterX;
        if (isInternode) {
          // In internode mode, align NUMA 0 to the left of the Node rectangle
          const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
          ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
        } else {
          // Normal centered positioning
          const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
          ensembleCenterX = systemCenterX + ensembleOffsetX;
        }

        drawEnsemble(renderer, ensembleGlobalIndex, ensembleCenterX, cpuY, nvswitchY);
      }

      // Draw NUMA node borders (one per ensemble) if 2 ensembles
      if (ensembleCount === 2) {
        for (let ensIndex = 0; ensIndex < ensemblesToShow; ensIndex++) {
          let ensembleCenterX;
          if (isInternode) {
            // In internode mode, align NUMA 0 to the left
            const rectX = systemCenterX - (systemWidth + systemPadding * 2 + extraWidth) / 2;
            ensembleCenterX = rectX + systemPadding + ensembleWidth / 2;
          } else {
            // Normal centered positioning
            const ensembleOffsetX = (ensIndex - (ensemblesToShow - 1) / 2) * (ensembleWidth + CONFIG.gaps.ensembleGap);
            ensembleCenterX = systemCenterX + ensembleOffsetX;
          }

          // Calculate NUMA node bounding box (same as system but for single ensemble)
          const numaWidth = ensembleWidth;
          const numaHeight = systemHeight;
          const numaPadding = 15;

          const numaX = ensembleCenterX - (numaWidth + numaPadding * 2) / 2;
          const numaY = systemBgCenterY - (numaHeight + numaPadding * 2) / 2;
          const numaRectWidth = numaWidth + numaPadding * 2;
          const numaRectHeight = numaHeight + numaPadding * 2;

          renderer.structuralGroup.rect(numaRectWidth, numaRectHeight)
            .move(numaX, numaY)
            .fill('none')
            .stroke({
              color: CONFIG.colors.groupBorder,
              width: 3,
              opacity: 1
            })
            .radius(8)
            .attr('data-group-border', 'numa');

          // Add "NUMA" label at top right
          renderer.nodesGroup.text(`NUMA ${ensIndex}`)
            .move(numaX + numaRectWidth - 15, numaY + 15)
            .font({
              size: 14,
              family: 'var(--font-family)',
              weight: 600,
              fill: CONFIG.colors.textSecondary,
              anchor: 'end'
            })
            .opacity(0.7);
        }
      }

      // GPU to NVSwitch connections (full mesh - all GPUs to all NVSwitches in system)
      const linkDef = CONFIG.gpuNvswitchLink;
      const bw = getBandwidth(linkDef.bandwidth);
      const color = CONFIG.colors.linkColor;
      const offset = getLinkOffset(bw.width);

      // Connect all GPUs in the system to all NVSwitches in the system
      const totalGpusInSystem = ensemblesToShow * CONFIG.groupCount;
      const totalNVSwitchesInSystem = ensemblesToShow * CONFIG.nvswitchCount;

      // Collect all GPU-NVSwitch connections for randomized drawing
      const gpuNvswitchConnections = [];
      for (let gpuIndex = 0; gpuIndex < totalGpusInSystem; gpuIndex++) {
        const gpuGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + gpuIndex;
        const gpuId = gpuGlobalIndex === 0 ? 'gpu' : `gpu-${gpuGlobalIndex}`;

        for (let nvIndex = 0; nvIndex < totalNVSwitchesInSystem; nvIndex++) {
          const nvswitchGlobalIndex = systemIndex * CONFIG.ensembleCount * CONFIG.nvswitchCount + nvIndex;
          gpuNvswitchConnections.push({
            fromId: gpuId,
            toId: `nvswitch-${nvswitchGlobalIndex}`,
            color: color,
            width: bw.width,
            fromSide: linkDef.fromSide,
            toSide: linkDef.toSide,
            offset: offset,
            type: linkDef.type,
            bandwidth: linkDef.bandwidth
          });
        }
      }

      // Randomize and draw GPU-NVSwitch connections
      const shuffledGpuNvswitchConnections = gpuNvswitchConnections.sort(() => Math.random() - 0.5);
      shuffledGpuNvswitchConnections.forEach(conn => {
        renderer.drawLink(conn.fromId, conn.toId, conn.color, conn.width, conn.fromSide, conn.toSide, conn.offset, 0, 1, 0, 1, conn.type, conn.bandwidth);
      });

      // Draw CPU-to-CPU link between ensembles (only if 2 ensembles visible)
      if (ensemblesToShow === 2) {
        const cpu0Id = systemIndex * CONFIG.ensembleCount === 0 ? 'cpu' : `cpu-${systemIndex * CONFIG.ensembleCount}`;
        const cpu1Id = `cpu-${systemIndex * CONFIG.ensembleCount + 1}`;

        // Use a bandwidth for CPU-CPU connection (assuming similar to CPU-PCIe)
        const bw = getBandwidth('16GB/s');
        const color = CONFIG.colors.linkColor;
        const offset = getLinkOffset(bw.width);

        renderer.drawLink(cpu0Id, cpu1Id, color, bw.width, 'right', 'left', offset, 0, 1, 0, 1, 'cpu', '16GB/s');

        // Draw EFA-to-EFA link between ensembles (only if 2 ensembles visible and explicitly requested)
        if (ensemblesToShow === 2 && shouldDrawEfaCrossLinks) {
          const efaExt0Id = systemIndex * CONFIG.ensembleCount * CONFIG.groupCount === 0 ? 'efa-external' : `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount}`;
          const efaExt1Id = `efa-external-${systemIndex * CONFIG.ensembleCount * CONFIG.groupCount + CONFIG.groupCount}`;

          // Use unified EFA cross-links function
          drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
        }
      }
    }

    // ============================================================================
    // DRAW COMPLETE TOPOLOGY
    // ============================================================================
    let currentEnsembleCount = 2;  // Start with 2 ensembles (1 complete node)
    let currentSystemCount = 1;    // Start with 1 system
    let currentActivePathId = null; // Track active path for conditional rendering
    let showRealBandwidthsOverride = null; // User override via checkbox (null = use config)

    function drawTopology(ensembleCount = currentEnsembleCount, systemCount = currentSystemCount) {
      // Clear existing
      const container = getElement('aws-topology-container');
      container.innerHTML = '';

      // Use FIXED viewbox size for consistent zoom across all modes
      const ensembleWidth = CONFIG.groupCount * CONFIG.gaps.horizontal;
      const isInternodeLayout = systemCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode';

      // Calculate single system height (used in both layouts)
      const singleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;

      // Always use max viewbox dimensions for consistent zoom level
      const maxEnsembleWidthForViewbox = 2 * ensembleWidth;
      let viewboxWidth = maxEnsembleWidthForViewbox + CONFIG.gaps.ensembleGap + 200;
      let viewboxHeight = singleSystemHeight;

      // For single ensemble (CPU-GPU, GPU-GPU via CPU, storage paths), zoom in more
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxWidth *= 0.65;  // Zoom in by reducing viewbox width (increased from 0.75)
        viewboxHeight *= 0.65; // Zoom in by reducing viewbox height (increased from 0.75)
      }

      // For 2 systems in vertical layout, use scaled dimensions
      if (systemCount === 2 && !isInternodeLayout) {
        viewboxHeight = singleSystemHeight * 2 + CONFIG.gaps.systemGap;
        viewboxWidth *= 1.15;
        viewboxHeight *= 1.15;
      }

      // For internode horizontal layout, extend viewbox width to accommodate both extended systems
      if (isInternodeLayout) {
        const extraWidth = 210; // Extension per system for NUMA 1
        const systemPadding = 30;
        const singleEnsembleWidth = ensembleWidth;
        const totalSystemWidth = singleEnsembleWidth + systemPadding * 2 + extraWidth;
        const gap = 80;
        viewboxWidth = totalSystemWidth * 2 + gap + 200; // Extra margin for comfort
      }

      // Fixed height based on screen width for better consistency
      const embedConfig = readEmbedConfig();
      const containerWidth = container.clientWidth || 800;

      // Calculate fixed height: use max viewbox dimensions to determine aspect ratio
      // Max viewbox is for 2 ensembles, 2 systems (vertical layout)
      const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
      const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
        CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
        CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
        CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
        CONFIG.gaps.bottomMargin;
      const maxViewboxHeight = maxSingleSystemHeight * 1.15; // Account for 2-system scaling
      const maxViewboxWidth = maxEnsembleWidth + 200;

      const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
      const baseHeight = containerWidth * maxAspectRatio;
      const legendHeight = embedConfig.initialFilter ? 150 : 200;

      // Set fixed height once, won't change on filter change
      if (!container.dataset.heightSet) {
        container.style.height = `${baseHeight + legendHeight}px`;
        container.dataset.heightSet = 'true';
      }

      // Viewbox will auto-center/zoom content
      let viewboxY = 0;
      let paddedViewboxHeight = viewboxHeight;
      const verticalPadding = 0;
      viewboxY = -verticalPadding / 2 + 100;
      paddedViewboxHeight = viewboxHeight + verticalPadding;

      // For single ensemble, shift content up slightly
      if (ensembleCount === 1 && systemCount === 1) {
        viewboxY += 150;  // Shift up by reducing viewboxY (reduced from 80)
      }

      // For single node mode (no Node/NUMA groups), shift content down by 80px
      // BUT only if: 1) not an EFA filter, 2) a filter is active
      const isEfaFilter = currentActivePathId === 'gpu-gpu-efa-intranode' || currentActivePathId === 'gpu-gpu-efa-internode';
      const hasActiveFilter = currentActivePathId && currentActivePathId !== '';
      if (!isInternodeLayout && hasActiveFilter && !isEfaFilter) {
        viewboxY -= 80;  // Shift down by decreasing viewboxY (increased from 50px)
      }

      const draw = SVG().addTo(container).size('100%', '100%').viewbox(0, viewboxY, viewboxWidth, paddedViewboxHeight);
      const renderer = new TopologyRenderer(draw);

      const centerX = viewboxWidth / 2;

      // Draw each system - horizontally for internode, vertically for others
      const isInternodeHorizontalLayout = isInternodeLayout;

      for (let sysIndex = 0; sysIndex < systemCount; sysIndex++) {
        let systemCenterX, cpuY, nvswitchY;

        if (isInternodeHorizontalLayout) {
          // Horizontal layout for internode: systems side by side (rapprochés mais sans overlap)
          // Pour internode, on affiche 1 seul ensemble (NUMA) par système, donc largeur réelle = 50%
          const fullSystemWidth = ensembleCount * ensembleWidth + (ensembleCount - 1) * CONFIG.gaps.ensembleGap;
          const actualSystemWidth = fullSystemWidth * 0.5; // On n'affiche qu'1 ensemble sur 2
          const extraWidth = 210; // Extension pour le groupe NUMA 1
          const systemPadding = 10;
          const totalSystemWidth = actualSystemWidth + systemPadding * 2 + extraWidth; // Largeur totale incluant l'extension
          const gap = 80; // Gap visible entre les systèmes

          // Positionner les systèmes avec le gap (en prenant en compte la largeur totale)
          if (sysIndex === 0) {
            systemCenterX = centerX - (totalSystemWidth / 2 + gap / 2); // Premier système à gauche
          } else {
            systemCenterX = centerX + (totalSystemWidth / 2 + gap / 2); // Deuxième système à droite
          }
          cpuY = CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        } else {
          // Vertical layout for other cases: systems stacked vertically
          const systemOffsetY = sysIndex * (singleSystemHeight + CONFIG.gaps.systemGap);
          systemCenterX = centerX;
          cpuY = systemOffsetY + CONFIG.gaps.topMargin + CONFIG.sizes.cpu / 2;
          nvswitchY = cpuY + CONFIG.sizes.cpu / 2 + CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
            CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height / 2 + CONFIG.gaps.gpuToNvswitch +
            CONFIG.sizes.nvswitch.height / 2;
        }

        // Only draw EFA cross-links for intranode EFA path
        const shouldDrawEfaCrossLinks = currentActivePathId === 'gpu-gpu-efa-intranode';
        drawSystem(renderer, sysIndex, systemCenterX, cpuY, nvswitchY, ensembleCount, systemCount, shouldDrawEfaCrossLinks);
      }

      // Draw EFA cross-link between systems (for internode)
      if (systemCount === 2 && ensembleCount === 2 && currentActivePathId === 'gpu-gpu-efa-internode') {
        const efaExt0Id = 'efa-external';  // System 0, ensemble 0, group 0
        const efaExt1Id = 'efa-external-8';  // System 1, ensemble 0, group 0 (4 groups per ensemble, 2 ensembles per system = group 8)

        // Use unified EFA cross-links function
        drawEfaCrossLinks(renderer, efaExt0Id, efaExt1Id, 'efa-crosslink');
      }

      currentEnsembleCount = ensembleCount;
      currentSystemCount = systemCount;
    }

    // ============================================================================
    // REAL BANDWIDTH HELPERS
    // ============================================================================
    function getRealBandwidthForPath(pathId) {
      const pathToRealBandwidth = {
        'cpu-gpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-cpu': { value: '14.2', unit: 'GB/s' },
        'gpu-gpu-nvswitch': { value: '786', unit: 'GB/s' },
        'gpu-gpu-efa-intranode': { value: '40', unit: 'GB/s' },
        'gpu-gpu-efa-internode': { value: '40', unit: 'GB/s' },
        'gpu-storage': { value: '14.2', unit: 'GB/s' },
        'cpu-storage': { value: '14.2', unit: 'GB/s' },
        'gpu-cpu-storage': { value: '14.2', unit: 'GB/s' }
      };

      const bandwidth = pathToRealBandwidth[pathId];
      if (bandwidth) {
        return {
          value: bandwidth.value,
          unit: bandwidth.unit
        };
      }
      return null;
    }

    // ============================================================================
    // HIGHLIGHT HELPERS
    // ============================================================================
    function highlightPath(path, pathLabel = '', pathId = '') {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear previous active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Ghost all base links and cross-links groups at once
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '0.35';

        // Increase stroke width of group borders to make them more visible when ghosted
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '5');
          // border.setAttribute('stroke-opacity', '0.8');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '0.25';
      }

      // Dim nodes individually (they're not in a group)
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '0.6';
        // Dim text labels
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '0.25';
        });
      });

      // Highlight path nodes
      path.nodes.forEach(nodeId => {
        let nodeEl = svg.querySelector(`g[id="${nodeId}"]`);
        if (!nodeEl) {
          const candidates = svg.querySelectorAll(`g[id^="${nodeId}"]`);
          nodeEl = candidates[0];
        }
        if (nodeEl) {
          nodeEl.style.opacity = '1';
          // Restore text opacity
          nodeEl.querySelectorAll('text').forEach(text => {
            text.style.opacity = '1';
          });
        }
      });

      // Duplicate active links into activeLinksGroup
      if (activeLinksGroup) {
        path.links.forEach(linkSpec => {
          // Find matching links in base groups
          const allBaseLinks = [
            ...svg.querySelectorAll('g[data-group="base-links"] > g[data-link-type]'),
            ...svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type]')
          ];

          allBaseLinks.forEach(linkGroup => {
            const linkFrom = linkGroup.getAttribute('data-from');
            const linkTo = linkGroup.getAttribute('data-to');

            const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
            const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

            if (matchesFrom && matchesTo) {
              // Clone the link and append to active group
              const clonedLink = linkGroup.cloneNode(true);
              activeLinksGroup.appendChild(clonedLink);
            }
          });
        });

        // Duplicate EFA cross-links if they match the current path
        const currentPathId = currentActivePathId;
        if (currentPathId === 'gpu-gpu-efa-intranode' || currentPathId === 'gpu-gpu-efa-internode') {
          const efaCrossLinks = svg.querySelectorAll('g[data-group="base-cross-links"] > g[data-link-type="efa-crosslink"]');
          efaCrossLinks.forEach(linkGroup => {
            const clonedLink = linkGroup.cloneNode(true);
            activeLinksGroup.appendChild(clonedLink);
          });
        }
      }

      // Calculate and show bottleneck (minimum bandwidth in the path)
      let minBandwidth = Infinity;
      let minBandwidthValue = null;
      const usedBandwidths = new Set();

      path.links.forEach(linkSpec => {
        svg.querySelectorAll('g[data-link-type]').forEach(linkGroup => {
          const linkFrom = linkGroup.getAttribute('data-from');
          const linkTo = linkGroup.getAttribute('data-to');

          const matchesFrom = linkFrom === linkSpec.from || linkFrom === `${linkSpec.from}`;
          const matchesTo = linkTo === linkSpec.to || linkTo === `${linkSpec.to}`;

          if (matchesFrom && matchesTo) {
            const bandwidth = linkGroup.getAttribute('data-bandwidth');
            if (bandwidth) {
              const bw = getBandwidth(bandwidth);
              if (bw && bw.numericValue < minBandwidth) {
                minBandwidth = bw.numericValue;
                minBandwidthValue = bw.speed;
              }
              if (bw) {
                usedBandwidths.add(bw.speed);
              }
            }
          }
        });
      });

      // Highlight all used bandwidths in the legend
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          const bandwidth = legendItem.getAttribute('data-legend-bandwidth');
          if (usedBandwidths.has(bandwidth)) {
            // Used in the path - active
            legendItem.style.opacity = '1';
          } else {
            // Not used - ghosted
            legendItem.style.opacity = '0.4';
          }
        });
      }

      // Show bottleneck info
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      const efficiencyValueEl = bottleneckEl.querySelector('.efficiency-value');

      // Check if real bandwidths are enabled
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (showRealBandwidths) {
        // When real bandwidths are shown, display real bandwidth value directly
        const realBandwidth = getRealBandwidthForPath(pathId);
        if (realBandwidth) {
          bottleneckValueEl.textContent = realBandwidth.value;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');

          // Calculate and display efficiency
          if (minBandwidthValue && efficiencyEl && efficiencyValueEl) {
            const theoreticalBandwidth = parseFloat(minBandwidthValue.replace('GB/s', ''));
            const realBandwidthNum = parseFloat(realBandwidth.value);

            // For EFA (12.5GB/s), multiply by 4 to get total theoretical bandwidth
            const adjustedTheoretical = minBandwidthValue === '12.5GB/s' ? theoreticalBandwidth * 4 : theoreticalBandwidth;

            const efficiency = (realBandwidthNum / adjustedTheoretical) * 100;
            efficiencyValueEl.textContent = `${efficiency.toFixed(1)}%`;
            efficiencyEl.style.display = 'block';
          }
        } else {
          // Fallback if no real bandwidth found
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckLabelEl.textContent = 'Real Bandwidth';
          bottleneckEl.classList.add('visible');
          if (efficiencyEl) {
            efficiencyEl.style.display = 'none';
          }
        }
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      } else {
        // Normal bottleneck display
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        if (minBandwidthValue) {
          const value = minBandwidthValue.replace('GB/s', '');
          // For EFA (12.5GB/s), display as 50 (4 links × 12.5)
          const displayValue = value === '12.5' ? '50' : value;
          bottleneckValueEl.textContent = displayValue;
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        } else {
          // Debug: show the module even without bandwidth data
          bottleneckValueEl.textContent = '?';
          bottleneckPathEl.textContent = `for ${pathLabel}`;
          bottleneckEl.classList.add('visible');
        }
        // Hide efficiency in normal mode
        if (efficiencyEl) {
          efficiencyEl.style.display = 'none';
        }
      }
    }

    function resetHighlight() {
      const svg = getElement('aws-topology-container').querySelector('svg');
      if (!svg) return;

      // Clear active links
      const activeLinksGroup = svg.querySelector('g[data-group="active-links"]');
      if (activeLinksGroup) {
        activeLinksGroup.innerHTML = '';
      }

      // Restore opacity to base links groups
      const baseLinksGroup = svg.querySelector('g[data-group="base-links"]');
      const baseCrossLinksGroup = svg.querySelector('g[data-group="base-cross-links"]');

      if (baseLinksGroup) {
        baseLinksGroup.style.opacity = '1';

        // Restore original stroke width for group borders
        baseLinksGroup.querySelectorAll('[data-group-border]').forEach(border => {
          border.setAttribute('stroke-width', '3');
          border.setAttribute('stroke-opacity', '1');
        });
      }
      if (baseCrossLinksGroup) {
        baseCrossLinksGroup.style.opacity = '1';
      }

      // Reset nodes opacity
      svg.querySelectorAll('g[data-node-type]').forEach(el => {
        el.style.opacity = '1';
        // Reset text opacity
        el.querySelectorAll('text').forEach(text => {
          text.style.opacity = '1';
        });
      });

      // Clear current active path to ensure EFA cross-links are not drawn
      currentActivePathId = null;

      // Reset legend opacity
      const legendContainer = getElement('aws-topology-legend');
      if (legendContainer) {
        legendContainer.querySelectorAll('g[data-legend-bandwidth]').forEach(legendItem => {
          legendItem.style.opacity = '1';
        });
      }

      // Hide bottleneck (unless real bandwidths are enabled)
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
      const embedConfig = readEmbedConfig();
      const showRealBandwidths = embedConfig.showRealBandwidths;

      if (!showRealBandwidths) {
        bottleneckLabelEl.textContent = 'Bandwidth Max';
        bottleneckEl.classList.remove('visible');
      } else {
        // When real bandwidths are enabled, hide the module when no path is active
        bottleneckLabelEl.textContent = 'Real Bandwidth';
        bottleneckEl.classList.remove('visible');
        // Hide the detailed real bandwidths list
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
      }

      // Hide efficiency display
      const efficiencyEl = bottleneckEl.querySelector('.bottleneck-efficiency');
      if (efficiencyEl) {
        efficiencyEl.style.display = 'none';
      }
    }

    // ============================================================================
    // CONFIG READING (from HtmlEmbed props)
    // ============================================================================
    function readEmbedConfig() {
      // Find the closest ancestor that carries the data-config attribute
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let providedConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          providedConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      const config = providedConfig || {};

      // Apply user override from checkbox if set
      if (showRealBandwidthsOverride !== null) {
        config.showRealBandwidths = showRealBandwidthsOverride;
      }

      return config;
    }

    // ============================================================================
    // REAL BANDWIDTHS DISPLAY
    // ============================================================================
    function displayContextualRealBandwidths(pathId, pathLabel) {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const bottleneckValueEl = bottleneckEl.querySelector('.bottleneck-value');
      const bottleneckPathEl = bottleneckEl.querySelector('.bottleneck-path');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Map path IDs to relevant real bandwidths
      const pathToBandwidths = {
        'cpu-gpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-cpu': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-GPU (via CPU)', value: CONFIG.realBandwidths['cpu-gpu'] }
        ],
        'gpu-gpu-nvswitch': [
          { label: 'GPU-GPU (NVSwitch)', value: CONFIG.realBandwidths['gpu-gpu-same-node'] }
        ],
        'gpu-gpu-efa-intranode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-intranode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
          { label: 'All2All', value: CONFIG.realBandwidths['all2all-same-node'] }
        ],
        'gpu-gpu-efa-internode': [
          { label: 'GPU-GPU (EFA)', value: CONFIG.realBandwidths['gpu-gpu-efa-internode'] },
          { label: 'AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
          { label: 'All2All', value: CONFIG.realBandwidths['alltoall-internode'] }
        ],
        'gpu-storage': [
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'cpu-storage': [
          { label: 'CPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ],
        'gpu-cpu-storage': [
          { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
          { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
        ]
      };

      const relevantBandwidths = pathToBandwidths[pathId] || [];

      if (relevantBandwidths.length > 0) {
        // Clear normal bottleneck display
        bottleneckValueEl.textContent = '';
        bottleneckPathEl.textContent = '';

        // Create HTML for relevant bandwidths
        const html = relevantBandwidths.map(item => `
          <div class="bandwidth-item">
            <span class="bandwidth-label">${item.label}</span>
            <span class="bandwidth-value">${item.value}</span>
          </div>
        `).join('');

        realBandwidthsContentEl.innerHTML = html;
      } else {
        // Fallback: show all bandwidths if path not found
        setupRealBandwidthsDisplay();
      }
    }

    function setupRealBandwidthsDisplay() {
      const bottleneckEl = getElement('aws-topology-bottleneck');
      const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');
      const realBandwidthsContentEl = bottleneckEl.querySelector('.real-bandwidths-content');

      if (!realBandwidthsEl || !realBandwidthsContentEl) return;

      // Show the real bandwidths section
      realBandwidthsEl.style.display = 'block';

      // Create the bandwidth items HTML
      const bandwidthItems = [
        { label: 'CPU-GPU', value: CONFIG.realBandwidths['cpu-gpu'] },
        { label: 'Same Node', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-same-node'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-same-node'] },
        { label: '  All2All', value: CONFIG.realBandwidths['all2all-same-node'] },
        { label: 'Internode', value: '' },
        { label: '  GPU-GPU', value: CONFIG.realBandwidths['gpu-gpu-internode'] },
        { label: '  AllReduce', value: CONFIG.realBandwidths['allreduce-internode'] },
        { label: '  All2All', value: CONFIG.realBandwidths['alltoall-internode'] },
        { label: 'GPU-Storage', value: CONFIG.realBandwidths['gpu-storage'] }
      ];

      const html = bandwidthItems.map(item => {
        if (item.value === '') {
          // Section header
          return `<div class="bandwidth-section-header" style="font-weight: 600; margin: 6px 0 4px 0; color: var(--text-secondary);">${item.label}</div>`;
        } else {
          // Bandwidth item
          return `
            <div class="bandwidth-item">
              <span class="bandwidth-label">${item.label}</span>
              <span class="bandwidth-value">${item.value}</span>
            </div>
          `;
        }
      }).join('');

      realBandwidthsContentEl.innerHTML = html;
    }

    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    function initialize() {
      const container = getElement('aws-topology-container');
      const tooltip = getElement('aws-topology-tooltip');

      // Read initial config from HtmlEmbed props (before any override)
      let mountEl = getElement('aws-topology-container');
      while (mountEl && !mountEl.getAttribute?.('data-config')) {
        mountEl = mountEl.parentElement;
      }

      let initialConfig = null;
      try {
        const cfg = mountEl && mountEl.getAttribute ? mountEl.getAttribute('data-config') : null;
        if (cfg && cfg.trim()) {
          initialConfig = cfg.trim().startsWith('{') ? JSON.parse(cfg) : cfg;
        }
      } catch (e) {
        console.error('Error parsing embed config:', e);
      }

      // Initialize override with initial config value (so checkbox is in sync)
      if (initialConfig && initialConfig.showRealBandwidths !== undefined) {
        showRealBandwidthsOverride = initialConfig.showRealBandwidths;
      }

      // Now read config (which will use override if set)
      const embedConfig = readEmbedConfig();

      // Setup real bandwidths display if enabled
      if (embedConfig.showRealBandwidths) {
        const bottleneckEl = getElement('aws-topology-bottleneck');
        const bottleneckLabelEl = bottleneckEl.querySelector('.bottleneck-label');
        const realBandwidthsEl = bottleneckEl.querySelector('.real-bandwidths');

        // Change label to "Real Bandwidth"
        bottleneckLabelEl.textContent = 'Real Bandwidth';

        // Hide the detailed real bandwidths list initially
        if (realBandwidthsEl) {
          realBandwidthsEl.style.display = 'none';
        }
        // Don't show the module initially - only when a path is selected
        bottleneckEl.classList.remove('visible');
      }

      drawTopology();

      // Initial fade in
      requestAnimationFrame(() => {
        container.style.opacity = '1';
      });

      // Setup tooltip

      container.addEventListener('mouseover', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          const bandwidth = target.getAttribute('data-bandwidth');
          const label = target.getAttribute('data-label');

          // Clear and rebuild tooltip content
          tooltip.innerHTML = '';

          if (label) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'tooltip-label';
            labelDiv.textContent = label;
            tooltip.appendChild(labelDiv);
          }

          const bandwidthDiv = document.createElement('div');
          bandwidthDiv.className = 'tooltip-bandwidth';
          bandwidthDiv.textContent = bandwidth;
          tooltip.appendChild(bandwidthDiv);

          tooltip.classList.add('visible');
        }
      });

      container.addEventListener('mousemove', (e) => {
        if (tooltip.classList.contains('visible')) {
          const rect = container.getBoundingClientRect();
          tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
          tooltip.style.top = (e.clientY - rect.top + 10) + 'px';
        }
      });

      container.addEventListener('mouseout', (e) => {
        const target = e.target.closest('[data-bandwidth]');
        if (target) {
          tooltip.classList.remove('visible');
        }
      });

      // Create control buttons organized by category
      const controlsContainer = getElement('aws-topology-controls');

      // Hide controls if an initial filter is provided
      if (embedConfig.initialFilter) {
        controlsContainer.style.display = 'none';
      } else {
        // Categorize paths
        const pathsByCategory = {
          intranode: [
            { id: 'cpu-gpu', label: CONFIG.paths['cpu-gpu'].label },
            { id: 'gpu-gpu-cpu', label: CONFIG.paths['gpu-gpu-cpu'].label },
            { id: 'gpu-gpu-nvswitch', label: CONFIG.paths['gpu-gpu-nvswitch'].label },
            { id: 'gpu-gpu-efa-intranode', label: CONFIG.paths['gpu-gpu-efa-intranode'].label }
          ],
          internode: [
            { id: 'gpu-gpu-efa-internode', label: CONFIG.paths['gpu-gpu-efa-internode'].label }
          ],
          storage: [
            { id: 'gpu-storage', label: CONFIG.paths['gpu-storage'].label },
            { id: 'cpu-storage', label: CONFIG.paths['cpu-storage'].label },
            { id: 'gpu-cpu-storage', label: CONFIG.paths['gpu-cpu-storage'].label }
          ]
        };

        // Create single select with prefixed options and checkbox
        const isChecked = showRealBandwidthsOverride === true || (showRealBandwidthsOverride === null && embedConfig.showRealBandwidths);
        const controlsHTML = `
          <div>
            <label id="real-bandwidth-label" style="display: flex; align-items: center; gap: 0px; font-size: 14px; color: var(--text-color); cursor: pointer; opacity: 0.3; transition: opacity 0.2s;">
              <input type="checkbox" id="real-bandwidth-toggle" ${isChecked ? 'checked' : ''} disabled>
              <span>Show Real Bandwidths</span>
            </label>
          </div>
          
          <div style="display: flex; gap: 12px; align-items: center; margin-top: 8px;">
            <select id="path-select" style="min-width: 250px;">
              <option value="">Select path...</option>
            </select>
          </div>
        `;
        controlsContainer.innerHTML = controlsHTML;

        const pathSelect = controlsContainer.querySelector('#path-select');
        const realBandwidthToggle = controlsContainer.querySelector('#real-bandwidth-toggle');
        const realBandwidthLabel = controlsContainer.querySelector('#real-bandwidth-label');

        // Populate single select with prefixed options
        Object.entries(pathsByCategory).forEach(([category, paths]) => {
          const categoryLabel = category.charAt(0).toUpperCase() + category.slice(1);

          paths.forEach(path => {
            const option = document.createElement('option');
            option.value = path.id;
            option.textContent = `${categoryLabel}: ${path.label}`;
            pathSelect.appendChild(option);
          });
        });

        // Helper function to enable/disable real bandwidth toggle
        const updateRealBandwidthToggleState = (enabled) => {
          if (enabled) {
            realBandwidthToggle.disabled = false;
            realBandwidthLabel.style.opacity = '1';
            realBandwidthLabel.style.cursor = 'pointer';
          } else {
            realBandwidthToggle.disabled = true;
            realBandwidthLabel.style.opacity = '0.3';
            realBandwidthLabel.style.cursor = 'default';
          }
        };

        // Real bandwidth toggle handler
        realBandwidthToggle.addEventListener('change', (e) => {
          showRealBandwidthsOverride = e.target.checked;

          // Re-apply highlight if a path is active
          if (currentActivePathId) {
            const path = CONFIG.paths[currentActivePathId];
            if (path) {
              highlightPath(path, path.label, currentActivePathId);
            }
          } else {
            // If no path active, just reset to clear any displayed values
            resetHighlight();
          }
        });

        // Function to activate a path
        const activatePath = (pathId) => {
          if (!pathId) {
            // Reset to default
            currentActivePathId = null;
            updateRealBandwidthToggleState(false); // Disable toggle when no path selected
            const needsRedraw = currentEnsembleCount !== 2 || currentSystemCount !== 1;

            if (needsRedraw) {
              const container = getElement('aws-topology-container');
              container.style.opacity = '0';

              setTimeout(() => {
                drawTopology(2, 1);
                resetHighlight();

                requestAnimationFrame(() => {
                  container.style.opacity = '1';
                });
              }, 150);
            } else {
              resetHighlight();
            }
            return;
          }

          const path = CONFIG.paths[pathId];
          if (!path) return;

          currentActivePathId = pathId;
          updateRealBandwidthToggleState(true); // Enable toggle when path is selected

          // Check if we need to redraw
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            pathId === 'gpu-gpu-efa-intranode' ||
            pathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            const container = getElement('aws-topology-container');
            container.style.opacity = '0';

            setTimeout(() => {
              currentActivePathId = pathId;
              drawTopology(path.requiredEnsembles, path.requiredSystems);
              highlightPath(path, path.label, pathId);

              requestAnimationFrame(() => {
                container.style.opacity = '1';
              });
            }, 150);
          } else {
            currentActivePathId = pathId;
            highlightPath(path, path.label, pathId);
          }
        };

        // Path select change handler
        pathSelect.addEventListener('change', (e) => {
          const pathId = e.target.value;
          activatePath(pathId);
        });
      }

      // Apply initial filter from embedConfig if provided
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          currentActivePathId = initialPathId;

          // Draw topology with correct requirements
          const needsRedraw = path.requiredEnsembles !== currentEnsembleCount ||
            path.requiredSystems !== currentSystemCount ||
            initialPathId === 'gpu-gpu-efa-intranode' ||
            initialPathId === 'gpu-gpu-efa-internode';

          if (needsRedraw) {
            drawTopology(path.requiredEnsembles, path.requiredSystems);
          }
        }
      }

      // Create SVG legend
      const legendContainer = getElement('aws-topology-legend');
      const legendSvg = SVG().addTo(legendContainer).size('100%', '100%');

      const lineLength = 36;  // 30 * 1.2
      const itemSpacing = 30;  // 25 * 1.2
      const startX = 96;  // 80 * 1.2
      const startY = 42;  // 35 * 1.2
      const textOffset = 24;  // 20 * 1.2

      // Calculate actual legend width based on content
      const legendWidth = startX + lineLength + textOffset + 168;  // 140 * 1.2
      const legendHeight = 144;  // 120 * 1.2
      legendSvg.viewbox(0, 0, legendWidth, legendHeight);

      [...CONFIG.bandwidths].reverse().forEach((bw, index) => {
        const y = startY + (index * itemSpacing);
        const color = CONFIG.colors.linkColor;  // Use primary color for all links
        const width = bw.width;

        // Create a group for each legend item with a data attribute for bandwidth
        const legendItemGroup = legendSvg.group();
        legendItemGroup.attr('data-legend-bandwidth', bw.speed);

        // Dessiner la ligne
        legendItemGroup.line(startX, y, startX + lineLength, y)
          .stroke({ color, width });

        // Dessiner les cercles aux extrémités
        const r = width * 0.8;
        const startCircle = legendItemGroup.circle(r * 2).move(startX - r, y - r);
        startCircle.fill(color);
        startCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        const endCircle = legendItemGroup.circle(r * 2).move(startX + lineLength - r, y - r);
        endCircle.fill(color);
        endCircle.stroke({ color: CONFIG.colors.linkCircleBorder, width: 0.5 });

        // Ajouter le texte (aligné à droite, valeur en gras)
        const textX = legendWidth - 5;
        const value = bw.speed.replace('GB/s', '').trim();

        // Format: "Label - 900 GB/s" avec 900 en gras
        const textEl = legendItemGroup.text(function (add) {
          add.tspan(bw.label + ' - ').font({ weight: 'normal' });
          add.tspan(value).font({ weight: 'bold' });
          add.tspan(' GB/s').font({ weight: 'normal' });
        })
          .move(textX, y)
          .font({
            family: 'system-ui, -apple-system, sans-serif',
            size: 14,  // 12 * 1.2 ≈ 14
            anchor: 'end',
            fill: CONFIG.colors.nodeText
          })
          .dy(-7);  // -6 * 1.2 ≈ -7
      });
    }

    // Initialize only if wrapper is found
    if (findWrapper()) {
      initialize();

      // Apply initial filter highlight after legend is created
      const embedConfig = readEmbedConfig();
      if (embedConfig.initialFilter) {
        const initialPathId = embedConfig.initialFilter;
        const path = CONFIG.paths[initialPathId];

        if (path) {
          // Apply highlight to both topology and legend
          highlightPath(path, path.label, initialPathId);
        }
      }

      // Add resize handler for responsive width changes (mobile/desktop)
      const handleResize = () => {
        const container = getElement('aws-topology-container');
        if (!container) return;

        // Recalculate fixed height based on new width (for responsive design)
        const containerWidth = container.clientWidth || 800;

        // Use max viewbox dimensions for consistent aspect ratio
        const maxEnsembleWidth = 2 * (CONFIG.groupCount * CONFIG.gaps.horizontal);
        const maxSingleSystemHeight = CONFIG.gaps.topMargin + CONFIG.sizes.cpu +
          CONFIG.gaps.cpuToPcie + CONFIG.sizes.pcie.height +
          CONFIG.gaps.pcieToGpu + CONFIG.sizes.gpu.height +
          CONFIG.gaps.gpuToNvswitch + CONFIG.sizes.nvswitch.height +
          CONFIG.gaps.bottomMargin;
        const maxViewboxHeight = maxSingleSystemHeight * 1.15;
        const maxViewboxWidth = maxEnsembleWidth + 200;

        const maxAspectRatio = maxViewboxHeight / maxViewboxWidth;
        const baseHeight = containerWidth * maxAspectRatio;
        const legendHeight = embedConfig.initialFilter ? 150 : 200;

        // Update height based on current width (responsive)
        container.style.height = `${baseHeight + legendHeight}px`;
      };

      // Use ResizeObserver for better performance (only for window resize, not content changes)
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => handleResize());
        ro.observe(findWrapper());
      } else {
        window.addEventListener('resize', handleResize);
      }
    } else {
      console.warn('AWS topology: wrapper not found, skipping initialization');
    }
  })();
</script></div></div></figure> </div>
<p>Now that we know how to identify bottlenecks in our hardware and software setup, lets see how we can go one step further and ensure we have a resilient system that can run stable for months.</p>
<h3 id="building-resilient-training-systems"><a href="#building-resilient-training-systems">Building Resilient Training Systems</a></h3>
<p>Having fast hardware is just the entry ticket to having good and stable infrastructure for LLM training. To go from a training amateur to a professional, we need to think beyond raw speed and focus on the less glamorous but critical infrastructure pieces that make the entire training experience smoother and with minimal downtime.</p>
<p>In this section, we shift from hardware &amp; software optimization to  <strong>production readiness</strong> : building systems  <strong>robust</strong>  enough to survive inevitable failures,  <strong>automated</strong>  enough to run without constant babysitting, and  <strong>flexible</strong>  enough to adapt when things go wrong.</p>
<h4 id="node-health-monitoring-and-replacement"><a href="#node-health-monitoring-and-replacement"><strong>Node Health Monitoring and Replacement</strong></a></h4>
<p>Having enough fast GPUs is important for training, but since LLM trainings run for weeks or months rather than single days, tracking GPU health over time becomes critical. GPUs that pass initial benchmarks can develop thermal throttling, memory errors, or performance degradation during extended training runs. In this section, we will share how we approach this challenge and the tools we use.</p>
<p><strong>Upfront tests:</strong>  Before launching SmolLM3, we ran comprehensive GPU diagnostics using multiple tools. We used <a href="https://github.com/huggingface/gpu-fryer">GPU Fryer</a>, an internal tool that stress-tests GPUs for thermal throttling, memory errors, and performance anomalies. We also ran <a href="https://docs.nvidia.com/datacenter/dcgm/latest/user-guide/dcgm-diagnostics.html">NVIDIA’s DCGM diagnostics</a>, a widely-used tool for validating GPU hardware, monitoring performance, and identifying root causes of failures or power anomalies through deep diagnostic tests covering compute, PCIe connectivity, memory integrity, and thermal stability. These upfront tests caught two problematic GPUs that would have caused issues during training.</p>
<p>You can see in the following table what can be tested with the DCGM diagnostic tool:</p>











































































<div class="table-scroll"><table><thead><tr><th>Test Level</th><th>Duration</th><th>Software</th><th>PCIe + NVLink</th><th>GPU Memory</th><th>Memory Bandwidth</th><th>Diagnostics</th><th>Targeted Stress</th><th>Targeted Power</th><th>NVBandwidth</th><th>Memory Stress</th><th>Input EDPp</th></tr></thead><tbody><tr><td>r1 (Short)</td><td>Seconds</td><td>✓</td><td>✓</td><td>✓</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>r2 (Medium)</td><td>&lt; 2 mins</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>r3 (Long)</td><td>&lt; 30 mins</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td></td><td></td></tr><tr><td>r4 (Extra Long)</td><td>1-2 hours</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr></tbody></table></div>
<p><em>DCGM diagnostic run levels. Source:</em> <a href="https://docs.nvidia.com/datacenter/dcgm/latest/user-guide/dcgm-diagnostics.html#run-levels-and-tests"> <em>NVIDIA DCGM Documentation</em> </a></p>
<div class="code-card"><button class="code-copy button--ghost" type="button" aria-label="Copy code"><svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button><pre class="astro-code astro-code-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;overflow-x:auto" tabindex="0" data-language="plaintext"><code><span class="line"><span>$ dcgmi diag -r 2 -v -d VERB</span></span>
<span class="line"><span>Successfully ran diagnostic for group.</span></span>
<span class="line"><span>+---------------------------+------------------------------------------------+</span></span>
<span class="line"><span>| Diagnostic | Result |</span></span>
<span class="line"><span>+===========================+================================================+</span></span>
<span class="line"><span>| -----  Metadata  ----------+------------------------------------------------ |</span></span>
<span class="line"><span>| DCGM Version | 3.3.1 |</span></span>
<span class="line"><span>| Driver Version Detected | 575.57.08 |</span></span>
<span class="line"><span>| GPU Device IDs Detected | 2330,2330,2330,2330,2330,2330,2330,2330 |</span></span>
<span class="line"><span>| -----  Deployment  --------+------------------------------------------------ |</span></span>
<span class="line"><span>| Denylist | Pass |</span></span>
<span class="line"><span>| NVML Library | Pass |</span></span>
<span class="line"><span>| CUDA Main Library | Pass |</span></span>
<span class="line"><span>| Permissions and OS Blocks | Pass |</span></span>
<span class="line"><span>| Persistence Mode | Pass |</span></span>
<span class="line"><span>| Environment Variables | Pass |</span></span>
<span class="line"><span>| Page Retirement/Row Remap | Pass |</span></span>
<span class="line"><span>| Graphics Processes | Pass |</span></span>
<span class="line"><span>| Inforom | Pass |</span></span>
<span class="line"><span></span></span>
<span class="line"><span>+-----  Integration  -------+------------------------------------------------+</span></span>
<span class="line"><span>| PCIe | Pass - All |</span></span>
<span class="line"><span>| Info | GPU 0 GPU to Host bandwidth:  14.26 GB/s, GPU |</span></span>
<span class="line"><span>| 0 Host to GPU bandwidth:  8.66 GB/s, GPU 0 b |</span></span>
<span class="line"><span>| idirectional bandwidth: 10.91 GB/s, GPU 0 GPU |</span></span>
<span class="line"><span>| to Host latency:  2.085 us, GPU 0 Host to GP |</span></span>
<span class="line"><span>| U latency:  2.484 us, GPU 0 bidirectional lat |</span></span>
<span class="line"><span>| ency:  3.813 us |</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>+-----  Hardware  ----------+------------------------------------------------+</span></span>
<span class="line"><span>| GPU Memory | Pass - All |</span></span>
<span class="line"><span>| Info | GPU 0 Allocated 83892938283 bytes (98.4%) |</span></span>
<span class="line"><span>| Info | GPU 1 Allocated 83892938283 bytes (98.4%) |</span></span>
<span class="line"><span>| Info | GPU 2 Allocated 83892938283 bytes (98.4%) |</span></span>
<span class="line"><span>| Info | GPU 3 Allocated 83892938283 bytes (98.4%) |</span></span>
<span class="line"><span>| Info | GPU 4 Allocated 83892938283 bytes (98.4%) |</span></span>
<span class="line"><span>| Info | GPU 5 Allocated 83892938283 bytes (98.4%) |</span></span>
<span class="line"><span>| Info | GPU 6 Allocated 83892938283 bytes (98.4%) |</span></span>
<span class="line"><span>| Info | GPU 7 Allocated 83892938283 bytes (98.4%) |</span></span>
<span class="line"><span></span></span>
<span class="line"><span>+-----  Stress  ------------+------------------------------------------------+</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre></div>
<p><strong>Node reservation:</strong>  Because SmolLM3 was trained on a Slurm managed cluster, we booked a fixed 48-node reservation for the entire run. This setup allowed us to track the health and performance of the exact same nodes over time, it was also necessary to solve a data storage issues we discussed. We also reserved a spare node (like a car’s spare wheel) so if one failed, we could swap it in immediately without waiting for repairs. While idle, the spare node ran eval jobs or dev experiments.</p>
<p><strong>Continuous monitoring:</strong>  During training, we tracked key metrics across all nodes such as GPU temperatures, memory usage, compute utilization and throughput fluctuations. We use <a href="https://prometheus.io/">Prometheus</a> to collect <a href="https://github.com/NVIDIA/DCGM">DCGM</a> metrics from all GPUs and visualize them in <a href="https://grafana.com/">Grafana</a> dashboards for real-time monitoring. For detailed setup instructions on deploying Prometheus and Grafana for GPU monitoring on AWS infrastructure, see <a href="https://github.com/aws-samples/awsome-distributed-training/tree/3ae961d022399021cc4053c3ba19b182ca6b8dc8/4.validation_and_observability/4.prometheus-grafana">this example setup guide</a>. A Slack bot alerted us when any node showed suspicious behavior, allowing us to proactively replace failing hardware before it crashed the entire training run.</p>
<p><a href="/screencapture-grafana-huggingface.pdf" target="_blank">Access to dashboard</a>
This multi-layered approach meant hardware issues became manageable interruptions.</p>
<p><strong>Thermal Reality Check: When GPUs Slow Down</strong></p>
<p>Marketing specs assume perfect cooling, but reality is messier. GPUs automatically reduce clock speeds when they overheat, cutting performance below theoretical maximums even in well-designed systems.</p>
<div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <div class="ri-root" data-ri-root="ri_hrmsirzv2m9" data-astro-cid-6kov3kig> <span class="img-dl-wrap" data-astro-cid-6kov3kig> <img src="./_astro/image_27d1384e-bcac-80b1-9ffb-ec29d0021ccc.D54wWyJ9_2jmnNO.webp" alt="Image" data-zoomable="1" data-downloadable="1" data-download-src="./_astro/image_27d1384e-bcac-80b1-9ffb-ec29d0021ccc.D54wWyJ9.png" data-astro-cid-6kov3kig width="1800" height="1036" loading="lazy" decoding="async"> <button type="button" class="button img-dl-btn" aria-label="Download image" title="Download image" data-astro-cid-6kov3kig> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" data-astro-cid-6kov3kig> <path d="M12 16c-.26 0-.52-.11-.71-.29l-5-5a1 1 0 0 1 1.42-1.42L11 12.59V4a1 1 0 1 1 2 0v8.59l3.29-3.3a1 1 0 1 1 1.42 1.42l-5 5c-.19.18-.45.29-.71.29zM5 20a1 1 0 1 1 0-2h14a1 1 0 1 1 0 2H5z" data-astro-cid-6kov3kig></path> </svg> </button> </span> </div> <script>
  (() => {
    const scriptEl = document.currentScript;
    const root = scriptEl ? scriptEl.previousElementSibling : null;
    if (!root) {
      console.log("Figure script: No root element found, exiting");
      return;
    }
    const img =
      root.tagName === "IMG"
        ? root
        : root.querySelector
          ? root.querySelector("img")
          : null;
    if (!img) {
      console.log("Figure script: No img element found, exiting");
      return;
    }

    // medium-zoom integration scoped to this image only
    const ensureMediumZoomReady = (cb) => {
      // @ts-ignore
      if (window.mediumZoom) return cb();
      const retry = () => {
        // @ts-ignore
        if (window.mediumZoom) cb();
        else setTimeout(retry, 30);
      };
      retry();
    };

    const initZoomIfNeeded = () => {
      if (img.getAttribute("data-zoomable") !== "1") return;
      const isDark =
        document.documentElement.getAttribute("data-theme") === "dark";
      const background = isDark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)";
      ensureMediumZoomReady(() => {
        // @ts-ignore
        const instance = window.mediumZoom
          ? window.mediumZoom(img, { background, margin: 24, scrollOffset: 0 })
          : null;
        if (!instance) return;
        let onScrollLike;
        const attachCloseOnScroll = () => {
          if (onScrollLike) return;
          onScrollLike = () => {
            try {
              instance.close && instance.close();
            } catch {}
          };
          window.addEventListener("wheel", onScrollLike, { passive: true });
          window.addEventListener("touchmove", onScrollLike, { passive: true });
          window.addEventListener("scroll", onScrollLike, { passive: true });
        };
        const detachCloseOnScroll = () => {
          if (!onScrollLike) return;
          window.removeEventListener("wheel", onScrollLike);
          window.removeEventListener("touchmove", onScrollLike);
          window.removeEventListener("scroll", onScrollLike);
          onScrollLike = null;
        };
        try {
          instance.on && instance.on("open", attachCloseOnScroll);
        } catch {}
        try {
          instance.on && instance.on("close", detachCloseOnScroll);
        } catch {}
        const themeObserver = new MutationObserver(() => {
          const dark =
            document.documentElement.getAttribute("data-theme") === "dark";
          try {
            instance.update &&
              instance.update({
                background: dark ? "rgba(0,0,0,.9)" : "rgba(0,0,0,.85)",
              });
          } catch {}
        });
        themeObserver.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ["data-theme"],
        });
      });
    };

    // Global zoom management to hide other Figures
    const setupGlobalZoomBehavior = () => {
      img.addEventListener("click", () => {
        if (img.getAttribute("data-zoomable") === "1") {
          // Enlever zoom-active de tous les autres ri-root
          document
            .querySelectorAll(".ri-root.zoom-active")
            .forEach((el) => el.classList.remove("zoom-active"));

          // Add zoom-active to this ri-root
          root.classList.add("zoom-active");
        }
      });
    };

    // Download button handler
    const dlBtn = root.querySelector ? root.querySelector(".img-dl-btn") : null;
    if (dlBtn) {
      dlBtn.addEventListener("click", async (ev) => {
        try {
          ev.preventDefault();
          ev.stopPropagation();
          const pickHrefAndName = () => {
            const current = img.currentSrc || img.src || "";
            let href = img.getAttribute("data-download-src") || current;
            const deriveName = () => {
              try {
                const u = new URL(current, location.href);
                const rawHref = u.searchParams.get("href");
                const candidate = rawHref
                  ? decodeURIComponent(rawHref)
                  : u.pathname;
                const last = String(candidate).split("/").pop() || "";
                const base = last.split("?")[0].split("#")[0];
                const m = base.match(
                  /^(.+?\.(?:png|jpe?g|webp|avif|gif|svg))(?:[._-].*)?$/i,
                );
                if (m && m[1]) return m[1];
                return base || "image";
              } catch {
                return "image";
              }
            };
            const name = img.getAttribute("data-download-name") || deriveName();
            return { href, name };
          };
          const picked = pickHrefAndName();
          const res = await fetch(picked.href, { credentials: "same-origin" });
          const blob = await res.blob();
          const objectUrl = URL.createObjectURL(blob);
          const tmp = document.createElement("a");
          tmp.href = objectUrl;
          tmp.download = picked.name || "image";
          tmp.target = "_self";
          tmp.rel = "noopener";
          tmp.style.display = "none";
          document.body.appendChild(tmp);
          tmp.click();
          setTimeout(() => {
            URL.revokeObjectURL(objectUrl);
            tmp.remove();
          }, 1000);
        } catch {}
      });
    }

    // Setup comportement zoom
    setupGlobalZoomBehavior();

    if (document.readyState === "complete") initZoomIfNeeded();
    else window.addEventListener("load", initZoomIfNeeded, { once: true });
  })();
</script>  </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>This Grafana dashboard shows thermal throttling events across our GPU cluster. The bars in the bottom panel indicate when GPUs automatically reduced clock speeds due to overheating.</figcaption> </figure> </div> 
<p>We monitor the  <code>DCGM_FI_DEV_CLOCK_THROTTLE_REASONS</code>  metric from <a href="https://github.com/NVIDIA/DCGM/tree/master">NVIDIA’s DCGM</a> to detect thermal throttling. When this metric shows non-zero values, the GPUs are automatically reducing clock speeds due to overheating. The dashboard above shows how these throttling events manifest in practice.</p>
<p>Thermal throttling doesn’t just hurt the affected GPU; it cascades across your entire distributed training setup. During our testing, we observed how a single throttling node can dramatically impact collective communication performance.</p>
<figure class="html-embed"><div class="html-embed__card"><div id="frag-nmlxm16qssg"><div class="nccl-all-reduce-bandwidth-plot-throttling"></div>
<style>
  .nccl-all-reduce-bandwidth-plot-throttling {
    position: relative;
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 16px;
  }

  .nccl-all-reduce-bandwidth-plot-throttling .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-top: 16px;
  }

  .nccl-all-reduce-bandwidth-plot-throttling .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
  }

  .nccl-all-reduce-bandwidth-plot-throttling .legend-swatch {
    width: 12px;
    height: 12px;
    border-radius: 2px;
  }

  .nccl-all-reduce-bandwidth-plot-throttling .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .nccl-all-reduce-bandwidth-plot-throttling .tick {
    font-size: 11px;
    fill: var(--muted-color);
  }

  .nccl-all-reduce-bandwidth-plot-throttling .grid-line {
    stroke: var(--grid-color);
    stroke-width: 1;
    shape-rendering: crispEdges;
  }

  .nccl-all-reduce-bandwidth-plot-throttling .reference-line {
    stroke: #e74c3c;
    stroke-width: 2;
    stroke-dasharray: 4, 4;
    opacity: 0.8;
  }
</style>
<script>
  (() => {
    // Prevent multiple executions
    if (window.ncclAllReduceThrottlingInitialized) return;
    window.ncclAllReduceThrottlingInitialized = true;

    // Load D3 from CDN once
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('nccl-all-reduce-bandwidth-plot-throttling'))) {
        const cs = Array.from(document.querySelectorAll('.nccl-all-reduce-bandwidth-plot-throttling')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      let tipInner;
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'd3-tooltip';
        Object.assign(tip.style, {
          position: 'absolute',
          top: '0px',
          left: '0px',
          transform: 'translate(-9999px, -9999px)',
          pointerEvents: 'none',
          padding: '8px 10px',
          borderRadius: '8px',
          fontSize: '12px',
          lineHeight: '1.35',
          border: '1px solid var(--border-color)',
          background: 'var(--surface-bg)',
          color: 'var(--text-color)',
          boxShadow: '0 4px 24px rgba(0,0,0,.18)',
          opacity: '0',
          transition: 'opacity .12s ease'
        });
        tipInner = document.createElement('div');
        tipInner.className = 'd3-tooltip__inner';
        tipInner.style.textAlign = 'left';
        tip.appendChild(tipInner);
        container.appendChild(tip);
      } else {
        tipInner = tip.querySelector('.d3-tooltip__inner') || tip;
      }

      // No header

      // Create SVG
      const svg = d3.select(container).append('svg').attr('width', '100%').style('display', 'block');
      const gRoot = svg.append('g');
      const gGrid = gRoot.append('g');
      const gAxes = gRoot.append('g');
      const gLines = gRoot.append('g');

      let data = {};
      let currentColors = [];

      // Color palette
      const getColors = () => {
        try {
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            return window.ColorPalettes.getColors('categorical', 26);
          }
        } catch (_) { }
        return d3.schemeCategory20;
      };

      // Format functions
      const formatBytes = (bytes) => {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
      };

      const formatBandwidth = (gbps) => {
        return `${gbps.toFixed(1)} GB/s`;
      };

      // Load data
      async function loadData() {
        try {
          const response = await fetch('./data/nccl-all-reduce-throttling-bandwidth.json');
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          data = await response.json();
          console.log('NCCL throttling data loaded:', data);
          render();
        } catch (error) {
          console.error('Error loading NCCL throttling data:', error);
        }
      }

      function updateSize() {
        const width = container.clientWidth || 800;
        const height = 300;
        const margin = { top: 20, right: 20, bottom: 70, left: 80 };

        svg
          .attr('viewBox', `0 0 ${width} ${height}`)
          .attr('preserveAspectRatio', 'xMidYMid meet')
          .style('width', '100%')
          .style('height', 'auto');

        gRoot.attr('transform', `translate(${margin.left},${margin.top})`);

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        return { innerWidth, innerHeight };
      }

      function render() {
        if (!data.data) return;

        const { innerWidth, innerHeight } = updateSize();
        
        // Prepare series data
        const series = [];
        const nodeKeys = Object.keys(data.data).sort((a, b) => {
          const aNum = parseInt(a.replace('nodes_', ''));
          const bNum = parseInt(b.replace('nodes_', ''));
          return aNum - bNum;
        });

        nodeKeys.forEach(nodeKey => {
          const nodeData = data.data[nodeKey];
          if (nodeData && nodeData.length > 0) {
            series.push({
              name: nodeKey.replace('nodes_', '') + ' nodes',
              key: nodeKey,
              data: nodeData
            });
          }
        });

        if (series.length === 0) return;

        // Get colors
        currentColors = getColors();

        // Calculate domains
        const allSizes = series.flatMap(s => s.data.map(d => d.messageSize));
        const allBandwidths = series.flatMap(s => s.data.map(d => d.bandwidth));
        
        const minSize = d3.min(allSizes);
        const maxSize = d3.max(allSizes);
        const maxBandwidth = d3.max(allBandwidths);

        // Scales
        const xScale = d3.scaleLog().domain([minSize, maxSize]).range([0, innerWidth]);
        const yScale = d3.scaleLinear().domain([0, Math.min(500, Math.ceil(maxBandwidth * 1.1))]).range([innerHeight, 0]);

        // Clear previous content
        gGrid.selectAll('*').remove();
        gAxes.selectAll('*').remove();
        gLines.selectAll('*').remove();

        // Grid lines
        const xTicks = xScale.ticks(8);
        const yTicks = yScale.ticks(6);

        gGrid.selectAll('line.x')
          .data(xTicks)
          .join('line')
          .attr('class', 'grid-line')
          .attr('x1', d => xScale(d))
          .attr('x2', d => xScale(d))
          .attr('y1', 0)
          .attr('y2', innerHeight);

        gGrid.selectAll('line.y')
          .data(yTicks)
          .join('line')
          .attr('class', 'grid-line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', d => yScale(d))
          .attr('y2', d => yScale(d));

        // Reference line (max theoretical bandwidth)
        const maxTheoreticalBandwidth = 485; // GB/s
        gLines.append('line')
          .attr('class', 'reference-line')
          .attr('x1', 0)
          .attr('x2', innerWidth)
          .attr('y1', yScale(maxTheoreticalBandwidth))
          .attr('y2', yScale(maxTheoreticalBandwidth));

        // Data lines
        const line = d3.line()
          .x(d => xScale(d.messageSize))
          .y(d => yScale(d.bandwidth))
          .curve(d3.curveLinear);

        series.forEach((s, i) => {
          gLines.append('path')
            .datum(s.data)
            .attr('fill', 'none')
            .attr('stroke', currentColors[i % currentColors.length])
            .attr('stroke-width', 2)
            .attr('d', line)
            .on('mouseover', function(event, d) {
              d3.select(this).attr('stroke-width', 3);
            })
            .on('mouseout', function(event, d) {
              d3.select(this).attr('stroke-width', 2);
            });
        });

        // X axis
        gAxes.append('g')
          .attr('transform', `translate(0,${innerHeight})`)
          .call(d3.axisBottom(xScale)
            .tickFormat(formatBytes)
            .ticks(8))
          .call(g => {
            g.selectAll('path, line').attr('stroke', 'var(--axis-color)');
            g.selectAll('text')
              .attr('fill', 'var(--muted-color)')
              .style('font-size', '10px')
              .attr('transform', 'rotate(-45)')
              .style('text-anchor', 'end')
              .attr('dx', '-8px');
          });

        // Y axis
        gAxes.append('g')
          .call(d3.axisLeft(yScale)
            .tickFormat(d => `${d} GB/s`)
            .ticks(6))
          .call(g => {
            g.selectAll('path, line').attr('stroke', 'var(--axis-color)');
            g.selectAll('text').attr('fill', 'var(--muted-color)').style('font-size', '11px');
          });

        // Axis labels
        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('text-anchor', 'middle')
          .attr('x', innerWidth / 2)
          .attr('y', innerHeight + 55)
          .text('Message Size (bytes)');

        gAxes.append('text')
          .attr('class', 'axis-label')
          .attr('text-anchor', 'middle')
          .attr('transform', `translate(${-60}, ${innerHeight / 2}) rotate(-90)`)
          .text('Bandwidth (GB/s)');

        // Legend with individual colored lines (outside the chart container)
        const legendContainer = container.parentNode.querySelector('.nccl-legend') || 
          (() => {
            const legend = document.createElement('div');
            legend.className = 'nccl-legend';
            legend.style.cssText = `
              margin-top: 20px;
              display: flex;
              flex-direction: column;
              align-items: center;
            `;
            container.parentNode.insertBefore(legend, container.nextSibling);
            return legend;
          })();
        
        // Create legend with individual colored lines
        const legendWidth = Math.min(innerWidth * 0.8, 600);
        const legendHeight = 30;
        const lineHeight = 5; // Height of each colored line
        const lineY = 0; // Y position of the lines
        
        // Calculate spacing between items
        const numItems = series.length;
        const itemWidth = legendWidth / numItems;
        
        legendContainer.innerHTML = `
          <div style="font-size: 12px; font-weight: 600; color: var(--text-color); margin-bottom: 12px;">Number of Nodes</div>
          <svg width="${legendWidth}" height="${legendHeight}" style="display: block; overflow:visible!important;">
            <!-- Individual colored lines and labels -->
            ${series.map((s, i) => {
              const x = (i + 0.5) * itemWidth;
              const lineWidth = itemWidth * 0.5; // 70% of available space for each line
              const lineX = i * itemWidth + (itemWidth - lineWidth) / 2;
              const nodeCount = s.name.replace(' nodes', '');
              const color = currentColors[i % currentColors.length];
              
              return `
                <!-- Colored line -->
                <line x1="${lineX}" y1="${lineY}" x2="${lineX + lineWidth}" y2="${lineY}" 
                      stroke="${color}" stroke-width="${lineHeight}" stroke-linecap="round" />
                
                <!-- Label -->
                <text x="${x}" y="${lineY + 20}" 
                      text-anchor="middle" 
                      font-size="11px" 
                      font-weight="600"
                      fill="var(--text-color)">${nodeCount}</text>
              `;
            }).join('')}
          </svg>
        `;
      }

      // Initial load
      loadData();

      // Resize handling
      const rerender = () => render();
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => rerender());
        ro.observe(container);
      } else {
        window.addEventListener('resize', rerender);
      }
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div><figcaption class="html-embed__desc" style="text-align:left">AllReduce bandwidth degradation across nodes during our stress testing. The sharp drop after 14 nodes (from 350 GB/s to 100 GB/s) was caused by a single thermally throttled GPU, demonstrating how one slow node can bottleneck the entire distributed training pipeline.</figcaption></figure>
<p>The chart above shows AllReduce bandwidth degrading as we scale from 1 to 16 nodes. Notice the sharp drop after 14 nodes, from 350 GB/s to 100 GB/s while we expect the bandwidth to stay above 300GB/s as we’ve seen before. This wasn’t a network issue: a single node with thermal throttling became the bottleneck, forcing all other nodes to wait during gradient synchronization. In distributed training, you’re only as fast as your slowest node.</p>
<p>👉  <strong>Key lesson:</strong>  Before committing to long training runs, stress-test your hardware using the tools mentioned earlier to identify thermal and power limitations. Monitor temperatures continuously using DCGM telemetry and plan for real-world thermal limits. It’s also good practice to verify that GPU clocks are set to maximum performance. For a deeper dive into why GPUs can’t sustain their advertised performance due to power constraints, see <a href="https://www.thonking.ai/p/strangely-matrix-multiplications">this excellent analysis on power throttling</a>.</p>
<h4 id="checkpoint-management"><a href="#checkpoint-management"><strong>Checkpoint Management</strong></a></h4>
<p>Checkpoints are our safety net during long training runs. We save them regularly for three practical reasons: recovering from failures, monitoring training progress through evaluation and sharing intermediate models with the community for research. The recovery aspect matters most. If our run fails, we want to restart from the latest saved checkpoint so we lose at most the save interval if we resume immediately (e.g., 4 hours of training if we save every 4 hours).</p>
<div class="note note--tip" data-astro-cid-qg6lmfty> <!-- When there's a title, emoji is inline with title -->
    <div class="note__body" data-astro-cid-qg6lmfty> <div class="note__header" data-astro-cid-qg6lmfty> <span class="note__emoji-inline" aria-hidden="true" data-astro-cid-qg6lmfty>💡</span> <div class="note__title" data-astro-cid-qg6lmfty>Automate your resume process</div> </div> <div class="note__content" data-astro-cid-qg6lmfty> <p>Try to automate your resume process. On Slurm, for example, you can you can just use <code>SBATCH --requeue</code> so the job restarts automatically from the latest checkpoint. That way, you avoid losing time waiting for someone to notice the failure and manually restart.</p> </div> </div> </div> 
<p>There’s two important details to keep in mind when implementing your resume mechanism:</p>
<ul>
<li>Checkpoint saving should happen in the background without impacting training throughput.</li>
<li>Watch your storage, over a 24-day run, saving every 4 hours means ~144 checkpoints. With large models and optimizer states, this adds up fast. In our case, we store only one local checkpoint (the latest saved) at a time and offload the rest to S3 to avoid filling up cluster storage.</li>
</ul>
<p><strong>A painful lesson from the past:</strong></p>
<p>During our first large-scale run (StarCoder 15B), training proceeded smoothly through multiple restarts. On the final day, we discovered the entire checkpoint folder had been deleted by a leftover  <code>rm -rf $CHECKPOINT_PATH</code>  command at the very end of the script from old throughput tests. This destructive command only triggered when the Slurm job actually finished, which hadn’t happened in previous restarts.</p>
<p>Luckily, we had the checkpoint from the day before saved, so it only cost us one day of retraining. The takeaways were clear: never leave destructive commands in production scripts, and automate checkpoint backups immediately after saving rather than relying on manual intervention.</p>
<p>In our nanotron trainings, we save checkpoints every 2 hours locally, immediately upload each one to S3, then delete the local copy once backup is confirmed. On resume, we pull from S3 if the latest checkpoint isn’t available locally. This approach saves storage, ensures backups, and enables quick recovery.</p>
<h4 id="automated-evaluations"><a href="#automated-evaluations"><strong>Automated Evaluations</strong></a></h4>
<p>Running evaluations manually becomes a bottleneck fast. They look simple until you’re doing them repeatedly. Running benchmarks, tracking and plotting results for every run adds up to significant overhead. The solution? Automate everything upfront.</p>
<p>For SmolLM3, we use <a href="https://github.com/huggingface/lighteval">LightEval</a> to run evaluations on nanotron checkpoints. Every saved checkpoint triggers an evaluation job on the cluster. The results are pushed directly to Weights &amp; Biases or <a href="https://github.com/gradio-app/trackio">Trackio</a>, so we just open the dashboard and watch the curves evolve. This saved us a huge amount of time and kept eval tracking consistent throughout the run.</p>
<p>If you can automate only one thing in your training setup, automate evaluations.</p>
<p>Finally, lets have a look at how we can optimize the training layout, ie how the model is distributed across the available GPUs, to maximize the throughput.</p>
<h3 id="optimizing-training-throughput"><a href="#optimizing-training-throughput">Optimizing Training Throughput</a></h3>
<h4 id="how-many-gpus-do-we-need"><a href="#how-many-gpus-do-we-need"><strong>How Many GPUs Do We Need?</strong></a></h4>
<p>Great question! After all this talk about specs and benchmarks, you still need to figure out the practical question: how many GPUs should you actually rent or buy?</p>
<p>Determining the right number of GPUs requires balancing training time, cost, and scaling efficiency. Here’s the framework we used:</p>
<p><strong>Basic Sizing Formula:</strong></p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>GPU Count</mtext><mo>=</mo><mfrac><mtext>Total FLOPs Required</mtext><mrow><mtext>Per-GPU Throughput</mtext><mo>×</mo><mtext>Target Training Time</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{GPU Count} = \frac{\text{Total FLOPs Required}}{\text{Per-GPU Throughput} \times \text{Target Training Time}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord text"><span class="mord">GPU Count</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.2519em;vertical-align:-0.8804em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord text"><span class="mord">Per-GPU Throughput</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord text"><span class="mord">Target Training Time</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord text"><span class="mord">Total FLOPs Required</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<p>This formula breaks down the problem into three key components:</p>
<ul>
<li><strong>Total FLOPs Required</strong> : The computational work needed to train your model (depends on model size, training tokens, and architecture)</li>
<li><strong>Per-GPU Throughput</strong> : How many FLOPs per second each GPU can actually deliver (not theoretical peak!)</li>
<li><strong>Target Training Time</strong> : How long you’re willing to wait for training to complete</li>
</ul>
<p>The key insight: you need to estimate  <strong>realistic throughput</strong> , not peak specs. This means accounting for Model FLOPs Utilization (MFU): the percentage of theoretical peak performance you actually achieve in practice.</p>
<p>For SmolLM3, our calculation looked like this:</p>
<ul>
<li><strong>Model size</strong> : 3B parameters</li>
<li><strong>Training tokens</strong> : 11 trillion tokens</li>
<li><strong>Target training time</strong> : ~4 weeks</li>
<li><strong>Expected MFU</strong> : 30% (based on similar scale experiments)</li>
</ul>
<p>First, we calculate total FLOPs needed using the standard transformer approximation of  <strong>6N FLOPs per token</strong>  (where N = parameters):</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Total FLOPs</mtext><mo>=</mo><mn>6</mn><mo>×</mo><mn>3</mn><mo>×</mo><msup><mn>10</mn><mn>9</mn></msup><mtext> params</mtext><mo>×</mo><mn>11</mn><mo>×</mo><msup><mn>10</mn><mn>12</mn></msup><mtext> tokens</mtext><mo>=</mo><mn>1.98</mn><mo>×</mo><msup><mn>10</mn><mn>23</mn></msup><mtext> FLOPs</mtext></mrow><annotation encoding="application/x-tex">\text{Total FLOPs} = 6 \times 3 \times 10^9 \text{ params} \times 11 \times 10^{12} \text{ tokens} = 1.98 \times 10^{23} \text{ FLOPs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord text"><span class="mord">Total FLOPs</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.0585em;vertical-align:-0.1944em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> params</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">11</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8641em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> tokens</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">1.98</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8641em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">23</span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> FLOPs</span></span></span></span></span></span>
<p>With our expected MFU of 30%, our effective per-GPU throughput becomes:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Effective Throughput</mtext><mo>=</mo><mn>720</mn><mo>×</mo><msup><mn>10</mn><mn>12</mn></msup><mtext> FLOPs/sec</mtext><mo>×</mo><mn>0.30</mn><mo>=</mo><mn>216</mn><mo>×</mo><msup><mn>10</mn><mn>12</mn></msup><mtext> FLOPs/sec</mtext></mrow><annotation encoding="application/x-tex">\text{Effective Throughput} = 720 \times 10^{12} \text{ FLOPs/sec} \times 0.30 = 216 \times 10^{12} \text{ FLOPs/sec}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord">Effective Throughput</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">720</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> FLOPs/sec</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0.30</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">216</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> FLOPs/sec</span></span></span></span></span></span>
<p>Now plugging into our sizing formula:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>GPU Count</mtext><mo>=</mo><mfrac><mrow><mn>1.98</mn><mo>×</mo><msup><mn>10</mn><mn>23</mn></msup><mtext> FLOPs</mtext></mrow><mrow><mn>216</mn><mo>×</mo><msup><mn>10</mn><mn>12</mn></msup><mtext> FLOPs/sec</mtext><mo>×</mo><mn>4</mn><mtext> weeks</mtext><mo>×</mo><mn>604</mn><mo separator="true">,</mo><mn>800</mn><mtext> sec/week</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{GPU Count} = \frac{1.98 \times 10^{23} \text{ FLOPs}}{216 \times 10^{12} \text{ FLOPs/sec} \times 4 \text{ weeks} \times 604,800 \text{ sec/week}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord text"><span class="mord">GPU Count</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.4271em;vertical-align:-0.936em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">216</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em"><span style="top:-2.989em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> FLOPs/sec</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">4</span><span class="mord text"><span class="mord"> weeks</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">604</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">800</span><span class="mord text"><span class="mord"> sec/week</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1.98</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">23</span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> FLOPs</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><mfrac><mrow><mn>1.98</mn><mo>×</mo><msup><mn>10</mn><mn>23</mn></msup></mrow><mrow><mn>5.23</mn><mo>×</mo><msup><mn>10</mn><mn>20</mn></msup></mrow></mfrac><mo>≈</mo><mn>379</mn><mtext> GPUs</mtext></mrow><annotation encoding="application/x-tex">= \frac{1.98 \times 10^{23}}{5.23 \times 10^{20}} \approx 379 \text{ GPUs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.2604em;vertical-align:-0.7693em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">5.23</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em"><span style="top:-2.989em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1.98</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">23</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">379</span><span class="mord text"><span class="mord"> GPUs</span></span></span></span></span></span>
<p>This calculation pointed us toward 375-400 H100s, and we secured 384 H100s, a number that aligned well with our parallelism strategy and gave us a realistic 4-week timeline with some buffer for unexpected issues like node failures and restarts.</p>
<p><strong>Why More GPUs Isn’t Always Better: Amdahl’s Law in Action</strong></p>
<p>Here’s a counterintuitive truth:  <strong>adding more GPUs can actually make your training slower</strong> . This is where <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s Law</a> comes into play.</p>
<p>Amdahl’s Law states that the speedup from parallelization is fundamentally limited by the serial (non-parallelizable) portion of your workload. In LLM training, this “serial” portion is primarily  <strong>communication overhead:</strong> the time spent synchronizing gradients/weights/activations across GPUs that can’t be parallelized away (read more <a href="https://acenet-arc.github.io/ACENET_Summer_School_General/05-performance/index.html">here</a>).</p>
<p>The formula is:  <strong>Maximum Speedup = 1 / (Serial Fraction + Parallel Fraction / Number of Processors)</strong></p>
<div class="wide"> <figure class="html-embed"><figcaption class="html-embed__title" style="text-align:left">GPU Scaling in distributed LLM Training: Amdahl&#39;s Law in action</figcaption><div class="html-embed__card"><div id="frag-5zgn7jfe6uj"><div class="amdahl-law-gpu-scaling"></div>
<style>
  .amdahl-law-gpu-scaling {
    position: relative;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .amdahl-law-gpu-scaling .charts-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
  }

  .amdahl-law-gpu-scaling .chart-panel {
    background: var(--page-bg);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    position: relative;
    padding: 12px;
  }

  .amdahl-law-gpu-scaling .cell-header {
    padding: 8px 10px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }

  .amdahl-law-gpu-scaling .cell-title {
    font-size: 13px;
    font-weight: 700;
    color: var(--text-color);
  }

  .amdahl-law-gpu-scaling .cell-body {
    position: relative;
    width: 100%;
    overflow: hidden;
    flex: 1;
  }

  .amdahl-law-gpu-scaling .cell-body svg {
    max-width: 100%;
    height: auto;
  }

  .amdahl-law-gpu-scaling .axis-label {
    fill: var(--text-color);
    font-size: 12px;
    font-weight: 600;
  }

  .amdahl-law-gpu-scaling .tick text {
    fill: var(--tick-color);
    font-size: 10px;
  }

  .amdahl-law-gpu-scaling .tick line {
    stroke: var(--axis-color);
  }

  .amdahl-law-gpu-scaling .domain {
    stroke: var(--axis-color);
  }

  .amdahl-law-gpu-scaling .line {
    fill: none;
    stroke-width: 2px;
  }

  .amdahl-law-gpu-scaling .line-ideal {
    stroke: var(--muted-color);
    stroke-dasharray: 2,2;
    stroke-width: 1px;
  }

  .amdahl-law-gpu-scaling .amdahl-header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin: 0 0 0 0;
    flex-wrap: wrap;
  }

  .amdahl-law-gpu-scaling .legend-bottom {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-color);
  }

  .amdahl-law-gpu-scaling .legend-bottom .legend-title {
    font-size: 12px;
    font-weight: 700;
    color: var(--text-color);
  }

  .amdahl-law-gpu-scaling .legend-bottom .items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px 14px;
  }

  .amdahl-law-gpu-scaling .legend-bottom .item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    white-space: nowrap;
  }

  .amdahl-law-gpu-scaling .legend-bottom .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid var(--border-color);
    display: inline-block;
  }

  .amdahl-law-gpu-scaling .tooltip {
    position: absolute;
    text-align: center;
    padding: 8px 10px;
    font: 12px sans-serif;
    background: var(--surface-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    pointer-events: none;
    color: var(--text-color);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  @media (max-width: 800px) {
    .amdahl-law-gpu-scaling .charts-container {
      grid-template-columns: 1fr;
    }
  }
</style>
<script>
  (() => {
    // Prevent multiple executions
    if (window.amdahlLawGpuScalingInitialized) return;
    window.amdahlLawGpuScalingInitialized = true;

    // Load D3 from CDN once
    const ensureD3 = (cb) => {
      if (window.d3 && typeof window.d3.select === 'function') return cb();
      let s = document.getElementById('d3-cdn-script');
      if (!s) {
        s = document.createElement('script');
        s.id = 'd3-cdn-script';
        s.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
        document.head.appendChild(s);
      }
      const onReady = () => { if (window.d3 && typeof window.d3.select === 'function') cb(); };
      s.addEventListener('load', onReady, { once: true });
      if (window.d3) onReady();
    };

    const bootstrap = () => {
      const scriptEl = document.currentScript;
      let container = scriptEl ? scriptEl.previousElementSibling : null;
      if (!(container && container.classList && container.classList.contains('amdahl-law-gpu-scaling'))) {
        const cs = Array.from(document.querySelectorAll('.amdahl-law-gpu-scaling')).filter(el => !(el.dataset && el.dataset.mounted === 'true'));
        container = cs[cs.length - 1] || null;
      }
      if (!container) return;
      if (container.dataset) {
        if (container.dataset.mounted === 'true') return;
        container.dataset.mounted = 'true';
      }

      // Tooltip
      container.style.position = container.style.position || 'relative';
      let tip = container.querySelector('.d3-tooltip');
      if (!tip) {
        tip = document.createElement('div');
        tip.className = 'tooltip';
        container.appendChild(tip);
      }

      // Data parameters
      const nGpus = d3.range(1, 501);
      const sValues = [0.00, 0.01, 0.02, 0.05, 0.10, 0.20];
      const lineStyles = ['-', '-', '-', '--', '--', '--'];

      // Get colors from ColorPalettes
      const getColors = () => {
        try {
          if (window.ColorPalettes && typeof window.ColorPalettes.getColors === 'function') {
            return window.ColorPalettes.getColors('categorical', sValues.length);
          }
        } catch (_) { }
        return ['#1f77b4', '#ff7f0e', '#2ca02c', '#9467bd', '#8c564b', '#7f7f7f'];
      };

      const colors = getColors();

      // Amdahl's Law functions
      const amdahlSpeedup = (n, s) => 1 / (s + (1 - s) / n);
      const efficiency = (n, s) => amdahlSpeedup(n, s) / n * 100;

      // Create charts container
      const chartsContainer = document.createElement('div');
      chartsContainer.className = 'charts-container';
      container.appendChild(chartsContainer);

      // Create speedup chart
      const speedupPanel = document.createElement('div');
      speedupPanel.className = 'chart-panel';
      
      // Add header with title
      const speedupHeader = document.createElement('div');
      speedupHeader.className = 'cell-header';
      const speedupTitle = document.createElement('div');
      speedupTitle.className = 'cell-title';
      speedupTitle.textContent = 'GPU Speedup vs Number of GPUs';
      speedupHeader.appendChild(speedupTitle);
      speedupPanel.appendChild(speedupHeader);
      
      // Add body for SVG
      const speedupBody = document.createElement('div');
      speedupBody.className = 'cell-body';
      speedupPanel.appendChild(speedupBody);
      
      chartsContainer.appendChild(speedupPanel);

      // Create efficiency chart
      const efficiencyPanel = document.createElement('div');
      efficiencyPanel.className = 'chart-panel';
      
      // Add header with title
      const efficiencyHeader = document.createElement('div');
      efficiencyHeader.className = 'cell-header';
      const efficiencyTitle = document.createElement('div');
      efficiencyTitle.className = 'cell-title';
      efficiencyTitle.textContent = 'GPU Efficiency vs Number of GPUs';
      efficiencyHeader.appendChild(efficiencyTitle);
      efficiencyPanel.appendChild(efficiencyHeader);
      
      // Add body for SVG
      const efficiencyBody = document.createElement('div');
      efficiencyBody.className = 'cell-body';
      efficiencyPanel.appendChild(efficiencyBody);
      
      chartsContainer.appendChild(efficiencyPanel);

      // Chart dimensions
      const margin = { top: 16, right: 20, bottom: 46, left: 56 };
      const width = 600;
      const height = 340;
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      // Create speedup chart
      const speedupSvg = d3.select(speedupBody)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block')
        .attr('viewBox', `0 0 ${width} ${height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');

      const speedupG = speedupSvg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      // Speedup scales
      const speedupX = d3.scaleLinear()
        .domain([1, 500])
        .range([0, innerWidth]);

      const speedupY = d3.scaleLinear()
        .domain([1, 200])
        .range([innerHeight, 0]);

      // Speedup axes
      speedupG.append('g')
        .attr('transform', `translate(0,${innerHeight})`)
        .call(d3.axisBottom(speedupX).ticks(5))
        .selectAll('text')
        .attr('class', 'tick text');

      speedupG.append('g')
        .call(d3.axisLeft(speedupY).ticks(5))
        .selectAll('text')
        .attr('class', 'tick text');

      // Speedup axis labels
      speedupG.append('text')
        .attr('class', 'axis-label')
        .attr('text-anchor', 'middle')
        .attr('x', innerWidth / 2)
        .attr('y', innerHeight + 35)
        .text('Number of GPUs');

      speedupG.append('text')
        .attr('class', 'axis-label')
        .attr('text-anchor', 'middle')
        .attr('transform', `translate(${-40}, ${innerHeight / 2}) rotate(-90)`)
        .text('Speedup');

      // Create efficiency chart
      const efficiencySvg = d3.select(efficiencyBody)
        .append('svg')
        .attr('width', '100%')
        .style('display', 'block')
        .attr('viewBox', `0 0 ${width} ${height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');

      const efficiencyG = efficiencySvg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      // Efficiency scales
      const efficiencyX = d3.scaleLinear()
        .domain([1, 500])
        .range([0, innerWidth]);

      const efficiencyY = d3.scaleLinear()
        .domain([0, 105])
        .range([innerHeight, 0]);

      // Efficiency axes
      efficiencyG.append('g')
        .attr('transform', `translate(0,${innerHeight})`)
        .call(d3.axisBottom(efficiencyX).ticks(5))
        .selectAll('text')
        .attr('class', 'tick text');

      efficiencyG.append('g')
        .call(d3.axisLeft(efficiencyY).ticks(5))
        .selectAll('text')
        .attr('class', 'tick text');

      // Efficiency axis labels
      efficiencyG.append('text')
        .attr('class', 'axis-label')
        .attr('text-anchor', 'middle')
        .attr('x', innerWidth / 2)
        .attr('y', innerHeight + 35)
        .text('Number of GPUs');

      efficiencyG.append('text')
        .attr('class', 'axis-label')
        .attr('text-anchor', 'middle')
        .attr('transform', `translate(${-40}, ${innerHeight / 2}) rotate(-90)`)
        .text('Efficiency (%)');

      // Ideal efficiency line
      const idealData = nGpus.map(n => ({ n, efficiency: 100 }));
      efficiencyG.append('path')
        .datum(idealData)
        .attr('class', 'line line-ideal')
        .attr('d', d3.line()
          .x(d => efficiencyX(d.n))
          .y(d => efficiencyY(d.efficiency))
        );

      // Create legend below charts
      const header = document.createElement('div');
      header.className = 'amdahl-header';
      const legend = document.createElement('div');
      legend.className = 'legend-bottom';
      legend.innerHTML = '<div class="legend-title">Legend</div><div class="items"></div>';
      header.appendChild(legend);
      container.appendChild(header);

      // Add legend items
      const legendItemsHost = legend.querySelector('.items');
      sValues.forEach((s, i) => {
        const item = document.createElement('span');
        item.className = 'item';
        item.setAttribute('data-s', s);
        item.innerHTML = `<span class="swatch" style="background:${colors[i]}; border-top-style: ${lineStyles[i] === '--' ? 'dashed' : 'solid'}; border-top-width: 2px; border-top-color: ${colors[i]}"></span><span>s = ${s.toFixed(2)}</span>`;
        legendItemsHost.appendChild(item);
      });

      // Add hover effects to legend items
      legendItemsHost.querySelectorAll('.item').forEach(el => {
        el.addEventListener('mouseenter', () => {
          const s = el.getAttribute('data-s');
          const sValue = parseFloat(s);
          const index = sValues.indexOf(sValue);
          speedupSvg.selectAll('.line').style('opacity', (d, i) => i === index ? 1 : 0.3);
          efficiencySvg.selectAll('.line').style('opacity', (d, i) => i === index ? 1 : 0.3);
          efficiencySvg.selectAll('.line-ideal').style('opacity', 0.3);
        });
        
        el.addEventListener('mouseleave', () => {
          speedupSvg.selectAll('.line').style('opacity', 0.9);
          efficiencySvg.selectAll('.line').style('opacity', 0.9);
          efficiencySvg.selectAll('.line-ideal').style('opacity', 1);
        });
      });

      // Draw speedup lines
      sValues.forEach((s, i) => {
        const data = nGpus.map(n => ({ n, speedup: amdahlSpeedup(n, s) }));
        
        const line = speedupG.append('path')
          .datum(data)
          .attr('class', 'line')
          .attr('stroke', colors[i])
          .attr('stroke-dasharray', lineStyles[i] === '--' ? '5,5' : 'none')
          .attr('d', d3.line()
            .x(d => speedupX(d.n))
            .y(d => speedupY(d.speedup))
          );

        // Add hover effects
        line
          .on('mouseover', function(event, d) {
            const [mouseX, mouseY] = d3.pointer(event, container);
            const closestPoint = data.reduce((prev, curr) => {
              const prevDist = Math.abs(speedupX(prev.n) - (event.offsetX - margin.left));
              const currDist = Math.abs(speedupX(curr.n) - (event.offsetX - margin.left));
              return currDist < prevDist ? curr : prev;
            });
            
            tip.innerHTML = `<strong>s = ${s.toFixed(2)}</strong><br/>GPUs: ${closestPoint.n}<br/>Speedup: ${closestPoint.speedup.toFixed(2)}x`;
            tip.style.left = mouseX + 10 + 'px';
            tip.style.top = mouseY + 10 + 'px';
            tip.style.opacity = '1';
          })
          .on('mouseout', () => {
            tip.style.opacity = '0';
          });
      });

      // Draw efficiency lines
      sValues.forEach((s, i) => {
        const data = nGpus.map(n => ({ n, efficiency: efficiency(n, s) }));
        
        const line = efficiencyG.append('path')
          .datum(data)
          .attr('class', 'line')
          .attr('stroke', colors[i])
          .attr('stroke-dasharray', lineStyles[i] === '--' ? '5,5' : 'none')
          .attr('d', d3.line()
            .x(d => efficiencyX(d.n))
            .y(d => efficiencyY(d.efficiency))
          );

        // Add hover effects
        line
          .on('mouseover', function(event, d) {
            const [mouseX, mouseY] = d3.pointer(event, container);
            const closestPoint = data.reduce((prev, curr) => {
              const prevDist = Math.abs(efficiencyX(prev.n) - (event.offsetX - margin.left));
              const currDist = Math.abs(efficiencyX(curr.n) - (event.offsetX - margin.left));
              return currDist < prevDist ? curr : prev;
            });
            
            tip.innerHTML = `<strong>s = ${s.toFixed(2)}</strong><br/>GPUs: ${closestPoint.n}<br/>Efficiency: ${closestPoint.efficiency.toFixed(1)}%`;
            tip.style.left = mouseX + 10 + 'px';
            tip.style.top = mouseY + 10 + 'px';
            tip.style.opacity = '1';
          })
          .on('mouseout', () => {
            tip.style.opacity = '0';
          });
      });

    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => ensureD3(bootstrap), { once: true });
    } else {
      ensureD3(bootstrap);
    }
  })();
</script>
</div></div></figure> </div>
<p>For SmolLM3’s 3B model, if communication takes 10% of each training step, then no matter how many GPUs you add, you’ll never get more than 10x speedup. Worse, as you add more GPUs, the communication fraction often  <em>increases</em>  because:</p>
<ul>
<li>More GPUs = more AllReduce participants = longer synchronization</li>
<li>Network latency/bandwidth becomes the bottleneck</li>
<li>Small models can’t hide communication behind compute</li>
</ul>
<p>For SmolLM3, we used weak scaling principles: our global batch size scaled with our GPU count, maintaining roughly 8K tokens per GPU globally. This kept our communication-to-computation ratio reasonable while maximizing throughput.</p>
<h4 id="finding-the-optimal-parallelism-configuration"><a href="#finding-the-optimal-parallelism-configuration">Finding the Optimal Parallelism Configuration</a></h4>
<p>Once you’ve secured your GPUs, the next challenge is configuring them to actually train efficiently. For this the parallelism strategy becomes critical.</p>
<p>We follow the <a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook?section=step_1%3A_fitting_a_training_step_in_memory"> <strong>Ultra-Scale Playbook</strong> </a><a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook?section=step_1%3A_fitting_a_training_step_in_memory">‘s approach to finding optimal training configurations</a>. The playbook breaks the problem into three sequential steps: first ensure the model fits in memory, then achieve your target batch size, and finally optimize for maximum throughput. Let’s walk through how we applied this to SmolLM3.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>For detailed explanations of different parallelism strategies (Data Parallelism, Tensor Parallelism, Pipeline Parallelism, ZeRO, etc.), we urge you once again to checkout the <a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook">Ultra-Scale Playbook</a> <em>inserts Bernie meme</em></p> </aside> </div>  
<h4 id="step-1-fitting-a-training-step-in-memory"><a href="#step-1-fitting-a-training-step-in-memory">Step 1: Fitting a training step in memory</a></h4>
<p>The first question is simple: does our SmolLM3 3B model even fit in a single H100’s 80GB of memory? To answer this, we use nanotron’s  <code>predict_memory</code>  tool, which estimates memory consumption for model parameters, optimizer states, gradients, and activations.</p>
<div class="wide"> <div class="reference-wrapper" data-astro-cid-e5g6tzce> <figure class="reference" data-astro-cid-e5g6tzce> <div class="reference__content" data-astro-cid-e5g6tzce> <iframe class="card" width="100%" height="500px" src="https://nanotron-predict-memory.hf.space"></iframe> </div> <figcaption class="reference__caption" data-astro-cid-e5g6tzce>Memory timeline from nanotron's `predict_memory` tool showing SmolLM3 3B peaks at 79.9 GB, approaching the H100's 80GB limit.</figcaption> </figure> </div>  </div>
<p>The results show we’re pushing close to the 80GB limit. This means we need some form of parallelism that reduces per-GPU memory footprint, whether that’s Tensor Parallelism (splitting model layers across GPUs), Pipeline Parallelism (splitting model depth across GPUs), or ZeRO optimizer sharding (distributing optimizer states). Without at least one of these strategies, we won’t be able to train efficiently or at all.</p>
<h4 id="step-2-achieving-the-target-global-batch-size"><a href="#step-2-achieving-the-target-global-batch-size">Step 2: Achieving the target global batch size</a></h4>
<p>Now that we know the model fits in memory with some form of parallelism, we need to determine how to achieve our target global batch size (GBS) of approximately 2 million tokens. This constraint gives us our first equation:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mi>B</mi><mi>S</mi><mo>=</mo><mi>D</mi><mi>P</mi><mo>×</mo><mi>M</mi><mi>B</mi><mi>S</mi><mo>×</mo><mi>G</mi><mi>R</mi><mi>A</mi><msub><mi>D</mi><mi>A</mi></msub><mi>C</mi><mi>C</mi><mo>×</mo><mi>S</mi><mi>E</mi><mi>Q</mi><mi>L</mi><mi>E</mi><mi>N</mi><mo>≈</mo><mn>2</mn><mi>M</mi><mi>t</mi><mi>o</mi><mi>k</mi><mi>e</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">GBS = DP × MBS × GRAD_ACC × SEQLEN ≈ 2M tokens</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05764em">GBS</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.05764em">MBS</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord mathnormal" style="margin-right:0.00773em">GR</span><span class="mord mathnormal">A</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em">CC</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal">SEQ</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.10903em">EN</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord">2</span><span class="mord mathnormal">Mt</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span></span></span></span></span>
<p>Where:</p>
<ul>
<li><strong>DP (Data Parallelism)</strong> : Number of data-parallel replicas</li>
<li><strong>MBS (Micro Batch Size)</strong> : Tokens processed per GPU per micro-batch</li>
<li><strong>GRAD_ACC (Gradient Accumulation)</strong> : Number of forward-backwards before optimizer step</li>
<li><strong>SEQLEN (Sequence Length)</strong> : Tokens per sequence (4096 for the 1st pretraining stage)</li>
</ul>
<p>We also have a hardware constraint from our 384 H100s:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mi>P</mi><mo>×</mo><mi>T</mi><mi>P</mi><mo>×</mo><mi>P</mi><mi>P</mi><mo>=</mo><mn>384</mn><mo>=</mo><msup><mn>2</mn><mn>7</mn></msup><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">DP × TP × PP = 384 = 2^7 × 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.02778em">D</span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">TP</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.13889em">PP</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">384</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">3</span></span></span></span></span>
<p>Where:</p>
<ul>
<li><strong>TP (Tensor Parallelism)</strong> : GPUs per model layer (splits weight matrices)</li>
<li><strong>PP (Pipeline Parallelism)</strong> : GPUs per model depth (splits layers vertically)</li>
</ul>
<p>These two equations define our search space. We need to find values that satisfy both constraints while maximizing training throughput.</p>
<h4 id="step-3-optimizing-training-throughput"><a href="#step-3-optimizing-training-throughput">Step 3: Optimizing training throughput</a></h4>
<p>With our constraints established, we need to find the parallelism configuration that maximizes training throughput. The search space is defined by our hardware topology and model architecture.</p>
<p>Our hardware setup presents two distinct types of interconnects, as we saw in the section above: NVLink for intra-node communication (900 GB/s) and EFA for inter-node communication (~50 GB/s). This topology naturally suggests using at least two forms of parallelism to match our network characteristics. The dramatic bandwidth difference between these interconnects will heavily influence which parallelism strategies work best.</p>
<p>From a model perspective, SmolLM3’s architecture constrains our options. Since we’re not using a Mixture-of-Experts architecture, we don’t need  <strong>Expert Parallelism</strong> . Similarly, training with a 4096 sequence length in the first stage means  <strong>Context Parallelism</strong>  isn’t required. This leaves us with three primary parallelism dimensions to explore:  <strong>Data Parallelism</strong>  (DP),  <strong>Tensor Parallelism</strong>  (TP), and  <strong>Pipeline Parallelism</strong>  (PP).</p>
<p>Given our constraints from Step 2, we need to sweep across several parameters:</p>
<ul>
<li><strong>DP with ZeRO variants</strong>  (ZeRO-0, ZeRO-1, ZeRO-3): Values from 1 to 384, constrained to multiples of 2 and/or 3</li>
<li><strong>TP</strong>  (1, 2, 3, 4, 6, 8): Keep within a single node to fully leverage NVLink’s high bandwidth</li>
<li><strong>PP</strong>  (1..48): Split model depth across GPUs</li>
<li><strong>MBS</strong>  (2, 3, 4, 5): Depending on memory savings from parallelism, we can increase MBS to better utilize Tensor Cores</li>
<li><strong>Activation checkpointing</strong>  (none, selective, full): Trade additional compute for reduced memory and communication</li>
<li><strong>Kernel optimizations</strong> : CUDA graphs and optimized kernels where available</li>
</ul>
<p>While this may seem like an overwhelming number of combinations, a practical approach is to benchmark each dimension independently first, then eliminate configurations that significantly hurt throughput. The key insight is that not all parallelism strategies are created equal. Some introduce communication overhead that far outweighs their benefits, especially at our scale.</p>
<p>In our case,  <strong>Pipeline Parallelism</strong>  showed poor performance characteristics. PP requires frequent pipeline bubble synchronization across nodes, and with our relatively small 3B model, the communication overhead dominated any potential benefits. Additionally, we didn’t have access to highly efficient PP schedules that could eliminate the pipeline bubble entirely, which further limited PP’s viability. Similarly,  <strong>ZeRO</strong>  levels above 0 introduced significant all-gather and reduce-scatter operations that hurt throughput more than they helped with memory. These early benchmarks allowed us to narrow our search space dramatically, focusing on configurations that combined  <strong>Data Parallelism</strong> with modest  <strong>Tensor Parallelism</strong> .</p>
<p>👉 To evaluate each configuration, we run benchmarks for 5 iterations and record  <strong>tokens per second per GPU (tok/s/gpu)</strong> , which is ultimately the metric we care about. We use Weights &amp; Biases and Trackio to log throughputs and configurations, making it easy to compare different parallelism strategies.</p>
<p>After systematically benchmarking the available options in nanotron, we settled on  <strong>DP = 192</strong> , which leverages inter-node EFA bandwidth for data-parallel gradient synchronization. This means 192 independent model replicas, each processing different batches of data. For Tensor Parallelism, we chose  <strong>TP = 2</strong> , keeping tensor-parallel communication within a single node to fully exploit NVLink’s high bandwidth. This splits each layer’s weight matrices across two GPUs, requiring fast communication for the forward and backward passes.</p>
<p>Our  <strong>Micro Batch Size = 3</strong>  strikes a balance between memory usage and compute efficiency. Larger batch sizes would better utilize Tensor Cores, but we’re already pushing close to memory limits. Finally, we opted for ZeRO-0, meaning no optimizer state sharding. While ZeRO-1 or ZeRO-3 could reduce memory footprint, the communication overhead from gathering and scattering optimizer states across our 384 GPUs would significantly hurt throughput.</p>
<div class="sidenote-container"> <aside class="sidenote"> <p>Many of these parallelism decisions were influenced by the state of libraries at the time of experiments. For instance, nanotron didn’t support ZeRO-3 yet, and we lacked access to highly optimized Pipeline Parallelism schedules that could eliminate pipeline bubbles. As the framework evolves, some of these trade-offs may shift. Contributions are always welcome!</p> </aside> </div>  
<p>This configuration achieves our target global batch size of approximately 2 million tokens (192 × 3 × 1 × 4096 ≈ 2.3M) while maximizing throughput on our 384 H100 cluster. You can see the full training configuration in our <a href="https://github.com/huggingface/smollm/blob/main/text/pretraining/smollm3/stage1_8T.yaml">stage1_8T.yaml</a>.</p>
<h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2>
<p>We started this journey with a simple question: what does it actually take to train a high-performance LLM in 2025? After walking through the complete pipeline—from pretraining to post-training—we’ve shown you not just the techniques, but the methodology that makes them work.</p>
<p><strong>Pretraining at scale.</strong>  We walked through the Training Compass framework for deciding whether to train at all, then showed how to translate goals into concrete architectural decisions. You’ve seen how to set up reliable ablation pipelines, test changes individually, and scale from few-billion-token experiments to multi-trillion-token runs. We documented the infrastructure challenges that can emerge at scale (throughput collapses, dataloader bottlenecks, subtle bugs) and how monitoring and systematic derisking help you catch them early and debug quickly.</p>
<p><strong>Post-training in practice.</strong>  We showed that going from a base model to a production assistant requires its own systematic approach: establishing evals before training anything, iterating on SFT data mixtures, applying preference optimization, and optionally pushing further with RL. You’ve seen how vibe testing catches bugs that metrics miss, how chat templates can silently break instruction-following, and why data mixture balance matters as much in post-training as it does in pretraining.</p>
<p>Throughout both phases, we kept coming back to the same core insights: validate everything through experiments, change one thing at a time, expect scale to break things in new ways, and let your use case drive decisions rather than chasing every new paper. Following this process, we trained SmolLM3: a competitive 3B multilingual reasoner with long context. Along the way, we learned a lot about what works, what breaks, and how to debug when things go wrong. We’ve tried to document it all, the successes and failures alike.</p>
<p><strong>What’s next?</strong></p>
<p>This blog covers the fundamentals of modern LLM training, but the field evolves rapidly. Here are ways to go deeper:</p>
<ul>
<li><strong>Run experiments yourself.</strong>  Reading about ablations is useful; running your own teaches you what actually matters. Pick a small model, set up evals, and start experimenting.</li>
<li><strong>Read the source code.</strong>  Training frameworks like nanotron, TRL, and others are open source. Understanding their implementations reveals details that papers gloss over.</li>
<li><strong>Follow recent work.</strong>  Papers of recent state-of-the-art models show where the field is heading. The references section contains our curated list of impactful papers and resources.</li>
</ul>
<p>We hope this blog helps you approach your next training project with clarity and confidence, whether you’re at a large lab pushing the frontier or a small team solving a specific problem.</p>
<p>Now go train something. And when your loss spikes mysteriously at 2am, remember: every great model has debugging stories behind it. May the force of open source and open science always be with you!</p>
<h4 id="acknowledgments"><a href="#acknowledgments"><strong>Acknowledgments</strong></a></h4>
<p>We thank <a href="https://huggingface.co/guipenedo">Guilherme</a> and <a href="https://huggingface.co/hlarcher">Hugo</a> for their valuable feedback, and <a href="https://huggingface.co/abidlabs">Abubakar</a> for his help with Trackio features.</p>
<h2 id="references"><a href="#references">References</a></h2>
<p>Below is a curated list of papers, books, and blog posts that have informed us the most on our LLM training journey.</p>
<h4 id="llm-architecture"><a href="#llm-architecture">LLM Architecture</a></h4>
<ul>
<li>Dense models: <a href="https://huggingface.co/papers/2407.21783">Llama3</a>, <a href="https://huggingface.co/papers/2501.00656">Olmo2</a>, <a href="https://huggingface.co/papers/2402.14905">MobileLLM</a></li>
<li>MoEs: <a href="https://huggingface.co/papers/2405.04434">DeepSeek V2</a>, <a href="https://huggingface.co/papers/2412.19437">DeepSeek V3</a>, <a href="https://huggingface.co/papers/2507.17702">Scaling Laws of Efficient MoEs</a></li>
<li>Hybrid: <a href="https://huggingface.co/papers/2501.08313">MiniMax-01,</a> <a href="https://huggingface.co/papers/2405.21060">Mamba2</a></li>
</ul>
<h4 id="optimisers--training-parameters"><a href="#optimisers--training-parameters">Optimisers &amp; training parameters</a></h4>
<ul>
<li><a href="https://huggingface.co/papers/2502.16982">Muon is Scalable for LLM Training</a>, <a href="https://huggingface.co/papers/2509.02046">Fantastic pretraining optimisers</a></li>
<li><a href="https://arxiv.org/abs/1812.06162">Large Batch Training</a>, <a href="https://arxiv.org/abs/2401.02954">DeepSeekLLM</a></li>
</ul>
<h4 id="data-curation"><a href="#data-curation">Data curation</a></h4>
<ul>
<li>Web: <a href="https://huggingface.co/papers/2406.17557">FineWeb &amp; FineWeb-Edu</a>, <a href="https://huggingface.co/papers/2506.20920">FineWeb2</a>, <a href="https://huggingface.co/papers/2406.11794">DCLM</a></li>
<li>Code: <a href="https://huggingface.co/papers/2402.19173">The Stack v2</a>, <a href="https://huggingface.co/papers/2408.10914">To Code or Not to Code</a></li>
<li>Math: <a href="https://huggingface.co/papers/2402.03300">DeepSeekMath</a>, <a href="https://huggingface.co/papers/2502.02737">FineMath</a>, <a href="https://huggingface.co/papers/2504.02807">MegaMath</a></li>
<li>Data mixtures: <a href="https://huggingface.co/papers/2502.02737">SmolLM2</a>, <a href="https://huggingface.co/papers/2406.03476">Does your data spark joy</a></li>
</ul>
<h4 id="scaling-laws"><a href="#scaling-laws">Scaling laws</a></h4>
<ul>
<li><a href="https://huggingface.co/papers/2001.08361">Kaplan</a>, <a href="https://huggingface.co/papers/2203.15556">Chinchilla</a>, <a href="https://huggingface.co/papers/2305.16264">Scaling Data-Constrained Language Models</a></li>
</ul>
<h4 id="post-training"><a href="#post-training">Post-training</a></h4>
<ul>
<li><a href="https://huggingface.co/papers/2203.02155">InstructGPT:</a> OpenAI’s foundational paper to turn base models into helpful assistants. The precursor to ChatGPT and a key step on humanity’s path up the Kardashev scale.</li>
<li><a href="https://huggingface.co/papers/2307.09288">Llama 2</a> &amp; <a href="https://huggingface.co/papers/2407.21783">3</a>: Extremely detailed tech reports from Meta on the training behind their Llama models (may they rest in peace). They each contain many insights into human data collection, both for human preferences and model evaluation.</li>
<li>Secrets of RLHF in LLMs, <a href="https://huggingface.co/papers/2307.04964">Part I</a> &amp; <a href="https://huggingface.co/papers/2401.06080">II</a>: these papers contain lots of goodies on the nuts and bolts for RLHF, specifically on how to train strong reward models.</li>
<li><a href="https://huggingface.co/papers/2305.18290">Direct Preference Optimisation:</a> the breakthrough paper from 2023 that convinced everyone to stop doing RL with LLMs.</li>
<li><a href="https://huggingface.co/papers/2501.12948">DeepSeek-R1</a>: the breakthrough paper from 2025 that convinced everyone to start doing RL with LLMs.</li>
<li><a href="https://huggingface.co/papers/2503.20783">Dr. GRPO:</a> one of the most important papers on understanding the baked-in biases with GRPO and how to fix them.</li>
<li><a href="https://huggingface.co/papers/2503.14476">DAPO: </a>Bytedance shares many implementation details to unlock stable R1-Zero-like training for the community.</li>
<li><a href="https://huggingface.co/papers/2510.13786">ScaleRL:</a> a massive flex from Meta to derive scaling laws for RL. Burns over 400k GPU hours to establish a training recipe that scales reliably over many orders of compute.</li>
<li><a href="https://thinkingmachines.ai/blog/lora/">LoRA without Regret:</a> a beautifully written blog post which finds that RL with low-rank LoRA can match full-finetuning (a most surprising result).</li>
<li><a href="https://huggingface.co/papers/2504.00698">Command A:</a> a remarkably detailed tech report from Cohere on various strategies to post-train LLMs effectively.</li>
</ul>
<h4 id="infrastructure"><a href="#infrastructure">Infrastructure</a></h4>
<ul>
<li><a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook">UltraScale Playbook</a></li>
<li><a href="https://jax-ml.github.io/scaling-book/">Jax scaling book</a></li>
<li><a href="https://modal.com/gpu-glossary/readme">Modal GPU Glossary</a></li>
</ul>
<h4 id="training-frameworks"><a href="#training-frameworks">Training frameworks</a></h4>
<ul>
<li><a href="https://github.com/NVIDIA/Megatron-LM">Megatron-LM</a></li>
<li><a href="https://github.com/deepspeedai/DeepSpeed">DeepSpeed</a></li>
<li><a href="https://github.com/pytorch/torchtitan">Torchtitan</a></li>
<li><a href="https://github.com/huggingface/nanotron/">Nanotron</a></li>
<li><a href="https://github.com/karpathy/nanochat">NanoChat</a></li>
<li><a href="https://github.com/huggingface/trl">TRL</a></li>
</ul>
<h4 id="evaluation"><a href="#evaluation">Evaluation</a></h4>
<ul>
<li><a href="https://github.com/huggingface/evaluation-guidebook">The LLM Evaluation Guidebook</a></li>
<li><a href="https://huggingface.co/papers/2406.08446">OLMES</a></li>
<li><a href="https://huggingface.co/spaces/HuggingFaceFW/blogpost-fine-tasks">FineTasks</a></li>
<li><a href="https://huggingface.co/papers/2405.14782">Lessons from the trenches</a></li>
</ul>
<section data-footnotes="" class="footnotes" data-built-footnotes="1"><h2 class="sr-only" id="footnote-label"><a href="#footnote-label">Footnotes</a></h2>
<ol>
<li id="user-content-fn-f1">
<p>The idea to compute these statistics comes from the Llama 3 tech report <span class="" id="citation--llama3--154">(<a href="https://arxiv.org/abs/2407.21783" id="refctx-bib-llama3-3" data-ref-id="bib-llama3" target="_blank" rel="noopener noreferrer">Grattafiori et al., 2024</a>)</span>. </p>
<small class="backrefs"><a href="#user-content-fnref-f1" aria-label="Back to footnote call"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li>
<li id="user-content-fn-f2">
<p>For vLLM see:  <a href="https://docs.vllm.ai/en/v0.10.1.1/features/reasoning_outputs.html">Reasoning parsers, </a><a href="./href="/2421384ebcac80fbaa7cf939fc39269d">Tool parsers</a>. For SGLang, see: <a href="https://docs.sglang.ai/advanced_features/separate_reasoning.html">Reasoning parsers, </a><a href="https://docs.sglang.ai/advanced_features/tool_parser.html">Tool parsers</a> </p>
<small class="backrefs"><a href="#user-content-fnref-f2" aria-label="Back to footnote call"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li>
<li id="user-content-fn-f3">
<p>The Transformers team has recently added <a href="https://huggingface.co/docs/transformers/main/en/chat_response_parsing">parsers</a> for extract tool calling and reasoning outputs. If adopted by engines like vLLM, the compatibility criterion may become less important in the future. </p>
<small class="backrefs"><a href="#user-content-fnref-f3" aria-label="Back to footnote call"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li>
</ol>
</section><div id="bibliography-references-list" class="references csl-bib-body" data-bibliography-block="true" data-built-refs="1"><ol class="references"><li id="bib-gqa">Ainslie, J., Lee-Thorp, J., de Jong, M., Zemlyanskiy, Y., Lebrón, F., &amp; Sanghai, S. (2023). <i>GQA: Training Generalized Multi-Query Transformer Models from Multi-Head Checkpoints</i>. <a href="https://arxiv.org/abs/2305.13245" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2305.13245</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-gqa-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-gqa-2" aria-label="Back to citation">2</a></small></li><li id="bib-smollm2">Allal, L. B., Lozhkov, A., Bakouch, E., Blázquez, G. M., Penedo, G., Tunstall, L., Marafioti, A., Kydlíček, H., Lajarín, A. P., Srivastav, V., Lochner, J., Fahlgren, C., Nguyen, X.-S., Fourrier, C., Burtenshaw, B., Larcher, H., Zhao, H., Zakka, C., Morlon, M., … Wolf, T. (2025). <i>SmolLM2: When Smol Goes Big – Data-Centric Training of a Small Language Model</i>. <a href="https://arxiv.org/abs/2502.02737" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2502.02737</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-smollm2-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-smollm2-2" aria-label="Back to citation">2</a></small></li><li id="bib-almazrouei2023falconseriesopenlanguage">Almazrouei, E., Alobeidli, H., Alshamsi, A., Cappelli, A., Cojocaru, R., Debbah, M., Goffinet, É., Hesslow, D., Launay, J., Malartic, Q., Mazzotta, D., Noune, B., Pannier, B., &amp; Penedo, G. (2023). <i>The Falcon Series of Open Language Models</i>. <a href="https://arxiv.org/abs/2311.16867" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2311.16867</a><small class="backrefs"><a href="#refctx-bib-almazrouei2023falconseriesopenlanguage-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-dca">An, C., Huang, F., Zhang, J., Gong, S., Qiu, X., Zhou, C., &amp; Kong, L. (2024). <i>Training-Free Long-Context Scaling of Large Language Models</i>. <a href="https://arxiv.org/abs/2402.17463" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2402.17463</a><small class="backrefs"><a href="#refctx-bib-dca-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-aryabumi2024codecodeexploringimpact">Aryabumi, V., Su, Y., Ma, R., Morisot, A., Zhang, I., Locatelli, A., Fadaee, M., Üstün, A., &amp; Hooker, S. (2024). <i>To Code, or Not To Code? Exploring Impact of Code in Pre-training</i>. <a href="https://arxiv.org/abs/2408.10914" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2408.10914</a><small class="backrefs"><a href="#refctx-bib-aryabumi2024codecodeexploringimpact-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-qwen1">Bai, J., Bai, S., Chu, Y., Cui, Z., Dang, K., Deng, X., Fan, Y., Ge, W., Han, Y., Huang, F., Hui, B., Ji, L., Li, M., Lin, J., Lin, R., Liu, D., Liu, G., Lu, C., Lu, K., … Zhu, T. (2023). <i>Qwen Technical Report</i>. <a href="https://arxiv.org/abs/2309.16609" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2309.16609</a><small class="backrefs"><a href="#refctx-bib-qwen1-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-taubench">Barres, V., Dong, H., Ray, S., Si, X., &amp; Narasimhan, K. (2025). <i>τ<sup>2</sup>-Bench: Evaluating Conversational Agents in a Dual-Control Environment</i>. <a href="https://arxiv.org/abs/2506.07982" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2506.07982</a><small class="backrefs"><a href="#refctx-bib-taubench-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-beck2025tiledflashlinearattention">Beck, M., Pöppel, K., Lippe, P., &amp; Hochreiter, S. (2025). <i>Tiled Flash Linear Attention: More Efficient Linear RNN and xLSTM Kernels</i>. <a href="https://arxiv.org/abs/2503.14376" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2503.14376</a><small class="backrefs"><a href="#refctx-bib-beck2025tiledflashlinearattention-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-gpt3">Brown, T. B., Mann, B., Ryder, N., Subbiah, M., Kaplan, J., Dhariwal, P., Neelakantan, A., Shyam, P., Sastry, G., Askell, A., Agarwal, S., Herbert-Voss, A., Krueger, G., Henighan, T., Child, R., Ramesh, A., Ziegler, D. M., Wu, J., Winter, C., … Amodei, D. (2020). <i>Language Models are Few-Shot Learners</i>. <a href="https://arxiv.org/abs/2005.14165" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2005.14165</a><small class="backrefs"><a href="#refctx-bib-gpt3-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-codex">Chen, M., Tworek, J., Jun, H., Yuan, Q., de Oliveira Pinto, H. P., Kaplan, J., Edwards, H., Burda, Y., Joseph, N., Brockman, G., Ray, A., Puri, R., Krueger, G., Petrov, M., Khlaaf, H., Sastry, G., Mishkin, P., Chan, B., Gray, S., … Zaremba, W. (2021). <i>Evaluating Large Language Models Trained on Code</i>. <a href="https://arxiv.org/abs/2107.03374" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2107.03374</a><small class="backrefs"><a href="#refctx-bib-codex-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-chen2025">Chen, Y., Huang, B., Gao, Y., Wang, Z., Yang, J., &amp; Ji, H. (2025a). <i>Scaling Laws for Predicting Downstream Performance in LLMs</i>. <a href="https://arxiv.org/abs/2410.08527" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2410.08527</a><small class="backrefs"><a href="#refctx-bib-chen2025-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-chen2025scalinglawspredictingdownstream">Chen, Y., Huang, B., Gao, Y., Wang, Z., Yang, J., &amp; Ji, H. (2025b). <i>Scaling Laws for Predicting Downstream Performance in LLMs</i>. <a href="https://arxiv.org/abs/2410.08527" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2410.08527</a><small class="backrefs"><a href="#refctx-bib-chen2025scalinglawspredictingdownstream-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-child2019generating">Child, R., Gray, S., Radford, A., &amp; Sutskever, I. (2019). Generating long sequences with sparse transformers. <i>arXiv Preprint arXiv:1904.10509</i>.<small class="backrefs"><a href="#refctx-bib-child2019generating-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-palm">Chowdhery, A., Narang, S., Devlin, J., Bosma, M., Mishra, G., Roberts, A., Barham, P., Chung, H. W., Sutton, C., Gehrmann, S., Schuh, P., Shi, K., Tsvyashchenko, S., Maynez, J., Rao, A., Barnes, P., Tay, Y., Shazeer, N., Prabhakaran, V., … Fiedel, N. (2022). <i>PaLM: Scaling Language Modeling with Pathways</i>. <a href="https://arxiv.org/abs/2204.02311" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2204.02311</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-palm-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-palm-2" aria-label="Back to citation">2</a>, <a href="#refctx-bib-palm-3" aria-label="Back to citation">3</a></small></li><li id="bib-chu2025">Chu, T., Zhai, Y., Yang, J., Tong, S., Xie, S., Schuurmans, D., Le, Q. V., Levine, S., &amp; Ma, Y. (2025). <i>SFT Memorizes, RL Generalizes: A Comparative Study of Foundation Model Post-training</i>. <a href="https://arxiv.org/abs/2501.17161" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2501.17161</a><small class="backrefs"><a href="#refctx-bib-chu2025-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-gsm8k">Cobbe, K., Kosaraju, V., Bavarian, M., Chen, M., Jun, H., Kaiser, L., Plappert, M., Tworek, J., Hilton, J., Nakano, R., Hesse, C., &amp; Schulman, J. (2021). <i>Training Verifiers to Solve Math Word Problems</i>. <a href="https://arxiv.org/abs/2110.14168" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2110.14168</a><small class="backrefs"><a href="#refctx-bib-gsm8k-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-dagan2024gettingtokenizerpretrainingdomain">Dagan, G., Synnaeve, G., &amp; Rozière, B. (2024). <i>Getting the most out of your tokenizer for pre-training and domain adaptation</i>. <a href="https://arxiv.org/abs/2402.01035" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2402.01035</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-dagan2024gettingtokenizerpretrainingdomain-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-dagan2024gettingtokenizerpretrainingdomain-2" aria-label="Back to citation">2</a></small></li><li id="bib-mamba2">Dao, T., &amp; Gu, A. (2024). <i>Transformers are SSMs: Generalized Models and Efficient Algorithms Through Structured State Space Duality</i>. <a href="https://arxiv.org/abs/2405.21060" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2405.21060</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-mamba2-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-mamba2-2" aria-label="Back to citation">2</a></small></li><li id="bib-deepseekai2024deepseekllmscalingopensource">DeepSeek-AI, :, Bi, X., Chen, D., Chen, G., Chen, S., Dai, D., Deng, C., Ding, H., Dong, K., Du, Q., Fu, Z., Gao, H., Gao, K., Gao, W., Ge, R., Guan, K., Guo, D., Guo, J., … Zou, Y. (2024). <i>DeepSeek LLM: Scaling Open-Source Language Models with Longtermism</i>. <a href="https://arxiv.org/abs/2401.02954" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2401.02954</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-deepseekai2024deepseekllmscalingopensource-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-deepseekai2024deepseekllmscalingopensource-2" aria-label="Back to citation">2</a></small></li><li id="bib-deepseekr1">DeepSeek-AI, Guo, D., Yang, D., Zhang, H., Song, J., Zhang, R., Xu, R., Zhu, Q., Ma, S., Wang, P., Bi, X., Zhang, X., Yu, X., Wu, Y., Wu, Z. F., Gou, Z., Shao, Z., Li, Z., Gao, Z., … Zhang, Z. (2025). <i>DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</i>. <a href="https://arxiv.org/abs/2501.12948" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2501.12948</a><small class="backrefs"><a href="#refctx-bib-deepseekr1-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-deepseekv2">DeepSeek-AI, Liu, A., Feng, B., Wang, B., Wang, B., Liu, B., Zhao, C., Dengr, C., Ruan, C., Dai, D., Guo, D., Yang, D., Chen, D., Ji, D., Li, E., Lin, F., Luo, F., Hao, G., Chen, G., … Xie, Z. (2024). <i>DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model</i>. <a href="https://arxiv.org/abs/2405.04434" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2405.04434</a><small class="backrefs"><a href="#refctx-bib-deepseekv2-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-deepseekv3">DeepSeek-AI, Liu, A., Feng, B., Xue, B., Wang, B., Wu, B., Lu, C., Zhao, C., Deng, C., Zhang, C., Ruan, C., Dai, D., Guo, D., Yang, D., Chen, D., Ji, D., Li, E., Lin, F., Dai, F., … Pan, Z. (2025). <i>DeepSeek-V3 Technical Report</i>. <a href="https://arxiv.org/abs/2412.19437" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2412.19437</a><small class="backrefs"><a href="#refctx-bib-deepseekv3-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-dehghani2023scalingvisiontransformers22">Dehghani, M., Djolonga, J., Mustafa, B., Padlewski, P., Heek, J., Gilmer, J., Steiner, A., Caron, M., Geirhos, R., Alabdulmohsin, I., Jenatton, R., Beyer, L., Tschannen, M., Arnab, A., Wang, X., Riquelme, C., Minderer, M., Puigcerver, J., Evci, U., … Houlsby, N. (2023). <i>Scaling Vision Transformers to 22 Billion Parameters</i>. <a href="https://arxiv.org/abs/2302.05442" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2302.05442</a><small class="backrefs"><a href="#refctx-bib-dehghani2023scalingvisiontransformers22-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-bfd">Ding, H., Wang, Z., Paolini, G., Kumar, V., Deoras, A., Roth, D., &amp; Soatto, S. (2024). <i>Fewer Truncations Improve Language Modeling</i>. <a href="https://arxiv.org/abs/2404.10830" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2404.10830</a><small class="backrefs"><a href="#refctx-bib-bfd-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-apo">D’Oosterlinck, K., Xu, W., Develder, C., Demeester, T., Singh, A., Potts, C., Kiela, D., &amp; Mehri, S. (2024). <i>Anchored Preference Optimization and Contrastive Revisions: Addressing Underspecification in Alignment</i>. <a href="https://arxiv.org/abs/2408.06266" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2408.06266</a><small class="backrefs"><a href="#refctx-bib-apo-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-du2025">Du, Z., Zeng, A., Dong, Y., &amp; Tang, J. (2025). <i>Understanding Emergent Abilities of Language Models from the Loss Perspective</i>. <a href="https://arxiv.org/abs/2403.15796" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2403.15796</a><small class="backrefs"><a href="#refctx-bib-du2025-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-alpacaeval">Dubois, Y., Galambosi, B., Liang, P., &amp; Hashimoto, T. B. (2025). <i>Length-Controlled AlpacaEval: A Simple Way to Debias Automatic Evaluators</i>. <a href="https://arxiv.org/abs/2404.04475" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2404.04475</a><small class="backrefs"><a href="#refctx-bib-alpacaeval-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-kto">Ethayarajh, K., Xu, W., Muennighoff, N., Jurafsky, D., &amp; Kiela, D. (2024). <i>KTO: Model Alignment as Prospect Theoretic Optimization</i>. <a href="https://arxiv.org/abs/2402.01306" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2402.01306</a><small class="backrefs"><a href="#refctx-bib-kto-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-prolong">Gao, T., Wettig, A., Yen, H., &amp; Chen, D. (2025). <i>How to Train Long-Context Language Models (Effectively)</i>. <a href="https://arxiv.org/abs/2410.02660" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2410.02660</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-prolong-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-prolong-2" aria-label="Back to citation">2</a>, <a href="#refctx-bib-prolong-3" aria-label="Back to citation">3</a></small></li><li id="bib-llama3">Grattafiori, A., Dubey, A., Jauhri, A., Pandey, A., Kadian, A., Al-Dahle, A., Letman, A., Mathur, A., Schelten, A., Vaughan, A., Yang, A., Fan, A., Goyal, A., Hartshorn, A., Yang, A., Mitra, A., Sravankumar, A., Korenev, A., Hinsvark, A., … Ma, Z. (2024). <i>The Llama 3 Herd of Models</i>. <a href="https://arxiv.org/abs/2407.21783" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2407.21783</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-llama3-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-llama3-2" aria-label="Back to citation">2</a>, <a href="#refctx-bib-llama3-3" aria-label="Back to citation">3</a></small></li><li id="bib-mamba">Gu, A., &amp; Dao, T. (2024). <i>Mamba: Linear-Time Sequence Modeling with Selective State Spaces</i>. <a href="https://arxiv.org/abs/2312.00752" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2312.00752</a><small class="backrefs"><a href="#refctx-bib-mamba-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-olmes">Gu, Y., Tafjord, O., Kuehl, B., Haddad, D., Dodge, J., &amp; Hajishirzi, H. (2025). <i>OLMES: A Standard for Language Model Evaluations</i>. <a href="https://arxiv.org/abs/2406.08446" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2406.08446</a><small class="backrefs"><a href="#refctx-bib-olmes-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-hägele2024scalinglawscomputeoptimaltraining">Hägele, A., Bakouch, E., Kosson, A., Allal, L. B., Werra, L. V., &amp; Jaggi, M. (2024). <i>Scaling Laws and Compute-Optimal Training Beyond Fixed Training Durations</i>. <a href="https://arxiv.org/abs/2405.18392" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2405.18392</a><small class="backrefs"><a href="#refctx-bib-hägele2024scalinglawscomputeoptimaltraining-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-multiif">He, Y., Jin, D., Wang, C., Bi, C., Mandyam, K., Zhang, H., Zhu, C., Li, N., Xu, T., Lv, H., Bhosale, S., Zhu, C., Sankararaman, K. A., Helenowski, E., Kambadur, M., Tayade, A., Ma, H., Fang, H., &amp; Wang, S. (2024). <i>Multi-IF: Benchmarking LLMs on Multi-Turn and Multilingual Instructions Following</i>. <a href="https://arxiv.org/abs/2410.15553" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2410.15553</a><small class="backrefs"><a href="#refctx-bib-multiif-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-hoffmann2022trainingcomputeoptimallargelanguage">Hoffmann, J., Borgeaud, S., Mensch, A., Buchatskaya, E., Cai, T., Rutherford, E., de Las Casas, D., Hendricks, L. A., Welbl, J., Clark, A., Hennigan, T., Noland, E., Millican, K., van den Driessche, G., Damoc, B., Guy, A., Osindero, S., Simonyan, K., Elsen, E., … Sifre, L. (2022). <i>Training Compute-Optimal Large Language Models</i>. <a href="https://arxiv.org/abs/2203.15556" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2203.15556</a><small class="backrefs"><a href="#refctx-bib-hoffmann2022trainingcomputeoptimallargelanguage-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-orpo">Hong, J., Lee, N., &amp; Thorne, J. (2024). <i>ORPO: Monolithic Preference Optimization without Reference Model</i>. <a href="https://arxiv.org/abs/2403.07691" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2403.07691</a><small class="backrefs"><a href="#refctx-bib-orpo-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-ulmfit">Howard, J., &amp; Ruder, S. (2018). <i>Universal Language Model Fine-tuning for Text Classification</i>. <a href="https://arxiv.org/abs/1801.06146" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1801.06146</a><small class="backrefs"><a href="#refctx-bib-ulmfit-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-ruler">Hsieh, C.-P., Sun, S., Kriman, S., Acharya, S., Rekesh, D., Jia, F., Zhang, Y., &amp; Ginsburg, B. (2024). <i>RULER: What’s the Real Context Size of Your Long-Context Language Models?</i> <a href="https://arxiv.org/abs/2404.06654" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2404.06654</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-ruler-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-ruler-2" aria-label="Back to citation">2</a></small></li><li id="bib-hu2024minicpmunveilingpotentialsmall">Hu, S., Tu, Y., Han, X., He, C., Cui, G., Long, X., Zheng, Z., Fang, Y., Huang, Y., Zhao, W., Zhang, X., Thai, Z. L., Zhang, K., Wang, C., Yao, Y., Zhao, C., Zhou, J., Cai, J., Zhai, Z., … Sun, M. (2024). <i>MiniCPM: Unveiling the Potential of Small Language Models with Scalable Training Strategies</i>. <a href="https://arxiv.org/abs/2404.06395" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2404.06395</a><small class="backrefs"><a href="#refctx-bib-hu2024minicpmunveilingpotentialsmall-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-ndetailsrlhf">Huang, S., Noukhovitch, M., Hosseini, A., Rasul, K., Wang, W., &amp; Tunstall, L. (2024). <i>The N+ Implementation Details of RLHF with PPO: A Case Study on TL;DR Summarization</i>. <a href="https://arxiv.org/abs/2403.17031" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2403.17031</a><small class="backrefs"><a href="#refctx-bib-ndetailsrlhf-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-granite4">IBM Research. (2025). <i>IBM Granite 4.0: Hyper-efficient, High Performance Hybrid Models for Enterprise</i>. <a href="https://www.ibm.com/new/announcements/ibm-granite-4-0-hyper-efficient-high-performance-hybrid-models" target="_blank" rel="noopener noreferrer">https://www.ibm.com/new/announcements/ibm-granite-4-0-hyper-efficient-high-performance-hybrid-models</a><small class="backrefs"><a href="#refctx-bib-granite4-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-jiang2023mistral7b">Jiang, A. Q., Sablayrolles, A., Mensch, A., Bamford, C., Chaplot, D. S., de las Casas, D., Bressand, F., Lengyel, G., Lample, G., Saulnier, L., Lavaud, L. R., Lachaux, M.-A., Stock, P., Scao, T. L., Lavril, T., Wang, T., Lacroix, T., &amp; Sayed, W. E. (2023). <i>Mistral 7B</i>. <a href="https://arxiv.org/abs/2310.06825" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2310.06825</a><small class="backrefs"><a href="#refctx-bib-jiang2023mistral7b-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-niah">Kamradt, G. (2023). Needle In A Haystack - pressure testing LLMs. In <i>GitHub repository</i>. GitHub. <a href="https://github.com/gkamradt/LLMTest_NeedleInAHaystack" target="_blank" rel="noopener noreferrer">https://github.com/gkamradt/LLMTest_NeedleInAHaystack</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-niah-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-niah-2" aria-label="Back to citation">2</a></small></li><li id="bib-kaplan2020scalinglawsneurallanguage">Kaplan, J., McCandlish, S., Henighan, T., Brown, T. B., Chess, B., Child, R., Gray, S., Radford, A., Wu, J., &amp; Amodei, D. (2020). <i>Scaling Laws for Neural Language Models</i>. <a href="https://arxiv.org/abs/2001.08361" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2001.08361</a><small class="backrefs"><a href="#refctx-bib-kaplan2020scalinglawsneurallanguage-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-katsch2024gateloopfullydatacontrolledlinear">Katsch, T. (2024). <i>GateLoop: Fully Data-Controlled Linear Recurrence for Sequence Modeling</i>. <a href="https://arxiv.org/abs/2311.01927" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2311.01927</a><small class="backrefs"><a href="#refctx-bib-katsch2024gateloopfullydatacontrolledlinear-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-nope">Kazemnejad, A., Padhi, I., Ramamurthy, K. N., Das, P., &amp; Reddy, S. (2023). <i>The Impact of Positional Encoding on Length Generalization in Transformers</i>. <a href="https://arxiv.org/abs/2305.19466" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2305.19466</a><small class="backrefs"><a href="#refctx-bib-nope-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-scalerl">Khatri, D., Madaan, L., Tiwari, R., Bansal, R., Duvvuri, S. S., Zaheer, M., Dhillon, I. S., Brandfonbrener, D., &amp; Agarwal, R. (2025). <i>The Art of Scaling Reinforcement Learning Compute for LLMs</i>. <a href="https://arxiv.org/abs/2510.13786" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2510.13786</a><small class="backrefs"><a href="#refctx-bib-scalerl-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-kingma2014adam">Kingma, D. P. (2014). Adam: A method for stochastic optimization. <i>arXiv Preprint arXiv:1412.6980</i>.<small class="backrefs"><a href="#refctx-bib-kingma2014adam-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-krajewski2024scalinglawsfinegrainedmixture">Krajewski, J., Ludziejewski, J., Adamczewski, K., Pióro, M., Krutul, M., Antoniak, S., Ciebiera, K., Król, K., Odrzygóźdź, T., Sankowski, P., Cygan, M., &amp; Jaszczur, S. (2024). <i>Scaling Laws for Fine-Grained Mixture of Experts</i>. <a href="https://arxiv.org/abs/2402.07871" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2402.07871</a><small class="backrefs"><a href="#refctx-bib-krajewski2024scalinglawsfinegrainedmixture-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-rlhf">Lambert, N., Castricato, L., von Werra, L., &amp; Havrilla, A. (2022). Illustrating Reinforcement Learning from Human Feedback (RLHF). <i>Hugging Face Blog</i>.<small class="backrefs"><a href="#refctx-bib-rlhf-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-tulu3">Lambert, N., Morrison, J., Pyatkin, V., Huang, S., Ivison, H., Brahman, F., Miranda, L. J. V., Liu, A., Dziri, N., Lyu, S., Gu, Y., Malik, S., Graf, V., Hwang, J. D., Yang, J., Bras, R. L., Tafjord, O., Wilhelm, C., Soldaini, L., … Hajishirzi, H. (2025). <i>Tulu 3: Pushing Frontiers in Open Language Model Post-Training</i>. <a href="https://arxiv.org/abs/2411.15124" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2411.15124</a><small class="backrefs"><a href="#refctx-bib-tulu3-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-online-offline">Lanchantin, J., Chen, A., Lan, J., Li, X., Saha, S., Wang, T., Xu, J., Yu, P., Yuan, W., Weston, J. E., Sukhbaatar, S., &amp; Kulikov, I. (2025). <i>Bridging Offline and Online Reinforcement Learning for LLMs</i>. <a href="https://arxiv.org/abs/2506.21495" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2506.21495</a><small class="backrefs"><a href="#refctx-bib-online-offline-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-datacomp">Li, J., Fang, A., Smyrnis, G., Ivgi, M., Jordan, M., Gadre, S., Bansal, H., Guha, E., Keh, S., Arora, K., Garg, S., Xin, R., Muennighoff, N., Heckel, R., Mercat, J., Chen, M., Gururangan, S., Wortsman, M., Albalak, A., … Shankar, V. (2025). <i>DataComp-LM: In search of the next generation of training sets for language models</i>. <a href="https://arxiv.org/abs/2406.11794" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2406.11794</a><small class="backrefs"><a href="#refctx-bib-datacomp-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-gsmplus">Li, Q., Cui, L., Zhao, X., Kong, L., &amp; Bi, W. (2024). <i>GSM-Plus: A Comprehensive Benchmark for Evaluating the Robustness of LLMs as Mathematical Problem Solvers</i>. <a href="https://arxiv.org/abs/2402.19255" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2402.19255</a><small class="backrefs"><a href="#refctx-bib-gsmplus-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-starcoder">Li, R., Allal, L. B., Zi, Y., Muennighoff, N., Kocetkov, D., Mou, C., Marone, M., Akiki, C., Li, J., Chim, J., Liu, Q., Zheltonozhskii, E., Zhuo, T. Y., Wang, T., Dehaene, O., Davaadorj, M., Lamy-Poirier, J., Monteiro, J., Shliazhko, O., … de Vries, H. (2023). <i>StarCoder: may the source be with you!</i> <a href="https://arxiv.org/abs/2305.06161" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2305.06161</a><small class="backrefs"><a href="#refctx-bib-starcoder-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-arenahard">Li, T., Chiang, W.-L., Frick, E., Dunlap, L., Wu, T., Zhu, B., Gonzalez, J. E., &amp; Stoica, I. (2024). <i>From Crowdsourced Data to High-Quality Benchmarks: Arena-Hard and BenchBuilder Pipeline</i>. <a href="https://arxiv.org/abs/2406.11939" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2406.11939</a><small class="backrefs"><a href="#refctx-bib-arenahard-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-torchtitan">Liang, W., Liu, T., Wright, L., Constable, W., Gu, A., Huang, C.-C., Zhang, I., Feng, W., Huang, H., Wang, J., Purandare, S., Nadathur, G., &amp; Idreos, S. (2025). <i>TorchTitan: One-stop PyTorch native solution for production ready LLM pre-training</i>. <a href="https://arxiv.org/abs/2410.06511" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2410.06511</a><small class="backrefs"><a href="#refctx-bib-torchtitan-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-openaiprm">Lightman, H., Kosaraju, V., Burda, Y., Edwards, H., Baker, B., Lee, T., Leike, J., Schulman, J., Sutskever, I., &amp; Cobbe, K. (2023). <i>Let’s Verify Step by Step</i>. <a href="https://arxiv.org/abs/2305.20050" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2305.20050</a><small class="backrefs"><a href="#refctx-bib-openaiprm-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-liu2022">Liu, H., Xie, S. M., Li, Z., &amp; Ma, T. (2022). <i>Same Pre-training Loss, Better Downstream: Implicit Bias Matters for Language Models</i>. <a href="https://arxiv.org/abs/2210.14199" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2210.14199</a><small class="backrefs"><a href="#refctx-bib-liu2022-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-liu2025regmixdatamixtureregression">Liu, Q., Zheng, X., Muennighoff, N., Zeng, G., Dou, L., Pang, T., Jiang, J., &amp; Lin, M. (2025). <i>RegMix: Data Mixture as Regression for Language Model Pre-training</i>. <a href="https://arxiv.org/abs/2407.01492" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2407.01492</a><small class="backrefs"><a href="#refctx-bib-liu2025regmixdatamixtureregression-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-mobilellm">Liu, Z., Zhao, C., Iandola, F., Lai, C., Tian, Y., Fedorov, I., Xiong, Y., Chang, E., Shi, Y., Krishnamoorthi, R., Lai, L., &amp; Chandra, V. (2024). <i>MobileLLM: Optimizing Sub-billion Parameter Language Models for On-Device Use Cases</i>. <a href="https://arxiv.org/abs/2402.14905" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2402.14905</a><small class="backrefs"><a href="#refctx-bib-mobilellm-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-loshchilov2017sgdrstochasticgradientdescent">Loshchilov, I., &amp; Hutter, F. (2017). <i>SGDR: Stochastic Gradient Descent with Warm Restarts</i>. <a href="https://arxiv.org/abs/1608.03983" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1608.03983</a><small class="backrefs"><a href="#refctx-bib-loshchilov2017sgdrstochasticgradientdescent-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-starcoder2">Lozhkov, A., Li, R., Allal, L. B., Cassano, F., Lamy-Poirier, J., Tazi, N., Tang, A., Pykhtar, D., Liu, J., Wei, Y., Liu, T., Tian, M., Kocetkov, D., Zucker, A., Belkada, Y., Wang, Z., Liu, Q., Abulkhanov, D., Paul, I., … de Vries, H. (2024). <i>StarCoder 2 and The Stack v2: The Next Generation</i>. <a href="https://arxiv.org/abs/2402.19173" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2402.19173</a><small class="backrefs"><a href="#refctx-bib-starcoder2-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-mao2022finetuningpretrainedtransformersdecaying">Mao, H. H. (2022). <i>Fine-Tuning Pre-trained Transformers into Decaying Fast Weights</i>. <a href="https://arxiv.org/abs/2210.04243" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2210.04243</a><small class="backrefs"><a href="#refctx-bib-mao2022finetuningpretrainedtransformersdecaying-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-smolvlm">Marafioti, A., Zohar, O., Farré, M., Noyan, M., Bakouch, E., Cuenca, P., Zakka, C., Allal, L. B., Lozhkov, A., Tazi, N., Srivastav, V., Lochner, J., Larcher, H., Morlon, M., Tunstall, L., von Werra, L., &amp; Wolf, T. (2025). <i>SmolVLM: Redefining small and efficient multimodal models</i>. <a href="https://arxiv.org/abs/2504.05299" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2504.05299</a><small class="backrefs"><a href="#refctx-bib-smolvlm-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-mccandlish2018empiricalmodellargebatchtraining">McCandlish, S., Kaplan, J., Amodei, D., &amp; Team, O. D. (2018). <i>An Empirical Model of Large-Batch Training</i>. <a href="https://arxiv.org/abs/1812.06162" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1812.06162</a><small class="backrefs"><a href="#refctx-bib-mccandlish2018empiricalmodellargebatchtraining-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-merrill2025criticalbatchsizerevisited">Merrill, W., Arora, S., Groeneveld, D., &amp; Hajishirzi, H. (2025). <i>Critical Batch Size Revisited: A Simple Empirical Approach to Large-Batch Language Model Training</i>. <a href="https://arxiv.org/abs/2505.23971" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2505.23971</a><small class="backrefs"><a href="#refctx-bib-merrill2025criticalbatchsizerevisited-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-llama4">Meta AI. (2025). <i>The Llama 4 herd: The beginning of a new era of natively multimodal AI innovation</i>. <a href="https://ai.meta.com/blog/llama-4-multimodal-intelligence/" target="_blank" rel="noopener noreferrer">https://ai.meta.com/blog/llama-4-multimodal-intelligence/</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-llama4-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-llama4-2" aria-label="Back to citation">2</a></small></li><li id="bib-mindermann2022prioritizedtrainingpointslearnable">Mindermann, S., Brauner, J., Razzak, M., Sharma, M., Kirsch, A., Xu, W., Höltgen, B., Gomez, A. N., Morisot, A., Farquhar, S., &amp; Gal, Y. (2022). <i>Prioritized Training on Points that are Learnable, Worth Learning, and Not Yet Learnt</i>. <a href="https://arxiv.org/abs/2206.07137" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2206.07137</a><small class="backrefs"><a href="#refctx-bib-mindermann2022prioritizedtrainingpointslearnable-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-minimax01">MiniMax, Li, A., Gong, B., Yang, B., Shan, B., Liu, C., Zhu, C., Zhang, C., Guo, C., Chen, D., Li, D., Jiao, E., Li, G., Zhang, G., Sun, H., Dong, H., Zhu, J., Zhuang, J., Song, J., … Wu, Z. (2025). <i>MiniMax-01: Scaling Foundation Models with Lightning Attention</i>. <a href="https://arxiv.org/abs/2501.08313" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2501.08313</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-minimax01-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-minimax01-2" aria-label="Back to citation">2</a>, <a href="#refctx-bib-minimax01-3" aria-label="Back to citation">3</a></small></li><li id="bib-mistralsmall">Mistral AI. (2025). <i>Mistral Small 3.1</i>. <a href="https://mistral.ai/news/mistral-small-3-1" target="_blank" rel="noopener noreferrer">https://mistral.ai/news/mistral-small-3-1</a><small class="backrefs"><a href="#refctx-bib-mistralsmall-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-moshkov2025aimo2winningsolutionbuilding">Moshkov, I., Hanley, D., Sorokin, I., Toshniwal, S., Henkel, C., Schifferer, B., Du, W., &amp; Gitman, I. (2025). <i>AIMO-2 Winning Solution: Building State-of-the-Art Mathematical Reasoning Models with OpenMathReasoning dataset</i>. <a href="https://arxiv.org/abs/2504.16891" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2504.16891</a><small class="backrefs"><a href="#refctx-bib-moshkov2025aimo2winningsolutionbuilding-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-muennighoff2025scalingdataconstrainedlanguagemodels">Muennighoff, N., Rush, A. M., Barak, B., Scao, T. L., Piktus, A., Tazi, N., Pyysalo, S., Wolf, T., &amp; Raffel, C. (2025). <i>Scaling Data-Constrained Language Models</i>. <a href="https://arxiv.org/abs/2305.16264" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2305.16264</a><small class="backrefs"><a href="#refctx-bib-muennighoff2025scalingdataconstrainedlanguagemodels-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-mixeval">Ni, J., Xue, F., Yue, X., Deng, Y., Shah, M., Jain, K., Neubig, G., &amp; You, Y. (2024). <i>MixEval: Deriving Wisdom of the Crowd from LLM Benchmark Mixtures</i>. <a href="https://arxiv.org/abs/2406.06565" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2406.06565</a><small class="backrefs"><a href="#refctx-bib-mixeval-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-nvidia2025nvidianemotronnano2">NVIDIA, :, Basant, A., Khairnar, A., Paithankar, A., Khattar, A., Renduchintala, A., Malte, A., Bercovich, A., Hazare, A., Rico, A., Ficek, A., Kondratenko, A., Shaposhnikov, A., Bukharin, A., Taghibakhshi, A., Barton, A., Mahabaleshwarkar, A. S., Shen, A., … Chen, Z. (2025). <i>NVIDIA Nemotron Nano 2: An Accurate and Efficient Hybrid Mamba-Transformer Reasoning Model</i>. <a href="https://arxiv.org/abs/2508.14444" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2508.14444</a><small class="backrefs"><a href="#refctx-bib-nvidia2025nvidianemotronnano2-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-nemotronh">NVIDIA, :, Blakeman, A., Basant, A., Khattar, A., Renduchintala, A., Bercovich, A., Ficek, A., Bjorlin, A., Taghibakhshi, A., Deshmukh, A. S., Mahabaleshwarkar, A. S., Tao, A., Shors, A., Aithal, A., Poojary, A., Dattagupta, A., Buddharaju, B., Chen, B., … Chen, Z. (2025). <i>Nemotron-H: A Family of Accurate and Efficient Hybrid Mamba-Transformer Models</i>. <a href="https://arxiv.org/abs/2504.03624" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2504.03624</a><small class="backrefs"><a href="#refctx-bib-nemotronh-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-gpt4">OpenAI, Achiam, J., Adler, S., Agarwal, S., Ahmad, L., Akkaya, I., Aleman, F. L., Almeida, D., Altenschmidt, J., Altman, S., Anadkat, S., Avila, R., Babuschkin, I., Balaji, S., Balcom, V., Baltescu, P., Bao, H., Bavarian, M., Belgum, J., … Zoph, B. (2024). <i>GPT-4 Technical Report</i>. <a href="https://arxiv.org/abs/2303.08774" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2303.08774</a><small class="backrefs"><a href="#refctx-bib-gpt4-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-instructgpt">Ouyang, L., Wu, J., Jiang, X., Almeida, D., Wainwright, C. L., Mishkin, P., Zhang, C., Agarwal, S., Slama, K., Ray, A., Schulman, J., Hilton, J., Kelton, F., Miller, L., Simens, M., Askell, A., Welinder, P., Christiano, P., Leike, J., &amp; Lowe, R. (2022). <i>Training language models to follow instructions with human feedback</i>. <a href="https://arxiv.org/abs/2203.02155" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2203.02155</a><small class="backrefs"><a href="#refctx-bib-instructgpt-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-fineweb">Penedo, G., Kydlíček, H., allal, L. B., Lozhkov, A., Mitchell, M., Raffel, C., Werra, L. V., &amp; Wolf, T. (2024). <i>The FineWeb Datasets: Decanting the Web for the Finest Text Data at Scale</i>. <a href="https://arxiv.org/abs/2406.17557" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2406.17557</a><small class="backrefs"><a href="#refctx-bib-fineweb-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-fineweb2">Penedo, G., Kydlíček, H., Sabolčec, V., Messmer, B., Foroutan, N., Kargaran, A. H., Raffel, C., Jaggi, M., Werra, L. V., &amp; Wolf, T. (2025). <i>FineWeb2: One Pipeline to Scale Them All – Adapting Pre-Training Data Processing to Every Language</i>. <a href="https://arxiv.org/abs/2506.20920" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2506.20920</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-fineweb2-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-fineweb2-2" aria-label="Back to citation">2</a></small></li><li id="bib-peng2024eaglefinchrwkvmatrixvalued">Peng, B., Goldstein, D., Anthony, Q., Albalak, A., Alcaide, E., Biderman, S., Cheah, E., Du, X., Ferdinan, T., Hou, H., Kazienko, P., GV, K. K., Kocoń, J., Koptyra, B., Krishna, S., Jr., R. M., Lin, J., Muennighoff, N., Obeid, F., … Zhu, R.-J. (2024). <i>Eagle and Finch: RWKV with Matrix-Valued States and Dynamic Recurrence</i>. <a href="https://arxiv.org/abs/2404.05892" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2404.05892</a><small class="backrefs"><a href="#refctx-bib-peng2024eaglefinchrwkvmatrixvalued-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-yarn">Peng, B., Quesnelle, J., Fan, H., &amp; Shippole, E. (2023). <i>YaRN: Efficient Context Window Extension of Large Language Models</i>. <a href="https://arxiv.org/abs/2309.00071" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2309.00071</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-yarn-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-yarn-2" aria-label="Back to citation">2</a></small></li><li id="bib-peng2021randomfeatureattention">Peng, H., Pappas, N., Yogatama, D., Schwartz, R., Smith, N. A., &amp; Kong, L. (2021). <i>Random Feature Attention</i>. <a href="https://arxiv.org/abs/2103.02143" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2103.02143</a><small class="backrefs"><a href="#refctx-bib-peng2021randomfeatureattention-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-petty2024impactdepthcompositionalgeneralization">Petty, J., van Steenkiste, S., Dasgupta, I., Sha, F., Garrette, D., &amp; Linzen, T. (2024). <i>The Impact of Depth on Compositional Generalization in Transformer Language Models</i>. <a href="https://arxiv.org/abs/2310.19956" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2310.19956</a><small class="backrefs"><a href="#refctx-bib-petty2024impactdepthcompositionalgeneralization-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-tinybenchmarks">Polo, F. M., Weber, L., Choshen, L., Sun, Y., Xu, G., &amp; Yurochkin, M. (2024). <i>tinyBenchmarks: evaluating LLMs with fewer examples</i>. <a href="https://arxiv.org/abs/2402.14992" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2402.14992</a><small class="backrefs"><a href="#refctx-bib-tinybenchmarks-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-alibi">Press, O., Smith, N. A., &amp; Lewis, M. (2022). <i>Train Short, Test Long: Attention with Linear Biases Enables Input Length Extrapolation</i>. <a href="https://arxiv.org/abs/2108.12409" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2108.12409</a><small class="backrefs"><a href="#refctx-bib-alibi-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-ifbench">Pyatkin, V., Malik, S., Graf, V., Ivison, H., Huang, S., Dasigi, P., Lambert, N., &amp; Hajishirzi, H. (2025). <i>Generalizing Verifiable Instruction Following</i>. <a href="https://arxiv.org/abs/2507.02833" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2507.02833</a><small class="backrefs"><a href="#refctx-bib-ifbench-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-qin2022devillineartransformer">Qin, Z., Han, X., Sun, W., Li, D., Kong, L., Barnes, N., &amp; Zhong, Y. (2022). <i>The Devil in Linear Transformer</i>. <a href="https://arxiv.org/abs/2210.10340" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2210.10340</a><small class="backrefs"><a href="#refctx-bib-qin2022devillineartransformer-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-qin2024hgrn2gatedlinearrnns">Qin, Z., Yang, S., Sun, W., Shen, X., Li, D., Sun, W., &amp; Zhong, Y. (2024). <i>HGRN2: Gated Linear RNNs with State Expansion</i>. <a href="https://arxiv.org/abs/2404.07904" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2404.07904</a><small class="backrefs"><a href="#refctx-bib-qin2024hgrn2gatedlinearrnns-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-qiu2025demonsdetailimplementingload">Qiu, Z., Huang, Z., Zheng, B., Wen, K., Wang, Z., Men, R., Titov, I., Liu, D., Zhou, J., &amp; Lin, J. (2025). <i>Demons in the Detail: On Implementing Load Balancing Loss for Training Specialized Mixture-of-Expert Models</i>. <a href="https://arxiv.org/abs/2501.11873" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2501.11873</a><small class="backrefs"><a href="#refctx-bib-qiu2025demonsdetailimplementingload-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-qwen3next">Qwen Team. (2025). <i>Qwen3-Next: Towards Ultimate Training &amp; Inference Efficiency</i>. Alibaba Cloud. <a href="https://qwen.ai/blog?id=4074cca80393150c248e508aa62983f9cb7d27cd&from=research.latest-advancements-list" target="_blank" rel="noopener noreferrer">https://qwen.ai/blog?id=4074cca80393150c248e508aa62983f9cb7d27cd&amp;from=research.latest-advancements-list</a><small class="backrefs"><a href="#refctx-bib-qwen3next-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-gpt2">Radford, A., Wu, J., Child, R., Luan, D., Amodei, D., Sutskever, I., &amp; others. (2019). Language models are unsupervised multitask learners. In <i>OpenAI blog</i> (Vol. 1, p. 9).<small class="backrefs"><a href="#refctx-bib-gpt2-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-dpo">Rafailov, R., Sharma, A., Mitchell, E., Ermon, S., Manning, C. D., &amp; Finn, C. (2024). <i>Direct Preference Optimization: Your Language Model is Secretly a Reward Model</i>. <a href="https://arxiv.org/abs/2305.18290" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2305.18290</a><small class="backrefs"><a href="#refctx-bib-dpo-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-gpqa">Rein, D., Hou, B. L., Stickland, A. C., Petty, J., Pang, R. Y., Dirani, J., Michael, J., &amp; Bowman, S. R. (2024). Gpqa: A graduate-level google-proof q&amp;a benchmark. <i>First Conference on Language Modeling</i>.<small class="backrefs"><a href="#refctx-bib-gpqa-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-sennrich2016neuralmachinetranslationrare">Sennrich, R., Haddow, B., &amp; Birch, A. (2016). <i>Neural Machine Translation of Rare Words with Subword Units</i>. <a href="https://arxiv.org/abs/1508.07909" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1508.07909</a><small class="backrefs"><a href="#refctx-bib-sennrich2016neuralmachinetranslationrare-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-grpo">Shao, Z., Wang, P., Zhu, Q., Xu, R., Song, J., Bi, X., Zhang, H., Zhang, M., Li, Y. K., Wu, Y., &amp; Guo, D. (2024). <i>DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open Language Models</i>. <a href="https://arxiv.org/abs/2402.03300" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2402.03300</a><small class="backrefs"><a href="#refctx-bib-grpo-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-mqa">Shazeer, N. (2019). <i>Fast Transformer Decoding: One Write-Head is All You Need</i>. <a href="https://arxiv.org/abs/1911.02150" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1911.02150</a><small class="backrefs"><a href="#refctx-bib-mqa-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-mgsm">Shi, F., Suzgun, M., Freitag, M., Wang, X., Srivats, S., Vosoughi, S., Chung, H. W., Tay, Y., Ruder, S., Zhou, D., Das, D., &amp; Wei, J. (2022). <i>Language Models are Multilingual Chain-of-Thought Reasoners</i>. <a href="https://arxiv.org/abs/2210.03057" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2210.03057</a><small class="backrefs"><a href="#refctx-bib-mgsm-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-smolvla">Shukor, M., Aubakirova, D., Capuano, F., Kooijmans, P., Palma, S., Zouitine, A., Aractingi, M., Pascal, C., Russi, M., Marafioti, A., Alibert, S., Cord, M., Wolf, T., &amp; Cadene, R. (2025). <i>SmolVLA: A Vision-Language-Action Model for Affordable and Efficient Robotics</i>. <a href="https://arxiv.org/abs/2506.01844" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2506.01844</a><small class="backrefs"><a href="#refctx-bib-smolvla-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-globalmmlu">Singh, S., Romanou, A., Fourrier, C., Adelani, D. I., Ngui, J. G., Vila-Suero, D., Limkonchotiwat, P., Marchisio, K., Leong, W. Q., Susanto, Y., Ng, R., Longpre, S., Ko, W.-Y., Ruder, S., Smith, M., Bosselut, A., Oh, A., Martins, A. F. T., Choshen, L., … Hooker, S. (2025). <i>Global MMLU: Understanding and Addressing Cultural and Linguistic Biases in Multilingual Evaluation</i>. <a href="https://arxiv.org/abs/2412.03304" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2412.03304</a><small class="backrefs"><a href="#refctx-bib-globalmmlu-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-multichallenge">Sirdeshmukh, V., Deshpande, K., Mols, J., Jin, L., Cardona, E.-Y., Lee, D., Kritz, J., Primack, W., Yue, S., &amp; Xing, C. (2025). <i>MultiChallenge: A Realistic Multi-Turn Conversation Evaluation Benchmark Challenging to Frontier LLMs</i>. <a href="https://arxiv.org/abs/2501.17399" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2501.17399</a><small class="backrefs"><a href="#refctx-bib-multichallenge-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-smith2018superconvergencefasttrainingneural">Smith, L. N., &amp; Topin, N. (2018). <i>Super-Convergence: Very Fast Training of Neural Networks Using Large Learning Rates</i>. <a href="https://arxiv.org/abs/1708.07120" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1708.07120</a><small class="backrefs"><a href="#refctx-bib-smith2018superconvergencefasttrainingneural-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-rope">Su, J., Lu, Y., Pan, S., Murtadha, A., Wen, B., &amp; Liu, Y. (2023). <i>RoFormer: Enhanced Transformer with Rotary Position Embedding</i>. <a href="https://arxiv.org/abs/2104.09864" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2104.09864</a><small class="backrefs"><a href="#refctx-bib-rope-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-sun2024cacheoncedecoderdecoderarchitectures">Sun, Y., Dong, L., Zhu, Y., Huang, S., Wang, W., Ma, S., Zhang, Q., Wang, J., &amp; Wei, F. (2024). <i>You Only Cache Once: Decoder-Decoder Architectures for Language Models</i>. <a href="https://arxiv.org/abs/2405.05254" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2405.05254</a><small class="backrefs"><a href="#refctx-bib-sun2024cacheoncedecoderdecoderarchitectures-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-takase2025spikemorestabilizingpretraining">Takase, S., Kiyono, S., Kobayashi, S., &amp; Suzuki, J. (2025). <i>Spike No More: Stabilizing the Pre-training of Large Language Models</i>. <a href="https://arxiv.org/abs/2312.16903" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2312.16903</a><small class="backrefs"><a href="#refctx-bib-takase2025spikemorestabilizingpretraining-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-glm45">Team, 5, Zeng, A., Lv, X., Zheng, Q., Hou, Z., Chen, B., Xie, C., Wang, C., Yin, D., Zeng, H., Zhang, J., Wang, K., Zhong, L., Liu, M., Lu, R., Cao, S., Zhang, X., Huang, X., Wei, Y., … Tang, J. (2025). <i>GLM-4.5: Agentic, Reasoning, and Coding (ARC) Foundation Models</i>. <a href="https://arxiv.org/abs/2508.06471" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2508.06471</a><small class="backrefs"><a href="#refctx-bib-glm45-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-cwm">team, F. C., Copet, J., Carbonneaux, Q., Cohen, G., Gehring, J., Kahn, J., Kossen, J., Kreuk, F., McMilin, E., Meyer, M., Wei, Y., Zhang, D., Zheng, K., Armengol-Estapé, J., Bashiri, P., Beck, M., Chambon, P., Charnalia, A., Cummins, C., … Synnaeve, G. (2025). <i>CWM: An Open-Weights LLM for Research on Code Generation with World Models</i>. <a href="https://arxiv.org/abs/2510.02387" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2510.02387</a><small class="backrefs"><a href="#refctx-bib-cwm-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-gemma3">Team, G., Kamath, A., Ferret, J., Pathak, S., Vieillard, N., Merhej, R., Perrin, S., Matejovicova, T., Ramé, A., Rivière, M., Rouillard, L., Mesnard, T., Cideron, G., bastien Jean-Grill, Ramos, S., Yvinec, E., Casbon, M., Pot, E., Penchev, I., … Hussenot, L. (2025). <i>Gemma 3 Technical Report</i>. <a href="https://arxiv.org/abs/2503.19786" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2503.19786</a><small class="backrefs"><a href="#refctx-bib-gemma3-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-kimik2">Team, K., Bai, Y., Bao, Y., Chen, G., Chen, J., Chen, N., Chen, R., Chen, Y., Chen, Y., Chen, Y., Chen, Z., Cui, J., Ding, H., Dong, M., Du, A., Du, C., Du, D., Du, Y., Fan, Y., … Zu, X. (2025). <i>Kimi K2: Open Agentic Intelligence</i>. <a href="https://arxiv.org/abs/2507.20534" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2507.20534</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-kimik2-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-kimik2-2" aria-label="Back to citation">2</a>, <a href="#refctx-bib-kimik2-3" aria-label="Back to citation">3</a></small></li><li id="bib-lingteam2025attentionmattersefficienthybrid">Team, L., Han, B., Tang, C., Liang, C., Zhang, D., Yuan, F., Zhu, F., Gao, J., Hu, J., Li, L., Li, M., Zhang, M., Jiang, P., Jiao, P., Zhao, Q., Yang, Q., Shen, W., Yang, X., Zhang, Y., … Zhou, J. (2025). <i>Every Attention Matters: An Efficient Hybrid Architecture for Long-Context Reasoning</i>. <a href="https://arxiv.org/abs/2510.19338" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2510.19338</a><small class="backrefs"><a href="#refctx-bib-lingteam2025attentionmattersefficienthybrid-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-ling15">Team, L., Zeng, B., Huang, C., Zhang, C., Tian, C., Chen, C., Jin, D., Yu, F., Zhu, F., Yuan, F., Wang, F., Wang, G., Zhai, G., Zhang, H., Li, H., Zhou, J., Liu, J., Fang, J., Ou, J., … He, Z. (2025). <i>Every FLOP Counts: Scaling a 300B Mixture-of-Experts LING LLM without Premium GPUs</i>. <a href="https://arxiv.org/abs/2503.05139" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2503.05139</a><small class="backrefs"><a href="#refctx-bib-ling15-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-antgroup">Tian, C., Chen, K., Liu, J., Liu, Z., Zhang, Z., &amp; Zhou, J. (2025). <i>Towards Greater Leverage: Scaling Laws for Efficient Mixture-of-Experts Language Models</i>. <a href="https://arxiv.org/abs/2507.17702" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2507.17702</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-antgroup-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-antgroup-2" aria-label="Back to citation">2</a>, <a href="#refctx-bib-antgroup-3" aria-label="Back to citation">3</a></small></li><li id="bib-toshniwal2024openmathinstruct118millionmath">Toshniwal, S., Moshkov, I., Narenthiran, S., Gitman, D., Jia, F., &amp; Gitman, I. (2024). <i>OpenMathInstruct-1: A 1.8 Million Math Instruction Tuning Dataset</i>. <a href="https://arxiv.org/abs/2402.10176" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2402.10176</a><small class="backrefs"><a href="#refctx-bib-toshniwal2024openmathinstruct118millionmath-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-zephyr">Tunstall, L., Beeching, E., Lambert, N., Rajani, N., Rasul, K., Belkada, Y., Huang, S., von Werra, L., Fourrier, C., Habib, N., Sarrazin, N., Sanseviero, O., Rush, A. M., &amp; Wolf, T. (2023). <i>Zephyr: Direct Distillation of LM Alignment</i>. <a href="https://arxiv.org/abs/2310.16944" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2310.16944</a><small class="backrefs"><a href="#refctx-bib-zephyr-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-transformer">Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., Kaiser, L., &amp; Polosukhin, I. (2023). <i>Attention Is All You Need</i>. <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1706.03762</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-transformer-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-transformer-2" aria-label="Back to citation">2</a></small></li><li id="bib-waleffe2024empiricalstudymambabasedlanguage">Waleffe, R., Byeon, W., Riach, D., Norick, B., Korthikanti, V., Dao, T., Gu, A., Hatamizadeh, A., Singh, S., Narayanan, D., Kulshreshtha, G., Singh, V., Casper, J., Kautz, J., Shoeybi, M., &amp; Catanzaro, B. (2024). <i>An Empirical Study of Mamba-based Language Models</i>. <a href="https://arxiv.org/abs/2406.07887" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2406.07887</a><small class="backrefs"><a href="#refctx-bib-waleffe2024empiricalstudymambabasedlanguage-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-gptj">Wang, B., &amp; Komatsuzaki, A. (2021). <i>GPT-J-6B: A 6 Billion Parameter Autoregressive Language Model</i>. <a href="https://github.com/kingoflolz/mesh-transformer-jax" target="_blank" rel="noopener noreferrer">https://github.com/kingoflolz/mesh-transformer-jax</a><small class="backrefs"><a href="#refctx-bib-gptj-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-simpleqa">Wei, J., Karina, N., Chung, H. W., Jiao, Y. J., Papay, S., Glaese, A., Schulman, J., &amp; Fedus, W. (2024). Measuring short-form factuality in large language models. <i>arXiv Preprint arXiv:2411.04368</i>.<small class="backrefs"><a href="#refctx-bib-simpleqa-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-wen2025fantasticpretrainingoptimizers">Wen, K., Hall, D., Ma, T., &amp; Liang, P. (2025). <i>Fantastic Pretraining Optimizers and Where to Find Them</i>. <a href="https://arxiv.org/abs/2509.02046" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2509.02046</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-wen2025fantasticpretrainingoptimizers-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-wen2025fantasticpretrainingoptimizers-2" aria-label="Back to citation">2</a></small></li><li id="bib-xie2023doremioptimizingdatamixtures">Xie, S. M., Pham, H., Dong, X., Du, N., Liu, H., Lu, Y., Liang, P., Le, Q. V., Ma, T., &amp; Yu, A. W. (2023). <i>DoReMi: Optimizing Data Mixtures Speeds Up Language Model Pretraining</i>. <a href="https://arxiv.org/abs/2305.10429" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2305.10429</a><small class="backrefs"><a href="#refctx-bib-xie2023doremioptimizingdatamixtures-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-xiong2023effectivelongcontextscalingfoundation">Xiong, W., Liu, J., Molybog, I., Zhang, H., Bhargava, P., Hou, R., Martin, L., Rungta, R., Sankararaman, K. A., Oguz, B., Khabsa, M., Fang, H., Mehdad, Y., Narang, S., Malik, K., Fan, A., Bhosale, S., Edunov, S., Lewis, M., … Ma, H. (2023a). <i>Effective Long-Context Scaling of Foundation Models</i>. <a href="https://arxiv.org/abs/2309.16039" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2309.16039</a><small class="backrefs"><a href="#refctx-bib-xiong2023effectivelongcontextscalingfoundation-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-ropeabf">Xiong, W., Liu, J., Molybog, I., Zhang, H., Bhargava, P., Hou, R., Martin, L., Rungta, R., Sankararaman, K. A., Oguz, B., Khabsa, M., Fang, H., Mehdad, Y., Narang, S., Malik, K., Fan, A., Bhosale, S., Edunov, S., Lewis, M., … Ma, H. (2023b). <i>Effective Long-Context Scaling of Foundation Models</i>. <a href="https://arxiv.org/abs/2309.16039" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2309.16039</a><small class="backrefs"><a href="#refctx-bib-ropeabf-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-phi4reasoning">Xu, H., Peng, B., Awadalla, H., Chen, D., Chen, Y.-C., Gao, M., Kim, Y. J., Li, Y., Ren, L., Shen, Y., Wang, S., Xu, W., Gao, J., &amp; Chen, W. (2025). <i>Phi-4-Mini-Reasoning: Exploring the Limits of Small Reasoning Language Models in Math</i>. <a href="https://arxiv.org/abs/2504.21233" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2504.21233</a><small class="backrefs"><a href="#refctx-bib-phi4reasoning-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-qwen3">Yang, A., Li, A., Yang, B., Zhang, B., Hui, B., Zheng, B., Yu, B., Gao, C., Huang, C., Lv, C., Zheng, C., Liu, D., Zhou, F., Huang, F., Hu, F., Ge, H., Wei, H., Lin, H., Tang, J., … Qiu, Z. (2025). <i>Qwen3 Technical Report</i>. <a href="https://arxiv.org/abs/2505.09388" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2505.09388</a><small class="backrefs"><a href="#refctx-bib-qwen3-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-qwen1million">Yang, A., Yu, B., Li, C., Liu, D., Huang, F., Huang, H., Jiang, J., Tu, J., Zhang, J., Zhou, J., Lin, J., Dang, K., Yang, K., Yu, L., Li, M., Sun, M., Zhu, Q., Men, R., He, T., … Zhang, Z. (2025). <i>Qwen2.5-1M Technical Report</i>. <a href="https://arxiv.org/abs/2501.15383" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2501.15383</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-qwen1million-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-qwen1million-2" aria-label="Back to citation">2</a></small></li><li id="bib-rnope">Yang, B., Venkitesh, B., Talupuru, D., Lin, H., Cairuz, D., Blunsom, P., &amp; Locatelli, A. (2025). <i>Rope to Nope and Back Again: A New Hybrid Attention Strategy</i>. <a href="https://arxiv.org/abs/2501.18795" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2501.18795</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-rnope-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-rnope-2" aria-label="Back to citation">2</a></small></li><li id="bib-helmet">Yen, H., Gao, T., Hou, M., Ding, K., Fleischer, D., Izsak, P., Wasserblat, M., &amp; Chen, D. (2025). <i>HELMET: How to Evaluate Long-Context Language Models Effectively and Thoroughly</i>. <a href="https://arxiv.org/abs/2410.02694" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2410.02694</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-helmet-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-helmet-2" aria-label="Back to citation">2</a></small></li><li id="bib-dapo">Yu, Q., Zhang, Z., Zhu, R., Yuan, Y., Zuo, X., Yue, Y., Dai, W., Fan, T., Liu, G., Liu, L., Liu, X., Lin, H., Lin, Z., Ma, B., Sheng, G., Tong, Y., Zhang, C., Zhang, M., Zhang, W., … Wang, M. (2025). <i>DAPO: An Open-Source LLM Reinforcement Learning System at Scale</i>. <a href="https://arxiv.org/abs/2503.14476" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2503.14476</a><small class="backrefs"><a href="#refctx-bib-dapo-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-yue2025">Yue, Y., Chen, Z., Lu, R., Zhao, A., Wang, Z., Yue, Y., Song, S., &amp; Huang, G. (2025). <i>Does Reinforcement Learning Really Incentivize Reasoning Capacity in LLMs Beyond the Base Model?</i> <a href="https://arxiv.org/abs/2504.13837" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2504.13837</a><small class="backrefs"><a href="#refctx-bib-yue2025-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-zhao2024">Zhao, Y., Qu, Y., Staniszewski, K., Tworkowski, S., Liu, W., Miłoś, P., Wu, Y., &amp; Minervini, P. (2024). Analysing The Impact of Sequence Composition on Language Model Pre-Training. <i>Proceedings of the 62nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)</i>, 7897–7912. <a href="https://doi.org/10.18653/v1/2024.acl-long.427" target="_blank" rel="noopener noreferrer">10.18653/v1/2024.acl-long.427</a><small class="backrefs"><a href="#refctx-bib-zhao2024-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-zhou2025megamathpushinglimitsopen">Zhou, F., Wang, Z., Ranjan, N., Cheng, Z., Tang, L., He, G., Liu, Z., &amp; Xing, E. P. (2025). <i>MegaMath: Pushing the Limits of Open Math Corpora</i>. <a href="https://arxiv.org/abs/2504.02807" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2504.02807</a><small class="backrefs"><a href="#refctx-bib-zhou2025megamathpushinglimitsopen-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-ifeval">Zhou, J., Lu, T., Mishra, S., Brahma, S., Basu, S., Luan, Y., Zhou, D., &amp; Hou, L. (2023). <i>Instruction-Following Evaluation for Large Language Models</i>. <a href="https://arxiv.org/abs/2311.07911" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2311.07911</a><small class="backrefs"><a href="#refctx-bib-ifeval-1" aria-label="Back to citation"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg></a></small></li><li id="bib-skyladder">Zhu, T., Liu, Q., Wang, H., Chen, S., Gu, X., Pang, T., &amp; Kan, M.-Y. (2025). <i>SkyLadder: Better and Faster Pretraining via Context Window Scheduling</i>. <a href="https://arxiv.org/abs/2503.15450" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2503.15450</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-skyladder-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-skyladder-2" aria-label="Back to citation">2</a></small></li><li id="bib-falconh1">Zuo, J., Velikanov, M., Chahed, I., Belkada, Y., Rhayem, D. E., Kunsch, G., Hacid, H., Yous, H., Farhat, B., Khadraoui, I., Farooq, M., Campesan, G., Cojocaru, R., Djilali, Y., Hu, S., Chaabane, I., Khanna, P., Seddik, M. E. A., Huynh, N. D., … Frikha, S. (2025). <i>Falcon-H1: A Family of Hybrid-Head Language Models Redefining Efficiency and Performance</i>. <a href="https://arxiv.org/abs/2507.22448" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2507.22448</a><small class="backrefs"><svg class="back-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg> back: <a href="#refctx-bib-falconh1-1" aria-label="Back to citation">1</a>, <a href="#refctx-bib-falconh1-2" aria-label="Back to citation">2</a></small></li></ol></div> </main> </section> <footer class="footer"> <div class="footer-inner"> <section class="citation-block"> <h3>Citation</h3> <p>For attribution in academic contexts, please cite this work as</p> <pre class="citation short">Loubna Ben Allal, Lewis Tunstall, Nouamane Tazi, Elie Bakouch, Ed Beeching, Carlos Miguel Patiño, Clémentine Fourrier, Thibaud Frere, Anton Lozhkov, Colin Raffel, Leandro von Werra, Thomas Wolf (2025). &quot;The Smol Training Playbook: The Secrets to Building World-Class LLMs&quot;.</pre> <p>BibTeX citation</p> <pre class="citation long">@misc{allal2025_the_smol_training_playbook_the_secrets_to_building_world_class_llms,
  title={The Smol Training Playbook: The Secrets to Building World-Class LLMs},
  author={Loubna Ben Allal and Lewis Tunstall and Nouamane Tazi and Elie Bakouch and Ed Beeching and Carlos Miguel Patiño and Clémentine Fourrier and Thibaud Frere and Anton Lozhkov and Colin Raffel and Leandro von Werra and Thomas Wolf},
  year={2025},
  doi={10.1234/abcd.efgh}
}</pre> </section> <section class="doi-block"> <h3>DOI</h3> <p> <a href="https://doi.org/10.1234/abcd.efgh" target="_blank" rel="noopener noreferrer"> 10.1234/abcd.efgh </a> </p> </section> <section class="reuse-block"> <h3>Reuse</h3> <p>Diagrams and text are licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener noreferrer">CC‑BY 4.0</a> with the source available on <a href="https://huggingface.co/spaces/tfrere/research-article-template" target="_blank" rel="noopener noreferrer">Hugging Face</a>, unless noted otherwise. Figures reused from other sources are excluded and marked in their captions (“Figure from …”).
</p> </section> <section class="references-block">  </section> <div class="template-credit"> <p>
Made with ❤️ with <a href="https://huggingface.co/spaces/tfrere/research-article-template" target="_blank" rel="noopener noreferrer">research article template</a> </p> </div> </div> </footer> <script>
  (() => {
    const getFooter = () =>
      document.currentScript?.closest("footer") ||
      document.querySelector("footer.footer");
    const footer = getFooter();
    if (!footer) return;
    const target = footer.querySelector(".references-block");
    if (!target) return;

    const contentRoot =
      document.querySelector("section.content-grid main") ||
      document.querySelector("main") ||
      document.body;

    const ensureHeading = (text) => {
      const exists = Array.from(target.children).some(
        (c) =>
          c.tagName === "H3" &&
          c.textContent.trim().toLowerCase() === text.toLowerCase(),
      );
      if (!exists) {
        const h = document.createElement("h3");
        h.textContent = text;
        target.appendChild(h);
      }
    };

    const moveIntoFooter = (element, headingText) => {
      if (!element) return false;
      // Remove an eventual heading already included inside the block (avoid duplicates)
      const firstHeading = element.querySelector(
        ":scope > h1, :scope > h2, :scope > h3",
      );
      if (firstHeading) {
        const txt = (firstHeading.textContent || "").trim().toLowerCase();
        const targetTxt = headingText.trim().toLowerCase();
        if (
          txt === targetTxt ||
          txt.includes("reference") ||
          txt.includes("bibliograph")
        ) {
          firstHeading.remove();
        }
      }

      // Move footnote backref links inside paragraphs
      if (element.classList && element.classList.contains("footnotes")) {
        const footnoteItems = element.querySelectorAll("li");
        footnoteItems.forEach((item) => {
          const backrefContainer = item.querySelector("small.backrefs");
          const lastP = item.querySelector("p:last-of-type");
          if (backrefContainer && lastP && !lastP.contains(backrefContainer)) {
            lastP.appendChild(document.createTextNode(" "));
            lastP.appendChild(backrefContainer);
          }
        });
      }

      ensureHeading(headingText);
      target.appendChild(element);
      return true;
    };
    const run = () => {
      const findFirstOutsideFooter = (selectors) => {
        for (const sel of selectors) {
          const el = contentRoot.querySelector(sel);
          if (el && !footer.contains(el)) return el;
        }
        return null;
      };

      const referencesEl = findFirstOutsideFooter([
        "#bibliography-references-list",
        "[data-bibliography-block]",
        "#references",
        "#refs",
        ".references",
        ".bibliography",
      ]);
      const footnotesEl = findFirstOutsideFooter([".footnotes"]);

      const movedRefs = moveIntoFooter(referencesEl, "References");
      const movedNotes = moveIntoFooter(footnotesEl, "Footnotes");
      return movedRefs || movedNotes;
    };

    // Try now; if not found yet, try again on DOM ready
    const done = run();
    if (!done) {
      const onReady = () => run();
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", onReady, { once: true });
      } else {
        setTimeout(onReady, 0);
      }
    }

    // Resize on window changes (e.g., fonts, layout)
    // No textarea auto-resize needed for <pre> blocks
  })();
</script>    </body> </html>